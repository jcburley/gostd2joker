Default context:
{amd64 linux /usr/local/go /home/craig/.go true false gc [] [go1.1 go1.2 go1.3 go1.4 go1.5 go1.6 go1.7 go1.8 go1.9 go1.10 go1.11]  <nil> <nil> <nil> <nil> <nil> <nil> <nil>}
Walking from tests/big to tests/big/go
Processing sourceDir=tests/big dump=false:
Walking from tests/big to tests/big/net
Processing sourceDir=tests/big dump=false:
Package net:
Processing package=net:
Walking from tests/big to tests/big/net/http
Processing sourceDir=tests/big dump=false:
Package http:
Processing package=http:
Walking from tests/big to tests/big/net/http/cgi
Processing sourceDir=tests/big dump=false:
Package cgi:
Processing package=cgi:
Excluding tests/big/net/http/cgi/testdata
Walking from tests/big to tests/big/net/http/cookiejar
Processing sourceDir=tests/big dump=false:
Package cookiejar:
Processing package=cookiejar:
Walking from tests/big to tests/big/net/http/fcgi
Processing sourceDir=tests/big dump=false:
Package fcgi:
Processing package=fcgi:
Walking from tests/big to tests/big/net/http/httptest
Processing sourceDir=tests/big dump=false:
Package httptest:
Processing package=httptest:
Walking from tests/big to tests/big/net/http/httptrace
Processing sourceDir=tests/big dump=false:
Package httptrace:
Processing package=httptrace:
Walking from tests/big to tests/big/net/http/httputil
Processing sourceDir=tests/big dump=false:
Package httputil:
Processing package=httputil:
Excluding tests/big/net/http/internal
Walking from tests/big to tests/big/net/http/pprof
Processing sourceDir=tests/big dump=false:
Package pprof:
Processing package=pprof:
Excluding tests/big/net/http/testdata
Excluding tests/big/net/internal
Walking from tests/big to tests/big/net/mail
Processing sourceDir=tests/big dump=false:
Package mail:
Processing package=mail:
Walking from tests/big to tests/big/net/rpc
Processing sourceDir=tests/big dump=false:
Package rpc:
Processing package=rpc:
Walking from tests/big to tests/big/net/rpc/jsonrpc
Processing sourceDir=tests/big dump=false:
Package jsonrpc:
Processing package=jsonrpc:
Walking from tests/big to tests/big/net/smtp
Processing sourceDir=tests/big dump=false:
Package smtp:
Processing package=smtp:
Excluding tests/big/net/testdata
Walking from tests/big to tests/big/net/textproto
Processing sourceDir=tests/big dump=false:
Package textproto:
Processing package=textproto:
Walking from tests/big to tests/big/net/url
Processing sourceDir=tests/big dump=false:
Package url:
Processing package=url:
TYPE cgi.Handler:
  tests/big/net/http/cgi/host.go
TYPE cookiejar.Jar:
  tests/big/net/http/cookiejar/jar.go
TYPE cookiejar.Options:
  tests/big/net/http/cookiejar/jar.go
TYPE cookiejar.PublicSuffixList:
  tests/big/net/http/cookiejar/jar.go
TYPE http.Client:
  tests/big/net/http/client.go
TYPE http.CloseNotifier:
  tests/big/net/http/server.go
TYPE http.ConnState:
  tests/big/net/http/server.go
TYPE http.Cookie:
  tests/big/net/http/cookie.go
TYPE http.CookieJar:
  tests/big/net/http/jar.go
TYPE http.Dir:
  tests/big/net/http/fs.go
TYPE http.File:
  tests/big/net/http/fs.go
TYPE http.FileSystem:
  tests/big/net/http/fs.go
TYPE http.Flusher:
  tests/big/net/http/server.go
TYPE http.Handler:
  tests/big/net/http/server.go
TYPE http.HandlerFunc:
  tests/big/net/http/server.go
TYPE http.Header:
  tests/big/net/http/header.go
TYPE http.Hijacker:
  tests/big/net/http/server.go
TYPE http.ProtocolError:
  tests/big/net/http/request.go
TYPE http.PushOptions:
  tests/big/net/http/http.go
TYPE http.Pusher:
  tests/big/net/http/http.go
TYPE http.Request:
  tests/big/net/http/request.go
TYPE http.Response:
  tests/big/net/http/response.go
TYPE http.ResponseWriter:
  tests/big/net/http/server.go
TYPE http.RoundTripper:
  tests/big/net/http/client.go
TYPE http.SameSite:
  tests/big/net/http/cookie.go
TYPE http.ServeMux:
  tests/big/net/http/server.go
TYPE http.Server:
  tests/big/net/http/server.go
TYPE http.Transport:
  tests/big/net/http/transport.go
TYPE httptest.ResponseRecorder:
  tests/big/net/http/httptest/recorder.go
TYPE httptest.Server:
  tests/big/net/http/httptest/server.go
TYPE httptrace.ClientTrace:
  tests/big/net/http/httptrace/trace.go
TYPE httptrace.DNSDoneInfo:
  tests/big/net/http/httptrace/trace.go
TYPE httptrace.DNSStartInfo:
  tests/big/net/http/httptrace/trace.go
TYPE httptrace.GotConnInfo:
  tests/big/net/http/httptrace/trace.go
TYPE httptrace.WroteRequestInfo:
  tests/big/net/http/httptrace/trace.go
TYPE httputil.BufferPool:
  tests/big/net/http/httputil/reverseproxy.go
TYPE httputil.ClientConn:
  tests/big/net/http/httputil/persist.go
TYPE httputil.ReverseProxy:
  tests/big/net/http/httputil/reverseproxy.go
TYPE httputil.ServerConn:
  tests/big/net/http/httputil/persist.go
TYPE mail.Address:
  tests/big/net/mail/message.go
TYPE mail.AddressParser:
  tests/big/net/mail/message.go
TYPE mail.Header:
  tests/big/net/mail/message.go
TYPE mail.Message:
  tests/big/net/mail/message.go
TYPE net.Addr:
  tests/big/net/net.go
TYPE net.AddrError:
  tests/big/net/net.go
TYPE net.Buffers:
  tests/big/net/net.go
TYPE net.Conn:
  tests/big/net/net.go
TYPE net.DNSConfigError:
  tests/big/net/net.go
TYPE net.DNSError:
  tests/big/net/net.go
TYPE net.Dialer:
  tests/big/net/dial.go
TYPE net.Error:
  tests/big/net/net.go
TYPE net.Flags:
  tests/big/net/interface.go
TYPE net.HardwareAddr:
  tests/big/net/mac.go
TYPE net.IP:
  tests/big/net/ip.go
TYPE net.IPAddr:
  tests/big/net/iprawsock.go
TYPE net.IPConn:
  tests/big/net/iprawsock.go
TYPE net.IPMask:
  tests/big/net/ip.go
TYPE net.IPNet:
  tests/big/net/ip.go
TYPE net.Interface:
  tests/big/net/interface.go
TYPE net.InvalidAddrError:
  tests/big/net/net.go
TYPE net.ListenConfig:
  tests/big/net/dial.go
TYPE net.Listener:
  tests/big/net/net.go
TYPE net.MX:
  tests/big/net/dnsclient.go
TYPE net.NS:
  tests/big/net/dnsclient.go
TYPE net.OpError:
  tests/big/net/net.go
TYPE net.PacketConn:
  tests/big/net/net.go
TYPE net.ParseError:
  tests/big/net/net.go
TYPE net.Resolver:
  tests/big/net/lookup.go
TYPE net.SRV:
  tests/big/net/dnsclient.go
TYPE net.TCPAddr:
  tests/big/net/tcpsock.go
TYPE net.TCPConn:
  tests/big/net/tcpsock.go
TYPE net.TCPListener:
  tests/big/net/tcpsock.go
TYPE net.UDPAddr:
  tests/big/net/udpsock.go
TYPE net.UDPConn:
  tests/big/net/udpsock.go
TYPE net.UnixAddr:
  tests/big/net/unixsock.go
TYPE net.UnixConn:
  tests/big/net/unixsock.go
TYPE net.UnixListener:
  tests/big/net/unixsock.go
TYPE net.UnknownNetworkError:
  tests/big/net/net.go
TYPE rpc.Call:
  tests/big/net/rpc/client.go
TYPE rpc.Client:
  tests/big/net/rpc/client.go
TYPE rpc.ClientCodec:
  tests/big/net/rpc/client.go
TYPE rpc.Request:
  tests/big/net/rpc/server.go
TYPE rpc.Response:
  tests/big/net/rpc/server.go
TYPE rpc.Server:
  tests/big/net/rpc/server.go
TYPE rpc.ServerCodec:
  tests/big/net/rpc/server.go
TYPE rpc.ServerError:
  tests/big/net/rpc/client.go
TYPE smtp.Auth:
  tests/big/net/smtp/auth.go
TYPE smtp.Client:
  tests/big/net/smtp/smtp.go
TYPE smtp.ServerInfo:
  tests/big/net/smtp/auth.go
TYPE textproto.Conn:
  tests/big/net/textproto/textproto.go
TYPE textproto.Error:
  tests/big/net/textproto/textproto.go
TYPE textproto.MIMEHeader:
  tests/big/net/textproto/header.go
TYPE textproto.Pipeline:
  tests/big/net/textproto/pipeline.go
TYPE textproto.ProtocolError:
  tests/big/net/textproto/textproto.go
TYPE textproto.Reader:
  tests/big/net/textproto/reader.go
TYPE textproto.Writer:
  tests/big/net/textproto/writer.go
TYPE url.Error:
  tests/big/net/url/url.go
TYPE url.EscapeError:
  tests/big/net/url/url.go
TYPE url.InvalidHostError:
  tests/big/net/url/url.go
TYPE url.URL:
  tests/big/net/url/url.go
TYPE url.Userinfo:
  tests/big/net/url/url.go
TYPE url.Values:
  tests/big/net/url/url.go
JOKER FUNC cgi.Request has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/cgi/child.go:29:18) Error] Request
;;   "Request returns the HTTP request as represented in the current
;; environment. This assumes the current program is being run
;; by a web server in a CGI environment.
;; The returned Request's Body is populated, if applicable."
;;   {:added "1.0"
;;    :go "request()"}
;;   [])
;; 
JOKER FUNC cgi.RequestFromMap has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/cgi/child.go:52:49) Error] RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.
;; The returned Request's Body field is not populated."
;;   {:added "1.0"
;;    :go "requestFromMap(params)"}
;;   [^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/http/cgi/child.go:52:28) params])
;; 
JOKER FUNC cgi.Serve has: 
;; (defn ^Error Serve
;;   "Serve executes the provided Handler on the currently active CGI
;; request, if any. If there's no current CGI environment
;; an error is returned. The provided handler may be nil to use
;; http.DefaultServeMux."
;;   {:added "1.0"
;;    :go "serve(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/cgi/child.go:146:20) handler])
;; 
JOKER FUNC cookiejar.New has: 
;; (defn ^[{:pslist psList, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/cookiejar/jar.go:64:5) mu, :entries ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/http/cookiejar/jar.go:68:10) entries, :nextseqnum nextSeqNum} Error] New
;;   "New returns a new cookie jar. A nil *Options is equivalent to a zero
;; Options."
;;   {:added "1.0"
;;    :go "new(o)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/cookiejar/jar.go:77:12) o])
;; 
JOKER FUNC fcgi.ProcessEnv has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/fcgi/child.go:358:34) ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r
;; for which no effort was made to be included in the request itself - the data
;; is hidden in the request's context. As an example, if REMOTE_USER is set for a
;; request, it will not be found anywhere in r, but it will be included in
;; ProcessEnv's response (via r's context)."
;;   {:added "1.0"
;;    :go "processEnv(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fcgi/child.go:358:19) r])
;; 
JOKER FUNC fcgi.Serve has: 
;; (defn ^Error Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new
;; goroutine for each. The goroutine reads requests and then calls handler
;; to reply to them.
;; If l is nil, Serve accepts connections from os.Stdin.
;; If handler is nil, http.DefaultServeMux is used."
;;   {:added "1.0"
;;    :go "serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fcgi/child.go:331:14) l, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fcgi/child.go:331:36) handler])
;; 
JOKER FUNC http.CanonicalHeaderKey has: 
(defn ^String CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the
header key s. The canonicalization converts the first
letter and any letter following a hyphen to upper case;
the rest are converted to lowercase. For example, the
canonical key for "accept-encoding" is "Accept-Encoding".
If s contains a space or invalid header field bytes, it is
returned without modifications."
  {:added "1.0"
   :go "canonicalHeaderKey(s)"}
  [^String s])

JOKER FUNC http.DetectContentType has: 
;; (defn ^String DetectContentType
;;   "DetectContentType implements the algorithm described
;; at https://mimesniff.spec.whatwg.org/ to determine the
;; Content-Type of the given data. It considers at most the
;; first 512 bytes of data. DetectContentType always returns
;; a valid MIME type: if it cannot determine a more specific one, it
;; returns "application/octet-stream"."
;;   {:added "1.0"
;;    :go "detectContentType(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/http/sniff.go:21:29) data])
;; 
JOKER FUNC http.Error has: 
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.
;; It does not otherwise end the request; the caller should ensure no further
;; writes are done to w.
;; The error message should be plain text."
;;   {:added "1.0"
;;    :go "error(w, error, code)"}
;;   [w, ^String error, ^Int code])
;; 
JOKER FUNC http.FileServer has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/server.go:84:14) FileServer
;;   "FileServer returns a handler that serves HTTP requests
;; with the contents of the file system rooted at root.
;; 
;; To use the operating system's file system implementation,
;; use http.Dir:
;; 
;;     http.Handle("/", http.FileServer(http.Dir("/tmp")))
;; 
;; As a special case, the returned file server redirects any request
;; ending in "/index.html" to the same path, without the final
;; "index.html"."
;;   {:added "1.0"
;;    :go "fileServer(root)"}
;;   [root])
;; 
JOKER FUNC http.Get has: 
(defn ^[resp err] Get
  "Get issues a GET to the specified URL. If the response is one of
the following redirect codes, Get follows the redirect, up to a
maximum of 10 redirects:

   301 (Moved Permanently)
   302 (Found)
   303 (See Other)
   307 (Temporary Redirect)
   308 (Permanent Redirect)

An error is returned if there were too many redirects or if there
was an HTTP protocol error. A non-2xx response doesn't cause an
error. Any returned error will be of type *url.Error. The url.Error
value's Timeout method will report true if request timed out or was
canceled.

When err is nil, resp always contains a non-nil resp.Body.
Caller should close resp.Body when done reading from it.

Get is a wrapper around DefaultClient.Get.

To make a request with custom headers, use NewRequest and
DefaultClient.Do."
  {:added "1.0"
   :go "get(url)"}
  [^String url])

JOKER FUNC http.Handle has: 
;; (defn Handle
;;   "Handle registers the handler for the given pattern
;; in the DefaultServeMux.
;; The documentation for ServeMux explains how patterns are matched."
;;   {:added "1.0"
;;    :go "handle(pattern, handler)"}
;;   [^String pattern, handler])
;; 
JOKER FUNC http.HandleFunc has: 
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern
;; in the DefaultServeMux.
;; The documentation for ServeMux explains how patterns are matched."
;;   {:added "1.0"
;;    :go "handleFunc(pattern, handler)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/server.go:2406:41) handler])
;; 
JOKER FUNC http.Head has: 
(defn ^[resp err] Head
  "Head issues a HEAD to the specified URL. If the response is one of
the following redirect codes, Head follows the redirect, up to a
maximum of 10 redirects:

   301 (Moved Permanently)
   302 (Found)
   303 (See Other)
   307 (Temporary Redirect)
   308 (Permanent Redirect)

Head is a wrapper around DefaultClient.Head"
  {:added "1.0"
   :go "head(url)"}
  [^String url])

JOKER FUNC http.ListenAndServe has: 
(defn ^Error ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls
Serve with handler to handle requests on incoming connections.
Accepted connections are configured to enable TCP keep-alives.

The handler is typically nil, in which case the DefaultServeMux is used.

ListenAndServe always returns a non-nil error."
  {:added "1.0"
   :go "listenAndServe(addr, handler)"}
  [^String addr, handler])

JOKER FUNC http.ListenAndServeTLS has: 
(defn ^Error ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it
expects HTTPS connections. Additionally, files containing a certificate and
matching private key for the server must be provided. If the certificate
is signed by a certificate authority, the certFile should be the concatenation
of the server's certificate, any intermediates, and the CA's certificate."
  {:added "1.0"
   :go "listenAndServeTLS(addr, certFile, keyFile, handler)"}
  [^String addr, ^String certFile, ^String keyFile, handler])

JOKER FUNC http.MaxBytesReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:1056:65) MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for
;; limiting the size of incoming request bodies. In contrast to
;; io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a
;; non-EOF error for a Read beyond the limit, and closes the
;; underlying reader when its Close method is called.
;; 
;; MaxBytesReader prevents clients from accidentally or maliciously
;; sending a large request and wasting server resources."
;;   {:added "1.0"
;;    :go "maxBytesReader(w, r, n)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:1056:41) r, n])
;; 
JOKER FUNC http.NewFileTransport has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/client.go:115:19) NewFileTransport
;;   "NewFileTransport returns a new RoundTripper, serving the provided
;; FileSystem. The returned RoundTripper ignores the URL host in its
;; incoming requests, as well as most other properties of the
;; request.
;; 
;; The typical use case for NewFileTransport is to register the "file"
;; protocol with a Transport, as in:
;; 
;;   t := &http.Transport{}
;;   t.RegisterProtocol("file", http.NewFileTransport(http.Dir("/")))
;;   c := &http.Client{Transport: t}
;;   res, err := c.Get("file:///etc/passwd")
;;   ..."
;;   {:added "1.0"
;;    :go "newFileTransport(fs)"}
;;   [fs])
;; 
JOKER FUNC http.NewRequest has: 
;; (defn ^[{:method ^String Method, :url ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:127:6) URL, :proto ^String Proto, :protomajor ^Int ProtoMajor, :protominor ^Int ProtoMinor, :header Header, :body ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:181:7) Body, :getbody ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/request.go:189:10) GetBody, :contentlength ContentLength, :transferencoding ^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/http/request.go:204:19) TransferEncoding, :close Close, :host ^String Host, :form ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:241:7) Form, :postform ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:248:11) PostForm, :multipartform ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:253:16) MultipartForm, :trailer Trailer, :remoteaddr ^String RemoteAddr, :requesturi ^String RequestURI, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:297:6) TLS, :cancel ^ABEND881(unrecognized Expr type *ast.ChanType at: tests/big/net/http/request.go:308:9) Cancel, :response ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:313:11) Response, :ctx ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:319:6) ctx} Error] NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.
;; 
;; If the provided body is also an io.Closer, the returned
;; Request.Body is set to body and will be closed by the Client
;; methods Do, Post, and PostForm, and Transport.RoundTrip.
;; 
;; NewRequest returns a Request suitable for use with Client.Do or
;; Transport.RoundTrip. To create a request for use with testing a
;; Server Handler, either use the NewRequest function in the
;; net/http/httptest package, use ReadRequest, or manually update the
;; Request fields. See the Request type's documentation for the
;; difference between inbound and outbound request fields.
;; 
;; If body is of type *bytes.Buffer, *bytes.Reader, or
;; *strings.Reader, the returned request's ContentLength is set to its
;; exact value (instead of -1), GetBody is populated (so 307 and 308
;; redirects can replay the body), and Body is set to NoBody if the
;; ContentLength is 0."
;;   {:added "1.0"
;;    :go "newRequest(method, url, body)"}
;;   [^String method, ^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:792:42) body])
;; 
JOKER FUNC http.NewServeMux has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/server.go:2150:8) mu, :m ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/http/server.go:2151:8) m, :hosts hosts} NewServeMux
;;   "NewServeMux allocates and returns a new ServeMux."
;;   {:added "1.0"
;;    :go "newServeMux()"}
;;   [])
;; 
JOKER FUNC http.NotFound has: 
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error."
;;   {:added "1.0"
;;    :go "notFound(w, r)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/server.go:1981:35) r])
;; 
JOKER FUNC http.NotFoundHandler has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/server.go:84:14) NotFoundHandler
;;   "NotFoundHandler returns a simple request handler
;; that replies to each request with a ``404 page not found'' reply."
;;   {:added "1.0"
;;    :go "notFoundHandler()"}
;;   [])
;; 
JOKER FUNC http.ParseHTTPVersion has: 
(defn ^[major minor ok] ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.
"HTTP/1.0" returns (1, 0, true)."
  {:added "1.0"
   :go "parseHTTPVersion(vers)"}
  [^String vers])

JOKER FUNC http.ParseTime has: 
(defn ^[t err] ParseTime
  "ParseTime parses a time header (such as the Date: header),
trying each of the three formats allowed by HTTP/1.1:
TimeFormat, time.RFC850, and time.ANSIC."
  {:added "1.0"
   :go "parseTime(text)"}
  [^String text])

JOKER FUNC http.Post has: 
;; (defn ^[resp err] Post
;;   "Post issues a POST to the specified URL.
;; 
;; Caller should close resp.Body when done reading from it.
;; 
;; If the provided body is an io.Closer, it is closed after the
;; request.
;; 
;; Post is a wrapper around DefaultClient.Post.
;; 
;; To set custom headers, use NewRequest and DefaultClient.Do.
;; 
;; See the Client.Do method documentation for details on how redirects
;; are handled."
;;   {:added "1.0"
;;    :go "post(url, contentType, body)"}
;;   [^String url, ^String contentType, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/client.go:748:41) body])
;; 
JOKER FUNC http.PostForm has: 
;; (defn ^[resp err] PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and
;; values URL-encoded as the request body.
;; 
;; The Content-Type header is set to application/x-www-form-urlencoded.
;; To set other headers, use NewRequest and DefaultClient.Do.
;; 
;; When err is nil, resp always contains a non-nil resp.Body.
;; Caller should close resp.Body when done reading from it.
;; 
;; PostForm is a wrapper around DefaultClient.PostForm.
;; 
;; See the Client.Do method documentation for details on how redirects
;; are handled."
;;   {:added "1.0"
;;    :go "postForm(url, data)"}
;;   [^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/client.go:785:32) data])
;; 
JOKER FUNC http.ProxyFromEnvironment has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/transport.go:345:43) Error] ProxyFromEnvironment
;;   "ProxyFromEnvironment returns the URL of the proxy to use for a
;; given request, as indicated by the environment variables
;; HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions
;; thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https
;; requests.
;; 
;; The environment values may be either a complete URL or a
;; "host[:port]", in which case the "http" scheme is assumed.
;; An error is returned if the value is a different form.
;; 
;; A nil URL and nil error are returned if no proxy is defined in the
;; environment, or a proxy should not be used for the given request,
;; as defined by NO_PROXY.
;; 
;; As a special case, if req.URL.Host is "localhost" (with or without
;; a port number), then a nil URL and nil error will be returned."
;;   {:added "1.0"
;;    :go "proxyFromEnvironment(req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/transport.go:345:31) req])
;; 
JOKER FUNC http.ProxyURL has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/transport.go:351:34) ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)
;; that always returns the same URL."
;;   {:added "1.0"
;;    :go "proxyURL(fixedURL)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/transport.go:351:24) fixedURL])
;; 
JOKER FUNC http.ReadRequest has: 
;; (defn ^[{:method ^String Method, :url ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:127:6) URL, :proto ^String Proto, :protomajor ^Int ProtoMajor, :protominor ^Int ProtoMinor, :header Header, :body ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:181:7) Body, :getbody ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/request.go:189:10) GetBody, :contentlength ContentLength, :transferencoding ^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/http/request.go:204:19) TransferEncoding, :close Close, :host ^String Host, :form ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:241:7) Form, :postform ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:248:11) PostForm, :multipartform ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:253:16) MultipartForm, :trailer Trailer, :remoteaddr ^String RemoteAddr, :requesturi ^String RequestURI, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:297:6) TLS, :cancel ^ABEND881(unrecognized Expr type *ast.ChanType at: tests/big/net/http/request.go:308:9) Cancel, :response ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:313:11) Response, :ctx ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:319:6) ctx} Error] ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.
;; 
;; ReadRequest is a low-level function and should only be used for
;; specialized applications; most code should use the Server to read
;; requests and handle them via the Handler interface. ReadRequest
;; only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2."
;;   {:added "1.0"
;;    :go "readRequest(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:942:20) b])
;; 
JOKER FUNC http.ReadResponse has: 
;; (defn ^[{:status ^String Status, :statuscode ^Int StatusCode, :proto ^String Proto, :protomajor ^Int ProtoMajor, :protominor ^Int ProtoMinor, :header Header, :body ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:66:7) Body, :contentlength ContentLength, :transferencoding ^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/http/response.go:76:19) TransferEncoding, :close Close, :uncompressed Uncompressed, :trailer Trailer, :request ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/response.go:109:10) Request, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/response.go:115:6) TLS} Error] ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.
;; The req parameter optionally specifies the Request that corresponds
;; to this Response. If nil, a GET request is assumed.
;; Clients must call resp.Body.Close when finished reading resp.Body.
;; After that call, clients can inspect resp.Trailer to find key/value
;; pairs included in the response trailer."
;;   {:added "1.0"
;;    :go "readResponse(r, req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/response.go:148:21) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/response.go:148:40) req])
;; 
JOKER FUNC http.Redirect has: 
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,
;; which may be a path relative to the request path.
;; 
;; The provided code should be in the 3xx range and is usually
;; StatusMovedPermanently, StatusFound or StatusSeeOther.
;; 
;; If the Content-Type header has not been set, Redirect sets it
;; to "text/html; charset=utf-8" and writes a small HTML body.
;; Setting the Content-Type header to any value, including nil,
;; disables that behavior."
;;   {:added "1.0"
;;    :go "redirect(w, r, url, code)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/server.go:2020:35) r, ^String url, ^Int code])
;; 
JOKER FUNC http.RedirectHandler has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/server.go:84:14) RedirectHandler
;;   "RedirectHandler returns a request handler that redirects
;; each request it receives to the given url using the given
;; status code.
;; 
;; The provided code should be in the 3xx range and is usually
;; StatusMovedPermanently, StatusFound or StatusSeeOther."
;;   {:added "1.0"
;;    :go "redirectHandler(url, code)"}
;;   [^String url, ^Int code])
;; 
JOKER FUNC http.Serve has: 
;; (defn ^Error Serve
;;   "Serve accepts incoming HTTP connections on the listener l,
;; creating a new service goroutine for each. The service goroutines
;; read requests and then call handler to reply to them.
;; 
;; The handler is typically nil, in which case the DefaultServeMux is used.
;; 
;; HTTP/2 support is only enabled if the Listener returns *tls.Conn
;; connections and they were configured with "h2" in the TLS
;; Config.NextProtos.
;; 
;; Serve always returns a non-nil error."
;;   {:added "1.0"
;;    :go "serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/server.go:2421:14) l, handler])
;; 
JOKER FUNC http.ServeContent has: 
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the
;; provided ReadSeeker. The main benefit of ServeContent over io.Copy
;; is that it handles Range requests properly, sets the MIME type, and
;; handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,
;; and If-Range requests.
;; 
;; If the response's Content-Type header is not set, ServeContent
;; first tries to deduce the type from name's file extension and,
;; if that fails, falls back to reading the first block of the content
;; and passing it to DetectContentType.
;; The name is otherwise unused; in particular it can be empty and is
;; never sent in the response.
;; 
;; If modtime is not the zero time or Unix epoch, ServeContent
;; includes it in a Last-Modified header in the response. If the
;; request includes an If-Modified-Since header, ServeContent uses
;; modtime to decide whether the content needs to be sent at all.
;; 
;; The content's Seek method must work: ServeContent uses
;; a seek to the end of the content to determine its size.
;; 
;; If the caller has set w's ETag header formatted per RFC 7232, section 2.3,
;; ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.
;; 
;; Note that *os.File implements the io.ReadSeeker interface."
;;   {:added "1.0"
;;    :go "serveContent(w, req, name, modtime, content)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fs.go:151:41) req, ^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fs.go:151:72) modtime, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fs.go:151:91) content])
;; 
JOKER FUNC http.ServeFile has: 
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named
;; file or directory.
;; 
;; If the provided file or directory name is a relative path, it is
;; interpreted relative to the current directory and may ascend to
;; parent directories. If the provided name is constructed from user
;; input, it should be sanitized before calling ServeFile.
;; 
;; As a precaution, ServeFile will reject requests where r.URL.Path
;; contains a ".." path element; this protects against callers who
;; might unsafely use filepath.Join on r.URL.Path without sanitizing
;; it and then use that filepath.Join result as the name argument.
;; 
;; As another special case, ServeFile redirects any request where r.URL.Path
;; ends in "/index.html" to the same path, without the final
;; "index.html". To avoid such redirects either modify the path or
;; use ServeContent.
;; 
;; Outside of those two special cases, ServeFile does not use
;; r.URL.Path for selecting the file or directory to serve; only the
;; file or directory provided in the name argument is used."
;;   {:added "1.0"
;;    :go "serveFile(w, r, name)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fs.go:670:36) r, ^String name])
;; 
JOKER FUNC http.ServeTLS has: 
;; (defn ^Error ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,
;; creating a new service goroutine for each. The service goroutines
;; read requests and then call handler to reply to them.
;; 
;; The handler is typically nil, in which case the DefaultServeMux is used.
;; 
;; Additionally, files containing a certificate and matching private key
;; for the server must be provided. If the certificate is signed by a
;; certificate authority, the certFile should be the concatenation
;; of the server's certificate, any intermediates, and the CA's certificate.
;; 
;; ServeTLS always returns a non-nil error."
;;   {:added "1.0"
;;    :go "serveTLS(l, handler, certFile, keyFile)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/server.go:2438:17) l, handler, ^String certFile, ^String keyFile])
;; 
JOKER FUNC http.SetCookie has: 
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.
;; The provided cookie must have a valid Name. Invalid cookies may be
;; silently dropped."
;;   {:added "1.0"
;;    :go "setCookie(w, cookie)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/cookie.go:157:41) cookie])
;; 
JOKER FUNC http.StatusText has: 
(defn ^String StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty
string if the code is unknown."
  {:added "1.0"
   :go "statusText(code)"}
  [^Int code])

JOKER FUNC http.StripPrefix has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/server.go:84:14) StripPrefix
;;   "StripPrefix returns a handler that serves HTTP requests
;; by removing the given prefix from the request URL's Path
;; and invoking the handler h. StripPrefix handles a
;; request for a path that doesn't begin with prefix by
;; replying with an HTTP 404 not found error."
;;   {:added "1.0"
;;    :go "stripPrefix(prefix, h)"}
;;   [^String prefix, h])
;; 
JOKER FUNC http.TimeoutHandler has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/server.go:84:14) TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.
;; 
;; The new Handler calls h.ServeHTTP to handle each request, but if a
;; call runs for longer than its time limit, the handler responds with
;; a 503 Service Unavailable error and the given message in its body.
;; (If msg is empty, a suitable default message will be sent.)
;; After such a timeout, writes by h to its ResponseWriter will return
;; ErrHandlerTimeout.
;; 
;; TimeoutHandler buffers all Handler writes to memory and does not
;; support the Hijacker or Flusher interfaces."
;;   {:added "1.0"
;;    :go "timeoutHandler(h, dt, msg)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/server.go:3106:35) dt, ^String msg])
;; 
JOKER FUNC httptest.NewRecorder has: 
;; (defn ^{:code ^Int Code, :headermap ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/recorder.go:35:12) HeaderMap, :body ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/recorder.go:39:7) Body, :flushed Flushed, :result ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/recorder.go:44:14) result, :snapheader ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/recorder.go:45:14) snapHeader, :wroteheader wroteHeader} NewRecorder
;;   "NewRecorder returns an initialized ResponseRecorder."
;;   {:added "1.0"
;;    :go "newRecorder()"}
;;   [])
;; 
JOKER FUNC httptest.NewRequest has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/httptest.go:41:57) NewRequest
;;   "NewRequest returns a new incoming server Request, suitable
;; for passing to an http.Handler for testing.
;; 
;; The target is the RFC 7230 "request-target": it may be either a
;; path or an absolute URL. If target is an absolute URL, the host name
;; from the URL is used. Otherwise, "example.com" is used.
;; 
;; The TLS field is set to a non-nil dummy value if target has scheme
;; "https".
;; 
;; The Request.Proto is always HTTP/1.1.
;; 
;; An empty method means "GET".
;; 
;; The provided body may be nil. If the body is of type *bytes.Reader,
;; *strings.Reader, or *bytes.Buffer, the Request.ContentLength is
;; set.
;; 
;; NewRequest panics on error for ease of use in testing, where a
;; panic is acceptable.
;; 
;; To generate a client HTTP request instead of a server request, see
;; the NewRequest function in the net/http package."
;;   {:added "1.0"
;;    :go "newRequest(method, target, body)"}
;;   [^String method, ^String target, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/httptest.go:41:45) body])
;; 
JOKER FUNC httptest.NewServer has: 
;; (defn ^{:url ^String URL, :listener ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:28:11) Listener, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:33:6) TLS, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:37:9) Config, :certificate ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:40:14) certificate, :wg ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:44:5) wg, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:46:9) mu, :closed closed, :conns ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/http/httptest/server.go:48:9) conns, :client ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:52:9) client} NewServer
;;   "NewServer starts and returns a new Server.
;; The caller should call Close when finished, to shut it down."
;;   {:added "1.0"
;;    :go "newServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:80:24) handler])
;; 
JOKER FUNC httptest.NewTLSServer has: 
;; (defn ^{:url ^String URL, :listener ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:28:11) Listener, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:33:6) TLS, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:37:9) Config, :certificate ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:40:14) certificate, :wg ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:44:5) wg, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:46:9) mu, :closed closed, :conns ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/http/httptest/server.go:48:9) conns, :client ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:52:9) client} NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.
;; The caller should call Close when finished, to shut it down."
;;   {:added "1.0"
;;    :go "newTLSServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:160:27) handler])
;; 
JOKER FUNC httptest.NewUnstartedServer has: 
;; (defn ^{:url ^String URL, :listener ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:28:11) Listener, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:33:6) TLS, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:37:9) Config, :certificate ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:40:14) certificate, :wg ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:44:5) wg, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:46:9) mu, :closed closed, :conns ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/http/httptest/server.go:48:9) conns, :client ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptest/server.go:52:9) client} NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.
;; 
;; After changing its configuration, the caller should call Start or
;; StartTLS.
;; 
;; The caller should call Close when finished, to shut it down."
;;   {:added "1.0"
;;    :go "newUnstartedServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:92:33) handler])
;; 
JOKER FUNC httptrace.ContextClientTrace has: 
;; (defn ^{:getconn ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:85:10) GetConn, :gotconn ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:91:10) GotConn, :putidleconn ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:101:14) PutIdleConn, :gotfirstresponsebyte ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:105:23) GotFirstResponseByte, :got100continue ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:109:17) Got100Continue, :got1xxresponse ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:115:17) Got1xxResponse, :dnsstart ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:118:11) DNSStart, :dnsdone ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:121:10) DNSDone, :connectstart ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:126:15) ConnectStart, :connectdone ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:133:14) ConnectDone, :tlshandshakestart ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:138:20) TLSHandshakeStart, :tlshandshakedone ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:143:19) TLSHandshakeDone, :wroteheaderfield ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:148:19) WroteHeaderField, :wroteheaders ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:152:15) WroteHeaders, :wait100continue ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:158:18) Wait100Continue, :wroterequest ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:163:15) WroteRequest} ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the
;; provided context. If none, it returns nil."
;;   {:added "1.0"
;;    :go "contextClientTrace(ctx)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptrace/trace.go:24:29) ctx])
;; 
JOKER FUNC httptrace.WithClientTrace has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptrace/trace.go:34:63) WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent
;; ctx. HTTP client requests made with the returned context will use
;; the provided trace hooks, in addition to any previous hooks
;; registered with ctx. Any hooks defined in the provided trace will
;; be called first."
;;   {:added "1.0"
;;    :go "withClientTrace(ctx, trace)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptrace/trace.go:34:26) ctx, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptrace/trace.go:34:49) trace])
;; 
JOKER FUNC httputil.DumpRequest has: 
;; (defn ^[[ABEND042(cannot find typename httputil.byte)] Error] DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire
;; representation. It should only be used by servers to debug client
;; requests. The returned representation is an approximation only;
;; some details of the initial request are lost while parsing it into
;; an http.Request. In particular, the order and case of header field
;; names are lost. The order of values in multi-valued headers is kept
;; intact. HTTP/2 requests are dumped in HTTP/1.x form, not in their
;; original binary representations.
;; 
;; If body is true, DumpRequest also returns the body. To do so, it
;; consumes req.Body and then replaces it with a new io.ReadCloser
;; that yields the same bytes. If DumpRequest returns an error,
;; the state of req is undefined.
;; 
;; The documentation for http.Request.Write details which fields
;; of req are included in the dump."
;;   {:added "1.0"
;;    :go "dumpRequest(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/dump.go:191:22) req, body])
;; 
JOKER FUNC httputil.DumpRequestOut has: 
;; (defn ^[[ABEND042(cannot find typename httputil.byte)] Error] DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It
;; includes any headers that the standard http.Transport adds, such as
;; User-Agent."
;;   {:added "1.0"
;;    :go "dumpRequestOut(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/dump.go:66:25) req, body])
;; 
JOKER FUNC httputil.DumpResponse has: 
;; (defn ^[[ABEND042(cannot find typename httputil.byte)] Error] DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response."
;;   {:added "1.0"
;;    :go "dumpResponse(resp, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/dump.go:281:24) resp, body])
;; 
JOKER FUNC httputil.NewChunkedReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/httputil.go:20:36) NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r
;; out of HTTP "chunked" format before returning it.
;; The chunkedReader returns io.EOF when the final 0-length chunk is read.
;; 
;; NewChunkedReader is not needed by normal applications. The http package
;; automatically decodes chunking when reading response bodies."
;;   {:added "1.0"
;;    :go "newChunkedReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/httputil.go:20:25) r])
;; 
JOKER FUNC httputil.NewChunkedWriter has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/httputil.go:35:36) NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP
;; "chunked" format before writing them to w. Closing the returned chunkedWriter
;; sends the final 0-length chunk that marks the end of the stream but does
;; not send the final CRLF that appears after trailers; trailers and the last
;; CRLF must be written separately.
;; 
;; NewChunkedWriter is not needed by normal applications. The http
;; package adds chunking automatically if handlers don't set a
;; Content-Length header. Using NewChunkedWriter inside a handler
;; would result in double chunking or chunking with a Content-Length
;; length, both of which are wrong."
;;   {:added "1.0"
;;    :go "newChunkedWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/httputil.go:35:25) w])
;; 
JOKER FUNC httputil.NewClientConn has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:231:18) mu, :c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:232:18) c, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:233:18) r, :re re, :we we, :lastbody ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:235:18) lastbody, :nread ^Int nread, :nwritten ^Int nwritten, :pipereq ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/http/httputil/persist.go:237:18) pipereq, :pipe ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:239:11) pipe, :writereq ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httputil/persist.go:240:11) writeReq} NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.
;; It is low-level, old, and unused by Go's current HTTP stack.
;; We should have deleted it before Go 1.
;; 
;; Deprecated: Use the Client or Transport in package net/http instead."
;;   {:added "1.0"
;;    :go "newClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:248:22) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:248:34) r])
;; 
JOKER FUNC httputil.NewProxyClientConn has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:231:18) mu, :c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:232:18) c, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:233:18) r, :re re, :we we, :lastbody ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:235:18) lastbody, :nread ^Int nread, :nwritten ^Int nwritten, :pipereq ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/http/httputil/persist.go:237:18) pipereq, :pipe ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:239:11) pipe, :writereq ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httputil/persist.go:240:11) writeReq} NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.
;; It is low-level, old, and unused by Go's current HTTP stack.
;; We should have deleted it before Go 1.
;; 
;; Deprecated: Use the Client or Transport in package net/http instead."
;;   {:added "1.0"
;;    :go "newProxyClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:265:27) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:265:39) r])
;; 
JOKER FUNC httputil.NewServerConn has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:38:18) mu, :c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:39:18) c, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:40:18) r, :re re, :we we, :lastbody ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:42:18) lastbody, :nread ^Int nread, :nwritten ^Int nwritten, :pipereq ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/http/httputil/persist.go:44:18) pipereq, :pipe ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:46:7) pipe} NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.
;; It is low-level, old, and unused by Go's current HTTP stack.
;; We should have deleted it before Go 1.
;; 
;; Deprecated: Use the Server in package net/http instead."
;;   {:added "1.0"
;;    :go "newServerConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:54:22) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:54:34) r])
;; 
JOKER FUNC httputil.NewSingleHostReverseProxy has: 
;; (defn ^{:director ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httputil/reverseproxy.go:35:11) Director, :transport ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/reverseproxy.go:39:12) Transport, :flushinterval ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/reverseproxy.go:45:16) FlushInterval, :errorlog ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/reverseproxy.go:51:11) ErrorLog, :bufferpool BufferPool, :modifyresponse ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httputil/reverseproxy.go:67:17) ModifyResponse, :errorhandler ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httputil/reverseproxy.go:74:15) ErrorHandler} NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes
;; URLs to the scheme, host, and base path provided in target. If the
;; target's path is "/base" and the incoming request was for "/dir",
;; the target request will be for /base/dir.
;; NewSingleHostReverseProxy does not rewrite the Host header.
;; To rewrite Host headers, use ReverseProxy directly with a custom
;; Director policy."
;;   {:added "1.0"
;;    :go "newSingleHostReverseProxy(target)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/reverseproxy.go:103:39) target])
;; 
JOKER FUNC jsonrpc.Dial has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:118:38) Error] Dial
;;   "Dial connects to a JSON-RPC server at the specified network address."
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC jsonrpc.NewClient has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:113:42) NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the
;; set of services at the other end of the connection."
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:113:21) conn])
;; 
JOKER FUNC jsonrpc.NewClientCodec has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:37:46) NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn."
;;   {:added "1.0"
;;    :go "newClientCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:37:26) conn])
;; 
JOKER FUNC jsonrpc.NewServerCodec has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/server.go:37:46) NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn."
;;   {:added "1.0"
;;    :go "newServerCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/server.go:37:26) conn])
;; 
JOKER FUNC jsonrpc.ServeConn has: 
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.
;; ServeConn blocks, serving the connection until the client hangs up.
;; The caller typically invokes ServeConn in a go statement."
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/server.go:132:21) conn])
;; 
JOKER FUNC mail.ParseAddress has: 
(defn ^[{:name ^String Name, :address ^String Address} Error] ParseAddress
  "Parses a single RFC 5322 address, e.g. "Barry Gibbs <bg@example.com>""
  {:added "1.0"
   :go "parseAddress(address)"}
  [^String address])

JOKER FUNC mail.ParseAddressList has: 
(defn ^[[{:name ^String Name, :address ^String Address}] Error] ParseAddressList
  "ParseAddressList parses the given string as a list of addresses."
  {:added "1.0"
   :go "parseAddressList(list)"}
  [^String list])

JOKER FUNC mail.ParseDate has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/mail/message.go:95:30) Error] ParseDate
;;   "ParseDate parses an RFC 5322 date string."
;;   {:added "1.0"
;;    :go "parseDate(date)"}
;;   [^String date])
;; 
JOKER FUNC mail.ReadMessage has: 
;; (defn ^[msg err] ReadMessage
;;   "ReadMessage reads a message from r.
;; The headers are parsed, and the body of the message will be available
;; for reading from msg.Body."
;;   {:added "1.0"
;;    :go "readMessage(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/mail/message.go:52:20) r])
;; 
JOKER FUNC net.CIDRMask has: 
;; (defn ^[ABEND042(cannot find typename net.byte)] CIDRMask
;;   "CIDRMask returns an IPMask consisting of `ones' 1 bits
;; followed by 0s up to a total length of `bits' bits.
;; For a mask of this form, CIDRMask is the inverse of IPMask.Size."
;;   {:added "1.0"
;;    :go "cIDRMask(ones, bits)"}
;;   [^Int ones, ^Int bits])
;; 
JOKER FUNC net.Dial has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:113:11) Error] Dial
;;   "Dial connects to the address on the named network.
;; 
;; Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only),
;; "udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4"
;; (IPv4-only), "ip6" (IPv6-only), "unix", "unixgram" and
;; "unixpacket".
;; 
;; For TCP and UDP networks, the address has the form "host:port".
;; The host must be a literal IP address, or a host name that can be
;; resolved to IP addresses.
;; The port must be a literal port number or a service name.
;; If the host is a literal IPv6 address it must be enclosed in square
;; brackets, as in "[2001:db8::1]:80" or "[fe80::1%zone]:80".
;; The zone specifies the scope of the literal IPv6 address as defined
;; in RFC 4007.
;; The functions JoinHostPort and SplitHostPort manipulate a pair of
;; host and port in this form.
;; When using TCP, and the host resolves to multiple IP addresses,
;; Dial will try each IP address in order until one succeeds.
;; 
;; Examples:
;; 	Dial("tcp", "golang.org:http")
;; 	Dial("tcp", "192.0.2.1:http")
;; 	Dial("tcp", "198.51.100.1:80")
;; 	Dial("udp", "[2001:db8::1]:domain")
;; 	Dial("udp", "[fe80::1%lo0]:53")
;; 	Dial("tcp", ":80")
;; 
;; For IP networks, the network must be "ip", "ip4" or "ip6" followed
;; by a colon and a literal protocol number or a protocol name, and
;; the address has the form "host". The host must be a literal IP
;; address or a literal IPv6 address with zone.
;; It depends on each operating system how the operating system
;; behaves with a non-well known protocol number such as "0" or "255".
;; 
;; Examples:
;; 	Dial("ip4:1", "192.0.2.1")
;; 	Dial("ip6:ipv6-icmp", "2001:db8::1")
;; 	Dial("ip6:58", "fe80::1%lo0")
;; 
;; For TCP, UDP and IP networks, if the host is empty or a literal
;; unspecified IP address, as in ":80", "0.0.0.0:80" or "[::]:80" for
;; TCP and UDP, "", "0.0.0.0" or "::" for IP, the local system is
;; assumed.
;; 
;; For Unix networks, the address must be a file system path."
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC net.DialIP has: 
;; (defn ^[{} Error] DialIP
;;   "DialIP acts like Dial for IP networks.
;; 
;; The network must be an IP network name; see func Dial for details.
;; 
;; If laddr is nil, a local address is automatically chosen.
;; If the IP field of raddr is nil or an unspecified IP address, the
;; local system is assumed."
;;   {:added "1.0"
;;    :go "dialIP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/iprawsock.go:211:42) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/iprawsock.go:211:42) raddr])
;; 
JOKER FUNC net.DialTCP has: 
;; (defn ^[{} Error] DialTCP
;;   "DialTCP acts like Dial for TCP networks.
;; 
;; The network must be a TCP network name; see func Dial for details.
;; 
;; If laddr is nil, a local address is automatically chosen.
;; If the IP field of raddr is nil or an unspecified IP address, the
;; local system is assumed."
;;   {:added "1.0"
;;    :go "dialTCP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/tcpsock.go:206:43) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/tcpsock.go:206:43) raddr])
;; 
JOKER FUNC net.DialTimeout has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:113:11) Error] DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.
;; 
;; The timeout includes name resolution, if required.
;; When using TCP, and the host in the address parameter resolves to
;; multiple IP addresses, the timeout is spread over each consecutive
;; dial, such that each is given an appropriate fraction of the time
;; to connect.
;; 
;; See func Dial for a description of the network and address
;; parameters."
;;   {:added "1.0"
;;    :go "dialTimeout(network, address, timeout)"}
;;   [^String network, ^String address, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/dial.go:313:51) timeout])
;; 
JOKER FUNC net.DialUDP has: 
;; (defn ^[{} Error] DialUDP
;;   "DialUDP acts like Dial for UDP networks.
;; 
;; The network must be a UDP network name; see func Dial for details.
;; 
;; If laddr is nil, a local address is automatically chosen.
;; If the IP field of raddr is nil or an unspecified IP address, the
;; local system is assumed."
;;   {:added "1.0"
;;    :go "dialUDP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:205:43) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:205:43) raddr])
;; 
JOKER FUNC net.DialUnix has: 
;; (defn ^[{} Error] DialUnix
;;   "DialUnix acts like Dial for Unix networks.
;; 
;; The network must be a Unix network name; see func Dial for details.
;; 
;; If laddr is non-nil, it is used as the local address for the
;; connection."
;;   {:added "1.0"
;;    :go "dialUnix(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:200:44) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:200:44) raddr])
;; 
JOKER FUNC net.FileConn has: 
;; (defn ^[c err] FileConn
;;   "FileConn returns a copy of the network connection corresponding to
;; the open file f.
;; It is the caller's responsibility to close f when finished.
;; Closing c does not affect f, and closing f does not affect c."
;;   {:added "1.0"
;;    :go "fileConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/file.go:21:17) f])
;; 
JOKER FUNC net.FileListener has: 
;; (defn ^[ln err] FileListener
;;   "FileListener returns a copy of the network listener corresponding
;; to the open file f.
;; It is the caller's responsibility to close ln when finished.
;; Closing ln does not affect f, and closing f does not affect ln."
;;   {:added "1.0"
;;    :go "fileListener(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/file.go:33:21) f])
;; 
JOKER FUNC net.FilePacketConn has: 
;; (defn ^[c err] FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection
;; corresponding to the open file f.
;; It is the caller's responsibility to close f when finished.
;; Closing c does not affect f, and closing f does not affect c."
;;   {:added "1.0"
;;    :go "filePacketConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/file.go:45:23) f])
;; 
JOKER FUNC net.IPv4 has: 
;; (defn ^[ABEND042(cannot find typename net.byte)] IPv4
;;   "IPv4 returns the IP address (in 16-byte form) of the
;; IPv4 address a.b.c.d."
;;   {:added "1.0"
;;    :go "iPv4(a, b, c, d)"}
;;   [a, b, c, d])
;; 
JOKER FUNC net.IPv4Mask has: 
;; (defn ^[ABEND042(cannot find typename net.byte)] IPv4Mask
;;   "IPv4Mask returns the IP mask (in 4-byte form) of the
;; IPv4 mask a.b.c.d."
;;   {:added "1.0"
;;    :go "iPv4Mask(a, b, c, d)"}
;;   [a, b, c, d])
;; 
JOKER FUNC net.InterfaceAddrs has: 
;; (defn ^[[ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:105:11)] Error] InterfaceAddrs
;;   "InterfaceAddrs returns a list of the system's unicast interface
;; addresses.
;; 
;; The returned list does not identify the associated interface; use
;; Interfaces and Interface.Addrs for more detail."
;;   {:added "1.0"
;;    :go "interfaceAddrs()"}
;;   [])
;; 
JOKER FUNC net.InterfaceByIndex has: 
(defn ^[{:index ^Int Index, :mtu ^Int MTU, :name ^String Name, :hardwareaddr HardwareAddr, :flags Flags} Error] InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.

On Solaris, it returns one of the logical network interfaces
sharing the logical data link; for more precision use
InterfaceByName."
  {:added "1.0"
   :go "interfaceByIndex(index)"}
  [^Int index])

JOKER FUNC net.InterfaceByName has: 
(defn ^[{:index ^Int Index, :mtu ^Int MTU, :name ^String Name, :hardwareaddr HardwareAddr, :flags Flags} Error] InterfaceByName
  "InterfaceByName returns the interface specified by name."
  {:added "1.0"
   :go "interfaceByName(name)"}
  [^String name])

JOKER FUNC net.Interfaces has: 
(defn ^[[{:index ^Int Index, :mtu ^Int MTU, :name ^String Name, :hardwareaddr HardwareAddr, :flags Flags}] Error] Interfaces
  "Interfaces returns a list of the system's network interfaces."
  {:added "1.0"
   :go "interfaces()"}
  [])

JOKER FUNC net.JoinHostPort has: 
(defn ^String JoinHostPort
  "JoinHostPort combines host and port into a network address of the
form "host:port". If host contains a colon, as found in literal
IPv6 addresses, then JoinHostPort returns "[host]:port".

See func Dial for a description of the host and port parameters."
  {:added "1.0"
   :go "joinHostPort(host, port)"}
  [^String host, ^String port])

JOKER FUNC net.Listen has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:365:15) Error] Listen
;;   "Listen announces on the local network address.
;; 
;; The network must be "tcp", "tcp4", "tcp6", "unix" or "unixpacket".
;; 
;; For TCP networks, if the host in the address parameter is empty or
;; a literal unspecified IP address, Listen listens on all available
;; unicast and anycast IP addresses of the local system.
;; To only use IPv4, use network "tcp4".
;; The address can use a host name, but this is not recommended,
;; because it will create a listener for at most one of the host's IP
;; addresses.
;; If the port in the address parameter is empty or "0", as in
;; "127.0.0.1:" or "[::1]:0", a port number is automatically chosen.
;; The Addr method of Listener can be used to discover the chosen
;; port.
;; 
;; See func Dial for a description of the network and address
;; parameters."
;;   {:added "1.0"
;;    :go "listen(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC net.ListenIP has: 
;; (defn ^[{} Error] ListenIP
;;   "ListenIP acts like ListenPacket for IP networks.
;; 
;; The network must be an IP network name; see func Dial for details.
;; 
;; If the IP field of laddr is nil or an unspecified IP address,
;; ListenIP listens on all available IP addresses of the local system
;; except multicast IP addresses."
;;   {:added "1.0"
;;    :go "listenIP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/iprawsock.go:230:37) laddr])
;; 
JOKER FUNC net.ListenMulticastUDP has: 
;; (defn ^[{} Error] ListenMulticastUDP
;;   "ListenMulticastUDP acts like ListenPacket for UDP networks but
;; takes a group address on a specific network interface.
;; 
;; The network must be a UDP network name; see func Dial for details.
;; 
;; ListenMulticastUDP listens on all available IP addresses of the
;; local system including the group, multicast IP address.
;; If ifi is nil, ListenMulticastUDP uses the system-assigned
;; multicast interface, although this is not recommended because the
;; assignment depends on platforms and sometimes it might require
;; routing configuration.
;; If the Port field of gaddr is 0, a port number is automatically
;; chosen.
;; 
;; ListenMulticastUDP is just for convenience of simple, small
;; applications. There are golang.org/x/net/ipv4 and
;; golang.org/x/net/ipv6 packages for general purpose uses."
;;   {:added "1.0"
;;    :go "listenMulticastUDP(network, ifi, gaddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:265:45) ifi, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:265:63) gaddr])
;; 
JOKER FUNC net.ListenPacket has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:303:17) Error] ListenPacket
;;   "ListenPacket announces on the local network address.
;; 
;; The network must be "udp", "udp4", "udp6", "unixgram", or an IP
;; transport. The IP transports are "ip", "ip4", or "ip6" followed by
;; a colon and a literal protocol number or a protocol name, as in
;; "ip:1" or "ip:icmp".
;; 
;; For UDP and IP networks, if the host in the address parameter is
;; empty or a literal unspecified IP address, ListenPacket listens on
;; all available IP addresses of the local system except multicast IP
;; addresses.
;; To only use IPv4, use network "udp4" or "ip4:proto".
;; The address can use a host name, but this is not recommended,
;; because it will create a listener for at most one of the host's IP
;; addresses.
;; If the port in the address parameter is empty or "0", as in
;; "127.0.0.1:" or "[::1]:0", a port number is automatically chosen.
;; The LocalAddr method of PacketConn can be used to discover the
;; chosen port.
;; 
;; See func Dial for a description of the network and address
;; parameters."
;;   {:added "1.0"
;;    :go "listenPacket(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC net.ListenTCP has: 
;; (defn ^[{:fd ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/tcpsock.go:226:5) fd} Error] ListenTCP
;;   "ListenTCP acts like Listen for TCP networks.
;; 
;; The network must be a TCP network name; see func Dial for details.
;; 
;; If the IP field of laddr is nil or an unspecified IP address,
;; ListenTCP listens on all available unicast and anycast IP addresses
;; of the local system.
;; If the Port field of laddr is 0, a port number is automatically
;; chosen."
;;   {:added "1.0"
;;    :go "listenTCP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/tcpsock.go:323:38) laddr])
;; 
JOKER FUNC net.ListenUDP has: 
;; (defn ^[{} Error] ListenUDP
;;   "ListenUDP acts like ListenPacket for UDP networks.
;; 
;; The network must be a UDP network name; see func Dial for details.
;; 
;; If the IP field of laddr is nil or an unspecified IP address,
;; ListenUDP listens on all available IP addresses of the local system
;; except multicast IP addresses.
;; If the Port field of laddr is 0, a port number is automatically
;; chosen."
;;   {:added "1.0"
;;    :go "listenUDP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:231:38) laddr])
;; 
JOKER FUNC net.ListenUnix has: 
;; (defn ^[{:fd ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:218:13) fd, :path ^String path, :unlink unlink, :unlinkonce ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/unixsock.go:221:13) unlinkOnce} Error] ListenUnix
;;   "ListenUnix acts like Listen for Unix networks.
;; 
;; The network must be "unix" or "unixpacket"."
;;   {:added "1.0"
;;    :go "listenUnix(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:314:39) laddr])
;; 
JOKER FUNC net.ListenUnixgram has: 
;; (defn ^[{} Error] ListenUnixgram
;;   "ListenUnixgram acts like ListenPacket for Unix networks.
;; 
;; The network must be "unixgram"."
;;   {:added "1.0"
;;    :go "listenUnixgram(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:334:43) laddr])
;; 
JOKER FUNC net.LookupAddr has: 
(defn ^[names err] LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.

When using the host C library resolver, at most one result will be
returned. To bypass the host resolver, use a custom Resolver."
  {:added "1.0"
   :go "lookupAddr(addr)"}
  [^String addr])

JOKER FUNC net.LookupCNAME has: 
(defn ^[cname err] LookupCNAME
  "LookupCNAME returns the canonical name for the given host.
Callers that do not care about the canonical name can call
LookupHost or LookupIP directly; both take care of resolving
the canonical name as part of the lookup.

A canonical name is the final name after following zero
or more CNAME records.
LookupCNAME does not return an error if host does not
contain DNS "CNAME" records, as long as host resolves to
address records."
  {:added "1.0"
   :go "lookupCNAME(host)"}
  [^String host])

JOKER FUNC net.LookupHost has: 
(defn ^[addrs err] LookupHost
  "LookupHost looks up the given host using the local resolver.
It returns a slice of that host's addresses."
  {:added "1.0"
   :go "lookupHost(host)"}
  [^String host])

JOKER FUNC net.LookupIP has: 
;; (defn ^[[[ABEND042(cannot find typename net.byte)]] Error] LookupIP
;;   "LookupIP looks up host using the local resolver.
;; It returns a slice of that host's IPv4 and IPv6 addresses."
;;   {:added "1.0"
;;    :go "lookupIP(host)"}
;;   [^String host])
;; 
JOKER FUNC net.LookupMX has: 
(defn ^[[{:host ^String Host, :pref ^Int Pref}] Error] LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference."
  {:added "1.0"
   :go "lookupMX(name)"}
  [^String name])

JOKER FUNC net.LookupNS has: 
(defn ^[[{:host ^String Host}] Error] LookupNS
  "LookupNS returns the DNS NS records for the given domain name."
  {:added "1.0"
   :go "lookupNS(name)"}
  [^String name])

JOKER FUNC net.LookupPort has: 
(defn ^[port err] LookupPort
  "LookupPort looks up the port for the given network and service."
  {:added "1.0"
   :go "lookupPort(network, service)"}
  [^String network, ^String service])

JOKER FUNC net.LookupSRV has: 
(defn ^[cname addrs err] LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,
protocol, and domain name. The proto is "tcp" or "udp".
The returned records are sorted by priority and randomized
by weight within a priority.

LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name. To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly."
  {:added "1.0"
   :go "lookupSRV(service, proto, name)"}
  [^String service, ^String proto, ^String name])

JOKER FUNC net.LookupTXT has: 
(defn ^[[String] Error] LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name."
  {:added "1.0"
   :go "lookupTXT(name)"}
  [^String name])

JOKER FUNC net.ParseCIDR has: 
;; (defn ^[[ABEND042(cannot find typename net.byte)] {:ip IP, :mask Mask} Error] ParseCIDR
;;   "ParseCIDR parses s as a CIDR notation IP address and prefix length,
;; like "192.0.2.0/24" or "2001:db8::/32", as defined in
;; RFC 4632 and RFC 4291.
;; 
;; It returns the IP address and the network implied by the IP and
;; prefix length.
;; For example, ParseCIDR("192.0.2.1/24") returns the IP address
;; 192.0.2.1 and the network 192.0.2.0/24."
;;   {:added "1.0"
;;    :go "parseCIDR(s)"}
;;   [^String s])
;; 
JOKER FUNC net.ParseIP has: 
;; (defn ^[ABEND042(cannot find typename net.byte)] ParseIP
;;   "ParseIP parses s as an IP address, returning the result.
;; The string s can be in dotted decimal ("192.0.2.1")
;; or IPv6 ("2001:db8::68") form.
;; If s is not a valid textual representation of an IP address,
;; ParseIP returns nil."
;;   {:added "1.0"
;;    :go "parseIP(s)"}
;;   [^String s])
;; 
JOKER FUNC net.ParseMAC has: 
(defn ^[hw err] ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet
IP over InfiniBand link-layer address using one of the following formats:
  01:23:45:67:89:ab
  01:23:45:67:89:ab:cd:ef
  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00
  01-23-45-67-89-ab
  01-23-45-67-89-ab-cd-ef
  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00
  0123.4567.89ab
  0123.4567.89ab.cdef
  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000"
  {:added "1.0"
   :go "parseMAC(s)"}
  [^String s])

JOKER FUNC net.Pipe has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:113:11) ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:113:11)] Pipe
;;   "Pipe creates a synchronous, in-memory, full duplex
;; network connection; both ends implement the Conn interface.
;; Reads on one end are matched with writes on the other,
;; copying data directly between the two; there is no internal
;; buffering."
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])
;; 
JOKER FUNC net.ResolveIPAddr has: 
(defn ^[{:ip IP, :zone ^String Zone} Error] ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.

The network must be an IP network name.

If the host in the address parameter is not a literal IP address,
ResolveIPAddr resolves the address to an address of IP end point.
Otherwise, it parses the address as a literal IP address.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.

See func Dial for a description of the network and address
parameters."
  {:added "1.0"
   :go "resolveIPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveTCPAddr has: 
(defn ^[{:ip IP, :port ^Int Port, :zone ^String Zone} Error] ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.

The network must be a TCP network name.

If the host in the address parameter is not a literal IP address or
the port is not a literal port number, ResolveTCPAddr resolves the
address to an address of TCP end point.
Otherwise, it parses the address as a pair of literal IP address
and port number.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.

See func Dial for a description of the network and address
parameters."
  {:added "1.0"
   :go "resolveTCPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveUDPAddr has: 
(defn ^[{:ip IP, :port ^Int Port, :zone ^String Zone} Error] ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.

The network must be a UDP network name.

If the host in the address parameter is not a literal IP address or
the port is not a literal port number, ResolveUDPAddr resolves the
address to an address of UDP end point.
Otherwise, it parses the address as a pair of literal IP address
and port number.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.

See func Dial for a description of the network and address
parameters."
  {:added "1.0"
   :go "resolveUDPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveUnixAddr has: 
(defn ^[{:name ^String Name, :net ^String Net} Error] ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.

The network must be a Unix network name.

See func Dial for a description of the network and address
parameters."
  {:added "1.0"
   :go "resolveUnixAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.SplitHostPort has: 
(defn ^[host port err] SplitHostPort
  "SplitHostPort splits a network address of the form "host:port",
"host%zone:port", "[host]:port" or "[host%zone]:port" into host or
host%zone and port.

A literal IPv6 address in hostport must be enclosed in square
brackets, as in "[::1]:80", "[::1%lo0]:80".

See func Dial for a description of the hostport parameter, and host
and port results."
  {:added "1.0"
   :go "splitHostPort(hostport)"}
  [^String hostport])

JOKER FUNC pprof.Cmdline has: 
;; (defn Cmdline
;;   "Cmdline responds with the running program's
;; command line, with arguments separated by NUL bytes.
;; The package initialization registers it as /debug/pprof/cmdline."
;;   {:added "1.0"
;;    :go "cmdline(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:83:16) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:83:39) r])
;; 
JOKER FUNC pprof.Handler has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:221:27) Handler
;;   "Handler returns an HTTP handler that serves the named profile."
;;   {:added "1.0"
;;    :go "handler(name)"}
;;   [^String name])
;; 
JOKER FUNC pprof.Index has: 
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.
;; For example, "/debug/pprof/heap" serves the "heap" profile.
;; Index responds to a request for "/debug/pprof/" with an HTML page
;; listing the available profiles."
;;   {:added "1.0"
;;    :go "index(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:264:14) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:264:37) r])
;; 
JOKER FUNC pprof.Profile has: 
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.
;; Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
;; The package initialization registers it as /debug/pprof/profile."
;;   {:added "1.0"
;;    :go "profile(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:116:16) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:116:39) r])
;; 
JOKER FUNC pprof.Symbol has: 
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,
;; responding with a table mapping program counters to function names.
;; The package initialization registers it as /debug/pprof/symbol."
;;   {:added "1.0"
;;    :go "symbol(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:174:15) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:174:38) r])
;; 
JOKER FUNC pprof.Trace has: 
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.
;; Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
;; The package initialization registers it as /debug/pprof/trace."
;;   {:added "1.0"
;;    :go "trace(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:145:14) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:145:37) r])
;; 
JOKER FUNC rpc.Accept has: 
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests
;; to DefaultServer for each incoming connection.
;; Accept blocks; the caller typically invokes it in a go statement."
;;   {:added "1.0"
;;    :go "accept(lis)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:692:17) lis])
;; 
JOKER FUNC rpc.Dial has: 
;; (defn ^[{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:44:11) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:47:11) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/rpc/client.go:49:11) pending, :closing closing, :shutdown shutdown} Error] Dial
;;   "Dial connects to an RPC server at the specified network address."
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC rpc.DialHTTP has: 
;; (defn ^[{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:44:11) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:47:11) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/rpc/client.go:49:11) pending, :closing closing, :shutdown shutdown} Error] DialHTTP
;;   "DialHTTP connects to an HTTP RPC server at the specified network address
;; listening on the default HTTP RPC path."
;;   {:added "1.0"
;;    :go "dialHTTP(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC rpc.DialHTTPPath has: 
;; (defn ^[{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:44:11) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:47:11) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/rpc/client.go:49:11) pending, :closing closing, :shutdown shutdown} Error] DialHTTPPath
;;   "DialHTTPPath connects to an HTTP RPC server
;; at the specified network address and path."
;;   {:added "1.0"
;;    :go "dialHTTPPath(network, address, path)"}
;;   [^String network, ^String address, ^String path])
;; 
JOKER FUNC rpc.HandleHTTP has: 
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer
;; on DefaultRPCPath and a debugging handler on DefaultDebugPath.
;; It is still necessary to invoke http.Serve(), typically in a go statement."
;;   {:added "1.0"
;;    :go "handleHTTP()"}
;;   [])
;; 
JOKER FUNC rpc.NewClient has: 
;; (defn ^{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:44:11) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:47:11) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/rpc/client.go:49:11) pending, :closing closing, :shutdown shutdown} NewClient
;;   "NewClient returns a new Client to handle requests to the
;; set of services at the other end of the connection.
;; It adds a buffer to the write side of the connection so
;; the header and payload are sent as a unit.
;; 
;; The read and write halves of the connection are serialized independently,
;; so no interlocking is required. However each half may be accessed
;; concurrently so the implementation of conn should protect against
;; concurrent reads or concurrent writes."
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:193:21) conn])
;; 
JOKER FUNC rpc.NewClientWithCodec has: 
;; (defn ^{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:44:11) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:47:11) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/rpc/client.go:49:11) pending, :closing closing, :shutdown shutdown} NewClientWithCodec
;;   "NewClientWithCodec is like NewClient but uses the specified
;; codec to encode requests and decode responses."
;;   {:added "1.0"
;;    :go "newClientWithCodec(codec)"}
;;   [codec])
;; 
JOKER FUNC rpc.NewServer has: 
;; (defn ^{:servicemap ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:190:13) serviceMap, :reqlock ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:191:13) reqLock, :freereq ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/rpc/server.go:192:13) freeReq, :resplock ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:193:13) respLock, :freeresp ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/rpc/server.go:194:13) freeResp} NewServer
;;   "NewServer returns a new Server."
;;   {:added "1.0"
;;    :go "newServer()"}
;;   [])
;; 
JOKER FUNC rpc.Register has: 
;; (defn ^Error Register
;;   "Register publishes the receiver's methods in the DefaultServer."
;;   {:added "1.0"
;;    :go "register(rcvr)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: tests/big/net/rpc/server.go:642:20) rcvr])
;; 
JOKER FUNC rpc.RegisterName has: 
;; (defn ^Error RegisterName
;;   "RegisterName is like Register but uses the provided name for the type
;; instead of the receiver's concrete type."
;;   {:added "1.0"
;;    :go "registerName(name, rcvr)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: tests/big/net/rpc/server.go:646:37) rcvr])
;; 
JOKER FUNC rpc.ServeCodec has: 
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to
;; decode requests and encode responses."
;;   {:added "1.0"
;;    :go "serveCodec(codec)"}
;;   [codec])
;; 
JOKER FUNC rpc.ServeConn has: 
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.
;; ServeConn blocks, serving the connection until the client hangs up.
;; The caller typically invokes ServeConn in a go statement.
;; ServeConn uses the gob wire format (see package gob) on the
;; connection. To use an alternate codec, use ServeCodec.
;; See NewClient's comment for information about concurrent access."
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:673:21) conn])
;; 
JOKER FUNC rpc.ServeRequest has: 
(defn ^Error ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.
It does not close the codec upon completion."
  {:added "1.0"
   :go "serveRequest(codec)"}
  [codec])

JOKER FUNC smtp.CRAMMD5Auth has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/smtp/auth.go:15:11) CRAMMD5Auth
;;   "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication
;; mechanism as defined in RFC 2195.
;; The returned Auth uses the given username and secret to authenticate
;; to the server using the challenge-response mechanism."
;;   {:added "1.0"
;;    :go "cRAMMD5Auth(username, secret)"}
;;   [^String username, ^String secret])
;; 
JOKER FUNC smtp.Dial has: 
;; (defn ^[{:text ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/smtp/smtp.go:33:7) Text, :conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/smtp/smtp.go:36:7) conn, :tls tls, :servername ^String serverName, :ext ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/smtp/smtp.go:41:6) ext, :auth ^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/smtp/smtp.go:43:13) auth, :localname ^String localName, :didhello didHello, :helloerror helloError} Error] Dial
;;   "Dial returns a new Client connected to an SMTP server at addr.
;; The addr must include a port, as in "mail.example.com:smtp"."
;;   {:added "1.0"
;;    :go "dial(addr)"}
;;   [^String addr])
;; 
JOKER FUNC smtp.NewClient has: 
;; (defn ^[{:text ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/smtp/smtp.go:33:7) Text, :conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/smtp/smtp.go:36:7) conn, :tls tls, :servername ^String serverName, :ext ^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/smtp/smtp.go:41:6) ext, :auth ^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/smtp/smtp.go:43:13) auth, :localname ^String localName, :didhello didHello, :helloerror helloError} Error] NewClient
;;   "NewClient returns a new Client using an existing connection and host as a
;; server name to be used when authenticating."
;;   {:added "1.0"
;;    :go "newClient(conn, host)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/smtp/smtp.go:62:21) conn, ^String host])
;; 
JOKER FUNC smtp.PlainAuth has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/smtp/auth.go:15:11) PlainAuth
;;   "PlainAuth returns an Auth that implements the PLAIN authentication
;; mechanism as defined in RFC 4616. The returned Auth uses the given
;; username and password to authenticate to host and act as identity.
;; Usually identity should be the empty string, to act as username.
;; 
;; PlainAuth will only send the credentials if the connection is using TLS
;; or is connected to localhost. Otherwise authentication will fail with an
;; error, without sending the credentials."
;;   {:added "1.0"
;;    :go "plainAuth(identity, username, password, host)"}
;;   [^String identity, ^String username, ^String password, ^String host])
;; 
JOKER FUNC smtp.SendMail has: 
;; (defn ^Error SendMail
;;   "SendMail connects to the server at addr, switches to TLS if
;; possible, authenticates with the optional mechanism a if possible,
;; and then sends an email from address from, to addresses to, with
;; message msg.
;; The addr must include a port, as in "mail.example.com:smtp".
;; 
;; The addresses in the to parameter are the SMTP RCPT addresses.
;; 
;; The msg parameter should be an RFC 822-style email with headers
;; first, a blank line, and then the message body. The lines of msg
;; should be CRLF terminated. The msg headers should usually include
;; fields such as "From", "To", "Subject", and "Cc".  Sending "Bcc"
;; messages is accomplished by including an email address in the to
;; parameter but not including it in the msg headers.
;; 
;; The SendMail function and the net/smtp package are low-level
;; mechanisms and provide no support for DKIM signing, MIME
;; attachments (see the mime/multipart package), or other mail
;; functionality. Higher-level packages exist outside of the standard
;; library."
;;   {:added "1.0"
;;    :go "sendMail(addr, a, from, to, msg)"}
;;   [^String addr, a, ^String from, ^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/smtp/smtp.go:319:52) to, ^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/smtp/smtp.go:319:66) msg])
;; 
JOKER FUNC textproto.CanonicalMIMEHeaderKey has: 
(defn ^String CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the
MIME header key s. The canonicalization converts the first
letter and any letter following a hyphen to upper case;
the rest are converted to lowercase. For example, the
canonical key for "accept-encoding" is "Accept-Encoding".
MIME header keys are assumed to be ASCII only.
If s contains a space or invalid header field bytes, it is
returned without modifications."
  {:added "1.0"
   :go "canonicalMIMEHeaderKey(s)"}
  [^String s])

JOKER FUNC textproto.Dial has: 
;; (defn ^[{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/textproto/textproto.go:62:7) conn} Error] Dial
;;   "Dial connects to the given address on the given network using net.Dial
;; and then returns a new Conn for the connection."
;;   {:added "1.0"
;;    :go "dial(network, addr)"}
;;   [^String network, ^String addr])
;; 
JOKER FUNC textproto.NewConn has: 
;; (defn ^{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/textproto/textproto.go:62:7) conn} NewConn
;;   "NewConn returns a new Conn using conn for I/O."
;;   {:added "1.0"
;;    :go "newConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/textproto/textproto.go:66:19) conn])
;; 
JOKER FUNC textproto.NewReader has: 
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/textproto/reader.go:19:6) R, :dot ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/textproto/reader.go:20:6) dot, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/textproto/reader.go:21:6) buf} NewReader
;;   "NewReader returns a new Reader reading from r.
;; 
;; To avoid denial of service attacks, the provided bufio.Reader
;; should be reading from an io.LimitReader or similar Reader to bound
;; the size of responses."
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/textproto/reader.go:29:18) r])
;; 
JOKER FUNC textproto.NewWriter has: 
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/textproto/writer.go:16:6) W, :dot ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/textproto/writer.go:17:6) dot} NewWriter
;;   "NewWriter returns a new Writer writing to w."
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/textproto/writer.go:21:18) w])
;; 
JOKER FUNC textproto.TrimBytes has: 
;; (defn ^[ABEND042(cannot find typename textproto.byte)] TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space."
;;   {:added "1.0"
;;    :go "trimBytes(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/textproto/textproto.go:137:18) b])
;; 
JOKER FUNC textproto.TrimString has: 
(defn ^String TrimString
  "TrimString returns s without leading and trailing ASCII space."
  {:added "1.0"
   :go "trimString(s)"}
  [^String s])

JOKER FUNC url.Parse has: 
;; (defn ^[{:scheme ^String Scheme, :opaque ^String Opaque, :user ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/url/url.go:347:13) User, :host ^String Host, :path ^String Path, :rawpath ^String RawPath, :forcequery ForceQuery, :rawquery ^String RawQuery, :fragment ^String Fragment} Error] Parse
;;   "Parse parses rawurl into a URL structure.
;; 
;; The rawurl may be relative (a path, without a host) or absolute
;; (starting with a scheme). Trying to parse a hostname and path
;; without a scheme is invalid but may not necessarily return an
;; error, due to parsing ambiguities."
;;   {:added "1.0"
;;    :go "parse(rawurl)"}
;;   [^String rawurl])
;; 
JOKER FUNC url.ParseQuery has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/url/url.go:804:13) Error] ParseQuery
;;   "ParseQuery parses the URL-encoded query string and returns
;; a map listing the values specified for each key.
;; ParseQuery always returns a non-nil map containing all the
;; valid query parameters found; err describes the first decoding error
;; encountered, if any.
;; 
;; Query is expected to be a list of key=value settings separated by
;; ampersands or semicolons. A setting without an equals sign is
;; interpreted as a key set to an empty value."
;;   {:added "1.0"
;;    :go "parseQuery(query)"}
;;   [^String query])
;; 
JOKER FUNC url.ParseRequestURI has: 
;; (defn ^[{:scheme ^String Scheme, :opaque ^String Opaque, :user ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/url/url.go:347:13) User, :host ^String Host, :path ^String Path, :rawpath ^String RawPath, :forcequery ForceQuery, :rawquery ^String RawQuery, :fragment ^String Fragment} Error] ParseRequestURI
;;   "ParseRequestURI parses rawurl into a URL structure. It assumes that
;; rawurl was received in an HTTP request, so the rawurl is interpreted
;; only as an absolute URI or an absolute path.
;; The string rawurl is assumed not to have a #fragment suffix.
;; (Web browsers strip #fragment before sending the URL to a web server.)"
;;   {:added "1.0"
;;    :go "parseRequestURI(rawurl)"}
;;   [^String rawurl])
;; 
JOKER FUNC url.PathEscape has: 
(defn ^String PathEscape
  "PathEscape escapes the string so it can be safely placed
inside a URL path segment."
  {:added "1.0"
   :go "pathEscape(s)"}
  [^String s])

JOKER FUNC url.PathUnescape has: 
(defn ^[String Error] PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,
converting each 3-byte encoded substring of the form "%AB" into the
hex-decoded byte 0xAB. It returns an error if any % is not followed
by two hexadecimal digits.

PathUnescape is identical to QueryUnescape except that it does not
unescape '+' to ' ' (space)."
  {:added "1.0"
   :go "pathUnescape(s)"}
  [^String s])

JOKER FUNC url.QueryEscape has: 
(defn ^String QueryEscape
  "QueryEscape escapes the string so it can be safely placed
inside a URL query."
  {:added "1.0"
   :go "queryEscape(s)"}
  [^String s])

JOKER FUNC url.QueryUnescape has: 
(defn ^[String Error] QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,
converting each 3-byte encoded substring of the form "%AB" into the
hex-decoded byte 0xAB.
It returns an error if any % is not followed by two hexadecimal
digits."
  {:added "1.0"
   :go "queryUnescape(s)"}
  [^String s])

JOKER FUNC url.User has: 
(defn ^{:username ^String username, :password ^String password, :passwordset passwordSet} User
  "User returns a Userinfo containing the provided username
and no password set."
  {:added "1.0"
   :go "user(username)"}
  [^String username])

JOKER FUNC url.UserPassword has: 
(defn ^{:username ^String username, :password ^String password, :passwordset passwordSet} UserPassword
  "UserPassword returns a Userinfo containing the provided username
and password.

This functionality should only be used with legacy web sites.
RFC 2396 warns that interpreting Userinfo this way
``is NOT RECOMMENDED, because the passing of authentication
information in clear text (such as URI) has proven to be a
security risk in almost every case where it has been used.''"
  {:added "1.0"
   :go "userPassword(username, password)"}
  [^String username, ^String password])

GO FUNC http.Error has: 
// func error(w Object, error string, code int)  {
// 	 := http.Error(w, error, code)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.Handle has: 
// func handle(pattern string, handler Object)  {
// 	 := http.Handle(pattern, handler)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.HandleFunc has: 
// func handleFunc(pattern string, handler ABEND882(unrecognized Expr type *ast.FuncType at: tests/big/net/http/server.go:2406:41))  {
// 	 := http.HandleFunc(pattern, handler)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.NotFound has: 
// func notFound(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/server.go:1981:35))  {
// 	 := http.NotFound(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.Redirect has: 
// func redirect(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/server.go:2020:35), url string, code int)  {
// 	 := http.Redirect(w, r, url, code)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.ServeContent has: 
// func serveContent(w Object, req ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fs.go:151:41), name string, modtime ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fs.go:151:72), content ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fs.go:151:91))  {
// 	 := http.ServeContent(w, req, name, modtime, content)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.ServeFile has: 
// func serveFile(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fs.go:670:36), name string)  {
// 	 := http.ServeFile(w, r, name)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.SetCookie has: 
// func setCookie(w Object, cookie ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/cookie.go:157:41))  {
// 	 := http.SetCookie(w, cookie)
// 	...ABEND: TODO...
// }
// 
GO FUNC jsonrpc.ServeConn has: 
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/server.go:132:21))  {
// 	 := jsonrpc.ServeConn(conn)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Cmdline has: 
// func cmdline(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:83:16), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:83:39))  {
// 	 := pprof.Cmdline(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Index has: 
// func index(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:264:14), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:264:37))  {
// 	 := pprof.Index(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Profile has: 
// func profile(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:116:16), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:116:39))  {
// 	 := pprof.Profile(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Symbol has: 
// func symbol(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:174:15), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:174:38))  {
// 	 := pprof.Symbol(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Trace has: 
// func trace(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:145:14), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:145:37))  {
// 	 := pprof.Trace(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC rpc.Accept has: 
// func accept(lis ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:692:17))  {
// 	 := rpc.Accept(lis)
// 	...ABEND: TODO...
// }
// 
GO FUNC rpc.HandleHTTP has: 
// func handleHTTP()  {
// 	 := rpc.HandleHTTP()
// 	...ABEND: TODO...
// }
// 
GO FUNC rpc.ServeCodec has: 
// func serveCodec(codec Object)  {
// 	 := rpc.ServeCodec(codec)
// 	...ABEND: TODO...
// }
// 
GO FUNC rpc.ServeConn has: 
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:673:21))  {
// 	 := rpc.ServeConn(conn)
// 	...ABEND: TODO...
// }
// 
Totals: types=102 functions=148 receivers=1200
