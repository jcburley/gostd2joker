Walking from tests/big to tests/big/go
Processing sourceDir=tests/big dump=false:
Walking from tests/big to tests/big/net
Processing sourceDir=tests/big dump=false:
Package net:
Processing package=net:
Walking from tests/big to tests/big/net/http
Processing sourceDir=tests/big dump=false:
Package http:
Processing package=http:
Walking from tests/big to tests/big/net/http/cgi
Processing sourceDir=tests/big dump=false:
Package cgi:
Processing package=cgi:
Excluding tests/big/net/http/cgi/testdata
Walking from tests/big to tests/big/net/http/cookiejar
Processing sourceDir=tests/big dump=false:
Package cookiejar:
Processing package=cookiejar:
Walking from tests/big to tests/big/net/http/fcgi
Processing sourceDir=tests/big dump=false:
Package fcgi:
Processing package=fcgi:
Walking from tests/big to tests/big/net/http/httptest
Processing sourceDir=tests/big dump=false:
Package httptest:
Processing package=httptest:
Walking from tests/big to tests/big/net/http/httptrace
Processing sourceDir=tests/big dump=false:
Package httptrace:
Processing package=httptrace:
Walking from tests/big to tests/big/net/http/httputil
Processing sourceDir=tests/big dump=false:
Package httputil:
Processing package=httputil:
Excluding tests/big/net/http/internal
Walking from tests/big to tests/big/net/http/pprof
Processing sourceDir=tests/big dump=false:
Package pprof:
Processing package=pprof:
Excluding tests/big/net/http/testdata
Excluding tests/big/net/internal
Walking from tests/big to tests/big/net/mail
Processing sourceDir=tests/big dump=false:
Package mail:
Processing package=mail:
Walking from tests/big to tests/big/net/rpc
Processing sourceDir=tests/big dump=false:
Package rpc:
Processing package=rpc:
Walking from tests/big to tests/big/net/rpc/jsonrpc
Processing sourceDir=tests/big dump=false:
Package jsonrpc:
Processing package=jsonrpc:
Walking from tests/big to tests/big/net/smtp
Processing sourceDir=tests/big dump=false:
Package smtp:
Processing package=smtp:
Excluding tests/big/net/testdata
Walking from tests/big to tests/big/net/textproto
Processing sourceDir=tests/big dump=false:
Package textproto:
Processing package=textproto:
Walking from tests/big to tests/big/net/url
Processing sourceDir=tests/big dump=false:
Package url:
Processing package=url:
TYPE cgi.Handler:
  tests/big/net/http/cgi/host.go
TYPE cookiejar.Jar:
  tests/big/net/http/cookiejar/jar.go
TYPE cookiejar.Options:
  tests/big/net/http/cookiejar/jar.go
TYPE cookiejar.PublicSuffixList:
  tests/big/net/http/cookiejar/jar.go
TYPE http.Client:
  tests/big/net/http/client.go
TYPE http.CloseNotifier:
  tests/big/net/http/server.go
TYPE http.ConnState:
  tests/big/net/http/server.go
TYPE http.Cookie:
  tests/big/net/http/cookie.go
TYPE http.CookieJar:
  tests/big/net/http/jar.go
TYPE http.Dir:
  tests/big/net/http/fs.go
TYPE http.File:
  tests/big/net/http/fs.go
TYPE http.FileSystem:
  tests/big/net/http/fs.go
TYPE http.Flusher:
  tests/big/net/http/server.go
TYPE http.Handler:
  tests/big/net/http/server.go
TYPE http.HandlerFunc:
  tests/big/net/http/server.go
TYPE http.Header:
  tests/big/net/http/header.go
TYPE http.Hijacker:
  tests/big/net/http/server.go
TYPE http.ProtocolError:
  tests/big/net/http/request.go
TYPE http.PushOptions:
  tests/big/net/http/http.go
TYPE http.Pusher:
  tests/big/net/http/http.go
TYPE http.Request:
  tests/big/net/http/request.go
TYPE http.Response:
  tests/big/net/http/response.go
TYPE http.ResponseWriter:
  tests/big/net/http/server.go
TYPE http.RoundTripper:
  tests/big/net/http/client.go
TYPE http.SameSite:
  tests/big/net/http/cookie.go
TYPE http.ServeMux:
  tests/big/net/http/server.go
TYPE http.Server:
  tests/big/net/http/server.go
TYPE http.Transport:
  tests/big/net/http/transport.go
TYPE httptest.ResponseRecorder:
  tests/big/net/http/httptest/recorder.go
TYPE httptest.Server:
  tests/big/net/http/httptest/server.go
TYPE httptrace.ClientTrace:
  tests/big/net/http/httptrace/trace.go
TYPE httptrace.DNSDoneInfo:
  tests/big/net/http/httptrace/trace.go
TYPE httptrace.DNSStartInfo:
  tests/big/net/http/httptrace/trace.go
TYPE httptrace.GotConnInfo:
  tests/big/net/http/httptrace/trace.go
TYPE httptrace.WroteRequestInfo:
  tests/big/net/http/httptrace/trace.go
TYPE httputil.BufferPool:
  tests/big/net/http/httputil/reverseproxy.go
TYPE httputil.ClientConn:
  tests/big/net/http/httputil/persist.go
TYPE httputil.ReverseProxy:
  tests/big/net/http/httputil/reverseproxy.go
TYPE httputil.ServerConn:
  tests/big/net/http/httputil/persist.go
TYPE mail.Address:
  tests/big/net/mail/message.go
TYPE mail.AddressParser:
  tests/big/net/mail/message.go
TYPE mail.Header:
  tests/big/net/mail/message.go
TYPE mail.Message:
  tests/big/net/mail/message.go
TYPE net.Addr:
  tests/big/net/net.go
TYPE net.AddrError:
  tests/big/net/net.go
TYPE net.Buffers:
  tests/big/net/net.go
TYPE net.Conn:
  tests/big/net/net.go
TYPE net.DNSConfigError:
  tests/big/net/net.go
TYPE net.DNSError:
  tests/big/net/net.go
TYPE net.Dialer:
  tests/big/net/dial.go
TYPE net.Error:
  tests/big/net/net.go
TYPE net.Flags:
  tests/big/net/interface.go
TYPE net.HardwareAddr:
  tests/big/net/mac.go
TYPE net.IP:
  tests/big/net/ip.go
TYPE net.IPAddr:
  tests/big/net/iprawsock.go
TYPE net.IPConn:
  tests/big/net/iprawsock.go
TYPE net.IPMask:
  tests/big/net/ip.go
TYPE net.IPNet:
  tests/big/net/ip.go
TYPE net.Interface:
  tests/big/net/interface.go
TYPE net.InvalidAddrError:
  tests/big/net/net.go
TYPE net.ListenConfig:
  tests/big/net/dial.go
TYPE net.Listener:
  tests/big/net/net.go
TYPE net.MX:
  tests/big/net/dnsclient.go
TYPE net.NS:
  tests/big/net/dnsclient.go
TYPE net.OpError:
  tests/big/net/net.go
TYPE net.PacketConn:
  tests/big/net/net.go
TYPE net.ParseError:
  tests/big/net/net.go
TYPE net.Resolver:
  tests/big/net/lookup.go
TYPE net.SRV:
  tests/big/net/dnsclient.go
TYPE net.TCPAddr:
  tests/big/net/tcpsock.go
TYPE net.TCPConn:
  tests/big/net/tcpsock.go
TYPE net.TCPListener:
  tests/big/net/tcpsock.go
TYPE net.UDPAddr:
  tests/big/net/udpsock.go
TYPE net.UDPConn:
  tests/big/net/udpsock.go
TYPE net.UnixAddr:
  tests/big/net/unixsock.go
TYPE net.UnixConn:
  tests/big/net/unixsock.go
TYPE net.UnixListener:
  tests/big/net/unixsock.go
TYPE net.UnknownNetworkError:
  tests/big/net/net.go
TYPE rpc.Call:
  tests/big/net/rpc/client.go
TYPE rpc.Client:
  tests/big/net/rpc/client.go
TYPE rpc.ClientCodec:
  tests/big/net/rpc/client.go
TYPE rpc.Request:
  tests/big/net/rpc/server.go
TYPE rpc.Response:
  tests/big/net/rpc/server.go
TYPE rpc.Server:
  tests/big/net/rpc/server.go
TYPE rpc.ServerCodec:
  tests/big/net/rpc/server.go
TYPE rpc.ServerError:
  tests/big/net/rpc/client.go
TYPE smtp.Auth:
  tests/big/net/smtp/auth.go
TYPE smtp.Client:
  tests/big/net/smtp/smtp.go
TYPE smtp.ServerInfo:
  tests/big/net/smtp/auth.go
TYPE textproto.Conn:
  tests/big/net/textproto/textproto.go
TYPE textproto.Error:
  tests/big/net/textproto/textproto.go
TYPE textproto.MIMEHeader:
  tests/big/net/textproto/header.go
TYPE textproto.Pipeline:
  tests/big/net/textproto/pipeline.go
TYPE textproto.ProtocolError:
  tests/big/net/textproto/textproto.go
TYPE textproto.Reader:
  tests/big/net/textproto/reader.go
TYPE textproto.Writer:
  tests/big/net/textproto/writer.go
TYPE url.Error:
  tests/big/net/url/url.go
TYPE url.EscapeError:
  tests/big/net/url/url.go
TYPE url.InvalidHostError:
  tests/big/net/url/url.go
TYPE url.URL:
  tests/big/net/url/url.go
TYPE url.Userinfo:
  tests/big/net/url/url.go
TYPE url.Values:
  tests/big/net/url/url.go
JOKER FUNC cgi.Request has:
;; (defn Request
;;   "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\nGo return type: (*..., error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/cgi/child.go:29:18) Error]"
;;   {:added "1.0"
;;    :go "request()"}
;;   [])

JOKER FUNC cgi.RequestFromMap has:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\nGo return type: (*..., error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/cgi/child.go:52:49) Error]"
;;   {:added "1.0"
;;    :go "requestFromMap(params)"}
;;   [^ABEND881(unrecognized Expr type *ast.MapType at: tests/big/net/http/cgi/child.go:52:28) params])

JOKER FUNC cgi.Serve has:
;; (defn ^Error Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "serve(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/cgi/child.go:146:20) handler])

JOKER FUNC cookiejar.New has:
;; (defn New
;;   "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\nGo return type: (*Jar, error)\nJoker return type: [{:psList ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/cookiejar/jar.go:34:23), :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/cookiejar/jar.go:64:5), :entries ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/cookiejar/jar.go:68:10), :nextSeqNum ^ABEND042(cannot find typename cookiejar.uint64)} Error]"
;;   {:added "1.0"
;;    :go "new(o)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/cookiejar/jar.go:77:12) o])

JOKER FUNC fcgi.ProcessEnv has:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\nGo return type: ...\nJoker return type: ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "processEnv(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fcgi/child.go:358:19) r])

JOKER FUNC fcgi.Serve has:
;; (defn ^Error Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fcgi/child.go:331:14) l, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fcgi/child.go:331:36) handler])

JOKER FUNC http.CanonicalHeaderKey has:
(defn ^String CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "canonicalHeaderKey(s)"}
  [^String s])

JOKER FUNC http.DetectContentType has:
;; (defn ^String DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "detectContentType(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/http/sniff.go:21:29) data])

JOKER FUNC http.Error has:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n"
;;   {:added "1.0"
;;    :go "error(w, error, code)"}
;;   [w, ^String error, ^Int code])

JOKER FUNC http.FileServer has:
;; (defn FileServer
;;   "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\nGo return type: Handler\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "fileServer(root)"}
;;   [root])

JOKER FUNC http.Get has:
;; (defn Get
;;   "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\nGo return type: (resp *Response, err error)\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: tests/big/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:319:6)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "get(url)"}
;;   [^String url])

JOKER FUNC http.Handle has:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n"
;;   {:added "1.0"
;;    :go "handle(pattern, handler)"}
;;   [^String pattern, handler])

JOKER FUNC http.HandleFunc has:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n"
;;   {:added "1.0"
;;    :go "handleFunc(pattern, handler)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.FuncType at: tests/big/net/http/server.go:2406:41) handler])

JOKER FUNC http.Head has:
;; (defn Head
;;   "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\nGo return type: (resp *Response, err error)\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: tests/big/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:319:6)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "head(url)"}
;;   [^String url])

JOKER FUNC http.ListenAndServe has:
(defn ^Error ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "listenAndServe(addr, handler)"}
  [^String addr, handler])

JOKER FUNC http.ListenAndServeTLS has:
(defn ^Error ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "listenAndServeTLS(addr, certFile, keyFile, handler)"}
  [^String addr, ^String certFile, ^String keyFile, handler])

JOKER FUNC http.MaxBytesReader has:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\nGo return type: ...\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:1056:65)"
;;   {:added "1.0"
;;    :go "maxBytesReader(w, r, n)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:1056:41) r, n])

JOKER FUNC http.NewFileTransport has:
;; (defn NewFileTransport
;;   "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\nGo return type: RoundTripper\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/client.go:115:19)"
;;   {:added "1.0"
;;    :go "newFileTransport(fs)"}
;;   [fs])

JOKER FUNC http.NewRequest has:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\nGo return type: (*Request, error)\nJoker return type: [{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: tests/big/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:319:6)} Error]"
;;   {:added "1.0"
;;    :go "newRequest(method, url, body)"}
;;   [^String method, ^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:792:42) body])

JOKER FUNC http.NewServeMux has:
;; (defn NewServeMux
;;   "NewServeMux allocates and returns a new ServeMux.\nGo return type: *ServeMux\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/server.go:2150:8), :m ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/server.go:2151:8), :hosts ^Bool}"
;;   {:added "1.0"
;;    :go "newServeMux()"}
;;   [])

JOKER FUNC http.NotFound has:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n"
;;   {:added "1.0"
;;    :go "notFound(w, r)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/server.go:1981:35) r])

JOKER FUNC http.NotFoundHandler has:
;; (defn NotFoundHandler
;;   "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\nGo return type: Handler\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "notFoundHandler()"}
;;   [])

JOKER FUNC http.ParseHTTPVersion has:
;; (defn ParseHTTPVersion
;;   "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\nGo return type: (major int, minor int, ok bool)\nJoker return type: [Int Int Bool]"
;;   {:added "1.0"
;;    :go "parseHTTPVersion(vers)"}
;;   [^String vers])

JOKER FUNC http.ParseTime has:
;; (defn ParseTime
;;   "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\nGo return type: (t ..., err error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/header.go:86:32) Error]"
;;   {:added "1.0"
;;    :go "parseTime(text)"}
;;   [^String text])

JOKER FUNC http.Post has:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\nGo return type: (resp *Response, err error)\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: tests/big/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:319:6)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "post(url, contentType, body)"}
;;   [^String url, ^String contentType, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/client.go:748:41) body])

JOKER FUNC http.PostForm has:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\nGo return type: (resp *Response, err error)\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: tests/big/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:319:6)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "postForm(url, data)"}
;;   [^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/client.go:785:32) data])

JOKER FUNC http.ProxyFromEnvironment has:
;; (defn ProxyFromEnvironment
;;   "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\nGo return type: (*..., error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/transport.go:345:43) Error]"
;;   {:added "1.0"
;;    :go "proxyFromEnvironment(req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/transport.go:345:31) req])

JOKER FUNC http.ProxyURL has:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\nGo return type: ...\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/transport.go:351:34)"
;;   {:added "1.0"
;;    :go "proxyURL(fixedURL)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/transport.go:351:24) fixedURL])

JOKER FUNC http.ReadRequest has:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\nGo return type: (*Request, error)\nJoker return type: [{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: tests/big/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:319:6)} Error]"
;;   {:added "1.0"
;;    :go "readRequest(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:942:20) b])

JOKER FUNC http.ReadResponse has:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\nGo return type: (*Response, error)\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: tests/big/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:319:6)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "readResponse(r, req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/response.go:148:21) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/response.go:148:40) req])

JOKER FUNC http.Redirect has:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n"
;;   {:added "1.0"
;;    :go "redirect(w, r, url, code)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/server.go:2020:35) r, ^String url, ^Int code])

JOKER FUNC http.RedirectHandler has:
;; (defn RedirectHandler
;;   "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\nGo return type: Handler\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "redirectHandler(url, code)"}
;;   [^String url, ^Int code])

JOKER FUNC http.Serve has:
;; (defn ^Error Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/server.go:2421:14) l, handler])

JOKER FUNC http.ServeContent has:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n"
;;   {:added "1.0"
;;    :go "serveContent(w, req, name, modtime, content)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fs.go:151:41) req, ^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fs.go:151:72) modtime, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fs.go:151:91) content])

JOKER FUNC http.ServeFile has:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n"
;;   {:added "1.0"
;;    :go "serveFile(w, r, name)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fs.go:670:36) r, ^String name])

JOKER FUNC http.ServeTLS has:
;; (defn ^Error ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "serveTLS(l, handler, certFile, keyFile)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/server.go:2438:17) l, handler, ^String certFile, ^String keyFile])

JOKER FUNC http.SetCookie has:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n"
;;   {:added "1.0"
;;    :go "setCookie(w, cookie)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/cookie.go:157:41) cookie])

JOKER FUNC http.StatusText has:
(defn ^String StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "statusText(code)"}
  [^Int code])

JOKER FUNC http.StripPrefix has:
;; (defn StripPrefix
;;   "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\nGo return type: Handler\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "stripPrefix(prefix, h)"}
;;   [^String prefix, h])

JOKER FUNC http.TimeoutHandler has:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\nGo return type: Handler\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "timeoutHandler(h, dt, msg)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/server.go:3106:35) dt, ^String msg])

JOKER FUNC httptest.NewRecorder has:
;; (defn NewRecorder
;;   "NewRecorder returns an initialized ResponseRecorder.\nGo return type: *ResponseRecorder\nJoker return type: {:Code ^Int, :HeaderMap ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/recorder.go:35:12), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/recorder.go:39:8), :Flushed ^Bool, :result ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/recorder.go:44:15), :snapHeader ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/recorder.go:45:14), :wroteHeader ^Bool}"
;;   {:added "1.0"
;;    :go "newRecorder()"}
;;   [])

JOKER FUNC httptest.NewRequest has:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\nGo return type: *...\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/httptest.go:41:57)"
;;   {:added "1.0"
;;    :go "newRequest(method, target, body)"}
;;   [^String method, ^String target, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/httptest.go:41:45) body])

JOKER FUNC httptest.NewServer has:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\nGo return type: *Server\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:28:11), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:33:7), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:37:10), :certificate ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:40:15), :wg ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:44:5), :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:46:9), :closed ^Bool, :conns ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/httptest/server.go:48:9), :client ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:52:10)}"
;;   {:added "1.0"
;;    :go "newServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:80:24) handler])

JOKER FUNC httptest.NewTLSServer has:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\nGo return type: *Server\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:28:11), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:33:7), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:37:10), :certificate ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:40:15), :wg ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:44:5), :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:46:9), :closed ^Bool, :conns ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/httptest/server.go:48:9), :client ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:52:10)}"
;;   {:added "1.0"
;;    :go "newTLSServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:160:27) handler])

JOKER FUNC httptest.NewUnstartedServer has:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\nGo return type: *Server\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:28:11), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:33:7), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:37:10), :certificate ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:40:15), :wg ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:44:5), :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:46:9), :closed ^Bool, :conns ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/httptest/server.go:48:9), :client ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:52:10)}"
;;   {:added "1.0"
;;    :go "newUnstartedServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:92:33) handler])

JOKER FUNC httptrace.ContextClientTrace has:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\nGo return type: *ClientTrace\nJoker return type: {:GetConn ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:85:10), :GotConn ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:91:10), :PutIdleConn ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:101:14), :GotFirstResponseByte ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:105:23), :Got100Continue ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:109:17), :Got1xxResponse ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:115:17), :DNSStart ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:118:11), :DNSDone ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:121:10), :ConnectStart ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:126:15), :ConnectDone ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:133:14), :TLSHandshakeStart ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:138:20), :TLSHandshakeDone ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:143:19), :WroteHeaderField ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:148:19), :WroteHeaders ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:152:15), :Wait100Continue ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:158:18), :WroteRequest ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httptrace/trace.go:163:15)}"
;;   {:added "1.0"
;;    :go "contextClientTrace(ctx)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptrace/trace.go:24:29) ctx])

JOKER FUNC httptrace.WithClientTrace has:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\nGo return type: ...\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptrace/trace.go:34:63)"
;;   {:added "1.0"
;;    :go "withClientTrace(ctx, trace)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptrace/trace.go:34:26) ctx, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptrace/trace.go:34:49) trace])

JOKER FUNC httputil.DumpRequest has:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequest(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/dump.go:191:22) req, body])

JOKER FUNC httputil.DumpRequestOut has:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequestOut(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/dump.go:66:25) req, body])

JOKER FUNC httputil.DumpResponse has:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpResponse(resp, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/dump.go:281:24) resp, body])

JOKER FUNC httputil.NewChunkedReader has:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\nGo return type: ...\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/httputil.go:20:36)"
;;   {:added "1.0"
;;    :go "newChunkedReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/httputil.go:20:25) r])

JOKER FUNC httputil.NewChunkedWriter has:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\nGo return type: ...\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/httputil.go:35:36)"
;;   {:added "1.0"
;;    :go "newChunkedWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/httputil.go:35:25) w])

JOKER FUNC httputil.NewClientConn has:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\nGo return type: *ClientConn\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:231:18), :c ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:232:18), :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:233:19), :re ^Error, :we ^Error, :lastbody ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:235:18), :nread ^Int, :nwritten ^Int, :pipereq ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/httputil/persist.go:237:18), :pipe ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:239:11), :writeReq ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httputil/persist.go:240:11)}"
;;   {:added "1.0"
;;    :go "newClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:248:22) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:248:34) r])

JOKER FUNC httputil.NewProxyClientConn has:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\nGo return type: *ClientConn\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:231:18), :c ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:232:18), :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:233:19), :re ^Error, :we ^Error, :lastbody ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:235:18), :nread ^Int, :nwritten ^Int, :pipereq ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/httputil/persist.go:237:18), :pipe ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:239:11), :writeReq ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httputil/persist.go:240:11)}"
;;   {:added "1.0"
;;    :go "newProxyClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:265:27) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:265:39) r])

JOKER FUNC httputil.NewServerConn has:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\nGo return type: *ServerConn\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:38:18), :c ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:39:18), :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:40:19), :re ^Error, :we ^Error, :lastbody ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:42:18), :nread ^Int, :nwritten ^Int, :pipereq ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/http/httputil/persist.go:44:18), :pipe ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:46:7)}"
;;   {:added "1.0"
;;    :go "newServerConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:54:22) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:54:34) r])

JOKER FUNC httputil.NewSingleHostReverseProxy has:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\nGo return type: *ReverseProxy\nJoker return type: {:Director ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httputil/reverseproxy.go:35:11), :Transport ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/reverseproxy.go:39:12), :FlushInterval ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/reverseproxy.go:45:16), :ErrorLog ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/reverseproxy.go:51:12), :BufferPool ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/http/httputil/reverseproxy.go:79:17), :ModifyResponse ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httputil/reverseproxy.go:67:17), :ErrorHandler ^ABEND883(unrecognized Expr type *ast.FuncType at: tests/big/net/http/httputil/reverseproxy.go:74:15)}"
;;   {:added "1.0"
;;    :go "newSingleHostReverseProxy(target)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/reverseproxy.go:103:39) target])

JOKER FUNC jsonrpc.Dial has:
;; (defn Dial
;;   "Dial connects to a JSON-RPC server at the specified network address.\nGo return type: (*..., error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:118:38) Error]"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC jsonrpc.NewClient has:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\nGo return type: *...\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:113:42)"
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:113:21) conn])

JOKER FUNC jsonrpc.NewClientCodec has:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\nGo return type: ...\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:37:46)"
;;   {:added "1.0"
;;    :go "newClientCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:37:26) conn])

JOKER FUNC jsonrpc.NewServerCodec has:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\nGo return type: ...\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/server.go:37:46)"
;;   {:added "1.0"
;;    :go "newServerCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/server.go:37:26) conn])

JOKER FUNC jsonrpc.ServeConn has:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n"
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/server.go:132:21) conn])

JOKER FUNC mail.ParseAddress has:
;; (defn ParseAddress
;;   "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\nGo return type: (*Address, error)\nJoker return type: [{:Name ^String, :Address ^String} Error]"
;;   {:added "1.0"
;;    :go "parseAddress(address)"}
;;   [^String address])

JOKER FUNC mail.ParseAddressList has:
;; (defn ParseAddressList
;;   "ParseAddressList parses the given string as a list of addresses.\nGo return type: ([]*Address, error)\nJoker return type: [(vector-of {:Name ^String, :Address ^String}) Error]"
;;   {:added "1.0"
;;    :go "parseAddressList(list)"}
;;   [^String list])

JOKER FUNC mail.ParseDate has:
;; (defn ParseDate
;;   "ParseDate parses an RFC 5322 date string.\nGo return type: (..., error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/mail/message.go:95:30) Error]"
;;   {:added "1.0"
;;    :go "parseDate(date)"}
;;   [^String date])

JOKER FUNC mail.ReadMessage has:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\nGo return type: (msg *Message, err error)\nJoker return type: [{:Header ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/mail/message.go:106:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/mail/message.go:46:9)} Error]"
;;   {:added "1.0"
;;    :go "readMessage(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/mail/message.go:52:20) r])

JOKER FUNC net.CIDRMask has:
;; (defn CIDRMask
;;   "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\nGo return type: IPMask\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "cIDRMask(ones, bits)"}
;;   [^Int ones, ^Int bits])

JOKER FUNC net.Dial has:
;; (defn Dial
;;   "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\nGo return type: (Conn, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.DialIP has:
;; (defn DialIP
;;   "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\nGo return type: (*IPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialIP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/iprawsock.go:211:42) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/iprawsock.go:211:42) raddr])

JOKER FUNC net.DialTCP has:
;; (defn DialTCP
;;   "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\nGo return type: (*TCPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialTCP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/tcpsock.go:206:43) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/tcpsock.go:206:43) raddr])

JOKER FUNC net.DialTimeout has:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (Conn, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "dialTimeout(network, address, timeout)"}
;;   [^String network, ^String address, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/dial.go:313:51) timeout])

JOKER FUNC net.DialUDP has:
;; (defn DialUDP
;;   "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\nGo return type: (*UDPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialUDP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:205:43) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:205:43) raddr])

JOKER FUNC net.DialUnix has:
;; (defn DialUnix
;;   "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\nGo return type: (*UnixConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialUnix(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:200:44) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:200:44) raddr])

JOKER FUNC net.FileConn has:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\nGo return type: (c Conn, err error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "fileConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/file.go:21:17) f])

JOKER FUNC net.FileListener has:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\nGo return type: (ln Listener, err error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:365:15) Error]"
;;   {:added "1.0"
;;    :go "fileListener(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/file.go:33:21) f])

JOKER FUNC net.FilePacketConn has:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\nGo return type: (c PacketConn, err error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:303:17) Error]"
;;   {:added "1.0"
;;    :go "filePacketConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/file.go:45:23) f])

JOKER FUNC net.IPv4 has:
;; (defn IPv4
;;   "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\nGo return type: IP\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "iPv4(a, b, c, d)"}
;;   [a, b, c, d])

JOKER FUNC net.IPv4Mask has:
;; (defn IPv4Mask
;;   "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\nGo return type: IPMask\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "iPv4Mask(a, b, c, d)"}
;;   [a, b, c, d])

JOKER FUNC net.InterfaceAddrs has:
;; (defn InterfaceAddrs
;;   "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\nGo return type: ([]Addr, error)\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:105:11)) Error]"
;;   {:added "1.0"
;;    :go "interfaceAddrs()"}
;;   [])

JOKER FUNC net.InterfaceByIndex has:
;; (defn InterfaceByIndex
;;   "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\nGo return type: (*Interface, error)\nJoker return type: [{:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int} Error]"
;;   {:added "1.0"
;;    :go "interfaceByIndex(index)"}
;;   [^Int index])

JOKER FUNC net.InterfaceByName has:
;; (defn InterfaceByName
;;   "InterfaceByName returns the interface specified by name.\nGo return type: (*Interface, error)\nJoker return type: [{:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int} Error]"
;;   {:added "1.0"
;;    :go "interfaceByName(name)"}
;;   [^String name])

JOKER FUNC net.Interfaces has:
;; (defn Interfaces
;;   "Interfaces returns a list of the system's network interfaces.\nGo return type: ([]Interface, error)\nJoker return type: [(vector-of {:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int}) Error]"
;;   {:added "1.0"
;;    :go "interfaces()"}
;;   [])

JOKER FUNC net.JoinHostPort has:
(defn ^String JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "joinHostPort(host, port)"}
  [^String host, ^String port])

JOKER FUNC net.Listen has:
;; (defn Listen
;;   "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (Listener, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:365:15) Error]"
;;   {:added "1.0"
;;    :go "listen(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ListenIP has:
;; (defn ListenIP
;;   "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nGo return type: (*IPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenIP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/iprawsock.go:230:37) laddr])

JOKER FUNC net.ListenMulticastUDP has:
;; (defn ListenMulticastUDP
;;   "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\nGo return type: (*UDPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenMulticastUDP(network, ifi, gaddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:265:45) ifi, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:265:63) gaddr])

JOKER FUNC net.ListenPacket has:
;; (defn ListenPacket
;;   "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (PacketConn, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:303:17) Error]"
;;   {:added "1.0"
;;    :go "listenPacket(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ListenTCP has:
;; (defn ListenTCP
;;   "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\nGo return type: (*TCPListener, error)\nJoker return type: [{:fd ^ABEND042(cannot find typename net.netFD)} Error]"
;;   {:added "1.0"
;;    :go "listenTCP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/tcpsock.go:323:38) laddr])

JOKER FUNC net.ListenUDP has:
;; (defn ListenUDP
;;   "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\nGo return type: (*UDPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUDP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:231:38) laddr])

JOKER FUNC net.ListenUnix has:
;; (defn ListenUnix
;;   "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\nGo return type: (*UnixListener, error)\nJoker return type: [{:fd ^ABEND042(cannot find typename net.netFD), :path ^String, :unlink ^Bool, :unlinkOnce ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/unixsock.go:221:13)} Error]"
;;   {:added "1.0"
;;    :go "listenUnix(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:314:39) laddr])

JOKER FUNC net.ListenUnixgram has:
;; (defn ListenUnixgram
;;   "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\nGo return type: (*UnixConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUnixgram(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:334:43) laddr])

JOKER FUNC net.LookupAddr has:
;; (defn LookupAddr
;;   "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\nGo return type: (names []string, err error)\nJoker return type: [(vector-of String) Error]"
;;   {:added "1.0"
;;    :go "lookupAddr(addr)"}
;;   [^String addr])

JOKER FUNC net.LookupCNAME has:
;; (defn LookupCNAME
;;   "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\nGo return type: (cname string, err error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "lookupCNAME(host)"}
;;   [^String host])

JOKER FUNC net.LookupHost has:
;; (defn LookupHost
;;   "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\nGo return type: (addrs []string, err error)\nJoker return type: [(vector-of String) Error]"
;;   {:added "1.0"
;;    :go "lookupHost(host)"}
;;   [^String host])

JOKER FUNC net.LookupIP has:
;; (defn LookupIP
;;   "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\nGo return type: ([]IP, error)\nJoker return type: [(vector-of (vector-of Int)) Error]"
;;   {:added "1.0"
;;    :go "lookupIP(host)"}
;;   [^String host])

JOKER FUNC net.LookupMX has:
;; (defn LookupMX
;;   "LookupMX returns the DNS MX records for the given domain name sorted by preference.\nGo return type: ([]*MX, error)\nJoker return type: [(vector-of {:Host ^String, :Pref ^Int}) Error]"
;;   {:added "1.0"
;;    :go "lookupMX(name)"}
;;   [^String name])

JOKER FUNC net.LookupNS has:
;; (defn LookupNS
;;   "LookupNS returns the DNS NS records for the given domain name.\nGo return type: ([]*NS, error)\nJoker return type: [(vector-of {:Host ^String}) Error]"
;;   {:added "1.0"
;;    :go "lookupNS(name)"}
;;   [^String name])

JOKER FUNC net.LookupPort has:
;; (defn LookupPort
;;   "LookupPort looks up the port for the given network and service.\nGo return type: (port int, err error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "lookupPort(network, service)"}
;;   [^String network, ^String service])

JOKER FUNC net.LookupSRV has:
;; (defn LookupSRV
;;   "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\nGo return type: (cname string, addrs []*SRV, err error)\nJoker return type: [String (vector-of {:Target ^String, :Port ^Int, :Priority ^Int, :Weight ^Int}) Error]"
;;   {:added "1.0"
;;    :go "lookupSRV(service, proto, name)"}
;;   [^String service, ^String proto, ^String name])

JOKER FUNC net.LookupTXT has:
;; (defn LookupTXT
;;   "LookupTXT returns the DNS TXT records for the given domain name.\nGo return type: ([]string, error)\nJoker return type: [(vector-of String) Error]"
;;   {:added "1.0"
;;    :go "lookupTXT(name)"}
;;   [^String name])

JOKER FUNC net.ParseCIDR has:
;; (defn ParseCIDR
;;   "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\nGo return type: (IP, *IPNet, error)\nJoker return type: [(vector-of Int) {:IP ^(vector-of Int), :Mask ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "parseCIDR(s)"}
;;   [^String s])

JOKER FUNC net.ParseIP has:
;; (defn ParseIP
;;   "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\nGo return type: IP\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "parseIP(s)"}
;;   [^String s])

JOKER FUNC net.ParseMAC has:
;; (defn ParseMAC
;;   "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\nGo return type: (hw HardwareAddr, err error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "parseMAC(s)"}
;;   [^String s])

JOKER FUNC net.Pipe has:
;; (defn Pipe
;;   "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\nGo return type: (Conn, Conn)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:113:11) ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/net.go:113:11)]"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC net.ResolveIPAddr has:
;; (defn ResolveIPAddr
;;   "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (*IPAddr, error)\nJoker return type: [{:IP ^(vector-of Int), :Zone ^String} Error]"
;;   {:added "1.0"
;;    :go "resolveIPAddr(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ResolveTCPAddr has:
;; (defn ResolveTCPAddr
;;   "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (*TCPAddr, error)\nJoker return type: [{:IP ^(vector-of Int), :Port ^Int, :Zone ^String} Error]"
;;   {:added "1.0"
;;    :go "resolveTCPAddr(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ResolveUDPAddr has:
;; (defn ResolveUDPAddr
;;   "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (*UDPAddr, error)\nJoker return type: [{:IP ^(vector-of Int), :Port ^Int, :Zone ^String} Error]"
;;   {:added "1.0"
;;    :go "resolveUDPAddr(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ResolveUnixAddr has:
;; (defn ResolveUnixAddr
;;   "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (*UnixAddr, error)\nJoker return type: [{:Name ^String, :Net ^String} Error]"
;;   {:added "1.0"
;;    :go "resolveUnixAddr(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.SplitHostPort has:
;; (defn SplitHostPort
;;   "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\nGo return type: (host string, port string, err error)\nJoker return type: [String String Error]"
;;   {:added "1.0"
;;    :go "splitHostPort(hostport)"}
;;   [^String hostport])

JOKER FUNC pprof.Cmdline has:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n"
;;   {:added "1.0"
;;    :go "cmdline(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:83:16) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:83:39) r])

JOKER FUNC pprof.Handler has:
;; (defn Handler
;;   "Handler returns an HTTP handler that serves the named profile.\nGo return type: ...\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:221:27)"
;;   {:added "1.0"
;;    :go "handler(name)"}
;;   [^String name])

JOKER FUNC pprof.Index has:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n"
;;   {:added "1.0"
;;    :go "index(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:264:14) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:264:37) r])

JOKER FUNC pprof.Profile has:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n"
;;   {:added "1.0"
;;    :go "profile(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:116:16) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:116:39) r])

JOKER FUNC pprof.Symbol has:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n"
;;   {:added "1.0"
;;    :go "symbol(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:174:15) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:174:38) r])

JOKER FUNC pprof.Trace has:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n"
;;   {:added "1.0"
;;    :go "trace(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:145:14) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:145:37) r])

JOKER FUNC rpc.Accept has:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n"
;;   {:added "1.0"
;;    :go "accept(lis)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:692:17) lis])

JOKER FUNC rpc.Dial has:
;; (defn Dial
;;   "Dial connects to an RPC server at the specified network address.\nGo return type: (*Client, error)\nJoker return type: [{:codec ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/rpc/client.go:63:18), :reqMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:44:11), :request ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:47:11), :seq ^ABEND042(cannot find typename rpc.uint64), :pending ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/rpc/client.go:49:11), :closing ^Bool, :shutdown ^Bool} Error]"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC rpc.DialHTTP has:
;; (defn DialHTTP
;;   "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\nGo return type: (*Client, error)\nJoker return type: [{:codec ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/rpc/client.go:63:18), :reqMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:44:11), :request ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:47:11), :seq ^ABEND042(cannot find typename rpc.uint64), :pending ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/rpc/client.go:49:11), :closing ^Bool, :shutdown ^Bool} Error]"
;;   {:added "1.0"
;;    :go "dialHTTP(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC rpc.DialHTTPPath has:
;; (defn DialHTTPPath
;;   "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\nGo return type: (*Client, error)\nJoker return type: [{:codec ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/rpc/client.go:63:18), :reqMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:44:11), :request ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:47:11), :seq ^ABEND042(cannot find typename rpc.uint64), :pending ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/rpc/client.go:49:11), :closing ^Bool, :shutdown ^Bool} Error]"
;;   {:added "1.0"
;;    :go "dialHTTPPath(network, address, path)"}
;;   [^String network, ^String address, ^String path])

JOKER FUNC rpc.HandleHTTP has:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n"
;;   {:added "1.0"
;;    :go "handleHTTP()"}
;;   [])

JOKER FUNC rpc.NewClient has:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\nGo return type: *Client\nJoker return type: {:codec ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/rpc/client.go:63:18), :reqMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:44:11), :request ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:47:11), :seq ^ABEND042(cannot find typename rpc.uint64), :pending ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/rpc/client.go:49:11), :closing ^Bool, :shutdown ^Bool}"
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:193:21) conn])

JOKER FUNC rpc.NewClientWithCodec has:
;; (defn NewClientWithCodec
;;   "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\nGo return type: *Client\nJoker return type: {:codec ^ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/rpc/client.go:63:18), :reqMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:44:11), :request ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:47:11), :seq ^ABEND042(cannot find typename rpc.uint64), :pending ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/rpc/client.go:49:11), :closing ^Bool, :shutdown ^Bool}"
;;   {:added "1.0"
;;    :go "newClientWithCodec(codec)"}
;;   [codec])

JOKER FUNC rpc.NewServer has:
;; (defn NewServer
;;   "NewServer returns a new Server.\nGo return type: *Server\nJoker return type: {:serviceMap ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:190:13), :reqLock ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:191:13), :freeReq ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :respLock ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:193:13), :freeResp ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :Error ^String, :next ^ABEND947(recursive type reference involving rpc.Response)}}"
;;   {:added "1.0"
;;    :go "newServer()"}
;;   [])

JOKER FUNC rpc.Register has:
;; (defn ^Error Register
;;   "Register publishes the receiver's methods in the DefaultServer.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "register(rcvr)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: tests/big/net/rpc/server.go:642:20) rcvr])

JOKER FUNC rpc.RegisterName has:
;; (defn ^Error RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "registerName(name, rcvr)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: tests/big/net/rpc/server.go:646:37) rcvr])

JOKER FUNC rpc.ServeCodec has:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n"
;;   {:added "1.0"
;;    :go "serveCodec(codec)"}
;;   [codec])

JOKER FUNC rpc.ServeConn has:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n"
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:673:21) conn])

JOKER FUNC rpc.ServeRequest has:
(defn ^Error ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "serveRequest(codec)"}
  [codec])

JOKER FUNC smtp.CRAMMD5Auth has:
;; (defn CRAMMD5Auth
;;   "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\nGo return type: Auth\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/smtp/auth.go:15:11)"
;;   {:added "1.0"
;;    :go "cRAMMD5Auth(username, secret)"}
;;   [^String username, ^String secret])

JOKER FUNC smtp.Dial has:
;; (defn Dial
;;   "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\nGo return type: (*Client, error)\nJoker return type: [{:Text ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/smtp/smtp.go:33:8), :conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/smtp/smtp.go:36:7), :tls ^Bool, :serverName ^String, :ext ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/smtp/smtp.go:41:6), :auth ^(vector-of String), :localName ^String, :didHello ^Bool, :helloError ^Error} Error]"
;;   {:added "1.0"
;;    :go "dial(addr)"}
;;   [^String addr])

JOKER FUNC smtp.NewClient has:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\nGo return type: (*Client, error)\nJoker return type: [{:Text ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/smtp/smtp.go:33:8), :conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/smtp/smtp.go:36:7), :tls ^Bool, :serverName ^String, :ext ^ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/smtp/smtp.go:41:6), :auth ^(vector-of String), :localName ^String, :didHello ^Bool, :helloError ^Error} Error]"
;;   {:added "1.0"
;;    :go "newClient(conn, host)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/smtp/smtp.go:62:21) conn, ^String host])

JOKER FUNC smtp.PlainAuth has:
;; (defn PlainAuth
;;   "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\nGo return type: Auth\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: tests/big/net/smtp/auth.go:15:11)"
;;   {:added "1.0"
;;    :go "plainAuth(identity, username, password, host)"}
;;   [^String identity, ^String username, ^String password, ^String host])

JOKER FUNC smtp.SendMail has:
;; (defn ^Error SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "sendMail(addr, a, from, to, msg)"}
;;   [^String addr, a, ^String from, ^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/smtp/smtp.go:319:52) to, ^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/smtp/smtp.go:319:66) msg])

JOKER FUNC textproto.CanonicalMIMEHeaderKey has:
(defn ^String CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "canonicalMIMEHeaderKey(s)"}
  [^String s])

JOKER FUNC textproto.Dial has:
;; (defn Dial
;;   "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\nGo return type: (*Conn, error)\nJoker return type: [{:conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/textproto/textproto.go:62:7)} Error]"
;;   {:added "1.0"
;;    :go "dial(network, addr)"}
;;   [^String network, ^String addr])

JOKER FUNC textproto.NewConn has:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\nGo return type: *Conn\nJoker return type: {:conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/textproto/textproto.go:62:7)}"
;;   {:added "1.0"
;;    :go "newConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/textproto/textproto.go:66:19) conn])

JOKER FUNC textproto.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\nGo return type: *Reader\nJoker return type: {:R ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/textproto/reader.go:19:7), :dot ^ABEND042(cannot find typename textproto.dotReader), :buf ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/textproto/reader.go:29:18) r])

JOKER FUNC textproto.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\nGo return type: *Writer\nJoker return type: {:W ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/textproto/writer.go:16:7), :dot ^ABEND042(cannot find typename textproto.dotWriter)}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/big/net/textproto/writer.go:21:18) w])

JOKER FUNC textproto.TrimBytes has:
;; (defn TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimBytes(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: tests/big/net/textproto/textproto.go:137:18) b])

JOKER FUNC textproto.TrimString has:
(defn ^String TrimString
  "TrimString returns s without leading and trailing ASCII space.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "trimString(s)"}
  [^String s])

JOKER FUNC url.Parse has:
;; (defn Parse
;;   "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\nGo return type: (*URL, error)\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^{:username ^String, :password ^String, :passwordSet ^Bool}, :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
;;   {:added "1.0"
;;    :go "parse(rawurl)"}
;;   [^String rawurl])

JOKER FUNC url.ParseQuery has:
;; (defn ParseQuery
;;   "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\nGo return type: (Values, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: tests/big/net/url/url.go:804:13) Error]"
;;   {:added "1.0"
;;    :go "parseQuery(query)"}
;;   [^String query])

JOKER FUNC url.ParseRequestURI has:
;; (defn ParseRequestURI
;;   "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\nGo return type: (*URL, error)\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^{:username ^String, :password ^String, :passwordSet ^Bool}, :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
;;   {:added "1.0"
;;    :go "parseRequestURI(rawurl)"}
;;   [^String rawurl])

JOKER FUNC url.PathEscape has:
(defn ^String PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "pathEscape(s)"}
  [^String s])

JOKER FUNC url.PathUnescape has:
;; (defn PathUnescape
;;   "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "pathUnescape(s)"}
;;   [^String s])

JOKER FUNC url.QueryEscape has:
(defn ^String QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "queryEscape(s)"}
  [^String s])

JOKER FUNC url.QueryUnescape has:
;; (defn QueryUnescape
;;   "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "queryUnescape(s)"}
;;   [^String s])

JOKER FUNC url.User has:
;; (defn User
;;   "User returns a Userinfo containing the provided username\nand no password set.\nGo return type: *Userinfo\nJoker return type: {:username ^String, :password ^String, :passwordSet ^Bool}"
;;   {:added "1.0"
;;    :go "user(username)"}
;;   [^String username])

JOKER FUNC url.UserPassword has:
;; (defn UserPassword
;;   "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\nGo return type: *Userinfo\nJoker return type: {:username ^String, :password ^String, :passwordSet ^Bool}"
;;   {:added "1.0"
;;    :go "userPassword(username, password)"}
;;   [^String username, ^String password])

GO FUNC cgi.Request has:
// func request() Object {
// 	arg_1, arg_2 := cgi.Request()
// 	...ABEND676: TODO...
// }

GO FUNC cgi.RequestFromMap has:
// func requestFromMap(params ABEND882(unrecognized Expr type *ast.MapType at: tests/big/net/http/cgi/child.go:52:28)) Object {
// 	arg_1, arg_2 := cgi.RequestFromMap(params)
// 	...ABEND676: TODO...
// }

GO FUNC cookiejar.New has:
// func new(o ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/cookiejar/jar.go:77:12)) Object {
// 	arg_1, arg_2 := cookiejar.New(o)
// 	...ABEND676: TODO...
// }

GO FUNC fcgi.ProcessEnv has:
// func processEnv(r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fcgi/child.go:358:19)) Object {
// 	arg_1 := fcgi.ProcessEnv(r)
// 	...ABEND676: TODO...
// }

GO FUNC http.Error has:
// func error(w Object, error string, code int) Object {
// 	http.Error(w, error, code)
// 	...ABEND676: TODO...
// }

GO FUNC http.FileServer has:
// func fileServer(root Object) Object {
// 	arg_1 := http.FileServer(root)
// 	...ABEND676: TODO...
// }

GO FUNC http.Get has:
// func get(url string) Object {
// 	resp, err := http.Get(url)
// 	...ABEND676: TODO...
// }

GO FUNC http.Handle has:
// func handle(pattern string, handler Object) Object {
// 	http.Handle(pattern, handler)
// 	...ABEND676: TODO...
// }

GO FUNC http.HandleFunc has:
// func handleFunc(pattern string, handler ABEND882(unrecognized Expr type *ast.FuncType at: tests/big/net/http/server.go:2406:41)) Object {
// 	http.HandleFunc(pattern, handler)
// 	...ABEND676: TODO...
// }

GO FUNC http.Head has:
// func head(url string) Object {
// 	resp, err := http.Head(url)
// 	...ABEND676: TODO...
// }

GO FUNC http.MaxBytesReader has:
// func maxBytesReader(w Object, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:1056:41), n Object) Object {
// 	arg_1 := http.MaxBytesReader(w, r, n)
// 	...ABEND676: TODO...
// }

GO FUNC http.NewFileTransport has:
// func newFileTransport(fs Object) Object {
// 	arg_1 := http.NewFileTransport(fs)
// 	...ABEND676: TODO...
// }

GO FUNC http.NewRequest has:
// func newRequest(method string, url string, body ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/request.go:792:42)) Object {
// 	arg_1, arg_2 := http.NewRequest(method, url, body)
// 	...ABEND676: TODO...
// }

GO FUNC http.NewServeMux has:
// func newServeMux() Object {
// 	arg_1 := http.NewServeMux()
// 	...ABEND676: TODO...
// }

GO FUNC http.NotFound has:
// func notFound(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/server.go:1981:35)) Object {
// 	http.NotFound(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC http.NotFoundHandler has:
// func notFoundHandler() Object {
// 	arg_1 := http.NotFoundHandler()
// 	...ABEND676: TODO...
// }

GO FUNC http.ParseHTTPVersion has:
// func parseHTTPVersion(vers string) Object {
// 	major, minor, ok := http.ParseHTTPVersion(vers)
// 	...ABEND676: TODO...
// }

GO FUNC http.ParseTime has:
// func parseTime(text string) Object {
// 	t, err := http.ParseTime(text)
// 	...ABEND676: TODO...
// }

GO FUNC http.Post has:
// func post(url string, contentType string, body ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/client.go:748:41)) Object {
// 	resp, err := http.Post(url, contentType, body)
// 	...ABEND676: TODO...
// }

GO FUNC http.PostForm has:
// func postForm(url string, data ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/client.go:785:32)) Object {
// 	resp, err := http.PostForm(url, data)
// 	...ABEND676: TODO...
// }

GO FUNC http.ProxyFromEnvironment has:
// func proxyFromEnvironment(req ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/transport.go:345:31)) Object {
// 	arg_1, arg_2 := http.ProxyFromEnvironment(req)
// 	...ABEND676: TODO...
// }

GO FUNC http.ProxyURL has:
// func proxyURL(fixedURL ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/transport.go:351:24)) Object {
// 	arg_1 := http.ProxyURL(fixedURL)
// 	...ABEND676: TODO...
// }

GO FUNC http.ReadRequest has:
// func readRequest(b ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/request.go:942:20)) Object {
// 	arg_1, arg_2 := http.ReadRequest(b)
// 	...ABEND676: TODO...
// }

GO FUNC http.ReadResponse has:
// func readResponse(r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/response.go:148:21), req ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/response.go:148:40)) Object {
// 	arg_1, arg_2 := http.ReadResponse(r, req)
// 	...ABEND676: TODO...
// }

GO FUNC http.Redirect has:
// func redirect(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/server.go:2020:35), url string, code int) Object {
// 	http.Redirect(w, r, url, code)
// 	...ABEND676: TODO...
// }

GO FUNC http.RedirectHandler has:
// func redirectHandler(url string, code int) Object {
// 	arg_1 := http.RedirectHandler(url, code)
// 	...ABEND676: TODO...
// }

GO FUNC http.ServeContent has:
// func serveContent(w Object, req ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fs.go:151:41), name string, modtime ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fs.go:151:72), content ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/fs.go:151:91)) Object {
// 	http.ServeContent(w, req, name, modtime, content)
// 	...ABEND676: TODO...
// }

GO FUNC http.ServeFile has:
// func serveFile(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/fs.go:670:36), name string) Object {
// 	http.ServeFile(w, r, name)
// 	...ABEND676: TODO...
// }

GO FUNC http.SetCookie has:
// func setCookie(w Object, cookie ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/cookie.go:157:41)) Object {
// 	http.SetCookie(w, cookie)
// 	...ABEND676: TODO...
// }

GO FUNC http.StripPrefix has:
// func stripPrefix(prefix string, h Object) Object {
// 	arg_1 := http.StripPrefix(prefix, h)
// 	...ABEND676: TODO...
// }

GO FUNC http.TimeoutHandler has:
// func timeoutHandler(h Object, dt ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/server.go:3106:35), msg string) Object {
// 	arg_1 := http.TimeoutHandler(h, dt, msg)
// 	...ABEND676: TODO...
// }

GO FUNC httptest.NewRecorder has:
// func newRecorder() Object {
// 	arg_1 := httptest.NewRecorder()
// 	...ABEND676: TODO...
// }

GO FUNC httptest.NewRequest has:
// func newRequest(method string, target string, body ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/httptest.go:41:45)) Object {
// 	arg_1 := httptest.NewRequest(method, target, body)
// 	...ABEND676: TODO...
// }

GO FUNC httptest.NewServer has:
// func newServer(handler ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:80:24)) Object {
// 	arg_1 := httptest.NewServer(handler)
// 	...ABEND676: TODO...
// }

GO FUNC httptest.NewTLSServer has:
// func newTLSServer(handler ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:160:27)) Object {
// 	arg_1 := httptest.NewTLSServer(handler)
// 	...ABEND676: TODO...
// }

GO FUNC httptest.NewUnstartedServer has:
// func newUnstartedServer(handler ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptest/server.go:92:33)) Object {
// 	arg_1 := httptest.NewUnstartedServer(handler)
// 	...ABEND676: TODO...
// }

GO FUNC httptrace.ContextClientTrace has:
// func contextClientTrace(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptrace/trace.go:24:29)) Object {
// 	arg_1 := httptrace.ContextClientTrace(ctx)
// 	...ABEND676: TODO...
// }

GO FUNC httptrace.WithClientTrace has:
// func withClientTrace(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httptrace/trace.go:34:26), trace ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httptrace/trace.go:34:49)) Object {
// 	arg_1 := httptrace.WithClientTrace(ctx, trace)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.DumpRequest has:
// func dumpRequest(req ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/dump.go:191:22), body Object) Object {
// 	arg_1, arg_2 := httputil.DumpRequest(req, body)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.DumpRequestOut has:
// func dumpRequestOut(req ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/dump.go:66:25), body Object) Object {
// 	arg_1, arg_2 := httputil.DumpRequestOut(req, body)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.DumpResponse has:
// func dumpResponse(resp ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/dump.go:281:24), body Object) Object {
// 	arg_1, arg_2 := httputil.DumpResponse(resp, body)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewChunkedReader has:
// func newChunkedReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/httputil.go:20:25)) Object {
// 	arg_1 := httputil.NewChunkedReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewChunkedWriter has:
// func newChunkedWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/httputil.go:35:25)) Object {
// 	arg_1 := httputil.NewChunkedWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewClientConn has:
// func newClientConn(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:248:22), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:248:34)) Object {
// 	arg_1 := httputil.NewClientConn(c, r)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewProxyClientConn has:
// func newProxyClientConn(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:265:27), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:265:39)) Object {
// 	arg_1 := httputil.NewProxyClientConn(c, r)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewServerConn has:
// func newServerConn(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/httputil/persist.go:54:22), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/persist.go:54:34)) Object {
// 	arg_1 := httputil.NewServerConn(c, r)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewSingleHostReverseProxy has:
// func newSingleHostReverseProxy(target ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/httputil/reverseproxy.go:103:39)) Object {
// 	arg_1 := httputil.NewSingleHostReverseProxy(target)
// 	...ABEND676: TODO...
// }

GO FUNC jsonrpc.Dial has:
// func dial(network string, address string) Object {
// 	arg_1, arg_2 := jsonrpc.Dial(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC jsonrpc.NewClient has:
// func newClient(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:113:21)) Object {
// 	arg_1 := jsonrpc.NewClient(conn)
// 	...ABEND676: TODO...
// }

GO FUNC jsonrpc.NewClientCodec has:
// func newClientCodec(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/client.go:37:26)) Object {
// 	arg_1 := jsonrpc.NewClientCodec(conn)
// 	...ABEND676: TODO...
// }

GO FUNC jsonrpc.NewServerCodec has:
// func newServerCodec(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/server.go:37:26)) Object {
// 	arg_1 := jsonrpc.NewServerCodec(conn)
// 	...ABEND676: TODO...
// }

GO FUNC jsonrpc.ServeConn has:
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/jsonrpc/server.go:132:21)) Object {
// 	jsonrpc.ServeConn(conn)
// 	...ABEND676: TODO...
// }

GO FUNC mail.ParseAddress has:
// func parseAddress(address string) Object {
// 	arg_1, arg_2 := mail.ParseAddress(address)
// 	...ABEND676: TODO...
// }

GO FUNC mail.ParseAddressList has:
// func parseAddressList(list string) Object {
// 	arg_1, arg_2 := mail.ParseAddressList(list)
// 	...ABEND676: TODO...
// }

GO FUNC mail.ParseDate has:
// func parseDate(date string) Object {
// 	arg_1, arg_2 := mail.ParseDate(date)
// 	...ABEND676: TODO...
// }

GO FUNC mail.ReadMessage has:
// func readMessage(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/mail/message.go:52:20)) Object {
// 	msg, err := mail.ReadMessage(r)
// 	...ABEND676: TODO...
// }

GO FUNC net.CIDRMask has:
// func cIDRMask(ones int, bits int) Object {
// 	arg_1 := net.CIDRMask(ones, bits)
// 	...ABEND676: TODO...
// }

GO FUNC net.Dial has:
// func dial(network string, address string) Object {
// 	arg_1, arg_2 := net.Dial(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.DialIP has:
// func dialIP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/iprawsock.go:211:42), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/iprawsock.go:211:42)) Object {
// 	arg_1, arg_2 := net.DialIP(network, laddr, raddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.DialTCP has:
// func dialTCP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/tcpsock.go:206:43), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/tcpsock.go:206:43)) Object {
// 	arg_1, arg_2 := net.DialTCP(network, laddr, raddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.DialTimeout has:
// func dialTimeout(network string, address string, timeout ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/dial.go:313:51)) Object {
// 	arg_1, arg_2 := net.DialTimeout(network, address, timeout)
// 	...ABEND676: TODO...
// }

GO FUNC net.DialUDP has:
// func dialUDP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:205:43), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:205:43)) Object {
// 	arg_1, arg_2 := net.DialUDP(network, laddr, raddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.DialUnix has:
// func dialUnix(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:200:44), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:200:44)) Object {
// 	arg_1, arg_2 := net.DialUnix(network, laddr, raddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.FileConn has:
// func fileConn(f ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/file.go:21:17)) Object {
// 	c, err := net.FileConn(f)
// 	...ABEND676: TODO...
// }

GO FUNC net.FileListener has:
// func fileListener(f ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/file.go:33:21)) Object {
// 	ln, err := net.FileListener(f)
// 	...ABEND676: TODO...
// }

GO FUNC net.FilePacketConn has:
// func filePacketConn(f ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/file.go:45:23)) Object {
// 	c, err := net.FilePacketConn(f)
// 	...ABEND676: TODO...
// }

GO FUNC net.IPv4 has:
// func iPv4(a Object, b Object, c Object, d Object) Object {
// 	arg_1 := net.IPv4(a, b, c, d)
// 	...ABEND676: TODO...
// }

GO FUNC net.IPv4Mask has:
// func iPv4Mask(a Object, b Object, c Object, d Object) Object {
// 	arg_1 := net.IPv4Mask(a, b, c, d)
// 	...ABEND676: TODO...
// }

GO FUNC net.InterfaceAddrs has:
// func interfaceAddrs() Object {
// 	arg_1, arg_2 := net.InterfaceAddrs()
// 	...ABEND676: TODO...
// }

GO FUNC net.InterfaceByIndex has:
// func interfaceByIndex(index int) Object {
// 	arg_1, arg_2 := net.InterfaceByIndex(index)
// 	...ABEND676: TODO...
// }

GO FUNC net.InterfaceByName has:
// func interfaceByName(name string) Object {
// 	arg_1, arg_2 := net.InterfaceByName(name)
// 	...ABEND676: TODO...
// }

GO FUNC net.Interfaces has:
// func interfaces() Object {
// 	arg_1, arg_2 := net.Interfaces()
// 	...ABEND676: TODO...
// }

GO FUNC net.Listen has:
// func listen(network string, address string) Object {
// 	arg_1, arg_2 := net.Listen(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenIP has:
// func listenIP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/iprawsock.go:230:37)) Object {
// 	arg_1, arg_2 := net.ListenIP(network, laddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenMulticastUDP has:
// func listenMulticastUDP(network string, ifi ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:265:45), gaddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:265:63)) Object {
// 	arg_1, arg_2 := net.ListenMulticastUDP(network, ifi, gaddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenPacket has:
// func listenPacket(network string, address string) Object {
// 	arg_1, arg_2 := net.ListenPacket(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenTCP has:
// func listenTCP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/tcpsock.go:323:38)) Object {
// 	arg_1, arg_2 := net.ListenTCP(network, laddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenUDP has:
// func listenUDP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/udpsock.go:231:38)) Object {
// 	arg_1, arg_2 := net.ListenUDP(network, laddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenUnix has:
// func listenUnix(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:314:39)) Object {
// 	arg_1, arg_2 := net.ListenUnix(network, laddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenUnixgram has:
// func listenUnixgram(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/unixsock.go:334:43)) Object {
// 	arg_1, arg_2 := net.ListenUnixgram(network, laddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupAddr has:
// func lookupAddr(addr string) Object {
// 	names, err := net.LookupAddr(addr)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupCNAME has:
// func lookupCNAME(host string) Object {
// 	cname, err := net.LookupCNAME(host)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupHost has:
// func lookupHost(host string) Object {
// 	addrs, err := net.LookupHost(host)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupIP has:
// func lookupIP(host string) Object {
// 	arg_1, arg_2 := net.LookupIP(host)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupMX has:
// func lookupMX(name string) Object {
// 	arg_1, arg_2 := net.LookupMX(name)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupNS has:
// func lookupNS(name string) Object {
// 	arg_1, arg_2 := net.LookupNS(name)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupPort has:
// func lookupPort(network string, service string) Object {
// 	port, err := net.LookupPort(network, service)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupSRV has:
// func lookupSRV(service string, proto string, name string) Object {
// 	cname, addrs, err := net.LookupSRV(service, proto, name)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupTXT has:
// func lookupTXT(name string) Object {
// 	arg_1, arg_2 := net.LookupTXT(name)
// 	...ABEND676: TODO...
// }

GO FUNC net.ParseCIDR has:
// func parseCIDR(s string) Object {
// 	arg_1, arg_2, arg_3 := net.ParseCIDR(s)
// 	...ABEND676: TODO...
// }

GO FUNC net.ParseIP has:
// func parseIP(s string) Object {
// 	arg_1 := net.ParseIP(s)
// 	...ABEND676: TODO...
// }

GO FUNC net.ParseMAC has:
// func parseMAC(s string) Object {
// 	hw, err := net.ParseMAC(s)
// 	...ABEND676: TODO...
// }

GO FUNC net.Pipe has:
// func pipe() Object {
// 	arg_1, arg_2 := net.Pipe()
// 	...ABEND676: TODO...
// }

GO FUNC net.ResolveIPAddr has:
// func resolveIPAddr(network string, address string) Object {
// 	arg_1, arg_2 := net.ResolveIPAddr(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.ResolveTCPAddr has:
// func resolveTCPAddr(network string, address string) Object {
// 	arg_1, arg_2 := net.ResolveTCPAddr(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.ResolveUDPAddr has:
// func resolveUDPAddr(network string, address string) Object {
// 	arg_1, arg_2 := net.ResolveUDPAddr(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.ResolveUnixAddr has:
// func resolveUnixAddr(network string, address string) Object {
// 	arg_1, arg_2 := net.ResolveUnixAddr(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.SplitHostPort has:
// func splitHostPort(hostport string) Object {
// 	host, port, err := net.SplitHostPort(hostport)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Cmdline has:
// func cmdline(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:83:16), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:83:39)) Object {
// 	pprof.Cmdline(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Handler has:
// func handler(name string) Object {
// 	arg_1 := pprof.Handler(name)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Index has:
// func index(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:264:14), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:264:37)) Object {
// 	pprof.Index(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Profile has:
// func profile(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:116:16), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:116:39)) Object {
// 	pprof.Profile(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Symbol has:
// func symbol(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:174:15), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:174:38)) Object {
// 	pprof.Symbol(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Trace has:
// func trace(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/http/pprof/pprof.go:145:14), r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/http/pprof/pprof.go:145:37)) Object {
// 	pprof.Trace(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.Accept has:
// func accept(lis ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:692:17)) Object {
// 	rpc.Accept(lis)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.Dial has:
// func dial(network string, address string) Object {
// 	arg_1, arg_2 := rpc.Dial(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.DialHTTP has:
// func dialHTTP(network string, address string) Object {
// 	arg_1, arg_2 := rpc.DialHTTP(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.DialHTTPPath has:
// func dialHTTPPath(network string, address string, path string) Object {
// 	arg_1, arg_2 := rpc.DialHTTPPath(network, address, path)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.HandleHTTP has:
// func handleHTTP() Object {
// 	rpc.HandleHTTP()
// 	...ABEND676: TODO...
// }

GO FUNC rpc.NewClient has:
// func newClient(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/client.go:193:21)) Object {
// 	arg_1 := rpc.NewClient(conn)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.NewClientWithCodec has:
// func newClientWithCodec(codec Object) Object {
// 	arg_1 := rpc.NewClientWithCodec(codec)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.NewServer has:
// func newServer() Object {
// 	arg_1 := rpc.NewServer()
// 	...ABEND676: TODO...
// }

GO FUNC rpc.ServeCodec has:
// func serveCodec(codec Object) Object {
// 	rpc.ServeCodec(codec)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.ServeConn has:
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/rpc/server.go:673:21)) Object {
// 	rpc.ServeConn(conn)
// 	...ABEND676: TODO...
// }

GO FUNC smtp.CRAMMD5Auth has:
// func cRAMMD5Auth(username string, secret string) Object {
// 	arg_1 := smtp.CRAMMD5Auth(username, secret)
// 	...ABEND676: TODO...
// }

GO FUNC smtp.Dial has:
// func dial(addr string) Object {
// 	arg_1, arg_2 := smtp.Dial(addr)
// 	...ABEND676: TODO...
// }

GO FUNC smtp.NewClient has:
// func newClient(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/smtp/smtp.go:62:21), host string) Object {
// 	arg_1, arg_2 := smtp.NewClient(conn, host)
// 	...ABEND676: TODO...
// }

GO FUNC smtp.PlainAuth has:
// func plainAuth(identity string, username string, password string, host string) Object {
// 	arg_1 := smtp.PlainAuth(identity, username, password, host)
// 	...ABEND676: TODO...
// }

GO FUNC textproto.Dial has:
// func dial(network string, addr string) Object {
// 	arg_1, arg_2 := textproto.Dial(network, addr)
// 	...ABEND676: TODO...
// }

GO FUNC textproto.NewConn has:
// func newConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: tests/big/net/textproto/textproto.go:66:19)) Object {
// 	arg_1 := textproto.NewConn(conn)
// 	...ABEND676: TODO...
// }

GO FUNC textproto.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/textproto/reader.go:29:18)) Object {
// 	arg_1 := textproto.NewReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC textproto.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.StarExpr at: tests/big/net/textproto/writer.go:21:18)) Object {
// 	arg_1 := textproto.NewWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC textproto.TrimBytes has:
// func trimBytes(b ABEND882(unrecognized Expr type *ast.ArrayType at: tests/big/net/textproto/textproto.go:137:18)) Object {
// 	arg_1 := textproto.TrimBytes(b)
// 	...ABEND676: TODO...
// }

GO FUNC url.Parse has:
// func parse(rawurl string) Object {
// 	arg_1, arg_2 := url.Parse(rawurl)
// 	...ABEND676: TODO...
// }

GO FUNC url.ParseQuery has:
// func parseQuery(query string) Object {
// 	arg_1, arg_2 := url.ParseQuery(query)
// 	...ABEND676: TODO...
// }

GO FUNC url.ParseRequestURI has:
// func parseRequestURI(rawurl string) Object {
// 	arg_1, arg_2 := url.ParseRequestURI(rawurl)
// 	...ABEND676: TODO...
// }

GO FUNC url.PathUnescape has:
// func pathUnescape(s string) Object {
// 	arg_1, arg_2 := url.PathUnescape(s)
// 	...ABEND676: TODO...
// }

GO FUNC url.QueryUnescape has:
// func queryUnescape(s string) Object {
// 	arg_1, arg_2 := url.QueryUnescape(s)
// 	...ABEND676: TODO...
// }

GO FUNC url.User has:
// func user(username string) Object {
// 	arg_1 := url.User(username)
// 	...ABEND676: TODO...
// }

GO FUNC url.UserPassword has:
// func userPassword(username string, password string) Object {
// 	arg_1 := url.UserPassword(username, password)
// 	...ABEND676: TODO...
// }

Totals: types=102 functions=148 receivers=1200
