Walking from GO.link/src to GO.link/src/archive
Processing archive:
Walking from GO.link/src to GO.link/src/archive/tar
Processing archive/tar:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/archive/tar/stat_actime2.go) => true <nil>
Matchfile(GO.link/src/archive/tar/format.go) => true <nil>
Matchfile(GO.link/src/archive/tar/writer.go) => true <nil>
Ignoring test code in tar_test.go
Matchfile(GO.link/src/archive/tar/common.go) => true <nil>
Matchfile(GO.link/src/archive/tar/stat_unix.go) => true <nil>
Matchfile(GO.link/src/archive/tar/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/archive/tar/strconv.go) => true <nil>
Matchfile(GO.link/src/archive/tar/stat_actime1.go) => false <nil>
Ignoring test code in strconv_test.go
Package tar:
Processing package=tar in archive/tar:
Excluding GO.link/src/archive/tar/testdata
Walking from GO.link/src to GO.link/src/archive/zip
Processing archive/zip:
Matchfile(GO.link/src/archive/zip/register.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Ignoring test code in zip_test.go
Matchfile(GO.link/src/archive/zip/writer.go) => true <nil>
Matchfile(GO.link/src/archive/zip/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/archive/zip/struct.go) => true <nil>
Package zip:
Processing package=zip in archive/zip:
Excluding GO.link/src/archive/zip/testdata
Walking from GO.link/src to GO.link/src/bufio
Processing bufio:
Ignoring test code in example_test.go
Ignoring test code in bufio_test.go
Matchfile(GO.link/src/bufio/scan.go) => true <nil>
Matchfile(GO.link/src/bufio/bufio.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in scan_test.go
Package bufio:
Processing package=bufio in bufio:
Excluding GO.link/src/builtin
Walking from GO.link/src to GO.link/src/bytes
Processing bytes:
Ignoring test code in compare_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/bytes/bytes_decl.go) => true <nil>
Ignoring test code in boundary_test.go
Ignoring test code in buffer_test.go
Matchfile(GO.link/src/bytes/buffer.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/bytes/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/bytes/bytes.go) => true <nil>
Ignoring test code in bytes_test.go
Package bytes:
Processing package=bytes in bytes:
Excluding GO.link/src/cmd
Walking from GO.link/src to GO.link/src/compress
Processing compress:
Walking from GO.link/src to GO.link/src/compress/bzip2
Processing compress/bzip2:
Ignoring test code in bzip2_test.go
Matchfile(GO.link/src/compress/bzip2/huffman.go) => true <nil>
Matchfile(GO.link/src/compress/bzip2/bzip2.go) => true <nil>
Matchfile(GO.link/src/compress/bzip2/move_to_front.go) => true <nil>
Matchfile(GO.link/src/compress/bzip2/bit_reader.go) => true <nil>
Package bzip2:
Processing package=bzip2 in compress/bzip2:
Excluding GO.link/src/compress/bzip2/testdata
Walking from GO.link/src to GO.link/src/compress/flate
Processing compress/flate:
Ignoring test code in flate_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/compress/flate/token.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(GO.link/src/compress/flate/inflate.go) => true <nil>
Matchfile(GO.link/src/compress/flate/deflate.go) => true <nil>
Ignoring test code in huffman_bit_writer_test.go
Ignoring test code in dict_decoder_test.go
Ignoring test code in deflate_test.go
Matchfile(GO.link/src/compress/flate/deflatefast.go) => true <nil>
Ignoring test code in inflate_test.go
Matchfile(GO.link/src/compress/flate/huffman_bit_writer.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/compress/flate/dict_decoder.go) => true <nil>
Matchfile(GO.link/src/compress/flate/huffman_code.go) => true <nil>
Package flate:
Processing package=flate in compress/flate:
Excluding GO.link/src/compress/flate/testdata
Walking from GO.link/src to GO.link/src/compress/gzip
Processing compress/gzip:
Ignoring test code in example_test.go
Matchfile(GO.link/src/compress/gzip/gzip.go) => true <nil>
Matchfile(GO.link/src/compress/gzip/gunzip.go) => true <nil>
Ignoring test code in gzip_test.go
Ignoring test code in issue14937_test.go
Ignoring test code in gunzip_test.go
Package gzip:
Processing package=gzip in compress/gzip:
Excluding GO.link/src/compress/gzip/testdata
Walking from GO.link/src to GO.link/src/compress/lzw
Processing compress/lzw:
Ignoring test code in writer_test.go
Matchfile(GO.link/src/compress/lzw/writer.go) => true <nil>
Matchfile(GO.link/src/compress/lzw/reader.go) => true <nil>
Ignoring test code in reader_test.go
Package lzw:
Processing package=lzw in compress/lzw:
Excluding GO.link/src/compress/testdata
Walking from GO.link/src to GO.link/src/compress/zlib
Processing compress/zlib:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/compress/zlib/writer.go) => true <nil>
Matchfile(GO.link/src/compress/zlib/reader.go) => true <nil>
Ignoring test code in reader_test.go
Package zlib:
Processing package=zlib in compress/zlib:
Walking from GO.link/src to GO.link/src/container
Processing container:
Walking from GO.link/src to GO.link/src/container/heap
Processing container/heap:
Matchfile(GO.link/src/container/heap/heap.go) => true <nil>
Ignoring test code in example_pq_test.go
Ignoring test code in example_intheap_test.go
Ignoring test code in heap_test.go
Package heap:
Processing package=heap in container/heap:
Walking from GO.link/src to GO.link/src/container/list
Processing container/list:
Matchfile(GO.link/src/container/list/list.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in list_test.go
Package list:
Processing package=list in container/list:
Walking from GO.link/src to GO.link/src/container/ring
Processing container/ring:
Ignoring test code in example_test.go
Matchfile(GO.link/src/container/ring/ring.go) => true <nil>
Ignoring test code in ring_test.go
Package ring:
Processing package=ring in container/ring:
Walking from GO.link/src to GO.link/src/context
Processing context:
Ignoring test code in example_test.go
Ignoring test code in net_test.go
Ignoring test code in context_test.go
Matchfile(GO.link/src/context/context.go) => true <nil>
Ignoring test code in x_test.go
Ignoring test code in benchmark_test.go
Package context:
Processing package=context in context:
Walking from GO.link/src to GO.link/src/crypto
Processing crypto:
Ignoring test code in issue21104_test.go
Matchfile(GO.link/src/crypto/crypto.go) => true <nil>
Package crypto:
Processing package=crypto in crypto:
Walking from GO.link/src to GO.link/src/crypto/aes
Processing crypto/aes:
Matchfile(GO.link/src/crypto/aes/cipher_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/ctr_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/cbc_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/gcm_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/aes_gcm.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/modes.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/cipher_generic.go) => false <nil>
Ignoring test code in modes_test.go
Ignoring test code in aes_test.go
Matchfile(GO.link/src/crypto/aes/cipher.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/const.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/cipher_ppc64le.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/cipher_asm.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/block.go) => true <nil>
Package aes:
Processing package=aes in crypto/aes:
Walking from GO.link/src to GO.link/src/crypto/cipher
Processing crypto/cipher:
Matchfile(GO.link/src/crypto/cipher/cfb.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/cbc.go) => true <nil>
Ignoring test code in ctr_aes_test.go
Ignoring test code in xor_test.go
Matchfile(GO.link/src/crypto/cipher/ofb.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in ctr_test.go
Ignoring test code in cipher_test.go
Ignoring test code in cbc_aes_test.go
Ignoring test code in gcm_test.go
Matchfile(GO.link/src/crypto/cipher/io.go) => true <nil>
Ignoring test code in common_test.go
Ignoring test code in cfb_test.go
Matchfile(GO.link/src/crypto/cipher/xor.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/ctr.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/cipher.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/gcm.go) => true <nil>
Ignoring test code in benchmark_test.go
Ignoring test code in ofb_test.go
Package cipher:
Processing package=cipher in crypto/cipher:
Walking from GO.link/src to GO.link/src/crypto/des
Processing crypto/des:
Ignoring test code in example_test.go
Ignoring test code in des_test.go
Matchfile(GO.link/src/crypto/des/cipher.go) => true <nil>
Matchfile(GO.link/src/crypto/des/const.go) => true <nil>
Matchfile(GO.link/src/crypto/des/block.go) => true <nil>
Package des:
Processing package=des in crypto/des:
Walking from GO.link/src to GO.link/src/crypto/dsa
Processing crypto/dsa:
Ignoring test code in dsa_test.go
Matchfile(GO.link/src/crypto/dsa/dsa.go) => true <nil>
Package dsa:
Processing package=dsa in crypto/dsa:
Walking from GO.link/src to GO.link/src/crypto/ecdsa
Processing crypto/ecdsa:
Ignoring test code in example_test.go
Ignoring test code in ecdsa_test.go
Matchfile(GO.link/src/crypto/ecdsa/ecdsa.go) => true <nil>
Package ecdsa:
Processing package=ecdsa in crypto/ecdsa:
Excluding GO.link/src/crypto/ecdsa/testdata
Walking from GO.link/src to GO.link/src/crypto/elliptic
Processing crypto/elliptic:
Matchfile(GO.link/src/crypto/elliptic/p224.go) => true <nil>
Ignoring test code in fuzz_test.go
Ignoring test code in p224_test.go
Matchfile(GO.link/src/crypto/elliptic/elliptic.go) => true <nil>
Ignoring test code in elliptic_test.go
Matchfile(GO.link/src/crypto/elliptic/p256_generic.go) => false <nil>
Matchfile(GO.link/src/crypto/elliptic/p256_asm.go) => true <nil>
Matchfile(GO.link/src/crypto/elliptic/p256_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/elliptic/p256.go) => false <nil>
Package elliptic:
Processing package=elliptic in crypto/elliptic:
Walking from GO.link/src to GO.link/src/crypto/hmac
Processing crypto/hmac:
Ignoring test code in hmac_test.go
Matchfile(GO.link/src/crypto/hmac/hmac.go) => true <nil>
Package hmac:
Processing package=hmac in crypto/hmac:
Excluding GO.link/src/crypto/internal
Walking from GO.link/src to GO.link/src/crypto/md5
Processing crypto/md5:
Matchfile(GO.link/src/crypto/md5/md5block_decl.go) => true <nil>
Matchfile(GO.link/src/crypto/md5/gen.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/md5/md5block.go) => true <nil>
Matchfile(GO.link/src/crypto/md5/md5block_generic.go) => false <nil>
Ignoring test code in md5_test.go
Matchfile(GO.link/src/crypto/md5/md5.go) => true <nil>
Package md5:
Processing package=md5 in crypto/md5:
Walking from GO.link/src to GO.link/src/crypto/rand
Processing crypto/rand:
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/rand/rand_unix.go) => true <nil>
Ignoring test code in rand_linux_test.go
Matchfile(GO.link/src/crypto/rand/rand_openbsd.go) => false <nil>
Ignoring test code in util_test.go
Ignoring test code in rand_test.go
Matchfile(GO.link/src/crypto/rand/util.go) => true <nil>
Matchfile(GO.link/src/crypto/rand/rand_js.go) => false <nil>
Matchfile(GO.link/src/crypto/rand/rand_linux.go) => false <nil>
Matchfile(GO.link/src/crypto/rand/rand.go) => true <nil>
Matchfile(GO.link/src/crypto/rand/eagain.go) => true <nil>
Matchfile(GO.link/src/crypto/rand/rand_windows.go) => false <nil>
Package rand:
Processing package=rand in crypto/rand:
Walking from GO.link/src to GO.link/src/crypto/rc4
Processing crypto/rc4:
Matchfile(GO.link/src/crypto/rc4/rc4_ref.go) => false <nil>
Matchfile(GO.link/src/crypto/rc4/rc4_asm.go) => true <nil>
Ignoring test code in rc4_test.go
Matchfile(GO.link/src/crypto/rc4/rc4.go) => true <nil>
Package rc4:
Processing package=rc4 in crypto/rc4:
Walking from GO.link/src to GO.link/src/crypto/rsa
Processing crypto/rsa:
Ignoring test code in pkcs1v15_test.go
Ignoring test code in example_test.go
Ignoring test code in pss_test.go
Ignoring test code in rsa_test.go
Matchfile(GO.link/src/crypto/rsa/rsa.go) => true <nil>
Matchfile(GO.link/src/crypto/rsa/pkcs1v15.go) => true <nil>
Matchfile(GO.link/src/crypto/rsa/pss.go) => true <nil>
Package rsa:
Processing package=rsa in crypto/rsa:
Excluding GO.link/src/crypto/rsa/testdata
Walking from GO.link/src to GO.link/src/crypto/sha1
Processing crypto/sha1:
Ignoring test code in fallback_test.go
Matchfile(GO.link/src/crypto/sha1/sha1block.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in sha1_test.go
Matchfile(GO.link/src/crypto/sha1/sha1.go) => true <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_arm64.go) => false <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_decl.go) => false <nil>
Ignoring test code in issue15617_test.go
Matchfile(GO.link/src/crypto/sha1/sha1block_generic.go) => false <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_amd64.go) => true <nil>
Package sha1:
Processing package=sha1 in crypto/sha1:
Walking from GO.link/src to GO.link/src/crypto/sha256
Processing crypto/sha256:
Ignoring test code in fallback_test.go
Matchfile(GO.link/src/crypto/sha256/sha256block_generic.go) => false <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_arm64.go) => false <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_decl.go) => true <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_s390x.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/sha256/sha256.go) => true <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_amd64.go) => true <nil>
Ignoring test code in sha256_test.go
Matchfile(GO.link/src/crypto/sha256/sha256block.go) => true <nil>
Package sha256:
Processing package=sha256 in crypto/sha256:
Walking from GO.link/src to GO.link/src/crypto/sha512
Processing crypto/sha512:
Ignoring test code in fallback_test.go
Matchfile(GO.link/src/crypto/sha512/sha512.go) => true <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block.go) => true <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block_decl.go) => false <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block_amd64.go) => true <nil>
Ignoring test code in sha512_test.go
Matchfile(GO.link/src/crypto/sha512/sha512block_generic.go) => false <nil>
Package sha512:
Processing package=sha512 in crypto/sha512:
Walking from GO.link/src to GO.link/src/crypto/subtle
Processing crypto/subtle:
Ignoring test code in constant_time_test.go
Matchfile(GO.link/src/crypto/subtle/constant_time.go) => true <nil>
Package subtle:
Processing package=subtle in crypto/subtle:
Walking from GO.link/src to GO.link/src/crypto/tls
Processing crypto/tls:
Ignoring test code in example_test.go
Ignoring test code in handshake_test.go
Ignoring test code in handshake_messages_test.go
Matchfile(GO.link/src/crypto/tls/ticket.go) => true <nil>
Ignoring test code in auth_test.go
Matchfile(GO.link/src/crypto/tls/handshake_client.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/auth.go) => true <nil>
Ignoring test code in prf_test.go
Ignoring test code in handshake_server_test.go
Matchfile(GO.link/src/crypto/tls/prf.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/handshake_server.go) => true <nil>
Ignoring test code in handshake_client_test.go
Matchfile(GO.link/src/crypto/tls/handshake_messages.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/common.go) => true <nil>
Ignoring test code in conn_test.go
Matchfile(GO.link/src/crypto/tls/key_agreement.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/cipher_suites.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/tls.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/alert.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/generate_cert.go) => false <nil>
Ignoring test code in tls_test.go
Matchfile(GO.link/src/crypto/tls/conn.go) => true <nil>
Package tls:
Processing package=tls in crypto/tls:
Excluding GO.link/src/crypto/tls/testdata
Walking from GO.link/src to GO.link/src/crypto/x509
Processing crypto/x509:
Matchfile(GO.link/src/crypto/x509/root_windows.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_js.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_unix.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/x509.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/pem_decrypt.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in name_constraints_test.go
Ignoring test code in root_unix_test.go
Ignoring test code in x509_test.go
Ignoring test code in pkcs8_test.go
Matchfile(GO.link/src/crypto/x509/x509_test_import.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/sec1.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/pkcs1.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/cert_pool.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_nocgo_darwin.go) => false <nil>
Ignoring test code in pem_decrypt_test.go
Matchfile(GO.link/src/crypto/x509/root_solaris.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_cgo_darwin.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_darwin_arm_gen.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_darwin.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_bsd.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_darwin_armx.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_nacl.go) => false <nil>
Ignoring test code in verify_test.go
Matchfile(GO.link/src/crypto/x509/root_plan9.go) => false <nil>
Ignoring test code in root_darwin_test.go
Matchfile(GO.link/src/crypto/x509/pkcs8.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_linux.go) => false <nil>
Ignoring test code in sec1_test.go
Matchfile(GO.link/src/crypto/x509/root.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/verify.go) => true <nil>
Package x509:
Processing package=x509 in crypto/x509:
Walking from GO.link/src to GO.link/src/crypto/x509/pkix
Processing crypto/x509/pkix:
Matchfile(GO.link/src/crypto/x509/pkix/pkix.go) => true <nil>
Package pkix:
Processing package=pkix in crypto/x509/pkix:
Excluding GO.link/src/crypto/x509/testdata
Walking from GO.link/src to GO.link/src/database
Processing database:
Walking from GO.link/src to GO.link/src/database/sql
Processing database/sql:
Ignoring test code in example_test.go
Matchfile(GO.link/src/database/sql/convert.go) => true <nil>
Ignoring test code in sql_test.go
Ignoring test code in fakedb_test.go
Ignoring test code in convert_test.go
Matchfile(GO.link/src/database/sql/ctxutil.go) => true <nil>
Matchfile(GO.link/src/database/sql/sql.go) => true <nil>
Package sql:
Processing package=sql in database/sql:
Walking from GO.link/src to GO.link/src/database/sql/driver
Processing database/sql/driver:
Ignoring test code in types_test.go
Matchfile(GO.link/src/database/sql/driver/types.go) => true <nil>
Matchfile(GO.link/src/database/sql/driver/driver.go) => true <nil>
Package driver:
Processing package=driver in database/sql/driver:
Walking from GO.link/src to GO.link/src/debug
Processing debug:
Walking from GO.link/src to GO.link/src/debug/dwarf
Processing debug/dwarf:
Matchfile(GO.link/src/debug/dwarf/buf.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/typeunit.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/class_string.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/type.go) => true <nil>
Ignoring test code in entry_test.go
Matchfile(GO.link/src/debug/dwarf/line.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/tag_string.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/open.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/entry.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/unit.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/attr_string.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in type_test.go
Ignoring test code in line_test.go
Matchfile(GO.link/src/debug/dwarf/const.go) => true <nil>
Package dwarf:
Processing package=dwarf in debug/dwarf:
Excluding GO.link/src/debug/dwarf/testdata
Walking from GO.link/src to GO.link/src/debug/elf
Processing debug/elf:
Ignoring test code in symbols_test.go
Ignoring test code in file_test.go
Ignoring test code in elf_test.go
Matchfile(GO.link/src/debug/elf/elf.go) => true <nil>
Matchfile(GO.link/src/debug/elf/file.go) => true <nil>
Matchfile(GO.link/src/debug/elf/reader.go) => true <nil>
Package elf:
Processing package=elf in debug/elf:
Excluding GO.link/src/debug/elf/testdata
Walking from GO.link/src to GO.link/src/debug/gosym
Processing debug/gosym:
Matchfile(GO.link/src/debug/gosym/symtab.go) => true <nil>
Matchfile(GO.link/src/debug/gosym/pclntab.go) => true <nil>
Ignoring test code in symtab_test.go
Ignoring test code in pclntab_test.go
Package gosym:
Processing package=gosym in debug/gosym:
Walking from GO.link/src to GO.link/src/debug/macho
Processing debug/macho:
Matchfile(GO.link/src/debug/macho/reloctype.go) => true <nil>
Matchfile(GO.link/src/debug/macho/macho.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(GO.link/src/debug/macho/file.go) => true <nil>
Matchfile(GO.link/src/debug/macho/fat.go) => true <nil>
Matchfile(GO.link/src/debug/macho/reloctype_string.go) => true <nil>
Package macho:
Processing package=macho in debug/macho:
Excluding GO.link/src/debug/macho/testdata
Walking from GO.link/src to GO.link/src/debug/pe
Processing debug/pe:
Matchfile(GO.link/src/debug/pe/section.go) => true <nil>
Matchfile(GO.link/src/debug/pe/symbol.go) => true <nil>
Ignoring test code in file_test.go
Ignoring test code in file_cgo_test.go
Matchfile(GO.link/src/debug/pe/file.go) => true <nil>
Matchfile(GO.link/src/debug/pe/pe.go) => true <nil>
Matchfile(GO.link/src/debug/pe/string.go) => true <nil>
Package pe:
Processing package=pe in debug/pe:
Excluding GO.link/src/debug/pe/testdata
Walking from GO.link/src to GO.link/src/debug/plan9obj
Processing debug/plan9obj:
Matchfile(GO.link/src/debug/plan9obj/plan9obj.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(GO.link/src/debug/plan9obj/file.go) => true <nil>
Package plan9obj:
Processing package=plan9obj in debug/plan9obj:
Excluding GO.link/src/debug/plan9obj/testdata
Walking from GO.link/src to GO.link/src/encoding
Processing encoding:
Matchfile(GO.link/src/encoding/encoding.go) => true <nil>
Package encoding:
Processing package=encoding in encoding:
Walking from GO.link/src to GO.link/src/encoding/ascii85
Processing encoding/ascii85:
Ignoring test code in ascii85_test.go
Matchfile(GO.link/src/encoding/ascii85/ascii85.go) => true <nil>
Package ascii85:
Processing package=ascii85 in encoding/ascii85:
Walking from GO.link/src to GO.link/src/encoding/asn1
Processing encoding/asn1:
Matchfile(GO.link/src/encoding/asn1/marshal.go) => true <nil>
Matchfile(GO.link/src/encoding/asn1/common.go) => true <nil>
Matchfile(GO.link/src/encoding/asn1/asn1.go) => true <nil>
Ignoring test code in marshal_test.go
Ignoring test code in asn1_test.go
Package asn1:
Processing package=asn1 in encoding/asn1:
Walking from GO.link/src to GO.link/src/encoding/base32
Processing encoding/base32:
Ignoring test code in base32_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/base32/base32.go) => true <nil>
Package base32:
Processing package=base32 in encoding/base32:
Walking from GO.link/src to GO.link/src/encoding/base64
Processing encoding/base64:
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/base64/base64.go) => true <nil>
Ignoring test code in base64_test.go
Package base64:
Processing package=base64 in encoding/base64:
Walking from GO.link/src to GO.link/src/encoding/binary
Processing encoding/binary:
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/binary/binary.go) => true <nil>
Ignoring test code in binary_test.go
Ignoring test code in varint_test.go
Matchfile(GO.link/src/encoding/binary/varint.go) => true <nil>
Package binary:
Processing package=binary in encoding/binary:
Walking from GO.link/src to GO.link/src/encoding/csv
Processing encoding/csv:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/encoding/csv/writer.go) => true <nil>
Matchfile(GO.link/src/encoding/csv/reader.go) => true <nil>
Ignoring test code in reader_test.go
Package csv:
Processing package=csv in encoding/csv:
Walking from GO.link/src to GO.link/src/encoding/gob
Processing encoding/gob:
Ignoring test code in timing_test.go
Matchfile(GO.link/src/encoding/gob/decgen.go) => false <nil>
Matchfile(GO.link/src/encoding/gob/encode.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/error.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in gobencdec_test.go
Matchfile(GO.link/src/encoding/gob/decoder.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/dec_helpers.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/encoder.go) => true <nil>
Ignoring test code in example_interface_test.go
Matchfile(GO.link/src/encoding/gob/type.go) => true <nil>
Ignoring test code in codec_test.go
Matchfile(GO.link/src/encoding/gob/debug.go) => false <nil>
Matchfile(GO.link/src/encoding/gob/doc.go) => true <nil>
Ignoring test code in type_test.go
Ignoring test code in encoder_test.go
Matchfile(GO.link/src/encoding/gob/dump.go) => false <nil>
Matchfile(GO.link/src/encoding/gob/enc_helpers.go) => true <nil>
Ignoring test code in example_encdec_test.go
Matchfile(GO.link/src/encoding/gob/decode.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/encgen.go) => false <nil>
Package gob:
Processing package=gob in encoding/gob:
Walking from GO.link/src to GO.link/src/encoding/hex
Processing encoding/hex:
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/hex/hex.go) => true <nil>
Ignoring test code in hex_test.go
Package hex:
Processing package=hex in encoding/hex:
Walking from GO.link/src to GO.link/src/encoding/json
Processing encoding/json:
Ignoring test code in decode_test.go
Matchfile(GO.link/src/encoding/json/encode.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/json/scanner.go) => true <nil>
Ignoring test code in tagkey_test.go
Matchfile(GO.link/src/encoding/json/tags.go) => true <nil>
Matchfile(GO.link/src/encoding/json/stream.go) => true <nil>
Ignoring test code in tags_test.go
Ignoring test code in fold_test.go
Matchfile(GO.link/src/encoding/json/tables.go) => true <nil>
Ignoring test code in number_test.go
Ignoring test code in stream_test.go
Matchfile(GO.link/src/encoding/json/indent.go) => true <nil>
Ignoring test code in bench_test.go
Ignoring test code in example_marshaling_test.go
Matchfile(GO.link/src/encoding/json/fold.go) => true <nil>
Matchfile(GO.link/src/encoding/json/decode.go) => true <nil>
Ignoring test code in scanner_test.go
Ignoring test code in encode_test.go
Package json:
Processing package=json in encoding/json:
Excluding GO.link/src/encoding/json/testdata
Walking from GO.link/src to GO.link/src/encoding/pem
Processing encoding/pem:
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/pem/pem.go) => true <nil>
Ignoring test code in pem_test.go
Package pem:
Processing package=pem in encoding/pem:
Walking from GO.link/src to GO.link/src/encoding/xml
Processing encoding/xml:
Ignoring test code in read_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/xml/marshal.go) => true <nil>
Matchfile(GO.link/src/encoding/xml/typeinfo.go) => true <nil>
Matchfile(GO.link/src/encoding/xml/xml.go) => true <nil>
Ignoring test code in atom_test.go
Matchfile(GO.link/src/encoding/xml/read.go) => true <nil>
Ignoring test code in xml_test.go
Ignoring test code in marshal_test.go
Package xml:
Processing package=xml in encoding/xml:
Walking from GO.link/src to GO.link/src/errors
Processing errors:
Ignoring test code in example_test.go
Ignoring test code in errors_test.go
Matchfile(GO.link/src/errors/errors.go) => true <nil>
Package errors:
Processing package=errors in errors:
Walking from GO.link/src to GO.link/src/expvar
Processing expvar:
Ignoring test code in expvar_test.go
Matchfile(GO.link/src/expvar/expvar.go) => true <nil>
Package expvar:
Processing package=expvar in expvar:
Walking from GO.link/src to GO.link/src/flag
Processing flag:
Ignoring test code in example_test.go
Matchfile(GO.link/src/flag/flag.go) => true <nil>
Ignoring test code in flag_test.go
Ignoring test code in export_test.go
Ignoring test code in example_value_test.go
Package flag:
Processing package=flag in flag:
Walking from GO.link/src to GO.link/src/fmt
Processing fmt:
Ignoring test code in example_test.go
Ignoring test code in fmt_test.go
Matchfile(GO.link/src/fmt/format.go) => true <nil>
Matchfile(GO.link/src/fmt/scan.go) => true <nil>
Matchfile(GO.link/src/fmt/doc.go) => true <nil>
Matchfile(GO.link/src/fmt/print.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in stringer_test.go
Ignoring test code in scan_test.go
Package fmt:
Processing package=fmt in fmt:
Walking from GO.link/src to GO.link/src/go
Processing go:
Walking from GO.link/src to GO.link/src/go/ast
Processing go/ast:
Matchfile(GO.link/src/go/ast/resolve.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in filter_test.go
Matchfile(GO.link/src/go/ast/import.go) => true <nil>
Ignoring test code in ast_test.go
Matchfile(GO.link/src/go/ast/filter.go) => true <nil>
Matchfile(GO.link/src/go/ast/ast.go) => true <nil>
Matchfile(GO.link/src/go/ast/print.go) => true <nil>
Ignoring test code in commentmap_test.go
Matchfile(GO.link/src/go/ast/walk.go) => true <nil>
Ignoring test code in print_test.go
Matchfile(GO.link/src/go/ast/scope.go) => true <nil>
Matchfile(GO.link/src/go/ast/commentmap.go) => true <nil>
Package ast:
Processing package=ast in go/ast:
Walking from GO.link/src to GO.link/src/go/build
Processing go/build:
Matchfile(GO.link/src/go/build/gc.go) => true <nil>
Ignoring test code in read_test.go
Matchfile(GO.link/src/go/build/build.go) => true <nil>
Matchfile(GO.link/src/go/build/syslist.go) => true <nil>
Ignoring test code in build_test.go
Ignoring test code in syslist_test.go
Matchfile(GO.link/src/go/build/gccgo.go) => false <nil>
Matchfile(GO.link/src/go/build/doc.go) => true <nil>
Ignoring test code in deps_test.go
Matchfile(GO.link/src/go/build/read.go) => true <nil>
Package build:
Processing package=build in go/build:
Excluding GO.link/src/go/build/testdata
Walking from GO.link/src to GO.link/src/go/constant
Processing go/constant:
Ignoring test code in example_test.go
Ignoring test code in value_test.go
Matchfile(GO.link/src/go/constant/value.go) => true <nil>
Package constant:
Processing package=constant in go/constant:
Walking from GO.link/src to GO.link/src/go/doc
Processing go/doc:
Ignoring test code in comment_test.go
Ignoring test code in example_test.go
Ignoring test code in synopsis_test.go
Matchfile(GO.link/src/go/doc/comment.go) => true <nil>
Matchfile(GO.link/src/go/doc/exports.go) => true <nil>
Matchfile(GO.link/src/go/doc/headscan.go) => false <nil>
Matchfile(GO.link/src/go/doc/synopsis.go) => true <nil>
Ignoring test code in doc_test.go
Matchfile(GO.link/src/go/doc/filter.go) => true <nil>
Matchfile(GO.link/src/go/doc/doc.go) => true <nil>
Matchfile(GO.link/src/go/doc/example.go) => true <nil>
Matchfile(GO.link/src/go/doc/reader.go) => true <nil>
Package doc:
Processing package=doc in go/doc:
Excluding GO.link/src/go/doc/testdata
Walking from GO.link/src to GO.link/src/go/format
Processing go/format:
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/format/internal.go) => true <nil>
Ignoring test code in format_test.go
Matchfile(GO.link/src/go/format/format.go) => true <nil>
Package format:
Processing package=format in go/format:
Walking from GO.link/src to GO.link/src/go/importer
Processing go/importer:
Matchfile(GO.link/src/go/importer/importer.go) => true <nil>
Ignoring test code in importer_test.go
Package importer:
Processing package=importer in go/importer:
Excluding GO.link/src/go/internal
Walking from GO.link/src to GO.link/src/go/parser
Processing go/parser:
Ignoring test code in example_test.go
Ignoring test code in parser_test.go
Matchfile(GO.link/src/go/parser/interface.go) => true <nil>
Ignoring test code in short_test.go
Ignoring test code in performance_test.go
Matchfile(GO.link/src/go/parser/parser.go) => true <nil>
Ignoring test code in error_test.go
Package parser:
Processing package=parser in go/parser:
Excluding GO.link/src/go/parser/testdata
Walking from GO.link/src to GO.link/src/go/printer
Processing go/printer:
Ignoring test code in example_test.go
Ignoring test code in printer_test.go
Ignoring test code in performance_test.go
Matchfile(GO.link/src/go/printer/printer.go) => true <nil>
Matchfile(GO.link/src/go/printer/nodes.go) => true <nil>
Package printer:
Processing package=printer in go/printer:
Excluding GO.link/src/go/printer/testdata
Walking from GO.link/src to GO.link/src/go/scanner
Processing go/scanner:
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Matchfile(GO.link/src/go/scanner/errors.go) => true <nil>
Package scanner:
Processing package=scanner in go/scanner:
Walking from GO.link/src to GO.link/src/go/token
Processing go/token:
Ignoring test code in serialize_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/token/token.go) => true <nil>
Matchfile(GO.link/src/go/token/serialize.go) => true <nil>
Ignoring test code in position_test.go
Matchfile(GO.link/src/go/token/position.go) => true <nil>
Package token:
Processing package=token in go/token:
Walking from GO.link/src to GO.link/src/go/types
Processing go/types:
Matchfile(GO.link/src/go/types/object.go) => true <nil>
Ignoring test code in check_test.go
Matchfile(GO.link/src/go/types/check.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in exprstring_test.go
Matchfile(GO.link/src/go/types/methodset.go) => true <nil>
Matchfile(GO.link/src/go/types/predicates.go) => true <nil>
Matchfile(GO.link/src/go/types/labels.go) => true <nil>
Matchfile(GO.link/src/go/types/interfaces.go) => true <nil>
Ignoring test code in stdlib_test.go
Ignoring test code in builtins_test.go
Ignoring test code in sizes_test.go
Matchfile(GO.link/src/go/types/package.go) => true <nil>
Matchfile(GO.link/src/go/types/sizes.go) => true <nil>
Matchfile(GO.link/src/go/types/type.go) => true <nil>
Ignoring test code in issues_test.go
Ignoring test code in resolver_test.go
Matchfile(GO.link/src/go/types/lookup.go) => true <nil>
Matchfile(GO.link/src/go/types/typestring.go) => true <nil>
Matchfile(GO.link/src/go/types/stmt.go) => true <nil>
Matchfile(GO.link/src/go/types/typexpr.go) => true <nil>
Matchfile(GO.link/src/go/types/conversions.go) => true <nil>
Matchfile(GO.link/src/go/types/operand.go) => true <nil>
Matchfile(GO.link/src/go/types/builtins.go) => true <nil>
Matchfile(GO.link/src/go/types/initorder.go) => true <nil>
Matchfile(GO.link/src/go/types/resolver.go) => true <nil>
Ignoring test code in token_test.go
Ignoring test code in eval_test.go
Ignoring test code in self_test.go
Matchfile(GO.link/src/go/types/universe.go) => true <nil>
Matchfile(GO.link/src/go/types/api.go) => true <nil>
Matchfile(GO.link/src/go/types/exprstring.go) => true <nil>
Matchfile(GO.link/src/go/types/assignments.go) => true <nil>
Ignoring test code in hilbert_test.go
Matchfile(GO.link/src/go/types/expr.go) => true <nil>
Ignoring test code in typestring_test.go
Matchfile(GO.link/src/go/types/scope.go) => true <nil>
Matchfile(GO.link/src/go/types/objset.go) => true <nil>
Matchfile(GO.link/src/go/types/return.go) => true <nil>
Matchfile(GO.link/src/go/types/decl.go) => true <nil>
Ignoring test code in api_test.go
Matchfile(GO.link/src/go/types/call.go) => true <nil>
Matchfile(GO.link/src/go/types/eval.go) => true <nil>
Matchfile(GO.link/src/go/types/selection.go) => true <nil>
Matchfile(GO.link/src/go/types/errors.go) => true <nil>
Ignoring test code in object_test.go
Matchfile(GO.link/src/go/types/gotype.go) => false <nil>
Package types:
Processing package=types in go/types:
Excluding GO.link/src/go/types/testdata
Walking from GO.link/src to GO.link/src/hash
Processing hash:
Ignoring test code in example_test.go
Matchfile(GO.link/src/hash/hash.go) => true <nil>
Ignoring test code in marshal_test.go
Package hash:
Processing package=hash in hash:
Walking from GO.link/src to GO.link/src/hash/adler32
Processing hash/adler32:
Matchfile(GO.link/src/hash/adler32/adler32.go) => true <nil>
Ignoring test code in adler32_test.go
Package adler32:
Processing package=adler32 in hash/adler32:
Walking from GO.link/src to GO.link/src/hash/crc32
Processing hash/crc32:
Matchfile(GO.link/src/hash/crc32/crc32_ppc64le.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32_amd64.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/hash/crc32/crc32_otherarch.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/gen_const_ppc64le.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32.go) => true <nil>
Ignoring test code in crc32_test.go
Matchfile(GO.link/src/hash/crc32/crc32_arm64.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32_generic.go) => true <nil>
Matchfile(GO.link/src/hash/crc32/crc32_s390x.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32_amd64p32.go) => false <nil>
Package crc32:
Processing package=crc32 in hash/crc32:
Walking from GO.link/src to GO.link/src/hash/crc64
Processing hash/crc64:
Ignoring test code in crc64_test.go
Matchfile(GO.link/src/hash/crc64/crc64.go) => true <nil>
Package crc64:
Processing package=crc64 in hash/crc64:
Walking from GO.link/src to GO.link/src/hash/fnv
Processing hash/fnv:
Matchfile(GO.link/src/hash/fnv/fnv.go) => true <nil>
Ignoring test code in fnv_test.go
Package fnv:
Processing package=fnv in hash/fnv:
Walking from GO.link/src to GO.link/src/html
Processing html:
Ignoring test code in example_test.go
Matchfile(GO.link/src/html/escape.go) => true <nil>
Matchfile(GO.link/src/html/entity.go) => true <nil>
Ignoring test code in entity_test.go
Ignoring test code in escape_test.go
Package html:
Processing package=html in html:
Walking from GO.link/src to GO.link/src/html/template
Processing html/template:
Ignoring test code in clone_test.go
Matchfile(GO.link/src/html/template/error.go) => true <nil>
Ignoring test code in examplefiles_test.go
Ignoring test code in example_test.go
Ignoring test code in content_test.go
Matchfile(GO.link/src/html/template/escape.go) => true <nil>
Ignoring test code in transition_test.go
Ignoring test code in js_test.go
Matchfile(GO.link/src/html/template/element_string.go) => true <nil>
Matchfile(GO.link/src/html/template/urlpart_string.go) => true <nil>
Matchfile(GO.link/src/html/template/transition.go) => true <nil>
Ignoring test code in css_test.go
Ignoring test code in template_test.go
Matchfile(GO.link/src/html/template/html.go) => true <nil>
Matchfile(GO.link/src/html/template/state_string.go) => true <nil>
Matchfile(GO.link/src/html/template/js.go) => true <nil>
Ignoring test code in html_test.go
Matchfile(GO.link/src/html/template/delim_string.go) => true <nil>
Matchfile(GO.link/src/html/template/template.go) => true <nil>
Matchfile(GO.link/src/html/template/doc.go) => true <nil>
Matchfile(GO.link/src/html/template/context.go) => true <nil>
Matchfile(GO.link/src/html/template/attr_string.go) => true <nil>
Matchfile(GO.link/src/html/template/content.go) => true <nil>
Matchfile(GO.link/src/html/template/css.go) => true <nil>
Matchfile(GO.link/src/html/template/url.go) => true <nil>
Ignoring test code in escape_test.go
Matchfile(GO.link/src/html/template/attr.go) => true <nil>
Ignoring test code in url_test.go
Matchfile(GO.link/src/html/template/jsctx_string.go) => true <nil>
Package template:
Processing package=template in html/template:
Walking from GO.link/src to GO.link/src/image
Processing image:
Ignoring test code in geom_test.go
Ignoring test code in decode_test.go
Matchfile(GO.link/src/image/format.go) => true <nil>
Matchfile(GO.link/src/image/geom.go) => true <nil>
Ignoring test code in ycbcr_test.go
Ignoring test code in image_test.go
Matchfile(GO.link/src/image/names.go) => true <nil>
Matchfile(GO.link/src/image/image.go) => true <nil>
Matchfile(GO.link/src/image/ycbcr.go) => true <nil>
Ignoring test code in decode_example_test.go
Package image:
Processing package=image in image:
Walking from GO.link/src to GO.link/src/image/color
Processing image/color:
Matchfile(GO.link/src/image/color/color.go) => true <nil>
Ignoring test code in color_test.go
Ignoring test code in ycbcr_test.go
Matchfile(GO.link/src/image/color/ycbcr.go) => true <nil>
Package color:
Processing package=color in image/color:
Walking from GO.link/src to GO.link/src/image/color/palette
Processing image/color/palette:
Matchfile(GO.link/src/image/color/palette/generate.go) => true <nil>
Matchfile(GO.link/src/image/color/palette/gen.go) => false <nil>
Matchfile(GO.link/src/image/color/palette/palette.go) => true <nil>
Package palette:
Processing package=palette in image/color/palette:
Walking from GO.link/src to GO.link/src/image/draw
Processing image/draw:
Ignoring test code in draw_test.go
Ignoring test code in example_test.go
Ignoring test code in clip_test.go
Ignoring test code in bench_test.go
Matchfile(GO.link/src/image/draw/draw.go) => true <nil>
Package draw:
Processing package=draw in image/draw:
Walking from GO.link/src to GO.link/src/image/gif
Processing image/gif:
Ignoring test code in writer_test.go
Matchfile(GO.link/src/image/gif/writer.go) => true <nil>
Matchfile(GO.link/src/image/gif/reader.go) => true <nil>
Ignoring test code in reader_test.go
Package gif:
Processing package=gif in image/gif:
Excluding GO.link/src/image/internal
Walking from GO.link/src to GO.link/src/image/jpeg
Processing image/jpeg:
Ignoring test code in writer_test.go
Matchfile(GO.link/src/image/jpeg/huffman.go) => true <nil>
Ignoring test code in dct_test.go
Matchfile(GO.link/src/image/jpeg/idct.go) => true <nil>
Matchfile(GO.link/src/image/jpeg/scan.go) => true <nil>
Matchfile(GO.link/src/image/jpeg/writer.go) => true <nil>
Matchfile(GO.link/src/image/jpeg/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/image/jpeg/fdct.go) => true <nil>
Package jpeg:
Processing package=jpeg in image/jpeg:
Walking from GO.link/src to GO.link/src/image/png
Processing image/png:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Ignoring test code in paeth_test.go
Matchfile(GO.link/src/image/png/writer.go) => true <nil>
Matchfile(GO.link/src/image/png/paeth.go) => true <nil>
Matchfile(GO.link/src/image/png/reader.go) => true <nil>
Ignoring test code in reader_test.go
Package png:
Processing package=png in image/png:
Excluding GO.link/src/image/png/testdata
Excluding GO.link/src/image/testdata
Walking from GO.link/src to GO.link/src/index
Processing index:
Walking from GO.link/src to GO.link/src/index/suffixarray
Processing index/suffixarray:
Ignoring test code in example_test.go
Ignoring test code in suffixarray_test.go
Matchfile(GO.link/src/index/suffixarray/suffixarray.go) => true <nil>
Matchfile(GO.link/src/index/suffixarray/qsufsort.go) => true <nil>
Package suffixarray:
Processing package=suffixarray in index/suffixarray:
Excluding GO.link/src/internal
Walking from GO.link/src to GO.link/src/io
Processing io:
Ignoring test code in example_test.go
Ignoring test code in multi_test.go
Matchfile(GO.link/src/io/io.go) => true <nil>
Matchfile(GO.link/src/io/multi.go) => true <nil>
Ignoring test code in pipe_test.go
Matchfile(GO.link/src/io/pipe.go) => true <nil>
Ignoring test code in io_test.go
Package io:
Processing package=io in io:
Walking from GO.link/src to GO.link/src/io/ioutil
Processing io/ioutil:
Ignoring test code in example_test.go
Matchfile(GO.link/src/io/ioutil/tempfile.go) => true <nil>
Matchfile(GO.link/src/io/ioutil/ioutil.go) => true <nil>
Ignoring test code in ioutil_test.go
Ignoring test code in tempfile_test.go
Package ioutil:
Processing package=ioutil in io/ioutil:
Excluding GO.link/src/io/ioutil/testdata
Walking from GO.link/src to GO.link/src/log
Processing log:
Matchfile(GO.link/src/log/log.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in log_test.go
Package log:
Processing package=log in log:
Walking from GO.link/src to GO.link/src/log/syslog
Processing log/syslog:
Ignoring test code in example_test.go
Matchfile(GO.link/src/log/syslog/syslog.go) => true <nil>
Matchfile(GO.link/src/log/syslog/doc.go) => true <nil>
Ignoring test code in syslog_test.go
Matchfile(GO.link/src/log/syslog/syslog_unix.go) => true <nil>
Package syslog:
Processing package=syslog in log/syslog:
Walking from GO.link/src to GO.link/src/math
Processing math:
Matchfile(GO.link/src/math/arith_s390x.go) => false <nil>
Matchfile(GO.link/src/math/sqrt.go) => true <nil>
Matchfile(GO.link/src/math/log.go) => true <nil>
Matchfile(GO.link/src/math/hypot.go) => true <nil>
Matchfile(GO.link/src/math/logb.go) => true <nil>
Matchfile(GO.link/src/math/nextafter.go) => true <nil>
Matchfile(GO.link/src/math/exp_asm.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/signbit.go) => true <nil>
Matchfile(GO.link/src/math/tanh.go) => true <nil>
Matchfile(GO.link/src/math/pow.go) => true <nil>
Matchfile(GO.link/src/math/acosh.go) => true <nil>
Matchfile(GO.link/src/math/bits.go) => true <nil>
Matchfile(GO.link/src/math/asinh.go) => true <nil>
Matchfile(GO.link/src/math/copysign.go) => true <nil>
Matchfile(GO.link/src/math/jn.go) => true <nil>
Matchfile(GO.link/src/math/erf.go) => true <nil>
Matchfile(GO.link/src/math/floor.go) => true <nil>
Matchfile(GO.link/src/math/modf.go) => true <nil>
Matchfile(GO.link/src/math/ldexp.go) => true <nil>
Matchfile(GO.link/src/math/abs.go) => true <nil>
Matchfile(GO.link/src/math/tan.go) => true <nil>
Matchfile(GO.link/src/math/atan2.go) => true <nil>
Matchfile(GO.link/src/math/asin.go) => true <nil>
Matchfile(GO.link/src/math/remainder.go) => true <nil>
Matchfile(GO.link/src/math/pow10.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(GO.link/src/math/expm1.go) => true <nil>
Matchfile(GO.link/src/math/unsafe.go) => true <nil>
Matchfile(GO.link/src/math/sincos_386.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/math/frexp.go) => true <nil>
Matchfile(GO.link/src/math/log10.go) => true <nil>
Matchfile(GO.link/src/math/sincos.go) => true <nil>
Matchfile(GO.link/src/math/const.go) => true <nil>
Matchfile(GO.link/src/math/gamma.go) => true <nil>
Matchfile(GO.link/src/math/sin.go) => true <nil>
Ignoring test code in arith_s390x_test.go
Matchfile(GO.link/src/math/atanh.go) => true <nil>
Matchfile(GO.link/src/math/cbrt.go) => true <nil>
Matchfile(GO.link/src/math/log1p.go) => true <nil>
Matchfile(GO.link/src/math/atan.go) => true <nil>
Matchfile(GO.link/src/math/mod.go) => true <nil>
Matchfile(GO.link/src/math/j1.go) => true <nil>
Matchfile(GO.link/src/math/exp.go) => true <nil>
Matchfile(GO.link/src/math/sinh.go) => true <nil>
Ignoring test code in export_s390x_test.go
Matchfile(GO.link/src/math/erfinv.go) => true <nil>
Matchfile(GO.link/src/math/j0.go) => true <nil>
Matchfile(GO.link/src/math/dim.go) => true <nil>
Matchfile(GO.link/src/math/lgamma.go) => true <nil>
Package math:
Processing package=math in math:
Walking from GO.link/src to GO.link/src/math/big
Processing math/big:
Matchfile(GO.link/src/math/big/sqrt.go) => true <nil>
Matchfile(GO.link/src/math/big/natconv.go) => true <nil>
Matchfile(GO.link/src/math/big/ratmarsh.go) => true <nil>
Ignoring test code in int_test.go
Ignoring test code in ratconv_test.go
Ignoring test code in example_test.go
Ignoring test code in rat_test.go
Matchfile(GO.link/src/math/big/intmarsh.go) => true <nil>
Matchfile(GO.link/src/math/big/prime.go) => true <nil>
Matchfile(GO.link/src/math/big/ftoa.go) => true <nil>
Matchfile(GO.link/src/math/big/roundingmode_string.go) => true <nil>
Ignoring test code in float_test.go
Ignoring test code in ratmarsh_test.go
Matchfile(GO.link/src/math/big/floatmarsh.go) => true <nil>
Ignoring test code in natconv_test.go
Ignoring test code in sqrt_test.go
Ignoring test code in intmarsh_test.go
Matchfile(GO.link/src/math/big/decimal.go) => true <nil>
Matchfile(GO.link/src/math/big/nat.go) => true <nil>
Ignoring test code in gcd_test.go
Ignoring test code in floatmarsh_test.go
Matchfile(GO.link/src/math/big/arith_decl_pure.go) => false <nil>
Matchfile(GO.link/src/math/big/arith_decl_s390x.go) => false <nil>
Matchfile(GO.link/src/math/big/arith_decl.go) => true <nil>
Matchfile(GO.link/src/math/big/float.go) => true <nil>
Ignoring test code in calibrate_test.go
Matchfile(GO.link/src/math/big/arith.go) => true <nil>
Matchfile(GO.link/src/math/big/ratconv.go) => true <nil>
Matchfile(GO.link/src/math/big/arith_amd64.go) => true <nil>
Ignoring test code in floatconv_test.go
Matchfile(GO.link/src/math/big/doc.go) => true <nil>
Ignoring test code in nat_test.go
Ignoring test code in floatexample_test.go
Ignoring test code in prime_test.go
Ignoring test code in arith_test.go
Ignoring test code in hilbert_test.go
Ignoring test code in arith_s390x_test.go
Ignoring test code in decimal_test.go
Matchfile(GO.link/src/math/big/int.go) => true <nil>
Matchfile(GO.link/src/math/big/intconv.go) => true <nil>
Matchfile(GO.link/src/math/big/accuracy_string.go) => true <nil>
Ignoring test code in example_rat_test.go
Matchfile(GO.link/src/math/big/rat.go) => true <nil>
Ignoring test code in intconv_test.go
Matchfile(GO.link/src/math/big/floatconv.go) => true <nil>
Ignoring test code in bits_test.go
Package big:
Processing package=big in math/big:
Walking from GO.link/src to GO.link/src/math/bits
Processing math/bits:
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/bits/bits.go) => true <nil>
Matchfile(GO.link/src/math/bits/bits_tables.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/math/bits/make_examples.go) => false <nil>
Matchfile(GO.link/src/math/bits/make_tables.go) => false <nil>
Ignoring test code in bits_test.go
Package bits:
Processing package=bits in math/bits:
Walking from GO.link/src to GO.link/src/math/cmplx
Processing math/cmplx:
Matchfile(GO.link/src/math/cmplx/sqrt.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/log.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/isnan.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/isinf.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/cmplx/pow.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/phase.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/polar.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/rect.go) => true <nil>
Ignoring test code in cmath_test.go
Matchfile(GO.link/src/math/cmplx/abs.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/tan.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/asin.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/sin.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/exp.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/conj.go) => true <nil>
Package cmplx:
Processing package=cmplx in math/cmplx:
Walking from GO.link/src to GO.link/src/math/rand
Processing math/rand:
Matchfile(GO.link/src/math/rand/gen_cooked.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in race_test.go
Ignoring test code in rand_test.go
Matchfile(GO.link/src/math/rand/rng.go) => true <nil>
Matchfile(GO.link/src/math/rand/normal.go) => true <nil>
Ignoring test code in regress_test.go
Matchfile(GO.link/src/math/rand/rand.go) => true <nil>
Matchfile(GO.link/src/math/rand/exp.go) => true <nil>
Matchfile(GO.link/src/math/rand/zipf.go) => true <nil>
Package rand:
Processing package=rand in math/rand:
Walking from GO.link/src to GO.link/src/mime
Processing mime:
Ignoring test code in encodedword_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/mime/type_windows.go) => false <nil>
Matchfile(GO.link/src/mime/grammar.go) => true <nil>
Matchfile(GO.link/src/mime/type.go) => true <nil>
Matchfile(GO.link/src/mime/type_plan9.go) => false <nil>
Ignoring test code in mediatype_test.go
Matchfile(GO.link/src/mime/mediatype.go) => true <nil>
Matchfile(GO.link/src/mime/encodedword.go) => true <nil>
Matchfile(GO.link/src/mime/type_freebsd.go) => false <nil>
Ignoring test code in type_test.go
Matchfile(GO.link/src/mime/type_unix.go) => true <nil>
Matchfile(GO.link/src/mime/type_dragonfly.go) => false <nil>
Matchfile(GO.link/src/mime/type_openbsd.go) => false <nil>
Package mime:
Processing package=mime in mime:
Walking from GO.link/src to GO.link/src/mime/multipart
Processing mime/multipart:
Ignoring test code in example_test.go
Ignoring test code in multipart_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/mime/multipart/multipart.go) => true <nil>
Matchfile(GO.link/src/mime/multipart/writer.go) => true <nil>
Matchfile(GO.link/src/mime/multipart/formdata.go) => true <nil>
Ignoring test code in formdata_test.go
Package multipart:
Processing package=multipart in mime/multipart:
Excluding GO.link/src/mime/multipart/testdata
Walking from GO.link/src to GO.link/src/mime/quotedprintable
Processing mime/quotedprintable:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/mime/quotedprintable/writer.go) => true <nil>
Matchfile(GO.link/src/mime/quotedprintable/reader.go) => true <nil>
Ignoring test code in reader_test.go
Package quotedprintable:
Processing package=quotedprintable in mime/quotedprintable:
Excluding GO.link/src/mime/testdata
Walking from GO.link/src to GO.link/src/net
Processing net:
Matchfile(GO.link/src/net/fd_windows.go) => false <nil>
Ignoring test code in ipsock_test.go
Matchfile(GO.link/src/net/fd_plan9.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_openbsd.go) => false <nil>
Matchfile(GO.link/src/net/cgo_unix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_solaris.go) => false <nil>
Matchfile(GO.link/src/net/fd_unix.go) => true <nil>
Matchfile(GO.link/src/net/error_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sockopt_stub.go) => false <nil>
Ignoring test code in mac_test.go
Ignoring test code in tcpsock_test.go
Ignoring test code in lookup_test.go
Matchfile(GO.link/src/net/sockoptip_stub.go) => false <nil>
Matchfile(GO.link/src/net/sock_cloexec.go) => false <nil>
Ignoring test code in main_cloexec_test.go
Matchfile(GO.link/src/net/error_windows.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_unix.go) => false <nil>
Matchfile(GO.link/src/net/sockaddr_posix.go) => true <nil>
Ignoring test code in dnsclient_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/interface_freebsd.go) => false <nil>
Ignoring test code in iprawsock_test.go
Ignoring test code in dnsconfig_unix_test.go
Matchfile(GO.link/src/net/cgo_socknew.go) => false <nil>
Matchfile(GO.link/src/net/error_nacl.go) => false <nil>
Matchfile(GO.link/src/net/sockoptip_windows.go) => false <nil>
Matchfile(GO.link/src/net/udpsock.go) => true <nil>
Matchfile(GO.link/src/net/udpsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sock_linux.go) => false <nil>
Matchfile(GO.link/src/net/sendfile_linux.go) => false <nil>
Ignoring test code in hosts_test.go
Matchfile(GO.link/src/net/cgo_resold.go) => false <nil>
Matchfile(GO.link/src/net/splice_linux.go) => false <nil>
Ignoring test code in main_windows_test.go
Matchfile(GO.link/src/net/unixsock_posix.go) => true <nil>
Matchfile(GO.link/src/net/rawconn.go) => true <nil>
Matchfile(GO.link/src/net/hook_windows.go) => false <nil>
Ignoring test code in interface_test.go
Matchfile(GO.link/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/cgo_linux.go) => false <nil>
Matchfile(GO.link/src/net/cgo_android.go) => false <nil>
Matchfile(GO.link/src/net/addrselect.go) => true <nil>
Matchfile(GO.link/src/net/net_fake.go) => false <nil>
Ignoring test code in interface_bsd_test.go
Matchfile(GO.link/src/net/file_unix.go) => true <nil>
Matchfile(GO.link/src/net/interface_plan9.go) => false <nil>
Matchfile(GO.link/src/net/port.go) => true <nil>
Matchfile(GO.link/src/net/sock_posix.go) => true <nil>
Ignoring test code in lookup_windows_test.go
Matchfile(GO.link/src/net/sockopt_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sendfile_stub.go) => true <nil>
Ignoring test code in tcpsock_unix_test.go
Matchfile(GO.link/src/net/lookup_unix.go) => true <nil>
Matchfile(GO.link/src/net/dnsclient_unix.go) => true <nil>
Ignoring test code in rawconn_windows_test.go
Ignoring test code in error_plan9_test.go
Matchfile(GO.link/src/net/lookup_windows.go) => false <nil>
Ignoring test code in timeout_test.go
Matchfile(GO.link/src/net/dnsconfig_unix.go) => true <nil>
Ignoring test code in dial_test.go
Matchfile(GO.link/src/net/hosts.go) => true <nil>
Matchfile(GO.link/src/net/lookup_fake.go) => false <nil>
Matchfile(GO.link/src/net/interface_bsdvar.go) => false <nil>
Ignoring test code in error_unix_test.go
Ignoring test code in interface_unix_test.go
Ignoring test code in platform_test.go
Matchfile(GO.link/src/net/sock_stub.go) => false <nil>
Matchfile(GO.link/src/net/error_posix.go) => true <nil>
Matchfile(GO.link/src/net/hook.go) => true <nil>
Matchfile(GO.link/src/net/ipsock.go) => true <nil>
Ignoring test code in cgo_unix_test.go
Ignoring test code in parse_test.go
Matchfile(GO.link/src/net/iprawsock.go) => true <nil>
Matchfile(GO.link/src/net/sock_windows.go) => false <nil>
Matchfile(GO.link/src/net/net.go) => true <nil>
Ignoring test code in error_posix_test.go
Matchfile(GO.link/src/net/lookup.go) => true <nil>
Matchfile(GO.link/src/net/interface.go) => true <nil>
Matchfile(GO.link/src/net/sys_cloexec.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(GO.link/src/net/conf.go) => true <nil>
Matchfile(GO.link/src/net/sockopt_posix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_windows.go) => false <nil>
Matchfile(GO.link/src/net/splice_stub.go) => true <nil>
Matchfile(GO.link/src/net/sock_plan9.go) => false <nil>
Ignoring test code in interface_linux_test.go
Ignoring test code in net_test.go
Matchfile(GO.link/src/net/udpsock_posix.go) => true <nil>
Ignoring test code in packetconn_test.go
Matchfile(GO.link/src/net/sockopt_linux.go) => false <nil>
Matchfile(GO.link/src/net/tcpsock_posix.go) => true <nil>
Ignoring test code in nss_test.go
Matchfile(GO.link/src/net/sendfile_windows.go) => false <nil>
Matchfile(GO.link/src/net/interface_linux.go) => false <nil>
Matchfile(GO.link/src/net/iprawsock_posix.go) => true <nil>
Matchfile(GO.link/src/net/unixsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sockopt_bsd.go) => true <nil>
Ignoring test code in protoconn_test.go
Ignoring test code in dnsname_test.go
Ignoring test code in main_posix_test.go
Matchfile(GO.link/src/net/interface_windows.go) => false <nil>
Ignoring test code in udpsock_plan9_test.go
Matchfile(GO.link/src/net/file_plan9.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_dragonfly.go) => false <nil>
Ignoring test code in port_test.go
Matchfile(GO.link/src/net/dnsclient.go) => true <nil>
Matchfile(GO.link/src/net/error_unix.go) => true <nil>
Ignoring test code in error_windows_test.go
Matchfile(GO.link/src/net/tcpsockopt_posix.go) => true <nil>
Ignoring test code in conf_test.go
Matchfile(GO.link/src/net/ip.go) => true <nil>
Matchfile(GO.link/src/net/nss.go) => true <nil>
Matchfile(GO.link/src/net/ipsock_posix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_bsd.go) => true <nil>
Matchfile(GO.link/src/net/cgo_sockold.go) => true <nil>
Ignoring test code in sendfile_test.go
Matchfile(GO.link/src/net/sendfile_unix_alt.go) => false <nil>
Matchfile(GO.link/src/net/writev_unix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_netbsd.go) => false <nil>
Matchfile(GO.link/src/net/file.go) => true <nil>
Matchfile(GO.link/src/net/interface_bsd.go) => true <nil>
Ignoring test code in ip_test.go
Ignoring test code in main_plan9_test.go
Matchfile(GO.link/src/net/cgo_resnew.go) => true <nil>
Ignoring test code in rawconn_test.go
Matchfile(GO.link/src/net/sockopt_solaris.go) => false <nil>
Matchfile(GO.link/src/net/interface_stub.go) => false <nil>
Ignoring test code in conn_test.go
Matchfile(GO.link/src/net/tcpsock.go) => true <nil>
Matchfile(GO.link/src/net/hook_plan9.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_solaris.go) => false <nil>
Ignoring test code in main_conf_test.go
Matchfile(GO.link/src/net/cgo_openbsd.go) => false <nil>
Ignoring test code in rawconn_unix_test.go
Ignoring test code in main_noconf_test.go
Ignoring test code in external_test.go
Ignoring test code in mockserver_test.go
Ignoring test code in pipe_test.go
Ignoring test code in rawconn_stub_test.go
Ignoring test code in net_windows_test.go
Matchfile(GO.link/src/net/port_unix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_stub.go) => false <nil>
Ignoring test code in main_unix_test.go
Matchfile(GO.link/src/net/mac.go) => true <nil>
Ignoring test code in unixsock_test.go
Ignoring test code in dial_unix_test.go
Ignoring test code in error_test.go
Matchfile(GO.link/src/net/tcpsockopt_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sockoptip_linux.go) => false <nil>
Matchfile(GO.link/src/net/unixsock.go) => true <nil>
Matchfile(GO.link/src/net/lookup_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sockopt_windows.go) => false <nil>
Matchfile(GO.link/src/net/sockoptip_posix.go) => true <nil>
Matchfile(GO.link/src/net/sockoptip_bsdvar.go) => true <nil>
Matchfile(GO.link/src/net/pipe.go) => true <nil>
Matchfile(GO.link/src/net/tcpsockopt_windows.go) => false <nil>
Matchfile(GO.link/src/net/hook_unix.go) => true <nil>
Matchfile(GO.link/src/net/tcpsockopt_stub.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_darwin.go) => true <nil>
Ignoring test code in udpsock_test.go
Matchfile(GO.link/src/net/interface_solaris.go) => false <nil>
Ignoring test code in listen_test.go
Matchfile(GO.link/src/net/sock_bsd.go) => true <nil>
Matchfile(GO.link/src/net/interface_darwin.go) => true <nil>
Matchfile(GO.link/src/net/dial.go) => true <nil>
Ignoring test code in server_test.go
Matchfile(GO.link/src/net/file_windows.go) => false <nil>
Ignoring test code in splice_test.go
Ignoring test code in addrselect_test.go
Matchfile(GO.link/src/net/ipsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/parse.go) => true <nil>
Ignoring test code in unixsock_linux_test.go
Matchfile(GO.link/src/net/conf_netcgo.go) => false <nil>
Ignoring test code in writev_test.go
Ignoring test code in netgo_unix_test.go
Ignoring test code in write_unix_test.go
Ignoring test code in main_test.go
Ignoring test code in dnsclient_unix_test.go
Matchfile(GO.link/src/net/file_stub.go) => false <nil>
Package net:
Processing package=net in net:
Walking from GO.link/src to GO.link/src/net/http
Processing net/http:
Matchfile(GO.link/src/net/http/jar.go) => true <nil>
Ignoring test code in cookie_test.go
Matchfile(GO.link/src/net/http/transport.go) => true <nil>
Matchfile(GO.link/src/net/http/header.go) => true <nil>
Ignoring test code in requestwrite_test.go
Ignoring test code in range_test.go
Ignoring test code in example_test.go
Ignoring test code in transfer_test.go
Matchfile(GO.link/src/net/http/server.go) => true <nil>
Ignoring test code in transport_internal_test.go
Ignoring test code in fs_test.go
Ignoring test code in http_test.go
Matchfile(GO.link/src/net/http/h2_bundle.go) => true <nil>
Ignoring test code in header_test.go
Matchfile(GO.link/src/net/http/response.go) => true <nil>
Ignoring test code in request_test.go
Matchfile(GO.link/src/net/http/request.go) => true <nil>
Ignoring test code in serve_test.go
Ignoring test code in response_test.go
Matchfile(GO.link/src/net/http/client.go) => true <nil>
Matchfile(GO.link/src/net/http/race.go) => false <nil>
Matchfile(GO.link/src/net/http/roundtrip_js.go) => false <nil>
Ignoring test code in responsewrite_test.go
Matchfile(GO.link/src/net/http/method.go) => true <nil>
Ignoring test code in clientserver_test.go
Matchfile(GO.link/src/net/http/http.go) => true <nil>
Ignoring test code in filetransport_test.go
Matchfile(GO.link/src/net/http/doc.go) => true <nil>
Matchfile(GO.link/src/net/http/fs.go) => true <nil>
Matchfile(GO.link/src/net/http/triv.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/net/http/transfer.go) => true <nil>
Matchfile(GO.link/src/net/http/cookie.go) => true <nil>
Ignoring test code in proxy_test.go
Matchfile(GO.link/src/net/http/sniff.go) => true <nil>
Ignoring test code in transport_test.go
Matchfile(GO.link/src/net/http/status.go) => true <nil>
Ignoring test code in sniff_test.go
Ignoring test code in client_test.go
Matchfile(GO.link/src/net/http/socks_bundle.go) => true <nil>
Ignoring test code in npn_test.go
Ignoring test code in readrequest_test.go
Matchfile(GO.link/src/net/http/roundtrip.go) => true <nil>
Ignoring test code in main_test.go
Matchfile(GO.link/src/net/http/filetransport.go) => true <nil>
Package http:
Processing package=http in net/http:
Walking from GO.link/src to GO.link/src/net/http/cgi
Processing net/http/cgi:
Ignoring test code in plan9_test.go
Ignoring test code in child_test.go
Ignoring test code in posix_test.go
Ignoring test code in host_test.go
Ignoring test code in matryoshka_test.go
Matchfile(GO.link/src/net/http/cgi/host.go) => true <nil>
Matchfile(GO.link/src/net/http/cgi/child.go) => true <nil>
Package cgi:
Processing package=cgi in net/http/cgi:
Excluding GO.link/src/net/http/cgi/testdata
Walking from GO.link/src to GO.link/src/net/http/cookiejar
Processing net/http/cookiejar:
Matchfile(GO.link/src/net/http/cookiejar/jar.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/cookiejar/punycode.go) => true <nil>
Ignoring test code in punycode_test.go
Ignoring test code in jar_test.go
Ignoring test code in dummy_publicsuffix_test.go
Package cookiejar:
Processing package=cookiejar in net/http/cookiejar:
Walking from GO.link/src to GO.link/src/net/http/fcgi
Processing net/http/fcgi:
Matchfile(GO.link/src/net/http/fcgi/child.go) => true <nil>
Matchfile(GO.link/src/net/http/fcgi/fcgi.go) => true <nil>
Ignoring test code in fcgi_test.go
Package fcgi:
Processing package=fcgi in net/http/fcgi:
Walking from GO.link/src to GO.link/src/net/http/httptest
Processing net/http/httptest:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/httptest/server.go) => true <nil>
Matchfile(GO.link/src/net/http/httptest/recorder.go) => true <nil>
Ignoring test code in httptest_test.go
Matchfile(GO.link/src/net/http/httptest/httptest.go) => true <nil>
Ignoring test code in recorder_test.go
Ignoring test code in server_test.go
Package httptest:
Processing package=httptest in net/http/httptest:
Walking from GO.link/src to GO.link/src/net/http/httptrace
Processing net/http/httptrace:
Ignoring test code in trace_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/httptrace/trace.go) => true <nil>
Package httptrace:
Processing package=httptrace in net/http/httptrace:
Walking from GO.link/src to GO.link/src/net/http/httputil
Processing net/http/httputil:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/httputil/httputil.go) => true <nil>
Matchfile(GO.link/src/net/http/httputil/persist.go) => true <nil>
Ignoring test code in dump_test.go
Matchfile(GO.link/src/net/http/httputil/dump.go) => true <nil>
Ignoring test code in reverseproxy_test.go
Matchfile(GO.link/src/net/http/httputil/reverseproxy.go) => true <nil>
Package httputil:
Processing package=httputil in net/http/httputil:
Excluding GO.link/src/net/http/internal
Walking from GO.link/src to GO.link/src/net/http/pprof
Processing net/http/pprof:
Matchfile(GO.link/src/net/http/pprof/pprof.go) => true <nil>
Ignoring test code in pprof_test.go
Package pprof:
Processing package=pprof in net/http/pprof:
Excluding GO.link/src/net/http/testdata
Excluding GO.link/src/net/internal
Walking from GO.link/src to GO.link/src/net/mail
Processing net/mail:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/mail/message.go) => true <nil>
Ignoring test code in message_test.go
Package mail:
Processing package=mail in net/mail:
Walking from GO.link/src to GO.link/src/net/rpc
Processing net/rpc:
Matchfile(GO.link/src/net/rpc/server.go) => true <nil>
Matchfile(GO.link/src/net/rpc/client.go) => true <nil>
Matchfile(GO.link/src/net/rpc/debug.go) => true <nil>
Ignoring test code in client_test.go
Ignoring test code in server_test.go
Package rpc:
Processing package=rpc in net/rpc:
Walking from GO.link/src to GO.link/src/net/rpc/jsonrpc
Processing net/rpc/jsonrpc:
Matchfile(GO.link/src/net/rpc/jsonrpc/server.go) => true <nil>
Matchfile(GO.link/src/net/rpc/jsonrpc/client.go) => true <nil>
Ignoring test code in all_test.go
Package jsonrpc:
Processing package=jsonrpc in net/rpc/jsonrpc:
Walking from GO.link/src to GO.link/src/net/smtp
Processing net/smtp:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/smtp/auth.go) => true <nil>
Ignoring test code in smtp_test.go
Matchfile(GO.link/src/net/smtp/smtp.go) => true <nil>
Package smtp:
Processing package=smtp in net/smtp:
Excluding GO.link/src/net/testdata
Walking from GO.link/src to GO.link/src/net/textproto
Processing net/textproto:
Matchfile(GO.link/src/net/textproto/header.go) => true <nil>
Matchfile(GO.link/src/net/textproto/textproto.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(GO.link/src/net/textproto/writer.go) => true <nil>
Matchfile(GO.link/src/net/textproto/pipeline.go) => true <nil>
Matchfile(GO.link/src/net/textproto/reader.go) => true <nil>
Ignoring test code in reader_test.go
Package textproto:
Processing package=textproto in net/textproto:
Walking from GO.link/src to GO.link/src/net/url
Processing net/url:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/url/url.go) => true <nil>
Ignoring test code in url_test.go
Package url:
Processing package=url in net/url:
Walking from GO.link/src to GO.link/src/os
Processing os:
Matchfile(GO.link/src/os/stat_openbsd.go) => false <nil>
Matchfile(GO.link/src/os/sticky_bsd.go) => true <nil>
Matchfile(GO.link/src/os/executable_procfs.go) => false <nil>
Ignoring test code in env_unix_test.go
Matchfile(GO.link/src/os/str.go) => true <nil>
Matchfile(GO.link/src/os/proc.go) => true <nil>
Matchfile(GO.link/src/os/error_plan9.go) => false <nil>
Matchfile(GO.link/src/os/pipe2_bsd.go) => false <nil>
Matchfile(GO.link/src/os/dir.go) => true <nil>
Matchfile(GO.link/src/os/env.go) => true <nil>
Matchfile(GO.link/src/os/types_unix.go) => true <nil>
Matchfile(GO.link/src/os/stat_dragonfly.go) => false <nil>
Matchfile(GO.link/src/os/error_windows.go) => false <nil>
Matchfile(GO.link/src/os/error.go) => true <nil>
Matchfile(GO.link/src/os/sys_windows.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in executable_test.go
Matchfile(GO.link/src/os/exec_posix.go) => true <nil>
Matchfile(GO.link/src/os/executable_darwin.go) => true <nil>
Matchfile(GO.link/src/os/wait_wait6.go) => false <nil>
Matchfile(GO.link/src/os/sticky_notbsd.go) => false <nil>
Matchfile(GO.link/src/os/stat_darwin.go) => true <nil>
Ignoring test code in fifo_test.go
Matchfile(GO.link/src/os/sys_plan9.go) => false <nil>
Matchfile(GO.link/src/os/executable_windows.go) => false <nil>
Matchfile(GO.link/src/os/file_unix.go) => true <nil>
Ignoring test code in os_unix_test.go
Matchfile(GO.link/src/os/getwd.go) => true <nil>
Matchfile(GO.link/src/os/types_windows.go) => false <nil>
Ignoring test code in env_test.go
Ignoring test code in path_test.go
Matchfile(GO.link/src/os/types.go) => true <nil>
Ignoring test code in timeout_test.go
Matchfile(GO.link/src/os/sys_bsd.go) => true <nil>
Matchfile(GO.link/src/os/types_plan9.go) => false <nil>
Matchfile(GO.link/src/os/stat_freebsd.go) => false <nil>
Matchfile(GO.link/src/os/executable_solaris.go) => false <nil>
Matchfile(GO.link/src/os/dir_plan9.go) => false <nil>
Ignoring test code in error_unix_test.go
Matchfile(GO.link/src/os/error_posix.go) => true <nil>
Matchfile(GO.link/src/os/stat_nacljs.go) => false <nil>
Ignoring test code in path_windows_test.go
Matchfile(GO.link/src/os/pipe_linux.go) => false <nil>
Matchfile(GO.link/src/os/dir_windows.go) => false <nil>
Matchfile(GO.link/src/os/path_unix.go) => true <nil>
Matchfile(GO.link/src/os/exec.go) => true <nil>
Matchfile(GO.link/src/os/sys_nacl.go) => false <nil>
Matchfile(GO.link/src/os/sys_solaris.go) => false <nil>
Matchfile(GO.link/src/os/exec_plan9.go) => false <nil>
Matchfile(GO.link/src/os/exec_unix.go) => true <nil>
Matchfile(GO.link/src/os/sys_linux.go) => false <nil>
Matchfile(GO.link/src/os/dir_unix.go) => true <nil>
Matchfile(GO.link/src/os/executable_path.go) => false <nil>
Matchfile(GO.link/src/os/file_plan9.go) => false <nil>
Matchfile(GO.link/src/os/stat_netbsd.go) => false <nil>
Matchfile(GO.link/src/os/sys_js.go) => false <nil>
Ignoring test code in os_test.go
Matchfile(GO.link/src/os/executable.go) => true <nil>
Matchfile(GO.link/src/os/error_unix.go) => true <nil>
Matchfile(GO.link/src/os/stat.go) => true <nil>
Ignoring test code in error_windows_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/os/path_windows.go) => false <nil>
Matchfile(GO.link/src/os/exec_windows.go) => false <nil>
Matchfile(GO.link/src/os/file.go) => true <nil>
Matchfile(GO.link/src/os/stat_linux.go) => false <nil>
Matchfile(GO.link/src/os/executable_freebsd.go) => false <nil>
Matchfile(GO.link/src/os/stat_solaris.go) => false <nil>
Matchfile(GO.link/src/os/stat_unix.go) => true <nil>
Matchfile(GO.link/src/os/wait_waitid.go) => false <nil>
Ignoring test code in pipe_test.go
Matchfile(GO.link/src/os/sys_unix.go) => true <nil>
Ignoring test code in os_windows_test.go
Ignoring test code in error_test.go
Matchfile(GO.link/src/os/sys.go) => true <nil>
Matchfile(GO.link/src/os/stat_windows.go) => false <nil>
Matchfile(GO.link/src/os/path.go) => true <nil>
Matchfile(GO.link/src/os/path_plan9.go) => false <nil>
Matchfile(GO.link/src/os/pipe_bsd.go) => true <nil>
Matchfile(GO.link/src/os/file_posix.go) => true <nil>
Matchfile(GO.link/src/os/stat_plan9.go) => false <nil>
Ignoring test code in export_windows_test.go
Matchfile(GO.link/src/os/wait_unimp.go) => true <nil>
Matchfile(GO.link/src/os/file_windows.go) => false <nil>
Matchfile(GO.link/src/os/executable_plan9.go) => false <nil>
Matchfile(GO.link/src/os/getwd_darwin.go) => true <nil>
Package os:
Processing package=os in os:
Walking from GO.link/src to GO.link/src/os/exec
Processing os/exec:
Matchfile(GO.link/src/os/exec/lp_windows.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in exec_test.go
Matchfile(GO.link/src/os/exec/lp_unix.go) => true <nil>
Ignoring test code in env_test.go
Matchfile(GO.link/src/os/exec/lp_js.go) => false <nil>
Matchfile(GO.link/src/os/exec/lp_plan9.go) => false <nil>
Matchfile(GO.link/src/os/exec/exec.go) => true <nil>
Matchfile(GO.link/src/os/exec/exec_unix.go) => true <nil>
Ignoring test code in lp_test.go
Matchfile(GO.link/src/os/exec/exec_windows.go) => false <nil>
Ignoring test code in lp_windows_test.go
Ignoring test code in internal_test.go
Ignoring test code in lp_unix_test.go
Ignoring test code in exec_posix_test.go
Package exec:
Processing package=exec in os/exec:
Walking from GO.link/src to GO.link/src/os/signal
Processing os/signal:
Matchfile(GO.link/src/os/signal/signal.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in signal_plan9_test.go
Ignoring test code in signal_windows_test.go
Matchfile(GO.link/src/os/signal/doc.go) => true <nil>
Ignoring test code in signal_test.go
Ignoring test code in signal_cgo_test.go
Matchfile(GO.link/src/os/signal/signal_plan9.go) => false <nil>
Matchfile(GO.link/src/os/signal/signal_unix.go) => true <nil>
Package signal:
Processing package=signal in os/signal:
Excluding GO.link/src/os/signal/internal
Walking from GO.link/src to GO.link/src/os/user
Processing os/user:
Matchfile(GO.link/src/os/user/lookup_android.go) => false <nil>
Matchfile(GO.link/src/os/user/user.go) => true <nil>
Ignoring test code in user_test.go
Matchfile(GO.link/src/os/user/lookup_unix.go) => false <nil>
Matchfile(GO.link/src/os/user/lookup_windows.go) => false <nil>
Matchfile(GO.link/src/os/user/getgrouplist_unix.go) => false <nil>
Ignoring test code in cgo_unix_test.go
Matchfile(GO.link/src/os/user/lookup.go) => true <nil>
Matchfile(GO.link/src/os/user/cgo_lookup_unix.go) => true <nil>
Matchfile(GO.link/src/os/user/listgroups_unix.go) => true <nil>
Matchfile(GO.link/src/os/user/getgrouplist_darwin.go) => true <nil>
Matchfile(GO.link/src/os/user/listgroups_solaris.go) => false <nil>
Matchfile(GO.link/src/os/user/lookup_stubs.go) => false <nil>
Matchfile(GO.link/src/os/user/lookup_plan9.go) => false <nil>
Ignoring test code in lookup_unix_test.go
Package user:
Processing package=user in os/user:
Walking from GO.link/src to GO.link/src/path
Processing path:
Ignoring test code in example_test.go
Ignoring test code in path_test.go
Ignoring test code in match_test.go
Matchfile(GO.link/src/path/match.go) => true <nil>
Matchfile(GO.link/src/path/path.go) => true <nil>
Package path:
Processing package=path in path:
Walking from GO.link/src to GO.link/src/path/filepath
Processing path/filepath:
Matchfile(GO.link/src/path/filepath/symlink.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in path_test.go
Ignoring test code in example_unix_test.go
Matchfile(GO.link/src/path/filepath/symlink_windows.go) => false <nil>
Ignoring test code in example_unix_walk_test.go
Ignoring test code in path_windows_test.go
Matchfile(GO.link/src/path/filepath/path_unix.go) => true <nil>
Ignoring test code in match_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/path/filepath/path_windows.go) => false <nil>
Matchfile(GO.link/src/path/filepath/symlink_unix.go) => true <nil>
Matchfile(GO.link/src/path/filepath/match.go) => true <nil>
Matchfile(GO.link/src/path/filepath/path.go) => true <nil>
Matchfile(GO.link/src/path/filepath/path_plan9.go) => false <nil>
Ignoring test code in export_windows_test.go
Package filepath:
Processing package=filepath in path/filepath:
Walking from GO.link/src to GO.link/src/plugin
Processing plugin:
Matchfile(GO.link/src/plugin/plugin_stubs.go) => false <nil>
Matchfile(GO.link/src/plugin/plugin_dlopen.go) => true <nil>
Matchfile(GO.link/src/plugin/plugin.go) => true <nil>
Package plugin:
Processing package=plugin in plugin:
Walking from GO.link/src to GO.link/src/reflect
Processing reflect:
Matchfile(GO.link/src/reflect/swapper.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/reflect/type.go) => true <nil>
Matchfile(GO.link/src/reflect/deepequal.go) => true <nil>
Ignoring test code in set_test.go
Ignoring test code in all_test.go
Ignoring test code in export_test.go
Ignoring test code in tostring_test.go
Matchfile(GO.link/src/reflect/makefunc.go) => true <nil>
Matchfile(GO.link/src/reflect/value.go) => true <nil>
Package reflect:
Processing package=reflect in reflect:
Walking from GO.link/src to GO.link/src/regexp
Processing regexp:
Ignoring test code in example_test.go
Ignoring test code in exec_test.go
Ignoring test code in onepass_test.go
Matchfile(GO.link/src/regexp/exec.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(GO.link/src/regexp/backtrack.go) => true <nil>
Ignoring test code in exec2_test.go
Matchfile(GO.link/src/regexp/regexp.go) => true <nil>
Matchfile(GO.link/src/regexp/onepass.go) => true <nil>
Ignoring test code in find_test.go
Package regexp:
Processing package=regexp in regexp:
Walking from GO.link/src to GO.link/src/regexp/syntax
Processing regexp/syntax:
Matchfile(GO.link/src/regexp/syntax/prog.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/simplify.go) => true <nil>
Ignoring test code in prog_test.go
Ignoring test code in parse_test.go
Ignoring test code in simplify_test.go
Matchfile(GO.link/src/regexp/syntax/doc.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/compile.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/regexp.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/perl_groups.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/op_string.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/parse.go) => true <nil>
Package syntax:
Processing package=syntax in regexp/syntax:
Excluding GO.link/src/regexp/testdata
Walking from GO.link/src to GO.link/src/runtime
Processing runtime:
Matchfile(GO.link/src/runtime/netpoll_stub.go) => false <nil>
Ignoring test code in export_mmap_test.go
Ignoring test code in fastlog2_test.go
Matchfile(GO.link/src/runtime/proc.go) => true <nil>
Matchfile(GO.link/src/runtime/lock_js.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/net_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_elf64.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/syscall_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/mbitmap.go) => true <nil>
Matchfile(GO.link/src/runtime/os_darwin.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/map_faststr.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/slice.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_amd64x.go) => true <nil>
Matchfile(GO.link/src/runtime/compiler.go) => true <nil>
Ignoring test code in memmove_linux_amd64_test.go
Ignoring test code in chan_test.go
Matchfile(GO.link/src/runtime/signal_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/error.go) => true <nil>
Matchfile(GO.link/src/runtime/symtab.go) => true <nil>
Matchfile(GO.link/src/runtime/sys_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/map_fast32.go) => true <nil>
Matchfile(GO.link/src/runtime/os_linux_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/lfstack_32bit.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/lfstack.go) => true <nil>
Matchfile(GO.link/src/runtime/env_posix.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/runtime/mwbbuf.go) => true <nil>
Ignoring test code in malloc_test.go
Matchfile(GO.link/src/runtime/profbuf.go) => true <nil>
Matchfile(GO.link/src/runtime/os2_nacl.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_plan9_amd64.go) => false <nil>
Ignoring test code in runtime_unix_test.go
Ignoring test code in slice_test.go
Matchfile(GO.link/src/runtime/stubs_android.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_nacl_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd_noauxv.go) => false <nil>
Ignoring test code in mfinal_test.go
Matchfile(GO.link/src/runtime/defs_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_plan9_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/os2_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/os3_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/mfinal.go) => true <nil>
Matchfile(GO.link/src/runtime/trace.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_darwin.go) => true <nil>
Matchfile(GO.link/src/runtime/defs3_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_bsd.go) => false <nil>
Matchfile(GO.link/src/runtime/defs2_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/runtime2.go) => true <nil>
Matchfile(GO.link/src/runtime/mem_darwin.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_linux_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/atomic_pointer.go) => true <nil>
Matchfile(GO.link/src/runtime/time.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_nacl_arm.go) => false <nil>
Ignoring test code in env_test.go
Matchfile(GO.link/src/runtime/alg.go) => true <nil>
Ignoring test code in profbuf_test.go
Matchfile(GO.link/src/runtime/defs_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_darwin_arm64.go) => false <nil>
Ignoring test code in softfloat64_test.go
Matchfile(GO.link/src/runtime/stubs_nonlinux.go) => true <nil>
Matchfile(GO.link/src/runtime/defs1_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/proflabel.go) => true <nil>
Matchfile(GO.link/src/runtime/msan.go) => false <nil>
Matchfile(GO.link/src/runtime/mgcsweep.go) => true <nil>
Matchfile(GO.link/src/runtime/mgclarge.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_mips64x.go) => false <nil>
Ignoring test code in numcpu_freebsd_test.go
Matchfile(GO.link/src/runtime/sema.go) => true <nil>
Matchfile(GO.link/src/runtime/unaligned2.go) => false <nil>
Matchfile(GO.link/src/runtime/runtime.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/type.go) => true <nil>
Matchfile(GO.link/src/runtime/os_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/auxv_none.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_plan9_386.go) => false <nil>
Matchfile(GO.link/src/runtime/env_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_linux.go) => false <nil>
Ignoring test code in norace_linux_test.go
Ignoring test code in gcinfo_test.go
Matchfile(GO.link/src/runtime/mem_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/netpoll_kqueue.go) => true <nil>
Matchfile(GO.link/src/runtime/fastlog2table.go) => true <nil>
Matchfile(GO.link/src/runtime/mcache.go) => true <nil>
Ignoring test code in proc_runtime_test.go
Matchfile(GO.link/src/runtime/stubs32.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_darwin.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_x86.go) => true <nil>
Matchfile(GO.link/src/runtime/vdso_in_none.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_linux_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_nacl.go) => false <nil>
Matchfile(GO.link/src/runtime/lock_sema.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/iface.go) => true <nil>
Ignoring test code in string_test.go
Matchfile(GO.link/src/runtime/cpuflags_amd64.go) => true <nil>
Matchfile(GO.link/src/runtime/cgocall.go) => true <nil>
Matchfile(GO.link/src/runtime/os_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_be64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_novdso.go) => false <nil>
Matchfile(GO.link/src/runtime/os2_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo_ppc64x.go) => false <nil>
Ignoring test code in lfstack_test.go
Matchfile(GO.link/src/runtime/defs_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/runtime/mcentral.go) => true <nil>
Matchfile(GO.link/src/runtime/syscall_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_wasm.go) => false <nil>
Matchfile(GO.link/src/runtime/os_nacl.go) => false <nil>
Ignoring test code in map_benchmark_test.go
Matchfile(GO.link/src/runtime/race.go) => false <nil>
Matchfile(GO.link/src/runtime/utf8.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/runtime/hash64.go) => true <nil>
Matchfile(GO.link/src/runtime/chan.go) => true <nil>
Matchfile(GO.link/src/runtime/mgcmark.go) => true <nil>
Matchfile(GO.link/src/runtime/traceback.go) => true <nil>
Matchfile(GO.link/src/runtime/panic.go) => true <nil>
Ignoring test code in rand_test.go
Matchfile(GO.link/src/runtime/defs_linux_386.go) => false <nil>
Matchfile(GO.link/src/runtime/sigaction.go) => false <nil>
Matchfile(GO.link/src/runtime/float.go) => true <nil>
Matchfile(GO.link/src/runtime/heapdump.go) => true <nil>
Ignoring test code in crash_nonunix_test.go
Matchfile(GO.link/src/runtime/os_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/write_err_android.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_sighandler.go) => true <nil>
Matchfile(GO.link/src/runtime/os_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/hash32.go) => false <nil>
Ignoring test code in proc_test.go
Matchfile(GO.link/src/runtime/defs1_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/sigtab_linux_generic.go) => false <nil>
Matchfile(GO.link/src/runtime/typekind.go) => true <nil>
Matchfile(GO.link/src/runtime/sizeclasses.go) => true <nil>
Ignoring test code in runtime_mmap_test.go
Matchfile(GO.link/src/runtime/race0.go) => true <nil>
Matchfile(GO.link/src/runtime/sys_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/plugin.go) => true <nil>
Ignoring test code in hash_test.go
Matchfile(GO.link/src/runtime/vdso_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/msize.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_netbsd.go) => false <nil>
Ignoring test code in crash_cgo_test.go
Matchfile(GO.link/src/runtime/timestub2.go) => false <nil>
Matchfile(GO.link/src/runtime/debugcall.go) => true <nil>
Matchfile(GO.link/src/runtime/zcallback_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_arm_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/defs1_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/os2_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/netpoll_epoll.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs_x86.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_arm.go) => false <nil>
Ignoring test code in rwmutex_test.go
Ignoring test code in crash_test.go
Ignoring test code in symtab_test.go
Matchfile(GO.link/src/runtime/debug.go) => true <nil>
Ignoring test code in export_unix_test.go
Matchfile(GO.link/src/runtime/os_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/mstats.go) => true <nil>
Matchfile(GO.link/src/runtime/timeasm.go) => false <nil>
Matchfile(GO.link/src/runtime/print.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_linux_mips64x.go) => false <nil>
Matchfile(GO.link/src/runtime/os_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_nonppc64x.go) => true <nil>
Matchfile(GO.link/src/runtime/stack.go) => true <nil>
Matchfile(GO.link/src/runtime/vdso_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_windows_386.go) => false <nil>
Matchfile(GO.link/src/runtime/softfloat64.go) => true <nil>
Matchfile(GO.link/src/runtime/defs1_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/cputicks.go) => true <nil>
Matchfile(GO.link/src/runtime/netpoll_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/timestub.go) => true <nil>
Matchfile(GO.link/src/runtime/mkduff.go) => false <nil>
Matchfile(GO.link/src/runtime/os_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_freebsd.go) => false <nil>
Ignoring test code in map_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/runtime/mfixalloc.go) => true <nil>
Matchfile(GO.link/src/runtime/os_nonopenbsd.go) => true <nil>
Matchfile(GO.link/src/runtime/unaligned1.go) => true <nil>
Ignoring test code in callers_test.go
Matchfile(GO.link/src/runtime/mksizeclasses.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_plan9_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_mips64x.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_openbsd_amd64.go) => false <nil>
Ignoring test code in crash_unix_test.go
Matchfile(GO.link/src/runtime/signal_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_linux_ppc64le.go) => false <nil>
Ignoring test code in export_debug_test.go
Matchfile(GO.link/src/runtime/syscall2_solaris.go) => false <nil>
Ignoring test code in futex_test.go
Ignoring test code in stack_test.go
Matchfile(GO.link/src/runtime/sys_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/os_netbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_darwin_amd64.go) => true <nil>
Ignoring test code in vlop_arm_test.go
Matchfile(GO.link/src/runtime/signal_openbsd_arm.go) => false <nil>
Ignoring test code in closure_test.go
Ignoring test code in vdso_linux_test.go
Matchfile(GO.link/src/runtime/rwmutex.go) => true <nil>
Ignoring test code in export_linux_test.go
Ignoring test code in iface_test.go
Matchfile(GO.link/src/runtime/signal_mips64x.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/cgocallback.go) => true <nil>
Matchfile(GO.link/src/runtime/wincallback.go) => false <nil>
Matchfile(GO.link/src/runtime/map.go) => true <nil>
Matchfile(GO.link/src/runtime/vdso_linux_386.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo.go) => true <nil>
Ignoring test code in complex_test.go
Matchfile(GO.link/src/runtime/signal_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/mbarrier.go) => true <nil>
Matchfile(GO.link/src/runtime/sigqueue.go) => true <nil>
Matchfile(GO.link/src/runtime/os_android.go) => false <nil>
Matchfile(GO.link/src/runtime/lock_futex.go) => false <nil>
Ignoring test code in gc_test.go
Matchfile(GO.link/src/runtime/malloc.go) => true <nil>
Matchfile(GO.link/src/runtime/netpoll_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs3.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_darwin_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd2.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/msan0.go) => true <nil>
Matchfile(GO.link/src/runtime/lfstack_64bit.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/netpoll.go) => true <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(GO.link/src/runtime/cgo_sigaction.go) => false <nil>
Matchfile(GO.link/src/runtime/fastlog2.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/relax_stub.go) => true <nil>
Matchfile(GO.link/src/runtime/os3_solaris.go) => false <nil>
Ignoring test code in runtime_linux_test.go
Ignoring test code in runtime_test.go
Matchfile(GO.link/src/runtime/vdso_freebsd_x86.go) => false <nil>
Matchfile(GO.link/src/runtime/sigqueue_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/complex.go) => true <nil>
Ignoring test code in runtime-gdb_test.go
Matchfile(GO.link/src/runtime/defs_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/runtime1.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_linux_386.go) => false <nil>
Matchfile(GO.link/src/runtime/mheap.go) => true <nil>
Matchfile(GO.link/src/runtime/rdebug.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_nacl_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_generic.go) => false <nil>
Matchfile(GO.link/src/runtime/os_js.go) => false <nil>
Matchfile(GO.link/src/runtime/os2_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/netpoll_fake.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/defs1_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_js.go) => false <nil>
Matchfile(GO.link/src/runtime/cgocheck.go) => true <nil>
Matchfile(GO.link/src/runtime/os_linux_noauxv.go) => false <nil>
Matchfile(GO.link/src/runtime/map_fast64.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_netbsd.go) => false <nil>
Ignoring test code in export_windows_test.go
Matchfile(GO.link/src/runtime/write_err.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_unix.go) => true <nil>
Matchfile(GO.link/src/runtime/mgc.go) => true <nil>
Matchfile(GO.link/src/runtime/mkfastlog2table.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/mprof.go) => true <nil>
Ignoring test code in sizeof_test.go
Matchfile(GO.link/src/runtime/defs_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/extern.go) => true <nil>
Ignoring test code in runtime-lldb_test.go
Matchfile(GO.link/src/runtime/defs_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/vlrt.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo_mmap.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_mips64x.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/sigtab_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_darwin.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/string.go) => true <nil>
Ignoring test code in norace_test.go
Matchfile(GO.link/src/runtime/sys_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/mgcsweepbuf.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_darwin_386.go) => false <nil>
Matchfile(GO.link/src/runtime/cpuprof.go) => true <nil>
Matchfile(GO.link/src/runtime/stubs2.go) => false <nil>
Ignoring test code in memmove_test.go
Matchfile(GO.link/src/runtime/select.go) => true <nil>
Ignoring test code in chanbarrier_test.go
Ignoring test code in debug_test.go
Matchfile(GO.link/src/runtime/mgcwork.go) => true <nil>
Ignoring test code in export_arm_test.go
Matchfile(GO.link/src/runtime/signal_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_elf32.go) => false <nil>
Matchfile(GO.link/src/runtime/os_dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/os_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/mmap.go) => false <nil>
Ignoring test code in export_futex_test.go
Package runtime:
Processing package=runtime in runtime:
Walking from GO.link/src to GO.link/src/runtime/cgo
Processing runtime/cgo:
Matchfile(GO.link/src/runtime/cgo/openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/iscgo.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/netbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/signal_darwin_armx.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/sigaction.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/setenv.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/callbacks.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/cgo.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/callbacks_traceback.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/mmap.go) => false <nil>
Package cgo:
Processing package=cgo in runtime/cgo:
Walking from GO.link/src to GO.link/src/runtime/debug
Processing runtime/debug:
Ignoring test code in garbage_test.go
Matchfile(GO.link/src/runtime/debug/stack.go) => true <nil>
Matchfile(GO.link/src/runtime/debug/stubs.go) => true <nil>
Ignoring test code in stack_test.go
Matchfile(GO.link/src/runtime/debug/garbage.go) => true <nil>
Ignoring test code in heapdump_test.go
Package debug:
Processing package=debug in runtime/debug:
Excluding GO.link/src/runtime/internal
Walking from GO.link/src to GO.link/src/runtime/msan
Processing runtime/msan:
Matchfile(GO.link/src/runtime/msan/msan.go) => false <nil>
Walking from GO.link/src to GO.link/src/runtime/pprof
Processing runtime/pprof:
Matchfile(GO.link/src/runtime/pprof/pprof.go) => true <nil>
Ignoring test code in mprof_test.go
Matchfile(GO.link/src/runtime/pprof/runtime.go) => true <nil>
Ignoring test code in label_test.go
Matchfile(GO.link/src/runtime/pprof/protomem.go) => true <nil>
Matchfile(GO.link/src/runtime/pprof/label.go) => true <nil>
Matchfile(GO.link/src/runtime/pprof/elf.go) => true <nil>
Ignoring test code in proto_test.go
Matchfile(GO.link/src/runtime/pprof/map.go) => true <nil>
Ignoring test code in runtime_test.go
Ignoring test code in pprof_test.go
Matchfile(GO.link/src/runtime/pprof/proto.go) => true <nil>
Matchfile(GO.link/src/runtime/pprof/protobuf.go) => true <nil>
Ignoring test code in protomem_test.go
Package pprof:
Processing package=pprof in runtime/pprof:
Excluding GO.link/src/runtime/pprof/internal
Excluding GO.link/src/runtime/pprof/testdata
Walking from GO.link/src to GO.link/src/runtime/race
Processing runtime/race:
Ignoring test code in race_unix_test.go
Ignoring test code in race_test.go
Ignoring test code in sched_test.go
Matchfile(GO.link/src/runtime/race/race.go) => false <nil>
Matchfile(GO.link/src/runtime/race/doc.go) => true <nil>
Ignoring test code in race_linux_test.go
Ignoring test code in race_windows_test.go
Ignoring test code in output_test.go
Package race:
Processing package=race in runtime/race:
Excluding GO.link/src/runtime/race/testdata
Excluding GO.link/src/runtime/testdata
Walking from GO.link/src to GO.link/src/runtime/trace
Processing runtime/trace:
Ignoring test code in trace_test.go
Ignoring test code in example_test.go
Ignoring test code in annotation_test.go
Matchfile(GO.link/src/runtime/trace/annotation.go) => true <nil>
Matchfile(GO.link/src/runtime/trace/trace.go) => true <nil>
Ignoring test code in trace_stack_test.go
Package trace:
Processing package=trace in runtime/trace:
Walking from GO.link/src to GO.link/src/sort
Processing sort:
Ignoring test code in example_search_test.go
Matchfile(GO.link/src/sort/slice.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/sort/zfuncversion.go) => true <nil>
Ignoring test code in example_interface_test.go
Matchfile(GO.link/src/sort/sort.go) => true <nil>
Matchfile(GO.link/src/sort/genzfunc.go) => false <nil>
Ignoring test code in example_wrapper_test.go
Ignoring test code in sort_test.go
Matchfile(GO.link/src/sort/search.go) => true <nil>
Ignoring test code in example_keys_test.go
Ignoring test code in search_test.go
Ignoring test code in export_test.go
Ignoring test code in example_multi_test.go
Package sort:
Processing package=sort in sort:
Walking from GO.link/src to GO.link/src/strconv
Processing strconv:
Ignoring test code in atof_test.go
Matchfile(GO.link/src/strconv/extfloat.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in quote_test.go
Matchfile(GO.link/src/strconv/ftoa.go) => true <nil>
Matchfile(GO.link/src/strconv/decimal.go) => true <nil>
Ignoring test code in fp_test.go
Matchfile(GO.link/src/strconv/quote.go) => true <nil>
Matchfile(GO.link/src/strconv/makeisprint.go) => false <nil>
Matchfile(GO.link/src/strconv/doc.go) => true <nil>
Matchfile(GO.link/src/strconv/itoa.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/strconv/atof.go) => true <nil>
Matchfile(GO.link/src/strconv/atob.go) => true <nil>
Ignoring test code in atoi_test.go
Ignoring test code in itoa_test.go
Ignoring test code in internal_test.go
Matchfile(GO.link/src/strconv/isprint.go) => true <nil>
Ignoring test code in atob_test.go
Ignoring test code in decimal_test.go
Matchfile(GO.link/src/strconv/atoi.go) => true <nil>
Ignoring test code in strconv_test.go
Ignoring test code in ftoa_test.go
Package strconv:
Processing package=strconv in strconv:
Excluding GO.link/src/strconv/testdata
Walking from GO.link/src to GO.link/src/strings
Processing strings:
Matchfile(GO.link/src/strings/strings_decl.go) => true <nil>
Ignoring test code in replace_test.go
Ignoring test code in compare_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/strings/search.go) => true <nil>
Ignoring test code in search_test.go
Ignoring test code in export_test.go
Ignoring test code in strings_test.go
Matchfile(GO.link/src/strings/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/strings/builder.go) => true <nil>
Matchfile(GO.link/src/strings/replace.go) => true <nil>
Matchfile(GO.link/src/strings/compare.go) => true <nil>
Matchfile(GO.link/src/strings/strings.go) => true <nil>
Ignoring test code in builder_test.go
Package strings:
Processing package=strings in strings:
Walking from GO.link/src to GO.link/src/sync
Processing sync:
Ignoring test code in map_bench_test.go
Ignoring test code in example_pool_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/sync/runtime.go) => true <nil>
Ignoring test code in once_test.go
Ignoring test code in mutex_test.go
Ignoring test code in rwmutex_test.go
Ignoring test code in map_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/sync/once.go) => true <nil>
Matchfile(GO.link/src/sync/cond.go) => true <nil>
Matchfile(GO.link/src/sync/rwmutex.go) => true <nil>
Matchfile(GO.link/src/sync/map.go) => true <nil>
Ignoring test code in runtime_sema_test.go
Ignoring test code in pool_test.go
Matchfile(GO.link/src/sync/mutex.go) => true <nil>
Matchfile(GO.link/src/sync/pool.go) => true <nil>
Ignoring test code in waitgroup_test.go
Ignoring test code in map_reference_test.go
Ignoring test code in cond_test.go
Matchfile(GO.link/src/sync/waitgroup.go) => true <nil>
Package sync:
Processing package=sync in sync:
Walking from GO.link/src to GO.link/src/sync/atomic
Processing sync/atomic:
Ignoring test code in example_test.go
Ignoring test code in value_test.go
Matchfile(GO.link/src/sync/atomic/doc.go) => true <nil>
Ignoring test code in atomic_test.go
Matchfile(GO.link/src/sync/atomic/value.go) => true <nil>
Package atomic:
Processing package=atomic in sync/atomic:
Walking from GO.link/src to GO.link/src/syscall
Processing syscall:
Matchfile(GO.link/src/syscall/dirent.go) => true <nil>
Matchfile(GO.link/src/syscall/types_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_getwd_bsd.go) => false <nil>
Matchfile(GO.link/src/syscall/str.go) => true <nil>
Ignoring test code in exec_solaris_test.go
Matchfile(GO.link/src/syscall/zsyscall_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_solaris.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_amd64.go) => false <nil>
Ignoring test code in syscall_unix_test.go
Matchfile(GO.link/src/syscall/zsysnum_openbsd_386.go) => false <nil>
Ignoring test code in mmap_unix_test.go
Matchfile(GO.link/src/syscall/zsyscall_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/setuidgid_32_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/env_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_windows_amd64.go) => false <nil>
Ignoring test code in creds_test.go
Matchfile(GO.link/src/syscall/syscall_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/fs_js.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/types_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_openbsd_arm.go) => false <nil>
Ignoring test code in syscall_plan9_test.go
Matchfile(GO.link/src/syscall/syscall_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_amd64.go) => false <nil>
Ignoring test code in exec_linux_test.go
Matchfile(GO.link/src/syscall/zerrors_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/bpf_bsd.go) => true <nil>
Matchfile(GO.link/src/syscall/route_netbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/tables_nacljs.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/types_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_netbsd_arm.go) => false <nil>
Ignoring test code in syscall_bsd_test.go
Matchfile(GO.link/src/syscall/zsysnum_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/msan.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_bsd.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysctl_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/types_dragonfly.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_plan9_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/env_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_nacl_386.go) => false <nil>
Matchfile(GO.link/src/syscall/dll_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/dir_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/timestruct.go) => true <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/types_solaris.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/types_darwin.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_js.go) => false <nil>
Matchfile(GO.link/src/syscall/net.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/sockcmsg_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/netlink_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/env_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/route_freebsd_32bit.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_bsd.go) => true <nil>
Matchfile(GO.link/src/syscall/exec_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/const_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/endian_big.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/security_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/route_freebsd.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/lsf_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/route_darwin.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/mksyscall_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/route_dragonfly.go) => false <nil>
Matchfile(GO.link/src/syscall/flock.go) => true <nil>
Matchfile(GO.link/src/syscall/flock_linux_32bit.go) => false <nil>
Ignoring test code in export_unix_test.go
Matchfile(GO.link/src/syscall/net_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/pwd_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/route_bsd.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/types_freebsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_plan9_arm.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/syscall/zsysnum_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/net_js.go) => false <nil>
Ignoring test code in exec_unix_test.go
Matchfile(GO.link/src/syscall/forkpipe2.go) => false <nil>
Matchfile(GO.link/src/syscall/types_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/mkpost.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_plan9_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/fd_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_arm64.go) => false <nil>
Ignoring test code in export_linux_test.go
Matchfile(GO.link/src/syscall/syscall_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/route_freebsd_64bit.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_dragonfly.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/unzip_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/msan0.go) => true <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_386.go) => false <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(GO.link/src/syscall/syscall_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_arm.go) => false <nil>
Ignoring test code in syscall_test.go
Matchfile(GO.link/src/syscall/syscall_linux_ppc64x.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_mips64x.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_solaris.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/route_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/setuidgid_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_nacl_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/fs_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/forkpipe.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_386.go) => false <nil>
Ignoring test code in syscall_linux_test.go
Matchfile(GO.link/src/syscall/syscall_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/types_netbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/endian_little.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/types_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/sockcmsg_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/errors_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_freebsd_amd64.go) => false <nil>
Package syscall:
Processing package=syscall in syscall:
Walking from GO.link/src to GO.link/src/syscall/js
Processing syscall/js:
Matchfile(GO.link/src/syscall/js/callback.go) => false <nil>
Ignoring test code in js_test.go
Matchfile(GO.link/src/syscall/js/typedarray.go) => false <nil>
Matchfile(GO.link/src/syscall/js/js.go) => false <nil>
Walking from GO.link/src to GO.link/src/testing
Processing testing:
Ignoring test code in helper_test.go
Matchfile(GO.link/src/testing/benchmark.go) => true <nil>
Ignoring test code in sub_test.go
Matchfile(GO.link/src/testing/cover.go) => true <nil>
Matchfile(GO.link/src/testing/allocs.go) => true <nil>
Ignoring test code in helperfuncs_test.go
Ignoring test code in allocs_test.go
Ignoring test code in testing_test.go
Ignoring test code in match_test.go
Matchfile(GO.link/src/testing/example.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/testing/match.go) => true <nil>
Ignoring test code in benchmark_test.go
Matchfile(GO.link/src/testing/testing.go) => true <nil>
Package testing:
Processing package=testing in testing:
Excluding GO.link/src/testing/internal
Walking from GO.link/src to GO.link/src/testing/iotest
Processing testing/iotest:
Matchfile(GO.link/src/testing/iotest/logger.go) => true <nil>
Matchfile(GO.link/src/testing/iotest/writer.go) => true <nil>
Matchfile(GO.link/src/testing/iotest/reader.go) => true <nil>
Package iotest:
Processing package=iotest in testing/iotest:
Walking from GO.link/src to GO.link/src/testing/quick
Processing testing/quick:
Ignoring test code in quick_test.go
Matchfile(GO.link/src/testing/quick/quick.go) => true <nil>
Package quick:
Processing package=quick in testing/quick:
Walking from GO.link/src to GO.link/src/text
Processing text:
Walking from GO.link/src to GO.link/src/text/scanner
Processing text/scanner:
Ignoring test code in example_test.go
Matchfile(GO.link/src/text/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Package scanner:
Processing package=scanner in text/scanner:
Walking from GO.link/src to GO.link/src/text/tabwriter
Processing text/tabwriter:
Ignoring test code in tabwriter_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/text/tabwriter/tabwriter.go) => true <nil>
Package tabwriter:
Processing package=tabwriter in text/tabwriter:
Walking from GO.link/src to GO.link/src/text/template
Processing text/template:
Matchfile(GO.link/src/text/template/option.go) => true <nil>
Ignoring test code in examplefunc_test.go
Ignoring test code in examplefiles_test.go
Ignoring test code in example_test.go
Ignoring test code in exec_test.go
Ignoring test code in multi_test.go
Matchfile(GO.link/src/text/template/exec.go) => true <nil>
Matchfile(GO.link/src/text/template/template.go) => true <nil>
Matchfile(GO.link/src/text/template/helper.go) => true <nil>
Matchfile(GO.link/src/text/template/doc.go) => true <nil>
Matchfile(GO.link/src/text/template/funcs.go) => true <nil>
Package template:
Processing package=template in text/template:
Walking from GO.link/src to GO.link/src/text/template/parse
Processing text/template/parse:
Ignoring test code in lex_test.go
Matchfile(GO.link/src/text/template/parse/lex.go) => true <nil>
Ignoring test code in parse_test.go
Matchfile(GO.link/src/text/template/parse/node.go) => true <nil>
Matchfile(GO.link/src/text/template/parse/parse.go) => true <nil>
Package parse:
Processing package=parse in text/template/parse:
Excluding GO.link/src/text/template/testdata
Walking from GO.link/src to GO.link/src/time
Processing time:
Ignoring test code in zoneinfo_windows_test.go
Matchfile(GO.link/src/time/sys_windows.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in zoneinfo_android_test.go
Matchfile(GO.link/src/time/zoneinfo_android.go) => false <nil>
Ignoring test code in sleep_test.go
Matchfile(GO.link/src/time/sys_plan9.go) => false <nil>
Ignoring test code in zoneinfo_test.go
Matchfile(GO.link/src/time/time.go) => true <nil>
Matchfile(GO.link/src/time/zoneinfo_plan9.go) => false <nil>
Ignoring test code in format_test.go
Matchfile(GO.link/src/time/format.go) => true <nil>
Matchfile(GO.link/src/time/zoneinfo_unix.go) => true <nil>
Ignoring test code in mono_test.go
Matchfile(GO.link/src/time/genzabbrs.go) => false <nil>
Matchfile(GO.link/src/time/zoneinfo.go) => true <nil>
Matchfile(GO.link/src/time/zoneinfo_windows.go) => false <nil>
Matchfile(GO.link/src/time/zoneinfo_abbrs_windows.go) => false <nil>
Matchfile(GO.link/src/time/zoneinfo_ios.go) => false <nil>
Matchfile(GO.link/src/time/sleep.go) => true <nil>
Matchfile(GO.link/src/time/tick.go) => true <nil>
Ignoring test code in tick_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/time/zoneinfo_read.go) => true <nil>
Ignoring test code in internal_test.go
Matchfile(GO.link/src/time/sys_unix.go) => true <nil>
Ignoring test code in export_android_test.go
Ignoring test code in time_test.go
Ignoring test code in export_windows_test.go
Package time:
Processing package=time in time:
Walking from GO.link/src to GO.link/src/unicode
Processing unicode:
Ignoring test code in example_test.go
Ignoring test code in graphic_test.go
Matchfile(GO.link/src/unicode/maketables.go) => false <nil>
Ignoring test code in script_test.go
Matchfile(GO.link/src/unicode/digit.go) => true <nil>
Matchfile(GO.link/src/unicode/tables.go) => true <nil>
Matchfile(GO.link/src/unicode/letter.go) => true <nil>
Ignoring test code in digit_test.go
Matchfile(GO.link/src/unicode/graphic.go) => true <nil>
Matchfile(GO.link/src/unicode/casetables.go) => true <nil>
Ignoring test code in letter_test.go
Package unicode:
Processing package=unicode in unicode:
Walking from GO.link/src to GO.link/src/unicode/utf16
Processing unicode/utf16:
Ignoring test code in utf16_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/unicode/utf16/utf16.go) => true <nil>
Package utf16:
Processing package=utf16 in unicode/utf16:
Walking from GO.link/src to GO.link/src/unicode/utf8
Processing unicode/utf8:
Ignoring test code in example_test.go
Ignoring test code in utf8_test.go
Matchfile(GO.link/src/unicode/utf8/utf8.go) => true <nil>
Package utf8:
Processing package=utf8 in unicode/utf8:
Walking from GO.link/src to GO.link/src/unsafe
Processing unsafe:
Matchfile(GO.link/src/unsafe/unsafe.go) => true <nil>
Package unsafe:
Processing package=unsafe in unsafe:
Excluding GO.link/src/vendor
TYPE aes.KeySizeError:
  GO.link/src/crypto/aes/cipher.go
TYPE ascii85.CorruptInputError:
  GO.link/src/encoding/ascii85/ascii85.go
TYPE asn1.BitString:
  GO.link/src/encoding/asn1/asn1.go
TYPE asn1.Enumerated:
  GO.link/src/encoding/asn1/asn1.go
TYPE asn1.Flag:
  GO.link/src/encoding/asn1/asn1.go
TYPE asn1.ObjectIdentifier:
  GO.link/src/encoding/asn1/asn1.go
TYPE asn1.RawContent:
  GO.link/src/encoding/asn1/asn1.go
TYPE asn1.RawValue:
  GO.link/src/encoding/asn1/asn1.go
TYPE asn1.StructuralError:
  GO.link/src/encoding/asn1/asn1.go
TYPE asn1.SyntaxError:
  GO.link/src/encoding/asn1/asn1.go
TYPE ast.ArrayType:
  GO.link/src/go/ast/ast.go
TYPE ast.AssignStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.BadDecl:
  GO.link/src/go/ast/ast.go
TYPE ast.BadExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.BadStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.BasicLit:
  GO.link/src/go/ast/ast.go
TYPE ast.BinaryExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.BlockStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.BranchStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.CallExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.CaseClause:
  GO.link/src/go/ast/ast.go
TYPE ast.ChanDir:
  GO.link/src/go/ast/ast.go
TYPE ast.ChanType:
  GO.link/src/go/ast/ast.go
TYPE ast.CommClause:
  GO.link/src/go/ast/ast.go
TYPE ast.Comment:
  GO.link/src/go/ast/ast.go
TYPE ast.CommentGroup:
  GO.link/src/go/ast/ast.go
TYPE ast.CommentMap:
  GO.link/src/go/ast/commentmap.go
TYPE ast.CompositeLit:
  GO.link/src/go/ast/ast.go
TYPE ast.Decl:
  GO.link/src/go/ast/ast.go
TYPE ast.DeclStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.DeferStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.Ellipsis:
  GO.link/src/go/ast/ast.go
TYPE ast.EmptyStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.Expr:
  GO.link/src/go/ast/ast.go
TYPE ast.ExprStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.Field:
  GO.link/src/go/ast/ast.go
TYPE ast.FieldFilter:
  GO.link/src/go/ast/print.go
TYPE ast.FieldList:
  GO.link/src/go/ast/ast.go
TYPE ast.File:
  GO.link/src/go/ast/ast.go
TYPE ast.Filter:
  GO.link/src/go/ast/filter.go
TYPE ast.ForStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.FuncDecl:
  GO.link/src/go/ast/ast.go
TYPE ast.FuncLit:
  GO.link/src/go/ast/ast.go
TYPE ast.FuncType:
  GO.link/src/go/ast/ast.go
TYPE ast.GenDecl:
  GO.link/src/go/ast/ast.go
TYPE ast.GoStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.Ident:
  GO.link/src/go/ast/ast.go
TYPE ast.IfStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.ImportSpec:
  GO.link/src/go/ast/ast.go
TYPE ast.Importer:
  GO.link/src/go/ast/resolve.go
TYPE ast.IncDecStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.IndexExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.InterfaceType:
  GO.link/src/go/ast/ast.go
TYPE ast.KeyValueExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.LabeledStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.MapType:
  GO.link/src/go/ast/ast.go
TYPE ast.MergeMode:
  GO.link/src/go/ast/filter.go
TYPE ast.Node:
  GO.link/src/go/ast/ast.go
TYPE ast.ObjKind:
  GO.link/src/go/ast/scope.go
TYPE ast.Object:
  GO.link/src/go/ast/scope.go
TYPE ast.Package:
  GO.link/src/go/ast/ast.go
TYPE ast.ParenExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.RangeStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.ReturnStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.Scope:
  GO.link/src/go/ast/scope.go
TYPE ast.SelectStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.SelectorExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.SendStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.SliceExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.Spec:
  GO.link/src/go/ast/ast.go
TYPE ast.StarExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.Stmt:
  GO.link/src/go/ast/ast.go
TYPE ast.StructType:
  GO.link/src/go/ast/ast.go
TYPE ast.SwitchStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.TypeAssertExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.TypeSpec:
  GO.link/src/go/ast/ast.go
TYPE ast.TypeSwitchStmt:
  GO.link/src/go/ast/ast.go
TYPE ast.UnaryExpr:
  GO.link/src/go/ast/ast.go
TYPE ast.ValueSpec:
  GO.link/src/go/ast/ast.go
TYPE ast.Visitor:
  GO.link/src/go/ast/walk.go
TYPE atomic.Value:
  GO.link/src/sync/atomic/value.go
TYPE base32.CorruptInputError:
  GO.link/src/encoding/base32/base32.go
TYPE base32.Encoding:
  GO.link/src/encoding/base32/base32.go
TYPE base64.CorruptInputError:
  GO.link/src/encoding/base64/base64.go
TYPE base64.Encoding:
  GO.link/src/encoding/base64/base64.go
TYPE big.Accuracy:
  GO.link/src/math/big/float.go
TYPE big.ErrNaN:
  GO.link/src/math/big/float.go
TYPE big.Float:
  GO.link/src/math/big/float.go
TYPE big.Int:
  GO.link/src/math/big/int.go
TYPE big.Rat:
  GO.link/src/math/big/rat.go
TYPE big.RoundingMode:
  GO.link/src/math/big/float.go
TYPE big.Word:
  GO.link/src/math/big/arith.go
TYPE binary.ByteOrder:
  GO.link/src/encoding/binary/binary.go
TYPE bufio.ReadWriter:
  GO.link/src/bufio/bufio.go
TYPE bufio.Reader:
  GO.link/src/bufio/bufio.go
TYPE bufio.Scanner:
  GO.link/src/bufio/scan.go
TYPE bufio.SplitFunc:
  GO.link/src/bufio/scan.go
TYPE bufio.Writer:
  GO.link/src/bufio/bufio.go
TYPE build.Context:
  GO.link/src/go/build/build.go
TYPE build.ImportMode:
  GO.link/src/go/build/build.go
TYPE build.MultiplePackageError:
  GO.link/src/go/build/build.go
TYPE build.NoGoError:
  GO.link/src/go/build/build.go
TYPE build.Package:
  GO.link/src/go/build/build.go
TYPE bytes.Buffer:
  GO.link/src/bytes/buffer.go
TYPE bytes.Reader:
  GO.link/src/bytes/reader.go
TYPE bzip2.StructuralError:
  GO.link/src/compress/bzip2/bzip2.go
TYPE cgi.Handler:
  GO.link/src/net/http/cgi/host.go
TYPE cipher.AEAD:
  GO.link/src/crypto/cipher/gcm.go
TYPE cipher.Block:
  GO.link/src/crypto/cipher/cipher.go
TYPE cipher.BlockMode:
  GO.link/src/crypto/cipher/cipher.go
TYPE cipher.Stream:
  GO.link/src/crypto/cipher/cipher.go
TYPE cipher.StreamReader:
  GO.link/src/crypto/cipher/io.go
TYPE cipher.StreamWriter:
  GO.link/src/crypto/cipher/io.go
TYPE color.Alpha:
  GO.link/src/image/color/color.go
TYPE color.Alpha16:
  GO.link/src/image/color/color.go
TYPE color.CMYK:
  GO.link/src/image/color/ycbcr.go
TYPE color.Color:
  GO.link/src/image/color/color.go
TYPE color.Gray:
  GO.link/src/image/color/color.go
TYPE color.Gray16:
  GO.link/src/image/color/color.go
TYPE color.Model:
  GO.link/src/image/color/color.go
TYPE color.NRGBA:
  GO.link/src/image/color/color.go
TYPE color.NRGBA64:
  GO.link/src/image/color/color.go
TYPE color.NYCbCrA:
  GO.link/src/image/color/ycbcr.go
TYPE color.Palette:
  GO.link/src/image/color/color.go
TYPE color.RGBA:
  GO.link/src/image/color/color.go
TYPE color.RGBA64:
  GO.link/src/image/color/color.go
TYPE color.YCbCr:
  GO.link/src/image/color/ycbcr.go
TYPE constant.Kind:
  GO.link/src/go/constant/value.go
TYPE constant.Value:
  GO.link/src/go/constant/value.go
TYPE context.CancelFunc:
  GO.link/src/context/context.go
TYPE context.Context:
  GO.link/src/context/context.go
TYPE cookiejar.Jar:
  GO.link/src/net/http/cookiejar/jar.go
TYPE cookiejar.Options:
  GO.link/src/net/http/cookiejar/jar.go
TYPE cookiejar.PublicSuffixList:
  GO.link/src/net/http/cookiejar/jar.go
TYPE crc32.Table:
  GO.link/src/hash/crc32/crc32.go
TYPE crc64.Table:
  GO.link/src/hash/crc64/crc64.go
TYPE crypto.Decrypter:
  GO.link/src/crypto/crypto.go
TYPE crypto.DecrypterOpts:
  GO.link/src/crypto/crypto.go
TYPE crypto.Hash:
  GO.link/src/crypto/crypto.go
TYPE crypto.PrivateKey:
  GO.link/src/crypto/crypto.go
TYPE crypto.PublicKey:
  GO.link/src/crypto/crypto.go
TYPE crypto.Signer:
  GO.link/src/crypto/crypto.go
TYPE crypto.SignerOpts:
  GO.link/src/crypto/crypto.go
TYPE csv.ParseError:
  GO.link/src/encoding/csv/reader.go
TYPE csv.Reader:
  GO.link/src/encoding/csv/reader.go
TYPE csv.Writer:
  GO.link/src/encoding/csv/writer.go
TYPE debug.GCStats:
  GO.link/src/runtime/debug/garbage.go
TYPE des.KeySizeError:
  GO.link/src/crypto/des/cipher.go
TYPE doc.Example:
  GO.link/src/go/doc/example.go
TYPE doc.Filter:
  GO.link/src/go/doc/filter.go
TYPE doc.Func:
  GO.link/src/go/doc/doc.go
TYPE doc.Mode:
  GO.link/src/go/doc/doc.go
TYPE doc.Note:
  GO.link/src/go/doc/doc.go
TYPE doc.Package:
  GO.link/src/go/doc/doc.go
TYPE doc.Type:
  GO.link/src/go/doc/doc.go
TYPE doc.Value:
  GO.link/src/go/doc/doc.go
TYPE draw.Drawer:
  GO.link/src/image/draw/draw.go
TYPE draw.Image:
  GO.link/src/image/draw/draw.go
TYPE draw.Op:
  GO.link/src/image/draw/draw.go
TYPE draw.Quantizer:
  GO.link/src/image/draw/draw.go
TYPE driver.ColumnConverter:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.Conn:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.ConnBeginTx:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.ConnPrepareContext:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.Connector:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.Driver:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.DriverContext:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.Execer:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.ExecerContext:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.IsolationLevel:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.NamedValue:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.NamedValueChecker:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.NotNull:
  GO.link/src/database/sql/driver/types.go
TYPE driver.Null:
  GO.link/src/database/sql/driver/types.go
TYPE driver.Pinger:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.Queryer:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.QueryerContext:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.Result:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.Rows:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.RowsAffected:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeDatabaseTypeName:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeLength:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeNullable:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.RowsColumnTypePrecisionScale:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeScanType:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.RowsNextResultSet:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.SessionResetter:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.Stmt:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.StmtExecContext:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.StmtQueryContext:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.Tx:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.TxOptions:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.Value:
  GO.link/src/database/sql/driver/driver.go
TYPE driver.ValueConverter:
  GO.link/src/database/sql/driver/types.go
TYPE driver.Valuer:
  GO.link/src/database/sql/driver/types.go
TYPE dsa.ParameterSizes:
  GO.link/src/crypto/dsa/dsa.go
TYPE dsa.Parameters:
  GO.link/src/crypto/dsa/dsa.go
TYPE dsa.PrivateKey:
  GO.link/src/crypto/dsa/dsa.go
TYPE dsa.PublicKey:
  GO.link/src/crypto/dsa/dsa.go
TYPE dwarf.AddrType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.ArrayType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.Attr:
  GO.link/src/debug/dwarf/const.go
TYPE dwarf.BasicType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.BoolType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.CharType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.Class:
  GO.link/src/debug/dwarf/entry.go
TYPE dwarf.CommonType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.ComplexType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.Data:
  GO.link/src/debug/dwarf/open.go
TYPE dwarf.DecodeError:
  GO.link/src/debug/dwarf/buf.go
TYPE dwarf.DotDotDotType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.Entry:
  GO.link/src/debug/dwarf/entry.go
TYPE dwarf.EnumType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.EnumValue:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.Field:
  GO.link/src/debug/dwarf/entry.go
TYPE dwarf.FloatType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.FuncType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.IntType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.LineEntry:
  GO.link/src/debug/dwarf/line.go
TYPE dwarf.LineFile:
  GO.link/src/debug/dwarf/line.go
TYPE dwarf.LineReader:
  GO.link/src/debug/dwarf/line.go
TYPE dwarf.LineReaderPos:
  GO.link/src/debug/dwarf/line.go
TYPE dwarf.Offset:
  GO.link/src/debug/dwarf/entry.go
TYPE dwarf.PtrType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.QualType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.Reader:
  GO.link/src/debug/dwarf/entry.go
TYPE dwarf.StructField:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.StructType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.Tag:
  GO.link/src/debug/dwarf/const.go
TYPE dwarf.Type:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.TypedefType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.UcharType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.UintType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.UnspecifiedType:
  GO.link/src/debug/dwarf/type.go
TYPE dwarf.VoidType:
  GO.link/src/debug/dwarf/type.go
TYPE ecdsa.PrivateKey:
  GO.link/src/crypto/ecdsa/ecdsa.go
TYPE ecdsa.PublicKey:
  GO.link/src/crypto/ecdsa/ecdsa.go
TYPE elf.Chdr32:
  GO.link/src/debug/elf/elf.go
TYPE elf.Chdr64:
  GO.link/src/debug/elf/elf.go
TYPE elf.Class:
  GO.link/src/debug/elf/elf.go
TYPE elf.CompressionType:
  GO.link/src/debug/elf/elf.go
TYPE elf.Data:
  GO.link/src/debug/elf/elf.go
TYPE elf.Dyn32:
  GO.link/src/debug/elf/elf.go
TYPE elf.Dyn64:
  GO.link/src/debug/elf/elf.go
TYPE elf.DynFlag:
  GO.link/src/debug/elf/elf.go
TYPE elf.DynTag:
  GO.link/src/debug/elf/elf.go
TYPE elf.File:
  GO.link/src/debug/elf/file.go
TYPE elf.FileHeader:
  GO.link/src/debug/elf/file.go
TYPE elf.FormatError:
  GO.link/src/debug/elf/file.go
TYPE elf.Header32:
  GO.link/src/debug/elf/elf.go
TYPE elf.Header64:
  GO.link/src/debug/elf/elf.go
TYPE elf.ImportedSymbol:
  GO.link/src/debug/elf/file.go
TYPE elf.Machine:
  GO.link/src/debug/elf/elf.go
TYPE elf.NType:
  GO.link/src/debug/elf/elf.go
TYPE elf.OSABI:
  GO.link/src/debug/elf/elf.go
TYPE elf.Prog:
  GO.link/src/debug/elf/file.go
TYPE elf.Prog32:
  GO.link/src/debug/elf/elf.go
TYPE elf.Prog64:
  GO.link/src/debug/elf/elf.go
TYPE elf.ProgFlag:
  GO.link/src/debug/elf/elf.go
TYPE elf.ProgHeader:
  GO.link/src/debug/elf/file.go
TYPE elf.ProgType:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_386:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_390:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_AARCH64:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_ALPHA:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_ARM:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_MIPS:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_PPC:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_PPC64:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_RISCV:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_SPARC:
  GO.link/src/debug/elf/elf.go
TYPE elf.R_X86_64:
  GO.link/src/debug/elf/elf.go
TYPE elf.Rel32:
  GO.link/src/debug/elf/elf.go
TYPE elf.Rel64:
  GO.link/src/debug/elf/elf.go
TYPE elf.Rela32:
  GO.link/src/debug/elf/elf.go
TYPE elf.Rela64:
  GO.link/src/debug/elf/elf.go
TYPE elf.Section:
  GO.link/src/debug/elf/file.go
TYPE elf.Section32:
  GO.link/src/debug/elf/elf.go
TYPE elf.Section64:
  GO.link/src/debug/elf/elf.go
TYPE elf.SectionFlag:
  GO.link/src/debug/elf/elf.go
TYPE elf.SectionHeader:
  GO.link/src/debug/elf/file.go
TYPE elf.SectionIndex:
  GO.link/src/debug/elf/elf.go
TYPE elf.SectionType:
  GO.link/src/debug/elf/elf.go
TYPE elf.Sym32:
  GO.link/src/debug/elf/elf.go
TYPE elf.Sym64:
  GO.link/src/debug/elf/elf.go
TYPE elf.SymBind:
  GO.link/src/debug/elf/elf.go
TYPE elf.SymType:
  GO.link/src/debug/elf/elf.go
TYPE elf.SymVis:
  GO.link/src/debug/elf/elf.go
TYPE elf.Symbol:
  GO.link/src/debug/elf/file.go
TYPE elf.Type:
  GO.link/src/debug/elf/elf.go
TYPE elf.Version:
  GO.link/src/debug/elf/elf.go
TYPE elliptic.Curve:
  GO.link/src/crypto/elliptic/elliptic.go
TYPE elliptic.CurveParams:
  GO.link/src/crypto/elliptic/elliptic.go
TYPE encoding.BinaryMarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding.BinaryUnmarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding.TextMarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding.TextUnmarshaler:
  GO.link/src/encoding/encoding.go
TYPE exec.Cmd:
  GO.link/src/os/exec/exec.go
TYPE exec.Error:
  GO.link/src/os/exec/exec.go
TYPE exec.ExitError:
  GO.link/src/os/exec/exec.go
TYPE expvar.Float:
  GO.link/src/expvar/expvar.go
TYPE expvar.Func:
  GO.link/src/expvar/expvar.go
TYPE expvar.Int:
  GO.link/src/expvar/expvar.go
TYPE expvar.KeyValue:
  GO.link/src/expvar/expvar.go
TYPE expvar.Map:
  GO.link/src/expvar/expvar.go
TYPE expvar.String:
  GO.link/src/expvar/expvar.go
TYPE expvar.Var:
  GO.link/src/expvar/expvar.go
TYPE filepath.WalkFunc:
  GO.link/src/path/filepath/path.go
TYPE flag.ErrorHandling:
  GO.link/src/flag/flag.go
TYPE flag.Flag:
  GO.link/src/flag/flag.go
TYPE flag.FlagSet:
  GO.link/src/flag/flag.go
TYPE flag.Getter:
  GO.link/src/flag/flag.go
TYPE flag.Value:
  GO.link/src/flag/flag.go
TYPE flate.CorruptInputError:
  GO.link/src/compress/flate/inflate.go
TYPE flate.InternalError:
  GO.link/src/compress/flate/inflate.go
TYPE flate.ReadError:
  GO.link/src/compress/flate/inflate.go
TYPE flate.Reader:
  GO.link/src/compress/flate/inflate.go
TYPE flate.Resetter:
  GO.link/src/compress/flate/inflate.go
TYPE flate.WriteError:
  GO.link/src/compress/flate/inflate.go
TYPE flate.Writer:
  GO.link/src/compress/flate/deflate.go
TYPE fmt.Formatter:
  GO.link/src/fmt/print.go
TYPE fmt.GoStringer:
  GO.link/src/fmt/print.go
TYPE fmt.ScanState:
  GO.link/src/fmt/scan.go
TYPE fmt.Scanner:
  GO.link/src/fmt/scan.go
TYPE fmt.State:
  GO.link/src/fmt/print.go
TYPE fmt.Stringer:
  GO.link/src/fmt/print.go
TYPE gif.GIF:
  GO.link/src/image/gif/reader.go
TYPE gif.Options:
  GO.link/src/image/gif/writer.go
TYPE gob.CommonType:
  GO.link/src/encoding/gob/type.go
TYPE gob.Decoder:
  GO.link/src/encoding/gob/decoder.go
TYPE gob.Encoder:
  GO.link/src/encoding/gob/encoder.go
TYPE gob.GobDecoder:
  GO.link/src/encoding/gob/type.go
TYPE gob.GobEncoder:
  GO.link/src/encoding/gob/type.go
TYPE gosym.DecodingError:
  GO.link/src/debug/gosym/symtab.go
TYPE gosym.Func:
  GO.link/src/debug/gosym/symtab.go
TYPE gosym.LineTable:
  GO.link/src/debug/gosym/pclntab.go
TYPE gosym.Obj:
  GO.link/src/debug/gosym/symtab.go
TYPE gosym.Sym:
  GO.link/src/debug/gosym/symtab.go
TYPE gosym.Table:
  GO.link/src/debug/gosym/symtab.go
TYPE gosym.UnknownFileError:
  GO.link/src/debug/gosym/symtab.go
TYPE gosym.UnknownLineError:
  GO.link/src/debug/gosym/symtab.go
TYPE gzip.Header:
  GO.link/src/compress/gzip/gunzip.go
TYPE gzip.Reader:
  GO.link/src/compress/gzip/gunzip.go
TYPE gzip.Writer:
  GO.link/src/compress/gzip/gzip.go
TYPE hash.Hash:
  GO.link/src/hash/hash.go
TYPE hash.Hash32:
  GO.link/src/hash/hash.go
TYPE hash.Hash64:
  GO.link/src/hash/hash.go
TYPE heap.Interface:
  GO.link/src/container/heap/heap.go
TYPE hex.InvalidByteError:
  GO.link/src/encoding/hex/hex.go
TYPE http.Client:
  GO.link/src/net/http/client.go
TYPE http.CloseNotifier:
  GO.link/src/net/http/server.go
TYPE http.ConnState:
  GO.link/src/net/http/server.go
TYPE http.Cookie:
  GO.link/src/net/http/cookie.go
TYPE http.CookieJar:
  GO.link/src/net/http/jar.go
TYPE http.Dir:
  GO.link/src/net/http/fs.go
TYPE http.File:
  GO.link/src/net/http/fs.go
TYPE http.FileSystem:
  GO.link/src/net/http/fs.go
TYPE http.Flusher:
  GO.link/src/net/http/server.go
TYPE http.Handler:
  GO.link/src/net/http/server.go
TYPE http.HandlerFunc:
  GO.link/src/net/http/server.go
TYPE http.Header:
  GO.link/src/net/http/header.go
TYPE http.Hijacker:
  GO.link/src/net/http/server.go
TYPE http.ProtocolError:
  GO.link/src/net/http/request.go
TYPE http.PushOptions:
  GO.link/src/net/http/http.go
TYPE http.Pusher:
  GO.link/src/net/http/http.go
TYPE http.Request:
  GO.link/src/net/http/request.go
TYPE http.Response:
  GO.link/src/net/http/response.go
TYPE http.ResponseWriter:
  GO.link/src/net/http/server.go
TYPE http.RoundTripper:
  GO.link/src/net/http/client.go
TYPE http.SameSite:
  GO.link/src/net/http/cookie.go
TYPE http.ServeMux:
  GO.link/src/net/http/server.go
TYPE http.Server:
  GO.link/src/net/http/server.go
TYPE http.Transport:
  GO.link/src/net/http/transport.go
TYPE httptest.ResponseRecorder:
  GO.link/src/net/http/httptest/recorder.go
TYPE httptest.Server:
  GO.link/src/net/http/httptest/server.go
TYPE httptrace.ClientTrace:
  GO.link/src/net/http/httptrace/trace.go
TYPE httptrace.DNSDoneInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE httptrace.DNSStartInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE httptrace.GotConnInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE httptrace.WroteRequestInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE httputil.BufferPool:
  GO.link/src/net/http/httputil/reverseproxy.go
TYPE httputil.ClientConn:
  GO.link/src/net/http/httputil/persist.go
TYPE httputil.ReverseProxy:
  GO.link/src/net/http/httputil/reverseproxy.go
TYPE httputil.ServerConn:
  GO.link/src/net/http/httputil/persist.go
TYPE image.Alpha:
  GO.link/src/image/image.go
TYPE image.Alpha16:
  GO.link/src/image/image.go
TYPE image.CMYK:
  GO.link/src/image/image.go
TYPE image.Config:
  GO.link/src/image/image.go
TYPE image.Gray:
  GO.link/src/image/image.go
TYPE image.Gray16:
  GO.link/src/image/image.go
TYPE image.Image:
  GO.link/src/image/image.go
TYPE image.NRGBA:
  GO.link/src/image/image.go
TYPE image.NRGBA64:
  GO.link/src/image/image.go
TYPE image.NYCbCrA:
  GO.link/src/image/ycbcr.go
TYPE image.Paletted:
  GO.link/src/image/image.go
TYPE image.PalettedImage:
  GO.link/src/image/image.go
TYPE image.Point:
  GO.link/src/image/geom.go
TYPE image.RGBA:
  GO.link/src/image/image.go
TYPE image.RGBA64:
  GO.link/src/image/image.go
TYPE image.Rectangle:
  GO.link/src/image/geom.go
TYPE image.Uniform:
  GO.link/src/image/names.go
TYPE image.YCbCr:
  GO.link/src/image/ycbcr.go
TYPE image.YCbCrSubsampleRatio:
  GO.link/src/image/ycbcr.go
TYPE importer.Lookup:
  GO.link/src/go/importer/importer.go
TYPE io.ByteReader:
  GO.link/src/io/io.go
TYPE io.ByteScanner:
  GO.link/src/io/io.go
TYPE io.ByteWriter:
  GO.link/src/io/io.go
TYPE io.Closer:
  GO.link/src/io/io.go
TYPE io.LimitedReader:
  GO.link/src/io/io.go
TYPE io.PipeReader:
  GO.link/src/io/pipe.go
TYPE io.PipeWriter:
  GO.link/src/io/pipe.go
TYPE io.ReadCloser:
  GO.link/src/io/io.go
TYPE io.ReadSeeker:
  GO.link/src/io/io.go
TYPE io.ReadWriteCloser:
  GO.link/src/io/io.go
TYPE io.ReadWriteSeeker:
  GO.link/src/io/io.go
TYPE io.ReadWriter:
  GO.link/src/io/io.go
TYPE io.Reader:
  GO.link/src/io/io.go
TYPE io.ReaderAt:
  GO.link/src/io/io.go
TYPE io.ReaderFrom:
  GO.link/src/io/io.go
TYPE io.RuneReader:
  GO.link/src/io/io.go
TYPE io.RuneScanner:
  GO.link/src/io/io.go
TYPE io.SectionReader:
  GO.link/src/io/io.go
TYPE io.Seeker:
  GO.link/src/io/io.go
TYPE io.WriteCloser:
  GO.link/src/io/io.go
TYPE io.WriteSeeker:
  GO.link/src/io/io.go
TYPE io.Writer:
  GO.link/src/io/io.go
TYPE io.WriterAt:
  GO.link/src/io/io.go
TYPE io.WriterTo:
  GO.link/src/io/io.go
TYPE jpeg.FormatError:
  GO.link/src/image/jpeg/reader.go
TYPE jpeg.Options:
  GO.link/src/image/jpeg/writer.go
TYPE jpeg.Reader:
  GO.link/src/image/jpeg/reader.go
TYPE jpeg.UnsupportedError:
  GO.link/src/image/jpeg/reader.go
TYPE json.Decoder:
  GO.link/src/encoding/json/stream.go
TYPE json.Delim:
  GO.link/src/encoding/json/stream.go
TYPE json.Encoder:
  GO.link/src/encoding/json/stream.go
TYPE json.InvalidUTF8Error:
  GO.link/src/encoding/json/encode.go
TYPE json.InvalidUnmarshalError:
  GO.link/src/encoding/json/decode.go
TYPE json.Marshaler:
  GO.link/src/encoding/json/encode.go
TYPE json.MarshalerError:
  GO.link/src/encoding/json/encode.go
TYPE json.Number:
  GO.link/src/encoding/json/decode.go
TYPE json.RawMessage:
  GO.link/src/encoding/json/stream.go
TYPE json.SyntaxError:
  GO.link/src/encoding/json/scanner.go
TYPE json.Token:
  GO.link/src/encoding/json/stream.go
TYPE json.UnmarshalFieldError:
  GO.link/src/encoding/json/decode.go
TYPE json.UnmarshalTypeError:
  GO.link/src/encoding/json/decode.go
TYPE json.Unmarshaler:
  GO.link/src/encoding/json/decode.go
TYPE json.UnsupportedTypeError:
  GO.link/src/encoding/json/encode.go
TYPE json.UnsupportedValueError:
  GO.link/src/encoding/json/encode.go
TYPE list.Element:
  GO.link/src/container/list/list.go
TYPE list.List:
  GO.link/src/container/list/list.go
TYPE log.Logger:
  GO.link/src/log/log.go
TYPE lzw.Order:
  GO.link/src/compress/lzw/reader.go
TYPE macho.Cpu:
  GO.link/src/debug/macho/macho.go
TYPE macho.Dylib:
  GO.link/src/debug/macho/file.go
TYPE macho.DylibCmd:
  GO.link/src/debug/macho/macho.go
TYPE macho.Dysymtab:
  GO.link/src/debug/macho/file.go
TYPE macho.DysymtabCmd:
  GO.link/src/debug/macho/macho.go
TYPE macho.FatArch:
  GO.link/src/debug/macho/fat.go
TYPE macho.FatArchHeader:
  GO.link/src/debug/macho/fat.go
TYPE macho.FatFile:
  GO.link/src/debug/macho/fat.go
TYPE macho.File:
  GO.link/src/debug/macho/file.go
TYPE macho.FileHeader:
  GO.link/src/debug/macho/macho.go
TYPE macho.FormatError:
  GO.link/src/debug/macho/file.go
TYPE macho.Load:
  GO.link/src/debug/macho/file.go
TYPE macho.LoadBytes:
  GO.link/src/debug/macho/file.go
TYPE macho.LoadCmd:
  GO.link/src/debug/macho/macho.go
TYPE macho.Nlist32:
  GO.link/src/debug/macho/macho.go
TYPE macho.Nlist64:
  GO.link/src/debug/macho/macho.go
TYPE macho.Regs386:
  GO.link/src/debug/macho/macho.go
TYPE macho.RegsAMD64:
  GO.link/src/debug/macho/macho.go
TYPE macho.Reloc:
  GO.link/src/debug/macho/file.go
TYPE macho.RelocTypeARM:
  GO.link/src/debug/macho/reloctype.go
TYPE macho.RelocTypeARM64:
  GO.link/src/debug/macho/reloctype.go
TYPE macho.RelocTypeGeneric:
  GO.link/src/debug/macho/reloctype.go
TYPE macho.RelocTypeX86_64:
  GO.link/src/debug/macho/reloctype.go
TYPE macho.Rpath:
  GO.link/src/debug/macho/file.go
TYPE macho.RpathCmd:
  GO.link/src/debug/macho/macho.go
TYPE macho.Section:
  GO.link/src/debug/macho/file.go
TYPE macho.Section32:
  GO.link/src/debug/macho/macho.go
TYPE macho.Section64:
  GO.link/src/debug/macho/macho.go
TYPE macho.SectionHeader:
  GO.link/src/debug/macho/file.go
TYPE macho.Segment:
  GO.link/src/debug/macho/file.go
TYPE macho.Segment32:
  GO.link/src/debug/macho/macho.go
TYPE macho.Segment64:
  GO.link/src/debug/macho/macho.go
TYPE macho.SegmentHeader:
  GO.link/src/debug/macho/file.go
TYPE macho.Symbol:
  GO.link/src/debug/macho/file.go
TYPE macho.Symtab:
  GO.link/src/debug/macho/file.go
TYPE macho.SymtabCmd:
  GO.link/src/debug/macho/macho.go
TYPE macho.Thread:
  GO.link/src/debug/macho/macho.go
TYPE macho.Type:
  GO.link/src/debug/macho/macho.go
TYPE mail.Address:
  GO.link/src/net/mail/message.go
TYPE mail.AddressParser:
  GO.link/src/net/mail/message.go
TYPE mail.Header:
  GO.link/src/net/mail/message.go
TYPE mail.Message:
  GO.link/src/net/mail/message.go
TYPE mime.WordDecoder:
  GO.link/src/mime/encodedword.go
TYPE mime.WordEncoder:
  GO.link/src/mime/encodedword.go
TYPE multipart.File:
  GO.link/src/mime/multipart/formdata.go
TYPE multipart.FileHeader:
  GO.link/src/mime/multipart/formdata.go
TYPE multipart.Form:
  GO.link/src/mime/multipart/formdata.go
TYPE multipart.Part:
  GO.link/src/mime/multipart/multipart.go
TYPE multipart.Reader:
  GO.link/src/mime/multipart/multipart.go
TYPE multipart.Writer:
  GO.link/src/mime/multipart/writer.go
TYPE net.Addr:
  GO.link/src/net/net.go
TYPE net.AddrError:
  GO.link/src/net/net.go
TYPE net.Buffers:
  GO.link/src/net/net.go
TYPE net.Conn:
  GO.link/src/net/net.go
TYPE net.DNSConfigError:
  GO.link/src/net/net.go
TYPE net.DNSError:
  GO.link/src/net/net.go
TYPE net.Dialer:
  GO.link/src/net/dial.go
TYPE net.Error:
  GO.link/src/net/net.go
TYPE net.Flags:
  GO.link/src/net/interface.go
TYPE net.HardwareAddr:
  GO.link/src/net/mac.go
TYPE net.IP:
  GO.link/src/net/ip.go
TYPE net.IPAddr:
  GO.link/src/net/iprawsock.go
TYPE net.IPConn:
  GO.link/src/net/iprawsock.go
TYPE net.IPMask:
  GO.link/src/net/ip.go
TYPE net.IPNet:
  GO.link/src/net/ip.go
TYPE net.Interface:
  GO.link/src/net/interface.go
TYPE net.InvalidAddrError:
  GO.link/src/net/net.go
TYPE net.ListenConfig:
  GO.link/src/net/dial.go
TYPE net.Listener:
  GO.link/src/net/net.go
TYPE net.MX:
  GO.link/src/net/dnsclient.go
TYPE net.NS:
  GO.link/src/net/dnsclient.go
TYPE net.OpError:
  GO.link/src/net/net.go
TYPE net.PacketConn:
  GO.link/src/net/net.go
TYPE net.ParseError:
  GO.link/src/net/net.go
TYPE net.Resolver:
  GO.link/src/net/lookup.go
TYPE net.SRV:
  GO.link/src/net/dnsclient.go
TYPE net.TCPAddr:
  GO.link/src/net/tcpsock.go
TYPE net.TCPConn:
  GO.link/src/net/tcpsock.go
TYPE net.TCPListener:
  GO.link/src/net/tcpsock.go
TYPE net.UDPAddr:
  GO.link/src/net/udpsock.go
TYPE net.UDPConn:
  GO.link/src/net/udpsock.go
TYPE net.UnixAddr:
  GO.link/src/net/unixsock.go
TYPE net.UnixConn:
  GO.link/src/net/unixsock.go
TYPE net.UnixListener:
  GO.link/src/net/unixsock.go
TYPE net.UnknownNetworkError:
  GO.link/src/net/net.go
TYPE os.File:
  GO.link/src/os/types.go
TYPE os.FileInfo:
  GO.link/src/os/types.go
TYPE os.FileMode:
  GO.link/src/os/types.go
TYPE os.LinkError:
  GO.link/src/os/file.go
TYPE os.PathError:
  GO.link/src/os/error.go
TYPE os.ProcAttr:
  GO.link/src/os/exec.go
TYPE os.Process:
  GO.link/src/os/exec.go
TYPE os.ProcessState:
  GO.link/src/os/exec_posix.go
TYPE os.Signal:
  GO.link/src/os/exec.go
TYPE os.SyscallError:
  GO.link/src/os/error.go
TYPE parse.ActionNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.BoolNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.BranchNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.ChainNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.CommandNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.DotNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.FieldNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.IdentifierNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.IfNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.ListNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.NilNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.Node:
  GO.link/src/text/template/parse/node.go
TYPE parse.NodeType:
  GO.link/src/text/template/parse/node.go
TYPE parse.NumberNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.PipeNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.Pos:
  GO.link/src/text/template/parse/node.go
TYPE parse.RangeNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.StringNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.TemplateNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.TextNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.Tree:
  GO.link/src/text/template/parse/parse.go
TYPE parse.VariableNode:
  GO.link/src/text/template/parse/node.go
TYPE parse.WithNode:
  GO.link/src/text/template/parse/node.go
TYPE parser.Mode:
  GO.link/src/go/parser/interface.go
TYPE pe.COFFSymbol:
  GO.link/src/debug/pe/symbol.go
TYPE pe.DataDirectory:
  GO.link/src/debug/pe/pe.go
TYPE pe.File:
  GO.link/src/debug/pe/file.go
TYPE pe.FileHeader:
  GO.link/src/debug/pe/pe.go
TYPE pe.FormatError:
  GO.link/src/debug/pe/file.go
TYPE pe.ImportDirectory:
  GO.link/src/debug/pe/file.go
TYPE pe.OptionalHeader32:
  GO.link/src/debug/pe/pe.go
TYPE pe.OptionalHeader64:
  GO.link/src/debug/pe/pe.go
TYPE pe.Reloc:
  GO.link/src/debug/pe/section.go
TYPE pe.Section:
  GO.link/src/debug/pe/section.go
TYPE pe.SectionHeader:
  GO.link/src/debug/pe/section.go
TYPE pe.SectionHeader32:
  GO.link/src/debug/pe/section.go
TYPE pe.StringTable:
  GO.link/src/debug/pe/string.go
TYPE pe.Symbol:
  GO.link/src/debug/pe/symbol.go
TYPE pem.Block:
  GO.link/src/encoding/pem/pem.go
TYPE pkix.AlgorithmIdentifier:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE pkix.AttributeTypeAndValue:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE pkix.AttributeTypeAndValueSET:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE pkix.CertificateList:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE pkix.Extension:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE pkix.Name:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE pkix.RDNSequence:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE pkix.RelativeDistinguishedNameSET:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE pkix.RevokedCertificate:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE pkix.TBSCertificateList:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE plan9obj.File:
  GO.link/src/debug/plan9obj/file.go
TYPE plan9obj.FileHeader:
  GO.link/src/debug/plan9obj/file.go
TYPE plan9obj.Section:
  GO.link/src/debug/plan9obj/file.go
TYPE plan9obj.SectionHeader:
  GO.link/src/debug/plan9obj/file.go
TYPE plan9obj.Sym:
  GO.link/src/debug/plan9obj/file.go
TYPE plugin.Plugin:
  GO.link/src/plugin/plugin.go
TYPE plugin.Symbol:
  GO.link/src/plugin/plugin.go
TYPE png.CompressionLevel:
  GO.link/src/image/png/writer.go
TYPE png.Encoder:
  GO.link/src/image/png/writer.go
TYPE png.EncoderBuffer:
  GO.link/src/image/png/writer.go
TYPE png.EncoderBufferPool:
  GO.link/src/image/png/writer.go
TYPE png.FormatError:
  GO.link/src/image/png/reader.go
TYPE png.UnsupportedError:
  GO.link/src/image/png/reader.go
TYPE pprof.LabelSet:
  GO.link/src/runtime/pprof/label.go
TYPE pprof.Profile:
  GO.link/src/runtime/pprof/pprof.go
TYPE printer.CommentedNode:
  GO.link/src/go/printer/printer.go
TYPE printer.Config:
  GO.link/src/go/printer/printer.go
TYPE printer.Mode:
  GO.link/src/go/printer/printer.go
TYPE quick.CheckEqualError:
  GO.link/src/testing/quick/quick.go
TYPE quick.CheckError:
  GO.link/src/testing/quick/quick.go
TYPE quick.Config:
  GO.link/src/testing/quick/quick.go
TYPE quick.Generator:
  GO.link/src/testing/quick/quick.go
TYPE quick.SetupError:
  GO.link/src/testing/quick/quick.go
TYPE quotedprintable.Reader:
  GO.link/src/mime/quotedprintable/reader.go
TYPE quotedprintable.Writer:
  GO.link/src/mime/quotedprintable/writer.go
TYPE rand.Rand:
  GO.link/src/math/rand/rand.go
TYPE rand.Source:
  GO.link/src/math/rand/rand.go
TYPE rand.Source64:
  GO.link/src/math/rand/rand.go
TYPE rand.Zipf:
  GO.link/src/math/rand/zipf.go
TYPE rc4.Cipher:
  GO.link/src/crypto/rc4/rc4.go
TYPE rc4.KeySizeError:
  GO.link/src/crypto/rc4/rc4.go
TYPE reflect.ChanDir:
  GO.link/src/reflect/type.go
TYPE reflect.Kind:
  GO.link/src/reflect/type.go
TYPE reflect.Method:
  GO.link/src/reflect/type.go
TYPE reflect.SelectCase:
  GO.link/src/reflect/value.go
TYPE reflect.SelectDir:
  GO.link/src/reflect/value.go
TYPE reflect.SliceHeader:
  GO.link/src/reflect/value.go
TYPE reflect.StringHeader:
  GO.link/src/reflect/value.go
TYPE reflect.StructField:
  GO.link/src/reflect/type.go
TYPE reflect.StructTag:
  GO.link/src/reflect/type.go
TYPE reflect.Type:
  GO.link/src/reflect/type.go
TYPE reflect.Value:
  GO.link/src/reflect/value.go
TYPE reflect.ValueError:
  GO.link/src/reflect/value.go
TYPE regexp.Regexp:
  GO.link/src/regexp/regexp.go
TYPE ring.Ring:
  GO.link/src/container/ring/ring.go
TYPE rpc.Call:
  GO.link/src/net/rpc/client.go
TYPE rpc.Client:
  GO.link/src/net/rpc/client.go
TYPE rpc.ClientCodec:
  GO.link/src/net/rpc/client.go
TYPE rpc.Request:
  GO.link/src/net/rpc/server.go
TYPE rpc.Response:
  GO.link/src/net/rpc/server.go
TYPE rpc.Server:
  GO.link/src/net/rpc/server.go
TYPE rpc.ServerCodec:
  GO.link/src/net/rpc/server.go
TYPE rpc.ServerError:
  GO.link/src/net/rpc/client.go
TYPE rsa.CRTValue:
  GO.link/src/crypto/rsa/rsa.go
TYPE rsa.OAEPOptions:
  GO.link/src/crypto/rsa/rsa.go
TYPE rsa.PKCS1v15DecryptOptions:
  GO.link/src/crypto/rsa/pkcs1v15.go
TYPE rsa.PSSOptions:
  GO.link/src/crypto/rsa/pss.go
TYPE rsa.PrecomputedValues:
  GO.link/src/crypto/rsa/rsa.go
TYPE rsa.PrivateKey:
  GO.link/src/crypto/rsa/rsa.go
TYPE rsa.PublicKey:
  GO.link/src/crypto/rsa/rsa.go
TYPE runtime.BlockProfileRecord:
  GO.link/src/runtime/mprof.go
TYPE runtime.Error:
  GO.link/src/runtime/error.go
TYPE runtime.Frame:
  GO.link/src/runtime/symtab.go
TYPE runtime.Frames:
  GO.link/src/runtime/symtab.go
TYPE runtime.Func:
  GO.link/src/runtime/symtab.go
TYPE runtime.MemProfileRecord:
  GO.link/src/runtime/mprof.go
TYPE runtime.MemStats:
  GO.link/src/runtime/mstats.go
TYPE runtime.StackRecord:
  GO.link/src/runtime/mprof.go
TYPE runtime.TypeAssertionError:
  GO.link/src/runtime/error.go
TYPE runtime._defer:
  GO.link/src/runtime/runtime2.go
TYPE runtime._func:
  GO.link/src/runtime/runtime2.go
TYPE runtime._panic:
  GO.link/src/runtime/runtime2.go
TYPE runtime._type:
  GO.link/src/runtime/type.go
TYPE runtime._typePair:
  GO.link/src/runtime/type.go
TYPE scanner.Error:
  GO.link/src/go/scanner/errors.go
TYPE scanner.ErrorHandler:
  GO.link/src/go/scanner/scanner.go
TYPE scanner.ErrorList:
  GO.link/src/go/scanner/errors.go
TYPE scanner.Mode:
  GO.link/src/go/scanner/scanner.go
TYPE scanner.Position:
  GO.link/src/text/scanner/scanner.go
TYPE scanner.Scanner:
  GO.link/src/go/scanner/scanner.go
TYPE scanner.Scanner:
  GO.link/src/text/scanner/scanner.go
TYPE smtp.Auth:
  GO.link/src/net/smtp/auth.go
TYPE smtp.Client:
  GO.link/src/net/smtp/smtp.go
TYPE smtp.ServerInfo:
  GO.link/src/net/smtp/auth.go
TYPE sort.Float64Slice:
  GO.link/src/sort/sort.go
TYPE sort.IntSlice:
  GO.link/src/sort/sort.go
TYPE sort.Interface:
  GO.link/src/sort/sort.go
TYPE sort.StringSlice:
  GO.link/src/sort/sort.go
TYPE sql.ColumnType:
  GO.link/src/database/sql/sql.go
TYPE sql.Conn:
  GO.link/src/database/sql/sql.go
TYPE sql.DB:
  GO.link/src/database/sql/sql.go
TYPE sql.DBStats:
  GO.link/src/database/sql/sql.go
TYPE sql.IsolationLevel:
  GO.link/src/database/sql/sql.go
TYPE sql.NamedArg:
  GO.link/src/database/sql/sql.go
TYPE sql.NullBool:
  GO.link/src/database/sql/sql.go
TYPE sql.NullFloat64:
  GO.link/src/database/sql/sql.go
TYPE sql.NullInt64:
  GO.link/src/database/sql/sql.go
TYPE sql.NullString:
  GO.link/src/database/sql/sql.go
TYPE sql.Out:
  GO.link/src/database/sql/sql.go
TYPE sql.RawBytes:
  GO.link/src/database/sql/sql.go
TYPE sql.Result:
  GO.link/src/database/sql/sql.go
TYPE sql.Row:
  GO.link/src/database/sql/sql.go
TYPE sql.Rows:
  GO.link/src/database/sql/sql.go
TYPE sql.Scanner:
  GO.link/src/database/sql/sql.go
TYPE sql.Stmt:
  GO.link/src/database/sql/sql.go
TYPE sql.Tx:
  GO.link/src/database/sql/sql.go
TYPE sql.TxOptions:
  GO.link/src/database/sql/sql.go
TYPE strconv.NumError:
  GO.link/src/strconv/atoi.go
TYPE strings.Builder:
  GO.link/src/strings/builder.go
TYPE strings.Reader:
  GO.link/src/strings/reader.go
TYPE strings.Replacer:
  GO.link/src/strings/replace.go
TYPE suffixarray.Index:
  GO.link/src/index/suffixarray/suffixarray.go
TYPE sync.Cond:
  GO.link/src/sync/cond.go
TYPE sync.Locker:
  GO.link/src/sync/mutex.go
TYPE sync.Map:
  GO.link/src/sync/map.go
TYPE sync.Mutex:
  GO.link/src/sync/mutex.go
TYPE sync.Once:
  GO.link/src/sync/once.go
TYPE sync.Pool:
  GO.link/src/sync/pool.go
TYPE sync.RWMutex:
  GO.link/src/sync/rwmutex.go
TYPE sync.WaitGroup:
  GO.link/src/sync/waitgroup.go
TYPE syntax.EmptyOp:
  GO.link/src/regexp/syntax/prog.go
TYPE syntax.Error:
  GO.link/src/regexp/syntax/parse.go
TYPE syntax.ErrorCode:
  GO.link/src/regexp/syntax/parse.go
TYPE syntax.Flags:
  GO.link/src/regexp/syntax/parse.go
TYPE syntax.Inst:
  GO.link/src/regexp/syntax/prog.go
TYPE syntax.InstOp:
  GO.link/src/regexp/syntax/prog.go
TYPE syntax.Op:
  GO.link/src/regexp/syntax/regexp.go
TYPE syntax.Prog:
  GO.link/src/regexp/syntax/prog.go
TYPE syntax.Regexp:
  GO.link/src/regexp/syntax/regexp.go
TYPE syscall.BpfHdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfInsn:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfProgram:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfStat:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfVersion:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Cmsghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Conn:
  GO.link/src/syscall/net.go
TYPE syscall.Credential:
  GO.link/src/syscall/exec_unix.go
TYPE syscall.Dirent:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Errno:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.Fbootstraptransfer_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.FdSet:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Flock_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Fsid:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Fstore_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.ICMPv6Filter:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPMreq:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPv6MTUInfo:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPv6Mreq:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfData:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfMsghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfaMsghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfmaMsghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfmaMsghdr2:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Inet4Pktinfo:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Inet6Pktinfo:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.InterfaceAddrMessage:
  GO.link/src/syscall/route_bsd.go
TYPE syscall.InterfaceMessage:
  GO.link/src/syscall/route_bsd.go
TYPE syscall.InterfaceMulticastAddrMessage:
  GO.link/src/syscall/route_darwin.go
TYPE syscall.Iovec:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Kevent_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Linger:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Log2phys_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Msghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.ProcAttr:
  GO.link/src/syscall/exec_unix.go
TYPE syscall.Radvisory_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawConn:
  GO.link/src/syscall/net.go
TYPE syscall.RawSockaddr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrAny:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrDatalink:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrInet4:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrInet6:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrUnix:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Rlimit:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RouteMessage:
  GO.link/src/syscall/route_bsd.go
TYPE syscall.RoutingMessage:
  GO.link/src/syscall/route_bsd.go
TYPE syscall.RtMetrics:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RtMsghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Rusage:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Signal:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.Sockaddr:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SockaddrDatalink:
  GO.link/src/syscall/syscall_darwin.go
TYPE syscall.SockaddrInet4:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SockaddrInet6:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SockaddrUnix:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SocketControlMessage:
  GO.link/src/syscall/sockcmsg_unix.go
TYPE syscall.Stat_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Statfs_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.SysProcAttr:
  GO.link/src/syscall/exec_bsd.go
TYPE syscall.Termios:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timespec:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timeval:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timeval32:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.WaitStatus:
  GO.link/src/syscall/syscall_bsd.go
TYPE syscall._C_int:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall._C_long:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall._C_long_long:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall._C_short:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall._Gid_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall._Socklen:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syslog.Priority:
  GO.link/src/log/syslog/syslog.go
TYPE syslog.Writer:
  GO.link/src/log/syslog/syslog.go
TYPE tabwriter.Writer:
  GO.link/src/text/tabwriter/tabwriter.go
TYPE tar.Format:
  GO.link/src/archive/tar/format.go
TYPE tar.Header:
  GO.link/src/archive/tar/common.go
TYPE tar.Reader:
  GO.link/src/archive/tar/reader.go
TYPE tar.Writer:
  GO.link/src/archive/tar/writer.go
TYPE template.CSS:
  GO.link/src/html/template/content.go
TYPE template.Error:
  GO.link/src/html/template/error.go
TYPE template.ErrorCode:
  GO.link/src/html/template/error.go
TYPE template.ExecError:
  GO.link/src/text/template/exec.go
TYPE template.FuncMap:
  GO.link/src/text/template/funcs.go
TYPE template.FuncMap:
  GO.link/src/html/template/template.go
TYPE template.HTML:
  GO.link/src/html/template/content.go
TYPE template.HTMLAttr:
  GO.link/src/html/template/content.go
TYPE template.JS:
  GO.link/src/html/template/content.go
TYPE template.JSStr:
  GO.link/src/html/template/content.go
TYPE template.Srcset:
  GO.link/src/html/template/content.go
TYPE template.Template:
  GO.link/src/html/template/template.go
TYPE template.Template:
  GO.link/src/text/template/template.go
TYPE template.URL:
  GO.link/src/html/template/content.go
TYPE testing.B:
  GO.link/src/testing/benchmark.go
TYPE testing.BenchmarkResult:
  GO.link/src/testing/benchmark.go
TYPE testing.Cover:
  GO.link/src/testing/cover.go
TYPE testing.CoverBlock:
  GO.link/src/testing/cover.go
TYPE testing.InternalBenchmark:
  GO.link/src/testing/benchmark.go
TYPE testing.InternalExample:
  GO.link/src/testing/example.go
TYPE testing.InternalTest:
  GO.link/src/testing/testing.go
TYPE testing.M:
  GO.link/src/testing/testing.go
TYPE testing.PB:
  GO.link/src/testing/benchmark.go
TYPE testing.T:
  GO.link/src/testing/testing.go
TYPE testing.TB:
  GO.link/src/testing/testing.go
TYPE textproto.Conn:
  GO.link/src/net/textproto/textproto.go
TYPE textproto.Error:
  GO.link/src/net/textproto/textproto.go
TYPE textproto.MIMEHeader:
  GO.link/src/net/textproto/header.go
TYPE textproto.Pipeline:
  GO.link/src/net/textproto/pipeline.go
TYPE textproto.ProtocolError:
  GO.link/src/net/textproto/textproto.go
TYPE textproto.Reader:
  GO.link/src/net/textproto/reader.go
TYPE textproto.Writer:
  GO.link/src/net/textproto/writer.go
TYPE time.Duration:
  GO.link/src/time/time.go
TYPE time.Location:
  GO.link/src/time/zoneinfo.go
TYPE time.Month:
  GO.link/src/time/time.go
TYPE time.ParseError:
  GO.link/src/time/format.go
TYPE time.Ticker:
  GO.link/src/time/tick.go
TYPE time.Time:
  GO.link/src/time/time.go
TYPE time.Timer:
  GO.link/src/time/sleep.go
TYPE time.Weekday:
  GO.link/src/time/time.go
TYPE tls.Certificate:
  GO.link/src/crypto/tls/common.go
TYPE tls.CertificateRequestInfo:
  GO.link/src/crypto/tls/common.go
TYPE tls.ClientAuthType:
  GO.link/src/crypto/tls/common.go
TYPE tls.ClientHelloInfo:
  GO.link/src/crypto/tls/common.go
TYPE tls.ClientSessionCache:
  GO.link/src/crypto/tls/common.go
TYPE tls.ClientSessionState:
  GO.link/src/crypto/tls/common.go
TYPE tls.Config:
  GO.link/src/crypto/tls/common.go
TYPE tls.Conn:
  GO.link/src/crypto/tls/conn.go
TYPE tls.ConnectionState:
  GO.link/src/crypto/tls/common.go
TYPE tls.CurveID:
  GO.link/src/crypto/tls/common.go
TYPE tls.RecordHeaderError:
  GO.link/src/crypto/tls/conn.go
TYPE tls.RenegotiationSupport:
  GO.link/src/crypto/tls/common.go
TYPE tls.SignatureScheme:
  GO.link/src/crypto/tls/common.go
TYPE token.File:
  GO.link/src/go/token/position.go
TYPE token.FileSet:
  GO.link/src/go/token/position.go
TYPE token.Pos:
  GO.link/src/go/token/position.go
TYPE token.Position:
  GO.link/src/go/token/position.go
TYPE token.Token:
  GO.link/src/go/token/token.go
TYPE trace.Region:
  GO.link/src/runtime/trace/annotation.go
TYPE trace.Task:
  GO.link/src/runtime/trace/annotation.go
TYPE types.Array:
  GO.link/src/go/types/type.go
TYPE types.Basic:
  GO.link/src/go/types/type.go
TYPE types.BasicInfo:
  GO.link/src/go/types/type.go
TYPE types.BasicKind:
  GO.link/src/go/types/type.go
TYPE types.Builtin:
  GO.link/src/go/types/object.go
TYPE types.Chan:
  GO.link/src/go/types/type.go
TYPE types.ChanDir:
  GO.link/src/go/types/type.go
TYPE types.Checker:
  GO.link/src/go/types/check.go
TYPE types.Config:
  GO.link/src/go/types/api.go
TYPE types.Const:
  GO.link/src/go/types/object.go
TYPE types.Error:
  GO.link/src/go/types/api.go
TYPE types.Func:
  GO.link/src/go/types/object.go
TYPE types.ImportMode:
  GO.link/src/go/types/api.go
TYPE types.Importer:
  GO.link/src/go/types/api.go
TYPE types.ImporterFrom:
  GO.link/src/go/types/api.go
TYPE types.Info:
  GO.link/src/go/types/api.go
TYPE types.Initializer:
  GO.link/src/go/types/api.go
TYPE types.Interface:
  GO.link/src/go/types/type.go
TYPE types.Label:
  GO.link/src/go/types/object.go
TYPE types.Map:
  GO.link/src/go/types/type.go
TYPE types.MethodSet:
  GO.link/src/go/types/methodset.go
TYPE types.Named:
  GO.link/src/go/types/type.go
TYPE types.Nil:
  GO.link/src/go/types/object.go
TYPE types.Object:
  GO.link/src/go/types/object.go
TYPE types.Package:
  GO.link/src/go/types/package.go
TYPE types.PkgName:
  GO.link/src/go/types/object.go
TYPE types.Pointer:
  GO.link/src/go/types/type.go
TYPE types.Qualifier:
  GO.link/src/go/types/typestring.go
TYPE types.Scope:
  GO.link/src/go/types/scope.go
TYPE types.Selection:
  GO.link/src/go/types/selection.go
TYPE types.SelectionKind:
  GO.link/src/go/types/selection.go
TYPE types.Signature:
  GO.link/src/go/types/type.go
TYPE types.Sizes:
  GO.link/src/go/types/sizes.go
TYPE types.Slice:
  GO.link/src/go/types/type.go
TYPE types.StdSizes:
  GO.link/src/go/types/sizes.go
TYPE types.Struct:
  GO.link/src/go/types/type.go
TYPE types.Tuple:
  GO.link/src/go/types/type.go
TYPE types.Type:
  GO.link/src/go/types/type.go
TYPE types.TypeAndValue:
  GO.link/src/go/types/api.go
TYPE types.TypeName:
  GO.link/src/go/types/object.go
TYPE types.Var:
  GO.link/src/go/types/object.go
TYPE unicode.CaseRange:
  GO.link/src/unicode/letter.go
TYPE unicode.Range16:
  GO.link/src/unicode/letter.go
TYPE unicode.Range32:
  GO.link/src/unicode/letter.go
TYPE unicode.RangeTable:
  GO.link/src/unicode/letter.go
TYPE unicode.SpecialCase:
  GO.link/src/unicode/letter.go
TYPE unsafe.ArbitraryType:
  GO.link/src/unsafe/unsafe.go
TYPE unsafe.Pointer:
  GO.link/src/unsafe/unsafe.go
TYPE url.Error:
  GO.link/src/net/url/url.go
TYPE url.EscapeError:
  GO.link/src/net/url/url.go
TYPE url.InvalidHostError:
  GO.link/src/net/url/url.go
TYPE url.URL:
  GO.link/src/net/url/url.go
TYPE url.Userinfo:
  GO.link/src/net/url/url.go
TYPE url.Values:
  GO.link/src/net/url/url.go
TYPE user.Group:
  GO.link/src/os/user/user.go
TYPE user.UnknownGroupError:
  GO.link/src/os/user/user.go
TYPE user.UnknownGroupIdError:
  GO.link/src/os/user/user.go
TYPE user.UnknownUserError:
  GO.link/src/os/user/user.go
TYPE user.UnknownUserIdError:
  GO.link/src/os/user/user.go
TYPE user.User:
  GO.link/src/os/user/user.go
TYPE x509.CertPool:
  GO.link/src/crypto/x509/cert_pool.go
TYPE x509.Certificate:
  GO.link/src/crypto/x509/x509.go
TYPE x509.CertificateInvalidError:
  GO.link/src/crypto/x509/verify.go
TYPE x509.CertificateRequest:
  GO.link/src/crypto/x509/x509.go
TYPE x509.ConstraintViolationError:
  GO.link/src/crypto/x509/x509.go
TYPE x509.ExtKeyUsage:
  GO.link/src/crypto/x509/x509.go
TYPE x509.HostnameError:
  GO.link/src/crypto/x509/verify.go
TYPE x509.InsecureAlgorithmError:
  GO.link/src/crypto/x509/x509.go
TYPE x509.InvalidReason:
  GO.link/src/crypto/x509/verify.go
TYPE x509.KeyUsage:
  GO.link/src/crypto/x509/x509.go
TYPE x509.PEMCipher:
  GO.link/src/crypto/x509/pem_decrypt.go
TYPE x509.PublicKeyAlgorithm:
  GO.link/src/crypto/x509/x509.go
TYPE x509.SignatureAlgorithm:
  GO.link/src/crypto/x509/x509.go
TYPE x509.SystemRootsError:
  GO.link/src/crypto/x509/verify.go
TYPE x509.UnhandledCriticalExtension:
  GO.link/src/crypto/x509/x509.go
TYPE x509.UnknownAuthorityError:
  GO.link/src/crypto/x509/verify.go
TYPE x509.VerifyOptions:
  GO.link/src/crypto/x509/verify.go
TYPE xml.Attr:
  GO.link/src/encoding/xml/xml.go
TYPE xml.CharData:
  GO.link/src/encoding/xml/xml.go
TYPE xml.Comment:
  GO.link/src/encoding/xml/xml.go
TYPE xml.Decoder:
  GO.link/src/encoding/xml/xml.go
TYPE xml.Directive:
  GO.link/src/encoding/xml/xml.go
TYPE xml.Encoder:
  GO.link/src/encoding/xml/marshal.go
TYPE xml.EndElement:
  GO.link/src/encoding/xml/xml.go
TYPE xml.Marshaler:
  GO.link/src/encoding/xml/marshal.go
TYPE xml.MarshalerAttr:
  GO.link/src/encoding/xml/marshal.go
TYPE xml.Name:
  GO.link/src/encoding/xml/xml.go
TYPE xml.ProcInst:
  GO.link/src/encoding/xml/xml.go
TYPE xml.StartElement:
  GO.link/src/encoding/xml/xml.go
TYPE xml.SyntaxError:
  GO.link/src/encoding/xml/xml.go
TYPE xml.TagPathError:
  GO.link/src/encoding/xml/typeinfo.go
TYPE xml.Token:
  GO.link/src/encoding/xml/xml.go
TYPE xml.TokenReader:
  GO.link/src/encoding/xml/xml.go
TYPE xml.UnmarshalError:
  GO.link/src/encoding/xml/read.go
TYPE xml.Unmarshaler:
  GO.link/src/encoding/xml/read.go
TYPE xml.UnmarshalerAttr:
  GO.link/src/encoding/xml/read.go
TYPE xml.UnsupportedTypeError:
  GO.link/src/encoding/xml/marshal.go
TYPE zip.Compressor:
  GO.link/src/archive/zip/register.go
TYPE zip.Decompressor:
  GO.link/src/archive/zip/register.go
TYPE zip.File:
  GO.link/src/archive/zip/reader.go
TYPE zip.FileHeader:
  GO.link/src/archive/zip/struct.go
TYPE zip.ReadCloser:
  GO.link/src/archive/zip/reader.go
TYPE zip.Reader:
  GO.link/src/archive/zip/reader.go
TYPE zip.Writer:
  GO.link/src/archive/zip/writer.go
TYPE zlib.Resetter:
  GO.link/src/compress/zlib/reader.go
TYPE zlib.Writer:
  GO.link/src/compress/zlib/writer.go
JOKER FUNC adler32.Checksum has:
;; (defn ^Int Checksum
;;   "Checksum returns the Adler-32 checksum of data.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "adler32.Checksum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/hash/adler32/adler32.go:134:20) data])

JOKER FUNC adler32.New has:
;; (defn New
;;   "New returns a new hash.Hash32 computing the Adler-32 checksum. Its\nSum method will lay the value out in big-endian byte order. The\nreturned Hash32 also implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/hash/adler32/adler32.go:43:12)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC aes.NewCipher has:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\nThe key argument should be the AES key,\neither 16, 24, or 32 bytes to select\nAES-128, AES-192, or AES-256.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/aes/cipher.go:32:29) Error]"
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/aes/cipher.go:32:20) key])

JOKER FUNC ascii85.Decode has:
;; (defn Decode
;;   "Decode decodes src into dst, returning both the number\nof bytes written to dst and the number consumed from src.\nIf src contains invalid ascii85 data, Decode will return the\nnumber of bytes successfully written and a CorruptInputError.\nDecode ignores space and control characters in src.\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nDecode expects these to have been stripped by the caller.\n\nIf flush is true, Decode assumes that src represents the\nend of the input stream and processes it completely rather\nthan wait for the completion of another 32-bit block.\n\nNewDecoder wraps an io.Reader interface around Decode.\n\nGo return type: (ndst int, nsrc int, err error)\n\nJoker return type: [Int Int Error]"
;;   {:added "1.0"
;;    :go "decode(dst, src, flush)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/ascii85/ascii85.go:189:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/ascii85/ascii85.go:189:22) src, ^Bool flush])

JOKER FUNC ascii85.Encode has:
;; (defn ^Int Encode
;;   "Encode encodes src into at most MaxEncodedLen(len(src))\nbytes of dst, returning the actual number of bytes written.\n\nThe encoding handles 4-byte chunks, using a special encoding\nfor the last fragment, so Encode is not appropriate for use on\nindividual blocks of a large data stream. Use NewEncoder() instead.\n\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nEncode does not add these.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "ascii85.Encode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/ascii85/ascii85.go:27:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/ascii85/ascii85.go:27:22) src])

JOKER FUNC ascii85.MaxEncodedLen has:
(defn ^Int MaxEncodedLen
  "MaxEncodedLen returns the maximum length of an encoding of n source bytes.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "ascii85.MaxEncodedLen(n)"}
  [^Int n])

JOKER FUNC ascii85.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder constructs a new ascii85 stream decoder.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/ascii85/ascii85.go:246:30)"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/ascii85/ascii85.go:246:19) r])

JOKER FUNC ascii85.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new ascii85 stream encoder. Data written to\nthe returned writer will be encoded and then written to w.\nAscii85 encodings operate in 32-bit blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\ntrailing partial block.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/ascii85/ascii85.go:93:30)"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/ascii85/ascii85.go:93:19) w])

JOKER FUNC asn1.Marshal has:
;; (defn Marshal
;;   "Marshal returns the ASN.1 encoding of val.\n\nIn addition to the struct tags recognised by Unmarshal, the following can be\nused:\n\n\tia5:         causes strings to be marshaled as ASN.1, IA5String values\n\tomitempty:   causes empty slices to be skipped\n\tprintable:   causes strings to be marshaled as ASN.1, PrintableString values\n\tutf8:        causes strings to be marshaled as ASN.1, UTF8String values\n\tutc:         causes time.Time to be marshaled as ASN.1, UTCTime values\n\tgeneralized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshal(val)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/asn1/marshal.go:677:18) val])

JOKER FUNC asn1.MarshalWithParams has:
;; (defn MarshalWithParams
;;   "MarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalWithParams(val, params)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/asn1/marshal.go:683:28) val, ^String params])

JOKER FUNC asn1.Unmarshal has:
;; (defn Unmarshal
;;   "Unmarshal parses the DER-encoded ASN.1 data structure b\nand uses the reflect package to fill in an arbitrary value pointed at by val.\nBecause Unmarshal uses the reflect package, the structs\nbeing written to must use upper case field names.\n\nAn ASN.1 INTEGER can be written to an int, int32, int64,\nor *big.Int (from the math/big package).\nIf the encoded value does not fit in the Go type,\nUnmarshal returns a parse error.\n\nAn ASN.1 BIT STRING can be written to a BitString.\n\nAn ASN.1 OCTET STRING can be written to a []byte.\n\nAn ASN.1 OBJECT IDENTIFIER can be written to an\nObjectIdentifier.\n\nAn ASN.1 ENUMERATED can be written to an Enumerated.\n\nAn ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.\n\nAn ASN.1 PrintableString, IA5String, or NumericString can be written to a string.\n\nAny of the above ASN.1 values can be written to an interface{}.\nThe value stored in the interface has the corresponding Go type.\nFor integers, that type is int64.\n\nAn ASN.1 SEQUENCE OF x or SET OF x can be written\nto a slice if an x can be written to the slice's element type.\n\nAn ASN.1 SEQUENCE or SET can be written to a struct\nif each of the elements in the sequence can be\nwritten to the corresponding element in the struct.\n\nThe following tags on struct fields have special meaning to Unmarshal:\n\n\tapplication specifies that an APPLICATION tag is used\n\tprivate     specifies that a PRIVATE tag is used\n\tdefault:x   sets the default value for optional integer fields (only used if optional is also present)\n\texplicit    specifies that an additional, explicit tag wraps the implicit one\n\toptional    marks the field as ASN.1 OPTIONAL\n\tset         causes a SET, rather than a SEQUENCE type to be expected\n\ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n\nIf the type of the first field of a structure is RawContent then the raw\nASN1 contents of the struct will be stored in it.\n\nIf the type name of a slice element ends with \"SET\" then it's treated as if\nthe \"set\" tag was set on it. This can be used with nested slices where a\nstruct tag cannot be given.\n\nOther ASN.1 types are not supported; if it encounters them,\nUnmarshal returns a parse error.\n\nGo return type: (rest []int, err error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "unmarshal(b, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/asn1/asn1.go:1053:18) b, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/asn1/asn1.go:1053:30) val])

JOKER FUNC asn1.UnmarshalWithParams has:
;; (defn UnmarshalWithParams
;;   "UnmarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo return type: (rest []int, err error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "unmarshalWithParams(b, val, params)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/asn1/asn1.go:1059:28) b, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/asn1/asn1.go:1059:40) val, ^String params])

JOKER FUNC ast.FileExports has:
;; (defn ^Bool FileExports
;;   "FileExports trims the AST for a Go source file in place such that\nonly exported nodes remain: all top-level identifiers which are not exported\nand their associated information (such as type, initial value, or function\nbody) are removed. Non-exported fields and methods of exported types are\nstripped. The File.Comments list is not changed.\n\nFileExports reports whether there are exported declarations.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FileExports(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/filter.go:28:22) src])

JOKER FUNC ast.FilterDecl has:
;; (defn ^Bool FilterDecl
;;   "FilterDecl trims the AST for a Go declaration in place by removing\nall names (including struct field and interface method names, but\nnot from parameter lists) that don't pass through the filter f.\n\nFilterDecl reports whether there are any declared names left after\nfiltering.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FilterDecl(decl, f)"}
;;   [^ABEND885(unrecognized type Decl at: GO.link/src/go/ast/filter.go:233:22) decl, ^ABEND885(unrecognized type Filter at: GO.link/src/go/ast/filter.go:233:30) f])

JOKER FUNC ast.FilterFile has:
;; (defn ^Bool FilterFile
;;   "FilterFile trims the AST for a Go file in place by removing all\nnames from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. Import declarations are\nalways removed. The File.Comments list is not changed.\n\nFilterFile reports whether there are any top-level declarations\nleft after filtering.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FilterFile(src, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/filter.go:258:21) src, ^ABEND885(unrecognized type Filter at: GO.link/src/go/ast/filter.go:258:30) f])

JOKER FUNC ast.FilterPackage has:
;; (defn ^Bool FilterPackage
;;   "FilterPackage trims the AST for a Go package in place by removing\nall names from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. The pkg.Files list is not\nchanged, so that file names and top-level package comments don't get\nlost.\n\nFilterPackage reports whether there are any top-level declarations\nleft after filtering.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FilterPackage(pkg, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/filter.go:285:24) pkg, ^ABEND885(unrecognized type Filter at: GO.link/src/go/ast/filter.go:285:36) f])

JOKER FUNC ast.Fprint has:
;; (defn ^Error Fprint
;;   "Fprint prints the (sub-)tree starting at AST node x to w.\nIf fset != nil, position information is interpreted relative\nto that file set. Otherwise positions are printed as integer\nvalues (file set specific offsets).\n\nA non-nil FieldFilter f may be provided to control the output:\nstruct fields for which f(fieldname, fieldvalue) is true are\nprinted; all others are filtered from the output. Unexported\nstruct fields are never printed.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Fprint(w, fset, x, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/print.go:39:15) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/print.go:39:31) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/print.go:39:49) x, ^ABEND885(unrecognized type FieldFilter at: GO.link/src/go/ast/print.go:39:64) f])

JOKER FUNC ast.Inspect has:
;; (defn Inspect
;;   "Inspect traverses an AST in depth-first order: It starts by calling\nf(node); node must not be nil. If f returns true, Inspect invokes f\nrecursively for each of the non-nil children of node, followed by a\ncall of f(nil).\n"
;;   {:added "1.0"
;;    :go "inspect(node, f)"}
;;   [^ABEND885(unrecognized type Node at: GO.link/src/go/ast/walk.go:384:19) node, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/go/ast/walk.go:384:27) f])

JOKER FUNC ast.IsExported has:
(defn ^Bool IsExported
  "IsExported reports whether name is an exported Go symbol\n(that is, whether it begins with an upper-case letter).\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "ast.IsExported(name)"}
  [^String name])

JOKER FUNC ast.MergePackageFiles has:
;; (defn MergePackageFiles
;;   "MergePackageFiles creates a file AST by merging the ASTs of the\nfiles belonging to a package. The mode flags control merging behavior.\n\nGo return type: *File\n\nJoker return type: {:Doc ^{:List ^(vector-of {:Slash ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:63:8), :Text ^String})}, :Package ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:988:13), :Name ^{:NamePos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:241:11), :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:81:7)}}, :Decls ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/ast.go:53:11)), :Scope ^{:Outer ^ABEND947(recursive type reference involving ast.Scope), :Objects ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/scope.go:21:10)}, :Imports ^(vector-of {:Doc ^{:List ^(vector-of {:Slash ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:63:8), :Text ^String})}, :Name ^{:NamePos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:241:11), :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:81:7)}}, :Path ^{:ValuePos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:256:12), :Kind ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:257:12), :Value ^String}, :Comment ^{:List ^(vector-of {:Slash ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:63:8), :Text ^String})}, :EndPos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:836:11)}), :Unresolved ^(vector-of {:NamePos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:241:11), :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:81:7)}}), :Comments ^(vector-of {:List ^(vector-of {:Slash ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:63:8), :Text ^String})})}"
;;   {:added "1.0"
;;    :go "mergePackageFiles(pkg, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/filter.go:344:28) pkg, ^ABEND885(unrecognized type MergeMode at: GO.link/src/go/ast/filter.go:344:43) mode])

JOKER FUNC ast.NewCommentMap has:
;; (defn NewCommentMap
;;   "NewCommentMap creates a new comment map by associating comment groups\nof the comments list with the nodes of the AST specified by node.\n\nA comment group g is associated with a node n if:\n\n  - g starts on the same line as n ends\n  - g starts on the line immediately following n, and there is\n    at least one empty line after g and before the next node\n  - g starts before n and is not associated to the node before n\n    via the previous rules\n\nNewCommentMap tries to associate a comment group to the \"largest\"\nnode possible: For instance, if the comment is a line comment\ntrailing an assignment, the comment is associated with the entire\nassignment rather than just the last operand in the assignment.\n\nGo return type: CommentMap\n\nJoker return type: ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/commentmap.go:35:17)"
;;   {:added "1.0"
;;    :go "newCommentMap(fset, node, comments)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/commentmap.go:143:25) fset, ^ABEND885(unrecognized type Node at: GO.link/src/go/ast/commentmap.go:143:46) node, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/ast/commentmap.go:143:61) comments])

JOKER FUNC ast.NewIdent has:
;; (defn NewIdent
;;   "NewIdent creates a new Ident without position.\nUseful for ASTs generated by code other than the Go parser.\n\nGo return type: *Ident\n\nJoker return type: {:NamePos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/ast.go:241:11), :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:81:7)}}"
;;   {:added "1.0"
;;    :go "newIdent(name)"}
;;   [^String name])

JOKER FUNC ast.NewObj has:
;; (defn NewObj
;;   "NewObj creates a new object of a given kind and name.\n\nGo return type: *Object\n\nJoker return type: {:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:81:7)}"
;;   {:added "1.0"
;;    :go "newObj(kind, name)"}
;;   [^ABEND885(unrecognized type ObjKind at: GO.link/src/go/ast/scope.go:85:18) kind, ^String name])

JOKER FUNC ast.NewPackage has:
;; (defn NewPackage
;;   "NewPackage creates a new Package node from a set of File nodes. It resolves\nunresolved identifiers across files and updates each file's Unresolved list\naccordingly. If a non-nil importer and universe scope are provided, they are\nused to resolve identifiers not declared in any of the package files. Any\nremaining unresolved identifiers are reported as undeclared. If the files\nbelong to different packages, one package name is selected and files with\ndifferent package names are reported and then ignored.\nThe result is a package node and a scanner.ErrorList if there were errors.\n\nGo return type: (*Package, error)\n\nJoker return type: [{:Name ^String, :Scope ^{:Outer ^ABEND947(recursive type reference involving ast.Scope), :Objects ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/scope.go:21:10)}, :Imports ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/ast.go:1011:10), :Files ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/ast.go:1012:10)} Error]"
;;   {:added "1.0"
;;    :go "newPackage(fset, files, importer, universe)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/resolve.go:74:22) fset, ^ABEND881(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/resolve.go:74:44) files, ^ABEND885(unrecognized type Importer at: GO.link/src/go/ast/resolve.go:74:71) importer, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/resolve.go:74:90) universe])

JOKER FUNC ast.NewScope has:
;; (defn NewScope
;;   "NewScope creates a new scope nested in the outer scope.\n\nGo return type: *Scope\n\nJoker return type: {:Outer ^ABEND947(recursive type reference involving ast.Scope), :Objects ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/scope.go:21:10)}"
;;   {:added "1.0"
;;    :go "newScope(outer)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/scope.go:25:21) outer])

JOKER FUNC ast.NotNilFilter has:
;; (defn ^Bool NotNilFilter
;;   "NotNilFilter returns true for field values that are not nil;\nit returns false otherwise.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.NotNilFilter(_, v)"}
;;   [^String _, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/ast/print.go:22:31) v])

JOKER FUNC ast.PackageExports has:
;; (defn ^Bool PackageExports
;;   "PackageExports trims the AST for a Go package in place such that\nonly exported nodes remain. The pkg.Files list is not changed, so that\nfile names and top-level package comments don't get lost.\n\nPackageExports reports whether there are exported declarations;\nit returns false otherwise.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.PackageExports(pkg)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/filter.go:39:25) pkg])

JOKER FUNC ast.Print has:
;; (defn ^Error Print
;;   "Print prints x to standard output, skipping nil fields.\nPrint(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Print(fset, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/print.go:73:17) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/print.go:73:35) x])

JOKER FUNC ast.SortImports has:
;; (defn SortImports
;;   "SortImports sorts runs of consecutive import lines in import blocks in f.\nIt also removes duplicate imports when it is possible to do so without data loss.\n"
;;   {:added "1.0"
;;    :go "sortImports(fset, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/import.go:15:23) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/import.go:15:41) f])

JOKER FUNC ast.Walk has:
;; (defn Walk
;;   "Walk traverses an AST in depth-first order: It starts by calling\nv.Visit(node); node must not be nil. If the visitor w returned by\nv.Visit(node) is not nil, Walk is invoked recursively with visitor\nw for each of the non-nil children of node, followed by a call of\nw.Visit(nil).\n"
;;   {:added "1.0"
;;    :go "walk(v, node)"}
;;   [^ABEND885(unrecognized type Visitor at: GO.link/src/go/ast/walk.go:51:13) v, ^ABEND885(unrecognized type Node at: GO.link/src/go/ast/walk.go:51:27) node])

JOKER FUNC atomic.AddInt32 has:
;; (defn ^Int AddInt32
;;   "AddInt32 atomically adds delta to *addr and returns the new value.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "atomic.AddInt32(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:92:20) addr, ^Int delta])

JOKER FUNC atomic.AddInt64 has:
;; (defn ^Int AddInt64
;;   "AddInt64 atomically adds delta to *addr and returns the new value.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "atomic.AddInt64(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:100:20) addr, ^Int delta])

JOKER FUNC atomic.AddUint32 has:
;; (defn ^Int AddUint32
;;   "AddUint32 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)).\nIn particular, to decrement x, do AddUint32(&x, ^uint32(0)).\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "atomic.AddUint32(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:97:21) addr, ^Int delta])

JOKER FUNC atomic.AddUint64 has:
;; (defn AddUint64
;;   "AddUint64 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)).\nIn particular, to decrement x, do AddUint64(&x, ^uint64(0)).\n\nGo return type: uint64\n\nJoker return type: ABEND042(cannot find typename atomic.uint64)"
;;   {:added "1.0"
;;    :go "addUint64(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:105:21) addr, ^ABEND885(unrecognized type uint64 at: GO.link/src/sync/atomic/doc.go:105:36) delta])

JOKER FUNC atomic.AddUintptr has:
;; (defn AddUintptr
;;   "AddUintptr atomically adds delta to *addr and returns the new value.\n\nGo return type: uintptr\n\nJoker return type: ABEND042(cannot find typename atomic.uintptr)"
;;   {:added "1.0"
;;    :go "addUintptr(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:108:22) addr, ^ABEND885(unrecognized type uintptr at: GO.link/src/sync/atomic/doc.go:108:38) delta])

JOKER FUNC atomic.CompareAndSwapInt32 has:
;; (defn ^Bool CompareAndSwapInt32
;;   "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt32(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:74:31) addr, ^Int old, ^Int new])

JOKER FUNC atomic.CompareAndSwapInt64 has:
;; (defn ^Bool CompareAndSwapInt64
;;   "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt64(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:77:31) addr, ^Int old, ^Int new])

JOKER FUNC atomic.CompareAndSwapPointer has:
;; (defn ^Bool CompareAndSwapPointer
;;   "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapPointer(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:89:33) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/sync/atomic/doc.go:89:59) old, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/sync/atomic/doc.go:89:59) new])

JOKER FUNC atomic.CompareAndSwapUint32 has:
;; (defn ^Bool CompareAndSwapUint32
;;   "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint32(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:80:32) addr, ^Int old, ^Int new])

JOKER FUNC atomic.CompareAndSwapUint64 has:
;; (defn ^Bool CompareAndSwapUint64
;;   "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint64(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:83:32) addr, ^ABEND885(unrecognized type uint64 at: GO.link/src/sync/atomic/doc.go:83:50) old, ^ABEND885(unrecognized type uint64 at: GO.link/src/sync/atomic/doc.go:83:50) new])

JOKER FUNC atomic.CompareAndSwapUintptr has:
;; (defn ^Bool CompareAndSwapUintptr
;;   "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUintptr(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:86:33) addr, ^ABEND885(unrecognized type uintptr at: GO.link/src/sync/atomic/doc.go:86:52) old, ^ABEND885(unrecognized type uintptr at: GO.link/src/sync/atomic/doc.go:86:52) new])

JOKER FUNC atomic.LoadInt32 has:
;; (defn ^Int LoadInt32
;;   "LoadInt32 atomically loads *addr.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "atomic.LoadInt32(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:111:21) addr])

JOKER FUNC atomic.LoadInt64 has:
;; (defn ^Int LoadInt64
;;   "LoadInt64 atomically loads *addr.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "atomic.LoadInt64(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:114:21) addr])

JOKER FUNC atomic.LoadPointer has:
;; (defn LoadPointer
;;   "LoadPointer atomically loads *addr.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/sync/atomic/doc.go:126:45)"
;;   {:added "1.0"
;;    :go "loadPointer(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:126:23) addr])

JOKER FUNC atomic.LoadUint32 has:
;; (defn ^Int LoadUint32
;;   "LoadUint32 atomically loads *addr.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "atomic.LoadUint32(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:117:22) addr])

JOKER FUNC atomic.LoadUint64 has:
;; (defn LoadUint64
;;   "LoadUint64 atomically loads *addr.\n\nGo return type: uint64\n\nJoker return type: ABEND042(cannot find typename atomic.uint64)"
;;   {:added "1.0"
;;    :go "loadUint64(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:120:22) addr])

JOKER FUNC atomic.LoadUintptr has:
;; (defn LoadUintptr
;;   "LoadUintptr atomically loads *addr.\n\nGo return type: uintptr\n\nJoker return type: ABEND042(cannot find typename atomic.uintptr)"
;;   {:added "1.0"
;;    :go "loadUintptr(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:123:23) addr])

JOKER FUNC atomic.StoreInt32 has:
;; (defn StoreInt32
;;   "StoreInt32 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeInt32(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:129:22) addr, ^Int val])

JOKER FUNC atomic.StoreInt64 has:
;; (defn StoreInt64
;;   "StoreInt64 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeInt64(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:132:22) addr, ^Int val])

JOKER FUNC atomic.StorePointer has:
;; (defn StorePointer
;;   "StorePointer atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storePointer(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:144:24) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/sync/atomic/doc.go:144:45) val])

JOKER FUNC atomic.StoreUint32 has:
;; (defn StoreUint32
;;   "StoreUint32 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeUint32(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:135:23) addr, ^Int val])

JOKER FUNC atomic.StoreUint64 has:
;; (defn StoreUint64
;;   "StoreUint64 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeUint64(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:138:23) addr, ^ABEND885(unrecognized type uint64 at: GO.link/src/sync/atomic/doc.go:138:36) val])

JOKER FUNC atomic.StoreUintptr has:
;; (defn StoreUintptr
;;   "StoreUintptr atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeUintptr(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:141:24) addr, ^ABEND885(unrecognized type uintptr at: GO.link/src/sync/atomic/doc.go:141:38) val])

JOKER FUNC atomic.SwapInt32 has:
;; (defn ^Int SwapInt32
;;   "SwapInt32 atomically stores new into *addr and returns the previous *addr value.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "atomic.SwapInt32(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:56:21) addr, ^Int new])

JOKER FUNC atomic.SwapInt64 has:
;; (defn ^Int SwapInt64
;;   "SwapInt64 atomically stores new into *addr and returns the previous *addr value.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "atomic.SwapInt64(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:59:21) addr, ^Int new])

JOKER FUNC atomic.SwapPointer has:
;; (defn SwapPointer
;;   "SwapPointer atomically stores new into *addr and returns the previous *addr value.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/sync/atomic/doc.go:71:65)"
;;   {:added "1.0"
;;    :go "swapPointer(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:71:23) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/sync/atomic/doc.go:71:44) new])

JOKER FUNC atomic.SwapUint32 has:
;; (defn ^Int SwapUint32
;;   "SwapUint32 atomically stores new into *addr and returns the previous *addr value.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "atomic.SwapUint32(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:62:22) addr, ^Int new])

JOKER FUNC atomic.SwapUint64 has:
;; (defn SwapUint64
;;   "SwapUint64 atomically stores new into *addr and returns the previous *addr value.\n\nGo return type: uint64\n\nJoker return type: ABEND042(cannot find typename atomic.uint64)"
;;   {:added "1.0"
;;    :go "swapUint64(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:65:22) addr, ^ABEND885(unrecognized type uint64 at: GO.link/src/sync/atomic/doc.go:65:35) new])

JOKER FUNC atomic.SwapUintptr has:
;; (defn SwapUintptr
;;   "SwapUintptr atomically stores new into *addr and returns the previous *addr value.\n\nGo return type: uintptr\n\nJoker return type: ABEND042(cannot find typename atomic.uintptr)"
;;   {:added "1.0"
;;    :go "swapUintptr(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:68:23) addr, ^ABEND885(unrecognized type uintptr at: GO.link/src/sync/atomic/doc.go:68:37) new])

JOKER FUNC base32.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base32 stream decoder.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base32/base32.go:530:45)"
;;   {:added "1.0"
;;    :go "newDecoder(enc, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/base32/base32.go:530:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base32/base32.go:530:34) r])

JOKER FUNC base32.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new base32 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase32 encodings operate in 5-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base32/base32.go:259:45)"
;;   {:added "1.0"
;;    :go "newEncoder(enc, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/base32/base32.go:259:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base32/base32.go:259:34) w])

JOKER FUNC base32.NewEncoding has:
;; (defn NewEncoding
;;   "NewEncoding returns a new Encoding defined by the given alphabet,\nwhich must be a 32-byte string.\n\nGo return type: *Encoding\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newEncoding(encoder)"}
;;   [^String encoder])

JOKER FUNC base64.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base64 stream decoder.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base64/base64.go:603:45)"
;;   {:added "1.0"
;;    :go "newDecoder(enc, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/base64/base64.go:603:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base64/base64.go:603:34) r])

JOKER FUNC base64.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new base64 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase64 encodings operate in 4-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base64/base64.go:250:45)"
;;   {:added "1.0"
;;    :go "newEncoder(enc, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/base64/base64.go:250:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base64/base64.go:250:34) w])

JOKER FUNC base64.NewEncoding has:
;; (defn NewEncoding
;;   "NewEncoding returns a new padded Encoding defined by the given alphabet,\nwhich must be a 64-byte string that does not contain the padding character\nor CR / LF ('\\r', '\\n').\nThe resulting Encoding uses the default padding character ('='),\nwhich may be changed or disabled via WithPadding.\n\nGo return type: *Encoding\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newEncoding(encoder)"}
;;   [^String encoder])

JOKER FUNC big.Jacobi has:
;; (defn ^Int Jacobi
;;   "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.\nThe y argument must be an odd integer.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "big.Jacobi(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/math/big/int.go:760:18) x, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/math/big/int.go:760:18) y])

JOKER FUNC big.NewFloat has:
;; (defn NewFloat
;;   "NewFloat allocates and returns a new Float set to x,\nwith precision 53 and rounding mode ToNearestEven.\nNewFloat panics with ErrNaN if x is a NaN.\n\nGo return type: *Float\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newFloat(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/big/float.go:82:17) x])

JOKER FUNC big.NewInt has:
;; (defn NewInt
;;   "NewInt allocates and returns a new Int set to x.\n\nGo return type: *Int\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newInt(x)"}
;;   [^Int x])

JOKER FUNC big.NewRat has:
;; (defn NewRat
;;   "NewRat creates a new Rat with numerator a and denominator b.\n\nGo return type: *Rat\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newRat(a, b)"}
;;   [^Int a, ^Int b])

JOKER FUNC big.ParseFloat has:
;; (defn ParseFloat
;;   "ParseFloat is like f.Parse(s, base) with f set to the given precision\nand rounding mode.\n\nGo return type: (f *Float, b int, err error)\n\nJoker return type: [{} Int Error]"
;;   {:added "1.0"
;;    :go "parseFloat(s, base, prec, mode)"}
;;   [^String s, ^Int base, ^Int prec, ^ABEND885(unrecognized type RoundingMode at: GO.link/src/math/big/floatconv.go:278:53) mode])

JOKER FUNC binary.PutUvarint has:
;; (defn ^Int PutUvarint
;;   "PutUvarint encodes a uint64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutUvarint will panic.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutUvarint(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/binary/varint.go:41:21) buf, ^ABEND885(unrecognized type uint64 at: GO.link/src/encoding/binary/varint.go:41:31) x])

JOKER FUNC binary.PutVarint has:
;; (defn ^Int PutVarint
;;   "PutVarint encodes an int64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutVarint will panic.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutVarint(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/binary/varint.go:78:20) buf, ^Int x])

JOKER FUNC binary.Read has:
;; (defn ^Error Read
;;   "Read reads structured binary data from r into data.\nData must be a pointer to a fixed-size value or a slice\nof fixed-size values.\nBytes read from r are decoded using the specified byte order\nand written to successive fields of the data.\nWhen decoding boolean values, a zero byte is decoded as false, and\nany other non-zero byte is decoded as true.\nWhen reading into structs, the field data for fields with\nblank (_) field names is skipped; i.e., blank field names\nmay be used for padding.\nWhen reading into a struct, all non-blank fields must be exported\nor Read may panic.\n\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nRead returns ErrUnexpectedEOF.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Read(r, order, data)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/binary/binary.go:161:13) r, ^ABEND885(unrecognized type ByteOrder at: GO.link/src/encoding/binary/binary.go:161:30) order, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/binary/binary.go:161:46) data])

JOKER FUNC binary.ReadUvarint has:
;; (defn ReadUvarint
;;   "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\n\nGo return type: (uint64, error)\n\nJoker return type: [ABEND042(cannot find typename binary.uint64) Error]"
;;   {:added "1.0"
;;    :go "readUvarint(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/binary/varint.go:106:20) r])

JOKER FUNC binary.ReadVarint has:
;; (defn ReadVarint
;;   "ReadVarint reads an encoded signed integer from r and returns it as an int64.\n\nGo return type: (int, error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readVarint(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/binary/varint.go:126:19) r])

JOKER FUNC binary.Size has:
;; (defn ^Int Size
;;   "Size returns how many bytes Write would generate to encode the value v, which\nmust be a fixed-size value or a slice of fixed-size values, or a pointer to such data.\nIf v is neither of these, Size returns -1.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.Size(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/binary/binary.go:374:13) v])

JOKER FUNC binary.Uvarint has:
;; (defn Uvarint
;;   "Uvarint decodes a uint64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo return type: (uint64, int)\n\nJoker return type: [ABEND042(cannot find typename binary.uint64) Int]"
;;   {:added "1.0"
;;    :go "uvarint(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/binary/varint.go:60:18) buf])

JOKER FUNC binary.Varint has:
;; (defn Varint
;;   "Varint decodes an int64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 with the following meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo return type: (int, int)\n\nJoker return type: [Int Int]"
;;   {:added "1.0"
;;    :go "varint(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/binary/varint.go:94:17) buf])

JOKER FUNC binary.Write has:
;; (defn ^Error Write
;;   "Write writes the binary representation of data into w.\nData must be a fixed-size value or a slice of fixed-size\nvalues, or a pointer to such data.\nBoolean values encode as one byte: 1 for true, and 0 for false.\nBytes written to w are encoded using the specified byte order\nand read from successive fields of the data.\nWhen writing structs, zero values are written for fields\nwith blank (_) field names.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Write(w, order, data)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/binary/binary.go:260:14) w, ^ABEND885(unrecognized type ByteOrder at: GO.link/src/encoding/binary/binary.go:260:31) order, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/binary/binary.go:260:47) data])

JOKER FUNC bits.LeadingZeros has:
(defn ^Int LeadingZeros
  "LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros(x)"}
  [^Int x])

JOKER FUNC bits.LeadingZeros16 has:
(defn ^Int LeadingZeros16
  "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros16(x)"}
  [^Int x])

JOKER FUNC bits.LeadingZeros32 has:
(defn ^Int LeadingZeros32
  "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros32(x)"}
  [^Int x])

JOKER FUNC bits.LeadingZeros64 has:
;; (defn ^Int LeadingZeros64
;;   "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.LeadingZeros64(x)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/math/bits/bits.go:31:23) x])

JOKER FUNC bits.LeadingZeros8 has:
;; (defn ^Int LeadingZeros8
;;   "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.LeadingZeros8(x)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/math/bits/bits.go:22:22) x])

JOKER FUNC bits.Len has:
(defn ^Int Len
  "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len(x)"}
  [^Int x])

JOKER FUNC bits.Len16 has:
(defn ^Int Len16
  "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len16(x)"}
  [^Int x])

JOKER FUNC bits.Len32 has:
(defn ^Int Len32
  "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len32(x)"}
  [^Int x])

JOKER FUNC bits.Len64 has:
;; (defn ^Int Len64
;;   "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.Len64(x)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/math/bits/bits.go:316:14) x])

JOKER FUNC bits.Len8 has:
;; (defn ^Int Len8
;;   "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.Len8(x)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/math/bits/bits.go:289:13) x])

JOKER FUNC bits.OnesCount has:
(defn ^Int OnesCount
  "OnesCount returns the number of one bits (\"population count\") in x.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount(x)"}
  [^Int x])

JOKER FUNC bits.OnesCount16 has:
(defn ^Int OnesCount16
  "OnesCount16 returns the number of one bits (\"population count\") in x.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount16(x)"}
  [^Int x])

JOKER FUNC bits.OnesCount32 has:
(defn ^Int OnesCount32
  "OnesCount32 returns the number of one bits (\"population count\") in x.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount32(x)"}
  [^Int x])

JOKER FUNC bits.OnesCount64 has:
;; (defn ^Int OnesCount64
;;   "OnesCount64 returns the number of one bits (\"population count\") in x.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.OnesCount64(x)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/math/bits/bits.go:134:20) x])

JOKER FUNC bits.OnesCount8 has:
;; (defn ^Int OnesCount8
;;   "OnesCount8 returns the number of one bits (\"population count\") in x.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.OnesCount8(x)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/math/bits/bits.go:119:19) x])

JOKER FUNC bits.Reverse has:
(defn ^Int Reverse
  "Reverse returns the value of x with its bits in reversed order.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Reverse(x)"}
  [^Int x])

JOKER FUNC bits.Reverse16 has:
(defn ^Int Reverse16
  "Reverse16 returns the value of x with its bits in reversed order.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Reverse16(x)"}
  [^Int x])

JOKER FUNC bits.Reverse32 has:
(defn ^Int Reverse32
  "Reverse32 returns the value of x with its bits in reversed order.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Reverse32(x)"}
  [^Int x])

JOKER FUNC bits.Reverse64 has:
;; (defn Reverse64
;;   "Reverse64 returns the value of x with its bits in reversed order.\n\nGo return type: uint64\n\nJoker return type: ABEND042(cannot find typename bits.uint64)"
;;   {:added "1.0"
;;    :go "reverse64(x)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/math/bits/bits.go:238:18) x])

JOKER FUNC bits.Reverse8 has:
;; (defn Reverse8
;;   "Reverse8 returns the value of x with its bits in reversed order.\n\nGo return type: uint8\n\nJoker return type: ABEND042(cannot find typename bits.uint8)"
;;   {:added "1.0"
;;    :go "reverse8(x)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/math/bits/bits.go:218:17) x])

JOKER FUNC bits.ReverseBytes has:
(defn ^Int ReverseBytes
  "ReverseBytes returns the value of x with its bytes in reversed order.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.ReverseBytes(x)"}
  [^Int x])

JOKER FUNC bits.ReverseBytes16 has:
(defn ^Int ReverseBytes16
  "ReverseBytes16 returns the value of x with its bytes in reversed order.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.ReverseBytes16(x)"}
  [^Int x])

JOKER FUNC bits.ReverseBytes32 has:
(defn ^Int ReverseBytes32
  "ReverseBytes32 returns the value of x with its bytes in reversed order.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.ReverseBytes32(x)"}
  [^Int x])

JOKER FUNC bits.ReverseBytes64 has:
;; (defn ReverseBytes64
;;   "ReverseBytes64 returns the value of x with its bytes in reversed order.\n\nGo return type: uint64\n\nJoker return type: ABEND042(cannot find typename bits.uint64)"
;;   {:added "1.0"
;;    :go "reverseBytes64(x)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/math/bits/bits.go:271:23) x])

JOKER FUNC bits.RotateLeft has:
(defn ^Int RotateLeft
  "RotateLeft returns the value of x rotated left by (k mod UintSize) bits.\nTo rotate x right by k bits, call RotateLeft(x, -k).\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.RotateLeft(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC bits.RotateLeft16 has:
(defn ^Int RotateLeft16
  "RotateLeft16 returns the value of x rotated left by (k mod 16) bits.\nTo rotate x right by k bits, call RotateLeft16(x, -k).\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.RotateLeft16(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC bits.RotateLeft32 has:
(defn ^Int RotateLeft32
  "RotateLeft32 returns the value of x rotated left by (k mod 32) bits.\nTo rotate x right by k bits, call RotateLeft32(x, -k).\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.RotateLeft32(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC bits.RotateLeft64 has:
;; (defn RotateLeft64
;;   "RotateLeft64 returns the value of x rotated left by (k mod 64) bits.\nTo rotate x right by k bits, call RotateLeft64(x, -k).\n\nGo return type: uint64\n\nJoker return type: ABEND042(cannot find typename bits.uint64)"
;;   {:added "1.0"
;;    :go "rotateLeft64(x, k)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/math/bits/bits.go:201:21) x, ^Int k])

JOKER FUNC bits.RotateLeft8 has:
;; (defn RotateLeft8
;;   "RotateLeft8 returns the value of x rotated left by (k mod 8) bits.\nTo rotate x right by k bits, call RotateLeft8(x, -k).\n\nGo return type: uint8\n\nJoker return type: ABEND042(cannot find typename bits.uint8)"
;;   {:added "1.0"
;;    :go "rotateLeft8(x, k)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/math/bits/bits.go:177:20) x, ^Int k])

JOKER FUNC bits.TrailingZeros has:
(defn ^Int TrailingZeros
  "TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros(x)"}
  [^Int x])

JOKER FUNC bits.TrailingZeros16 has:
(defn ^Int TrailingZeros16
  "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros16(x)"}
  [^Int x])

JOKER FUNC bits.TrailingZeros32 has:
(defn ^Int TrailingZeros32
  "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros32(x)"}
  [^Int x])

JOKER FUNC bits.TrailingZeros64 has:
;; (defn ^Int TrailingZeros64
;;   "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.TrailingZeros64(x)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/math/bits/bits.go:84:24) x])

JOKER FUNC bits.TrailingZeros8 has:
;; (defn ^Int TrailingZeros8
;;   "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.TrailingZeros8(x)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/math/bits/bits.go:61:23) x])

JOKER FUNC bufio.NewReadWriter has:
;; (defn NewReadWriter
;;   "NewReadWriter allocates a new ReadWriter that dispatches to r and w.\n\nGo return type: *ReadWriter\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newReadWriter(r, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/bufio/bufio.go:743:22) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/bufio/bufio.go:743:33) w])

JOKER FUNC bufio.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader whose buffer has the default size.\n\nGo return type: *Reader\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newReader(rd)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bufio/bufio.go:61:19) rd])

JOKER FUNC bufio.NewReaderSize has:
;; (defn NewReaderSize
;;   "NewReaderSize returns a new Reader whose buffer has at least the specified\nsize. If the argument io.Reader is already a Reader with large enough\nsize, it returns the underlying Reader.\n\nGo return type: *Reader\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newReaderSize(rd, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bufio/bufio.go:46:23) rd, ^Int size])

JOKER FUNC bufio.NewScanner has:
;; (defn NewScanner
;;   "NewScanner returns a new Scanner to read from r.\nThe split function defaults to ScanLines.\n\nGo return type: *Scanner\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newScanner(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bufio/scan.go:86:19) r])

JOKER FUNC bufio.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer whose buffer has the default size.\n\nGo return type: *Writer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bufio/bufio.go:552:18) w])

JOKER FUNC bufio.NewWriterSize has:
;; (defn NewWriterSize
;;   "NewWriterSize returns a new Writer whose buffer has at least the specified\nsize. If the argument io.Writer is already a Writer with large enough\nsize, it returns the underlying Writer.\n\nGo return type: *Writer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newWriterSize(w, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bufio/bufio.go:536:22) w, ^Int size])

JOKER FUNC bufio.ScanBytes has:
;; (defn ScanBytes
;;   "ScanBytes is a split function for a Scanner that returns each byte as a token.\n\nGo return type: (advance int, token []int, err error)\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "scanBytes(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bufio/scan.go:284:21) data, ^Bool atEOF])

JOKER FUNC bufio.ScanLines has:
;; (defn ScanLines
;;   "ScanLines is a split function for a Scanner that returns each line of\ntext, stripped of any trailing end-of-line marker. The returned line may\nbe empty. The end-of-line marker is one optional carriage return followed\nby one mandatory newline. In regular expression notation, it is `\\r?\\n`.\nThe last non-empty line of input will be returned even if it has no\nnewline.\n\nGo return type: (advance int, token []int, err error)\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "scanLines(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bufio/scan.go:345:21) data, ^Bool atEOF])

JOKER FUNC bufio.ScanRunes has:
;; (defn ScanRunes
;;   "ScanRunes is a split function for a Scanner that returns each\nUTF-8-encoded rune as a token. The sequence of runes returned is\nequivalent to that from a range loop over the input as a string, which\nmeans that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\".\nBecause of the Scan interface, this makes it impossible for the client to\ndistinguish correctly encoded replacement runes from encoding errors.\n\nGo return type: (advance int, token []int, err error)\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "scanRunes(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bufio/scan.go:299:21) data, ^Bool atEOF])

JOKER FUNC bufio.ScanWords has:
;; (defn ScanWords
;;   "ScanWords is a split function for a Scanner that returns each\nspace-separated word of text, with surrounding spaces deleted. It will\nnever return an empty string. The definition of space is set by\nunicode.IsSpace.\n\nGo return type: (advance int, token []int, err error)\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "scanWords(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bufio/scan.go:390:21) data, ^Bool atEOF])

JOKER FUNC build.ArchChar has:
(defn ArchChar
  "ArchChar returns \"?\" and an error.\nIn earlier versions of Go, the returned string was used to derive\nthe compiler and linker tool names, the default object file suffix,\nand the default linker output name. As of Go 1.5, those strings\nno longer vary by architecture; they are compile, link, .o, and a.out, respectively.\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "archChar(goarch)"}
  [^String goarch])

JOKER FUNC build.Import has:
;; (defn Import
;;   "Import is shorthand for Default.Import.\n\nGo return type: (*Package, error)\n\nJoker return type: [{:Dir ^String, :Name ^String, :ImportComment ^String, :Doc ^String, :ImportPath ^String, :Root ^String, :SrcRoot ^String, :PkgRoot ^String, :PkgTargetRoot ^String, :BinDir ^String, :Goroot ^Bool, :PkgObj ^String, :AllTags ^(vector-of String), :ConflictDir ^String, :BinaryOnly ^Bool, :GoFiles ^(vector-of String), :CgoFiles ^(vector-of String), :IgnoredGoFiles ^(vector-of String), :InvalidGoFiles ^(vector-of String), :CFiles ^(vector-of String), :CXXFiles ^(vector-of String), :MFiles ^(vector-of String), :HFiles ^(vector-of String), :FFiles ^(vector-of String), :SFiles ^(vector-of String), :SwigFiles ^(vector-of String), :SwigCXXFiles ^(vector-of String), :SysoFiles ^(vector-of String), :CgoCFLAGS ^(vector-of String), :CgoCPPFLAGS ^(vector-of String), :CgoCXXFLAGS ^(vector-of String), :CgoFFLAGS ^(vector-of String), :CgoLDFLAGS ^(vector-of String), :CgoPkgConfig ^(vector-of String), :Imports ^(vector-of String), :ImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:424:12), :TestGoFiles ^(vector-of String), :TestImports ^(vector-of String), :TestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:429:17), :XTestGoFiles ^(vector-of String), :XTestImports ^(vector-of String), :XTestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:432:17)} Error]"
;;   {:added "1.0"
;;    :go "import(path, srcDir, mode)"}
;;   [^String path, ^String srcDir, ^ABEND885(unrecognized type ImportMode at: GO.link/src/go/build/build.go:1270:39) mode])

JOKER FUNC build.ImportDir has:
;; (defn ImportDir
;;   "ImportDir is shorthand for Default.ImportDir.\n\nGo return type: (*Package, error)\n\nJoker return type: [{:Dir ^String, :Name ^String, :ImportComment ^String, :Doc ^String, :ImportPath ^String, :Root ^String, :SrcRoot ^String, :PkgRoot ^String, :PkgTargetRoot ^String, :BinDir ^String, :Goroot ^Bool, :PkgObj ^String, :AllTags ^(vector-of String), :ConflictDir ^String, :BinaryOnly ^Bool, :GoFiles ^(vector-of String), :CgoFiles ^(vector-of String), :IgnoredGoFiles ^(vector-of String), :InvalidGoFiles ^(vector-of String), :CFiles ^(vector-of String), :CXXFiles ^(vector-of String), :MFiles ^(vector-of String), :HFiles ^(vector-of String), :FFiles ^(vector-of String), :SFiles ^(vector-of String), :SwigFiles ^(vector-of String), :SwigCXXFiles ^(vector-of String), :SysoFiles ^(vector-of String), :CgoCFLAGS ^(vector-of String), :CgoCPPFLAGS ^(vector-of String), :CgoCXXFLAGS ^(vector-of String), :CgoFFLAGS ^(vector-of String), :CgoLDFLAGS ^(vector-of String), :CgoPkgConfig ^(vector-of String), :Imports ^(vector-of String), :ImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:424:12), :TestGoFiles ^(vector-of String), :TestImports ^(vector-of String), :TestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:429:17), :XTestGoFiles ^(vector-of String), :XTestImports ^(vector-of String), :XTestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:432:17)} Error]"
;;   {:added "1.0"
;;    :go "importDir(dir, mode)"}
;;   [^String dir, ^ABEND885(unrecognized type ImportMode at: GO.link/src/go/build/build.go:1275:33) mode])

JOKER FUNC build.IsLocalImport has:
(defn ^Bool IsLocalImport
  "IsLocalImport reports whether the import path is\na local import path, like \".\", \"..\", \"./foo\", or \"../foo\".\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "build.IsLocalImport(path)"}
  [^String path])

JOKER FUNC bytes.Compare has:
;; (defn ^Int Compare
;;   "Compare returns an integer comparing two byte slices lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\nA nil argument is equivalent to an empty slice.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Compare(a, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes_decl.go:24:19) a, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes_decl.go:24:19) b])

JOKER FUNC bytes.Contains has:
;; (defn ^Bool Contains
;;   "Contains reports whether subslice is within b.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.Contains(b, subslice)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:72:27) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:72:27) subslice])

JOKER FUNC bytes.ContainsAny has:
;; (defn ^Bool ContainsAny
;;   "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.ContainsAny(b, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:77:20) b, ^String chars])

JOKER FUNC bytes.ContainsRune has:
;; (defn ^Bool ContainsRune
;;   "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.ContainsRune(b, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:82:21) b, ^ABEND885(unrecognized type rune at: GO.link/src/bytes/bytes.go:82:31) r])

JOKER FUNC bytes.Count has:
;; (defn ^Int Count
;;   "Count counts the number of non-overlapping instances of sep in s.\nIf sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Count(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:52:19) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:52:19) sep])

JOKER FUNC bytes.Equal has:
;; (defn ^Bool Equal
;;   "Equal returns a boolean reporting whether a and b\nare the same length and contain the same bytes.\nA nil argument is equivalent to an empty slice.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.Equal(a, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes_decl.go:17:17) a, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes_decl.go:17:17) b])

JOKER FUNC bytes.EqualFold has:
;; (defn ^Bool EqualFold
;;   "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.EqualFold(s, t)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:779:21) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:779:21) t])

JOKER FUNC bytes.Fields has:
;; (defn Fields
;;   "Fields interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of subslices of s or an\nempty slice if s contains only white space.\n\nGo return type: [][]int\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "fields(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:283:15) s])

JOKER FUNC bytes.FieldsFunc has:
;; (defn FieldsFunc
;;   "FieldsFunc interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s at each run of code points c satisfying f(c) and\nreturns a slice of subslices of s. If all code points in s satisfy f(c), or\nlen(s) == 0, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo return type: [][]int\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "fieldsFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:339:19) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:339:29) f])

JOKER FUNC bytes.HasPrefix has:
;; (defn ^Bool HasPrefix
;;   "HasPrefix tests whether the byte slice s begins with prefix.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.HasPrefix(s, prefix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:410:26) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:410:26) prefix])

JOKER FUNC bytes.HasSuffix has:
;; (defn ^Bool HasSuffix
;;   "HasSuffix tests whether the byte slice s ends with suffix.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.HasSuffix(s, suffix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:415:26) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:415:26) suffix])

JOKER FUNC bytes.Index has:
;; (defn ^Int Index
;;   "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Index(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:833:19) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:833:19) sep])

JOKER FUNC bytes.IndexAny has:
;; (defn ^Int IndexAny
;;   "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\nIt returns the byte index of the first occurrence in s of any of the Unicode\ncode points in chars. It returns -1 if chars is empty or if there is no code\npoint in common.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexAny(s, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:151:17) s, ^String chars])

JOKER FUNC bytes.IndexByte has:
;; (defn ^Int IndexByte
;;   "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexByte(b, c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes_decl.go:10:18) b, ^Byte c])

JOKER FUNC bytes.IndexFunc has:
;; (defn ^Int IndexFunc
;;   "IndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:603:18) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:603:28) f])

JOKER FUNC bytes.IndexRune has:
;; (defn ^Int IndexRune
;;   "IndexRune interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index of the first occurrence in s of the given rune.\nIt returns -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexRune(s, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:125:18) s, ^ABEND885(unrecognized type rune at: GO.link/src/bytes/bytes.go:125:28) r])

JOKER FUNC bytes.Join has:
;; (defn Join
;;   "Join concatenates the elements of s to create a new byte slice. The separator\nsep is placed between elements in the resulting slice.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "join(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:387:13) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:387:27) sep])

JOKER FUNC bytes.LastIndex has:
;; (defn ^Int LastIndex
;;   "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndex(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:96:23) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:96:23) sep])

JOKER FUNC bytes.LastIndexAny has:
;; (defn ^Int LastIndexAny
;;   "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\npoints. It returns the byte index of the last occurrence in s of any of\nthe Unicode code points in chars. It returns -1 if chars is empty or if\nthere is no code point in common.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexAny(s, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:187:21) s, ^String chars])

JOKER FUNC bytes.LastIndexByte has:
;; (defn ^Int LastIndexByte
;;   "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexByte(s, c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:111:22) s, ^Byte c])

JOKER FUNC bytes.LastIndexFunc has:
;; (defn ^Int LastIndexFunc
;;   "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the last Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:610:22) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:610:32) f])

JOKER FUNC bytes.Map has:
;; (defn Map
;;   "Map returns a copy of the byte slice s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the byte slice with no replacement. The characters in s and the\noutput are interpreted as UTF-8-encoded code points.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "map(mapping, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:423:18) mapping, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:423:39) s])

JOKER FUNC bytes.NewBuffer has:
;; (defn NewBuffer
;;   "NewBuffer creates and initializes a new Buffer using buf as its\ninitial contents. The new Buffer takes ownership of buf, and the\ncaller should not use buf after this call. NewBuffer is intended to\nprepare a Buffer to read existing data. It can also be used to size\nthe internal buffer for writing. To do that, buf should have the\ndesired capacity but a length of zero.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo return type: *Buffer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newBuffer(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/buffer.go:450:20) buf])

JOKER FUNC bytes.NewBufferString has:
;; (defn NewBufferString
;;   "NewBufferString creates and initializes a new Buffer using string s as its\ninitial contents. It is intended to prepare a buffer to read an existing\nstring.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo return type: *Buffer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newBufferString(s)"}
;;   [^String s])

JOKER FUNC bytes.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from b.\n\nGo return type: *Reader\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newReader(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/reader.go:156:18) b])

JOKER FUNC bytes.Repeat has:
;; (defn Repeat
;;   "Repeat returns a new byte slice consisting of count copies of b.\n\nIt panics if count is negative or if\nthe result of (len(b) * count) overflows.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "repeat(b, count)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:460:15) b, ^Int count])

JOKER FUNC bytes.Replace has:
;; (defn Replace
;;   "Replace returns a copy of the slice s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the slice\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune slice.\nIf n < 0, there is no limit on the number of replacements.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "replace(s, old, new, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:741:26) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:741:26) old, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:741:26) new, ^Int n])

JOKER FUNC bytes.Runes has:
;; (defn Runes
;;   "Runes interprets s as a sequence of UTF-8-encoded code points.\nIt returns a slice of runes (Unicode code points) equivalent to s.\n\nGo return type: []rune\n\nJoker return type: (vector-of ABEND042(cannot find typename bytes.rune))"
;;   {:added "1.0"
;;    :go "runes(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:723:14) s])

JOKER FUNC bytes.Split has:
;; (defn Split
;;   "Split slices s into all subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, Split splits after each UTF-8 sequence.\nIt is equivalent to SplitN with a count of -1.\n\nGo return type: [][]int\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "split(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:267:19) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:267:19) sep])

JOKER FUNC bytes.SplitAfter has:
;; (defn SplitAfter
;;   "SplitAfter slices s into all subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfter splits after each UTF-8 sequence.\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo return type: [][]int\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "splitAfter(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:273:24) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:273:24) sep])

JOKER FUNC bytes.SplitAfterN has:
;; (defn SplitAfterN
;;   "SplitAfterN slices s into subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfterN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo return type: [][]int\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "splitAfterN(s, sep, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:259:25) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:259:25) sep, ^Int n])

JOKER FUNC bytes.SplitN has:
;; (defn SplitN
;;   "SplitN slices s into subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, SplitN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo return type: [][]int\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "splitN(s, sep, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:250:20) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:250:20) sep, ^Int n])

JOKER FUNC bytes.Title has:
;; (defn Title
;;   "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin\nwords mapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "title(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:536:14) s])

JOKER FUNC bytes.ToLower has:
;; (defn ToLower
;;   "ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toLower(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:484:16) s])

JOKER FUNC bytes.ToLowerSpecial has:
;; (defn ToLowerSpecial
;;   "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toLowerSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bytes/bytes.go:497:23) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:497:46) s])

JOKER FUNC bytes.ToTitle has:
;; (defn ToTitle
;;   "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toTitle(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:487:16) s])

JOKER FUNC bytes.ToTitleSpecial has:
;; (defn ToTitleSpecial
;;   "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toTitleSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bytes/bytes.go:503:23) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:503:46) s])

JOKER FUNC bytes.ToUpper has:
;; (defn ToUpper
;;   "ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toUpper(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:481:16) s])

JOKER FUNC bytes.ToUpperSpecial has:
;; (defn ToUpperSpecial
;;   "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toUpperSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bytes/bytes.go:491:23) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:491:46) s])

JOKER FUNC bytes.Trim has:
;; (defn Trim
;;   "Trim returns a subslice of s by slicing off all leading and\ntrailing UTF-8-encoded code points contained in cutset.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trim(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:699:13) s, ^String cutset])

JOKER FUNC bytes.TrimFunc has:
;; (defn TrimFunc
;;   "TrimFunc returns a subslice of s by slicing off all leading and trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:578:17) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:578:27) f])

JOKER FUNC bytes.TrimLeft has:
;; (defn TrimLeft
;;   "TrimLeft returns a subslice of s by slicing off all leading\nUTF-8-encoded code points contained in cutset.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimLeft(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:705:17) s, ^String cutset])

JOKER FUNC bytes.TrimLeftFunc has:
;; (defn TrimLeftFunc
;;   "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off\nall leading UTF-8-encoded code points c that satisfy f(c).\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimLeftFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:555:21) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:555:31) f])

JOKER FUNC bytes.TrimPrefix has:
;; (defn TrimPrefix
;;   "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimPrefix(s, prefix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:584:27) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:584:27) prefix])

JOKER FUNC bytes.TrimRight has:
;; (defn TrimRight
;;   "TrimRight returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points that are contained in cutset.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimRight(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:711:18) s, ^String cutset])

JOKER FUNC bytes.TrimRightFunc has:
;; (defn TrimRightFunc
;;   "TrimRightFunc returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimRightFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:565:22) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:565:32) f])

JOKER FUNC bytes.TrimSpace has:
;; (defn TrimSpace
;;   "TrimSpace returns a subslice of s by slicing off all leading and\ntrailing white space, as defined by Unicode.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimSpace(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:717:18) s])

JOKER FUNC bytes.TrimSuffix has:
;; (defn TrimSuffix
;;   "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimSuffix(s, suffix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:593:27) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:593:27) suffix])

JOKER FUNC bzip2.NewReader has:
;; (defn NewReader
;;   "NewReader returns an io.Reader which decompresses bzip2 data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/bzip2/bzip2.go:46:29)"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/bzip2/bzip2.go:46:18) r])

JOKER FUNC cgi.Request has:
;; (defn Request
;;   "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/cgi/child.go:29:18) Error]"
;;   {:added "1.0"
;;    :go "request()"}
;;   [])

JOKER FUNC cgi.RequestFromMap has:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/cgi/child.go:52:49) Error]"
;;   {:added "1.0"
;;    :go "requestFromMap(params)"}
;;   [^ABEND881(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/cgi/child.go:52:28) params])

JOKER FUNC cgi.Serve has:
;; (defn ^Error Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "cgi.Serve(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/cgi/child.go:146:20) handler])

JOKER FUNC cgo._cgo_panic has:
;; (defn _cgo_panic
;;   "go:linkname _cgo_panic _cgo_panic\ngo:cgo_export_static _cgo_panic\ngo:cgo_export_dynamic _cgo_panic\ngo:nosplit\ngo:norace\n"
;;   {:added "1.0"
;;    :go "_cgo_panic(a, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/cgo/callbacks.go:45:19) a, ^Int n])

JOKER FUNC cgo._runtime_cgocallback has:
;; (defn _runtime_cgocallback
;;   "cgocallback is defined in runtime\ngo:linkname _runtime_cgocallback runtime.cgocallback\n"
;;   {:added "1.0"
;;    :go "_runtime_cgocallback()"}
;;   [])

JOKER FUNC cipher.NewCBCDecrypter has:
;; (defn NewCBCDecrypter
;;   "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size and must match the iv used to encrypt the data.\n\nGo return type: BlockMode\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:45:16)"
;;   {:added "1.0"
;;    :go "newCBCDecrypter(b, iv)"}
;;   [^ABEND885(unrecognized type Block at: GO.link/src/crypto/cipher/cbc.go:105:24) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/cbc.go:105:34) iv])

JOKER FUNC cipher.NewCBCEncrypter has:
;; (defn NewCBCEncrypter
;;   "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size.\n\nGo return type: BlockMode\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:45:16)"
;;   {:added "1.0"
;;    :go "newCBCEncrypter(b, iv)"}
;;   [^ABEND885(unrecognized type Block at: GO.link/src/crypto/cipher/cbc.go:45:24) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/cbc.go:45:34) iv])

JOKER FUNC cipher.NewCFBDecrypter has:
;; (defn NewCFBDecrypter
;;   "NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo return type: Stream\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newCFBDecrypter(block, iv)"}
;;   [^ABEND885(unrecognized type Block at: GO.link/src/crypto/cipher/cfb.go:60:28) block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/cfb.go:60:38) iv])

JOKER FUNC cipher.NewCFBEncrypter has:
;; (defn NewCFBEncrypter
;;   "NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo return type: Stream\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newCFBEncrypter(block, iv)"}
;;   [^ABEND885(unrecognized type Block at: GO.link/src/crypto/cipher/cfb.go:53:28) block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/cfb.go:53:38) iv])

JOKER FUNC cipher.NewCTR has:
;; (defn NewCTR
;;   "NewCTR returns a Stream which encrypts/decrypts using the given Block in\ncounter mode. The length of iv must be the same as the Block's block size.\n\nGo return type: Stream\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newCTR(block, iv)"}
;;   [^ABEND885(unrecognized type Block at: GO.link/src/crypto/cipher/ctr.go:35:19) block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/ctr.go:35:29) iv])

JOKER FUNC cipher.NewGCM has:
;; (defn NewGCM
;;   "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode\nwith the standard nonce length.\n\nIn general, the GHASH operation performed by this implementation of GCM is not constant-time.\nAn exception is when the underlying Block was created by aes.NewCipher\non systems with hardware support for AES. See the crypto/aes package documentation for details.\n\nGo return type: (AEAD, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/gcm.go:16:11) Error]"
;;   {:added "1.0"
;;    :go "newGCM(cipher)"}
;;   [^ABEND885(unrecognized type Block at: GO.link/src/crypto/cipher/gcm.go:83:20) cipher])

JOKER FUNC cipher.NewGCMWithNonceSize has:
;; (defn NewGCMWithNonceSize
;;   "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which accepts nonces of the given length.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard nonce lengths. All other users should use\nNewGCM, which is faster and more resistant to misuse.\n\nGo return type: (AEAD, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/gcm.go:16:11) Error]"
;;   {:added "1.0"
;;    :go "newGCMWithNonceSize(cipher, size)"}
;;   [^ABEND885(unrecognized type Block at: GO.link/src/crypto/cipher/gcm.go:93:33) cipher, ^Int size])

JOKER FUNC cipher.NewGCMWithTagSize has:
;; (defn NewGCMWithTagSize
;;   "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which generates tags with the given length.\n\nTag sizes between 12 and 16 bytes are allowed.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard tag lengths. All other users should use\nNewGCM, which is more resistant to misuse.\n\nGo return type: (AEAD, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/gcm.go:16:11) Error]"
;;   {:added "1.0"
;;    :go "newGCMWithTagSize(cipher, tagSize)"}
;;   [^ABEND885(unrecognized type Block at: GO.link/src/crypto/cipher/gcm.go:105:31) cipher, ^Int tagSize])

JOKER FUNC cipher.NewOFB has:
;; (defn NewOFB
;;   "NewOFB returns a Stream that encrypts or decrypts using the block cipher b\nin output feedback mode. The initialization vector iv's length must be equal\nto b's block size.\n\nGo return type: Stream\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newOFB(b, iv)"}
;;   [^ABEND885(unrecognized type Block at: GO.link/src/crypto/cipher/ofb.go:21:15) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/ofb.go:21:25) iv])

JOKER FUNC cmplx.Abs has:
;; (defn Abs
;;   "Abs returns the absolute value (also called the modulus) of x.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename cmplx.float64)"
;;   {:added "1.0"
;;    :go "abs(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/abs.go:12:12) x])

JOKER FUNC cmplx.Acos has:
;; (defn Acos
;;   "Acos returns the inverse cosine of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "acos(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:87:13) x])

JOKER FUNC cmplx.Acosh has:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "acosh(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:93:14) x])

JOKER FUNC cmplx.Asin has:
;; (defn Asin
;;   "Asin returns the inverse sine of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "asin(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:51:13) x])

JOKER FUNC cmplx.Asinh has:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "asinh(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:64:14) x])

JOKER FUNC cmplx.Atan has:
;; (defn Atan
;;   "Atan returns the inverse tangent of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "atan(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:135:13) x])

JOKER FUNC cmplx.Atanh has:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "atanh(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:155:14) x])

JOKER FUNC cmplx.Conj has:
;; (defn Conj
;;   "Conj returns the complex conjugate of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "conj(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/conj.go:8:13) x])

JOKER FUNC cmplx.Cos has:
;; (defn Cos
;;   "Cos returns the cosine of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "cos(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/sin.go:98:12) x])

JOKER FUNC cmplx.Cosh has:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "cosh(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/sin.go:117:13) x])

JOKER FUNC cmplx.Cot has:
;; (defn Cot
;;   "Cot returns the cotangent of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "cot(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/tan.go:177:12) x])

JOKER FUNC cmplx.Exp has:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "exp(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/exp.go:51:12) x])

JOKER FUNC cmplx.Inf has:
;; (defn Inf
;;   "Inf returns a complex infinity, complex(+Inf, +Inf).\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "inf()"}
;;   [])

JOKER FUNC cmplx.IsInf has:
;; (defn ^Bool IsInf
;;   "IsInf returns true if either real(x) or imag(x) is an infinity.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "cmplx.IsInf(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/isinf.go:10:14) x])

JOKER FUNC cmplx.IsNaN has:
;; (defn ^Bool IsNaN
;;   "IsNaN returns true if either real(x) or imag(x) is NaN\nand neither is an infinity.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "cmplx.IsNaN(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/isnan.go:11:14) x])

JOKER FUNC cmplx.Log has:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "log(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/log.go:57:12) x])

JOKER FUNC cmplx.Log10 has:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "log10(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/log.go:62:14) x])

JOKER FUNC cmplx.NaN has:
;; (defn NaN
;;   "NaN returns a complex ``not-a-number'' value.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])

JOKER FUNC cmplx.Phase has:
;; (defn Phase
;;   "Phase returns the phase (also called the argument) of x.\nThe returned value is in the range [-Pi, Pi].\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename cmplx.float64)"
;;   {:added "1.0"
;;    :go "phase(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/phase.go:11:14) x])

JOKER FUNC cmplx.Polar has:
;; (defn Polar
;;   "Polar returns the absolute value r and phase θ of x,\nsuch that x = r * e**θi.\nThe phase is in the range [-Pi, Pi].\n\nGo return type: (r float64, θ float64)\n\nJoker return type: [ABEND042(cannot find typename cmplx.float64) ABEND042(cannot find typename cmplx.float64)]"
;;   {:added "1.0"
;;    :go "polar(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/polar.go:10:14) x])

JOKER FUNC cmplx.Pow has:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\nFor generalized compatibility with math.Pow:\n\tPow(0, ±0) returns 1+0i\n\tPow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "pow(x, y)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/pow.go:49:15) x, ^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/pow.go:49:15) y])

JOKER FUNC cmplx.Rect has:
;; (defn Rect
;;   "Rect returns the complex number x with polar coordinates r, θ.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "rect(r, θ)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/cmplx/rect.go:10:17) r, ^ABEND885(unrecognized type float64 at: GO.link/src/math/cmplx/rect.go:10:17) θ])

JOKER FUNC cmplx.Sin has:
;; (defn Sin
;;   "Sin returns the sine of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "sin(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/sin.go:53:12) x])

JOKER FUNC cmplx.Sinh has:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "sinh(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/sin.go:73:13) x])

JOKER FUNC cmplx.Sqrt has:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\nThe result r is chosen so that real(r) ≥ 0 and imag(r) has the same sign as imag(x).\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "sqrt(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/sqrt.go:58:13) x])

JOKER FUNC cmplx.Tan has:
;; (defn Tan
;;   "Tan returns the tangent of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "tan(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/tan.go:59:12) x])

JOKER FUNC cmplx.Tanh has:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nGo return type: complex128\n\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "tanh(x)"}
;;   [^ABEND885(unrecognized type complex128 at: GO.link/src/math/cmplx/tan.go:83:13) x])

JOKER FUNC color.CMYKToRGB has:
;; (defn CMYKToRGB
;;   "CMYKToRGB converts a CMYK quadruple to an RGB triple.\n\nGo return type: (uint8, uint8, uint8)\n\nJoker return type: [ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)]"
;;   {:added "1.0"
;;    :go "cMYKToRGB(c, m, y, k)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:336:27) c, ^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:336:27) m, ^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:336:27) y, ^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:336:27) k])

JOKER FUNC color.ModelFunc has:
;; (defn ModelFunc
;;   "ModelFunc returns a Model that invokes f to implement the conversion.\n\nGo return type: Model\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/color/color.go:142:12)"
;;   {:added "1.0"
;;    :go "modelFunc(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/image/color/color.go:147:18) f])

JOKER FUNC color.RGBToCMYK has:
;; (defn RGBToCMYK
;;   "RGBToCMYK converts an RGB triple to a CMYK quadruple.\n\nGo return type: (uint8, uint8, uint8, uint8)\n\nJoker return type: [ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)]"
;;   {:added "1.0"
;;    :go "rGBToCMYK(r, g, b)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:315:24) r, ^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:315:24) g, ^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:315:24) b])

JOKER FUNC color.RGBToYCbCr has:
;; (defn RGBToYCbCr
;;   "RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\n\nGo return type: (uint8, uint8, uint8)\n\nJoker return type: [ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)]"
;;   {:added "1.0"
;;    :go "rGBToYCbCr(r, g, b)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:8:25) r, ^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:8:25) g, ^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:8:25) b])

JOKER FUNC color.YCbCrToRGB has:
;; (defn YCbCrToRGB
;;   "YCbCrToRGB converts a Y'CbCr triple to an RGB triple.\n\nGo return type: (uint8, uint8, uint8)\n\nJoker return type: [ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)]"
;;   {:added "1.0"
;;    :go "yCbCrToRGB(y, cb, cr)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:58:27) y, ^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:58:27) cb, ^ABEND885(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:58:27) cr])

JOKER FUNC constant.BinaryOp has:
;; (defn BinaryOp
;;   "BinaryOp returns the result of the binary expression x op y.\nThe operation must be defined for the operands. If one of the\noperands is Unknown, the result is Unknown.\nBinaryOp doesn't handle comparisons or shifts; use Compare\nor Shift instead.\n\nTo force integer division of Int operands, use op == token.QUO_ASSIGN\ninstead of token.QUO; the result is guaranteed to be Int in this case.\nDivision by zero leads to a run-time panic.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "binaryOp(x_, op, y_)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:1011:18) x_, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/constant/value.go:1011:28) op, ^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:1011:44) y_])

JOKER FUNC constant.BitLen has:
;; (defn ^Int BitLen
;;   "BitLen returns the number of bits required to represent\nthe absolute value x in binary representation; x must be an Int or an Unknown.\nIf x is Unknown, the result is 0.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "constant.BitLen(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:536:15) x])

JOKER FUNC constant.BoolVal has:
;; (defn ^Bool BoolVal
;;   "BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown.\nIf x is Unknown, the result is false.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "constant.BoolVal(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:431:16) x])

JOKER FUNC constant.Bytes has:
;; (defn Bytes
;;   "Bytes returns the bytes for the absolute value of x in little-\nendian binary representation; x must be an Int.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "bytes(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:589:14) x])

JOKER FUNC constant.Compare has:
;; (defn ^Bool Compare
;;   "Compare returns the result of the comparison x op y.\nThe comparison must be defined for the operands.\nIf one of the operands is Unknown, the result is\nfalse.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "constant.Compare(x_, op, y_)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:1247:17) x_, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/constant/value.go:1247:27) op, ^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:1247:43) y_])

JOKER FUNC constant.Denom has:
;; (defn Denom
;;   "Denom returns the denominator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int >= 1.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "denom(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:675:14) x])

JOKER FUNC constant.Float32Val has:
;; (defn Float32Val
;;   "Float32Val is like Float64Val but for float32 instead of float64.\n\nGo return type: (float32, bool)\n\nJoker return type: [ABEND042(cannot find typename constant.float32) Bool]"
;;   {:added "1.0"
;;    :go "float32Val(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:488:19) x])

JOKER FUNC constant.Float64Val has:
;; (defn Float64Val
;;   "Float64Val returns the nearest Go float64 value of x and whether the result is exact;\nx must be numeric or an Unknown, but not Complex. For values too small (too close to 0)\nto represent as float64, Float64Val silently underflows to 0. The result sign always\nmatches the sign of x, even for 0.\nIf x is Unknown, the result is (0, false).\n\nGo return type: (float64, bool)\n\nJoker return type: [ABEND042(cannot find typename constant.float64) Bool]"
;;   {:added "1.0"
;;    :go "float64Val(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:513:19) x])

JOKER FUNC constant.Imag has:
;; (defn Imag
;;   "Imag returns the imaginary part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "imag(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:723:13) x])

JOKER FUNC constant.Int64Val has:
;; (defn Int64Val
;;   "Int64Val returns the Go int64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo return type: (int, bool)\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "int64Val(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:458:17) x])

JOKER FUNC constant.MakeBool has:
;; (defn MakeBool
;;   "MakeBool returns the Bool value for b.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeBool(b)"}
;;   [^Bool b])

JOKER FUNC constant.MakeFloat64 has:
;; (defn MakeFloat64
;;   "MakeFloat64 returns the Float value for x.\nIf x is not finite, the result is an Unknown.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeFloat64(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/go/constant/value.go:362:20) x])

JOKER FUNC constant.MakeFromBytes has:
;; (defn MakeFromBytes
;;   "MakeFromBytes returns the Int value given the bytes of its little-endian\nbinary representation. An empty byte slice argument represents 0.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeFromBytes(bytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/constant/value.go:621:26) bytes])

JOKER FUNC constant.MakeFromLiteral has:
;; (defn MakeFromLiteral
;;   "MakeFromLiteral returns the corresponding integer, floating-point,\nimaginary, character, or string value for a Go literal string. The\ntok value must be one of token.INT, token.FLOAT, token.IMAG,\ntoken.CHAR, or token.STRING. The final argument must be zero.\nIf the literal string syntax is invalid, the result is an Unknown.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeFromLiteral(lit, tok, zero)"}
;;   [^String lit, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/constant/value.go:378:38) tok, ^Int zero])

JOKER FUNC constant.MakeImag has:
;; (defn MakeImag
;;   "MakeImag returns the Complex value x*i;\nx must be Int, Float, or Unknown.\nIf x is Unknown, the result is Unknown.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeImag(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:697:17) x])

JOKER FUNC constant.MakeInt64 has:
;; (defn MakeInt64
;;   "MakeInt64 returns the Int value for x.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeInt64(x)"}
;;   [^Int x])

JOKER FUNC constant.MakeString has:
;; (defn MakeString
;;   "MakeString returns the String value for s.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeString(s)"}
;;   [^String s])

JOKER FUNC constant.MakeUint64 has:
;; (defn MakeUint64
;;   "MakeUint64 returns the Int value for x.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeUint64(x)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/go/constant/value.go:353:19) x])

JOKER FUNC constant.MakeUnknown has:
;; (defn MakeUnknown
;;   "MakeUnknown returns the Unknown value.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeUnknown()"}
;;   [])

JOKER FUNC constant.Num has:
;; (defn Num
;;   "Num returns the numerator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int\nwith the same sign as x.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "num(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:653:12) x])

JOKER FUNC constant.Real has:
;; (defn Real
;;   "Real returns the real part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "real(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:710:13) x])

JOKER FUNC constant.Shift has:
;; (defn Shift
;;   "Shift returns the result of the shift expression x op s\nwith op == token.SHL or token.SHR (<< or >>). x must be\nan Int or an Unknown. If x is Unknown, the result is x.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "shift(x, op, s)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:1191:14) x, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/constant/value.go:1191:24) op, ^Int s])

JOKER FUNC constant.Sign has:
;; (defn ^Int Sign
;;   "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0;\nx must be numeric or Unknown. For complex values x, the sign is 0 if x == 0,\notherwise it is != 0. If x is Unknown, the result is 1.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "constant.Sign(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:552:13) x])

JOKER FUNC constant.StringVal has:
;; (defn ^String StringVal
;;   "StringVal returns the Go string value of x, which must be a String or an Unknown.\nIf x is Unknown, the result is \"\".\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "constant.StringVal(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:444:18) x])

JOKER FUNC constant.ToComplex has:
;; (defn ToComplex
;;   "ToComplex converts x to a Complex value if x is representable as a Complex.\nOtherwise it returns an Unknown.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "toComplex(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:814:18) x])

JOKER FUNC constant.ToFloat has:
;; (defn ToFloat
;;   "ToFloat converts x to a Float value if x is representable as a Float.\nOtherwise it returns an Unknown.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "toFloat(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:795:16) x])

JOKER FUNC constant.ToInt has:
;; (defn ToInt
;;   "ToInt converts x to an Int value if x is representable as an Int.\nOtherwise it returns an Unknown.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "toInt(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:741:14) x])

JOKER FUNC constant.Uint64Val has:
;; (defn Uint64Val
;;   "Uint64Val returns the Go uint64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo return type: (uint64, bool)\n\nJoker return type: [ABEND042(cannot find typename constant.uint64) Bool]"
;;   {:added "1.0"
;;    :go "uint64Val(x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:474:18) x])

JOKER FUNC constant.UnaryOp has:
;; (defn UnaryOp
;;   "UnaryOp returns the result of the unary expression op y.\nThe operation must be defined for the operand.\nIf prec > 0 it specifies the ^ (xor) result size in bits.\nIf y is Unknown, the result is Unknown.\n\nGo return type: Value\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "unaryOp(op, y, prec)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/constant/value.go:850:17) op, ^ABEND885(unrecognized type Value at: GO.link/src/go/constant/value.go:850:32) y, ^Int prec])

JOKER FUNC context.Background has:
;; (defn Background
;;   "Background returns a non-nil, empty Context. It is never canceled, has no\nvalues, and has no deadline. It is typically used by the main function,\ninitialization, and tests, and as the top-level Context for incoming\nrequests.\n\nGo return type: Context\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "background()"}
;;   [])

JOKER FUNC context.TODO has:
;; (defn TODO
;;   "TODO returns a non-nil, empty Context. Code should use context.TODO when\nit's unclear which Context to use or it is not yet available (because the\nsurrounding function has not yet been extended to accept a Context\nparameter). TODO is recognized by static analysis tools that determine\nwhether Contexts are propagated correctly in a program.\n\nGo return type: Context\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "tODO()"}
;;   [])

JOKER FUNC context.WithCancel has:
;; (defn WithCancel
;;   "WithCancel returns a copy of parent with a new Done channel. The returned\ncontext's Done channel is closed when the returned cancel function is called\nor when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo return type: (ctx Context, cancel CancelFunc)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14) ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/context/context.go:222:17)]"
;;   {:added "1.0"
;;    :go "withCancel(parent)"}
;;   [^ABEND885(unrecognized type Context at: GO.link/src/context/context.go:230:24) parent])

JOKER FUNC context.WithDeadline has:
;; (defn WithDeadline
;;   "WithDeadline returns a copy of the parent context with the deadline adjusted\nto be no later than d. If the parent's deadline is already earlier than d,\nWithDeadline(parent, d) is semantically equivalent to parent. The returned\ncontext's Done channel is closed when the deadline expires, when the returned\ncancel function is called, or when the parent context's Done channel is\nclosed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo return type: (Context, CancelFunc)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14) ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/context/context.go:222:17)]"
;;   {:added "1.0"
;;    :go "withDeadline(parent, d)"}
;;   [^ABEND885(unrecognized type Context at: GO.link/src/context/context.go:384:26) parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/context/context.go:384:37) d])

JOKER FUNC context.WithTimeout has:
;; (defn WithTimeout
;;   "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete:\n\n\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n\t\treturn slowOperation(ctx)\n\t}\n\nGo return type: (Context, CancelFunc)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14) ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/context/context.go:222:17)]"
;;   {:added "1.0"
;;    :go "withTimeout(parent, timeout)"}
;;   [^ABEND885(unrecognized type Context at: GO.link/src/context/context.go:451:25) parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/context/context.go:451:42) timeout])

JOKER FUNC context.WithValue has:
;; (defn WithValue
;;   "WithValue returns a copy of parent in which the value associated with key is\nval.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type\nstring or any other built-in type to avoid collisions between\npackages using context. Users of WithValue should define their own\ntypes for keys. To avoid allocating when assigning to an\ninterface{}, context keys often have concrete type\nstruct{}. Alternatively, exported context key variables' static\ntype should be a pointer or interface.\n\nGo return type: Context\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "withValue(parent, key, val)"}
;;   [^ABEND885(unrecognized type Context at: GO.link/src/context/context.go:468:23) parent, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:468:41) key, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:468:41) val])

JOKER FUNC cookiejar.New has:
;; (defn New
;;   "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo return type: (*Jar, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "new(o)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/cookiejar/jar.go:77:12) o])

JOKER FUNC crc32.Checksum has:
;; (defn ^Int Checksum
;;   "Checksum returns the CRC-32 checksum of data\nusing the polynomial represented by the Table.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "crc32.Checksum(data, tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/hash/crc32/crc32.go:247:20) data, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/hash/crc32/crc32.go:247:32) tab])

JOKER FUNC crc32.ChecksumIEEE has:
;; (defn ^Int ChecksumIEEE
;;   "ChecksumIEEE returns the CRC-32 checksum of data\nusing the IEEE polynomial.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "crc32.ChecksumIEEE(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/hash/crc32/crc32.go:251:24) data])

JOKER FUNC crc32.MakeTable has:
(defn MakeTable
  "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo return type: *Table\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "makeTable(poly)"}
  [^Int poly])

JOKER FUNC crc32.New has:
;; (defn New
;;   "New creates a new hash.Hash32 computing the CRC-32 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash32 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/hash/crc32/crc32.go:147:22)"
;;   {:added "1.0"
;;    :go "new(tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/hash/crc32/crc32.go:147:14) tab])

JOKER FUNC crc32.NewIEEE has:
;; (defn NewIEEE
;;   "NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using\nthe IEEE polynomial. Its Sum method will lay the value out in\nbig-endian byte order. The returned Hash32 also implements\nencoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal\nand unmarshal the internal state of the hash.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/hash/crc32/crc32.go:159:16)"
;;   {:added "1.0"
;;    :go "newIEEE()"}
;;   [])

JOKER FUNC crc32.Update has:
;; (defn ^Int Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "crc32.Update(crc, tab, p)"}
;;   [^Int crc, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/hash/crc32/crc32.go:210:29) tab, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/hash/crc32/crc32.go:210:39) p])

JOKER FUNC crc64.Checksum has:
;; (defn Checksum
;;   "Checksum returns the CRC-64 checksum of data\nusing the polynomial represented by the Table.\n\nGo return type: uint64\n\nJoker return type: ABEND042(cannot find typename crc64.uint64)"
;;   {:added "1.0"
;;    :go "checksum(data, tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/hash/crc64/crc64.go:199:20) data, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/hash/crc64/crc64.go:199:32) tab])

JOKER FUNC crc64.MakeTable has:
;; (defn MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo return type: *Table\n\nJoker return type: (vector-of ABEND042(cannot find typename crc64.uint64))"
;;   {:added "1.0"
;;    :go "makeTable(poly)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/hash/crc64/crc64.go:37:21) poly])

JOKER FUNC crc64.New has:
;; (defn New
;;   "New creates a new hash.Hash64 computing the CRC-64 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash64 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/hash/crc64/crc64.go:88:22)"
;;   {:added "1.0"
;;    :go "new(tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/hash/crc64/crc64.go:88:14) tab])

JOKER FUNC crc64.Update has:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo return type: uint64\n\nJoker return type: ABEND042(cannot find typename crc64.uint64)"
;;   {:added "1.0"
;;    :go "update(crc, tab, p)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/hash/crc64/crc64.go:181:17) crc, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/hash/crc64/crc64.go:181:29) tab, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/hash/crc64/crc64.go:181:39) p])

JOKER FUNC crypto.RegisterHash has:
;; (defn RegisterHash
;;   "RegisterHash registers a function that returns a new instance of the given\nhash function. This is intended to be called from the init function in\npackages that implement hash functions.\n"
;;   {:added "1.0"
;;    :go "registerHash(h, f)"}
;;   [^ABEND885(unrecognized type Hash at: GO.link/src/crypto/crypto.go:100:21) h, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/crypto.go:100:29) f])

JOKER FUNC csv.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader that reads from r.\n\nGo return type: *Reader\n\nJoker return type: {:Comma ^ABEND042(cannot find typename csv.rune), :Comment ^ABEND042(cannot find typename csv.rune), :FieldsPerRecord ^Int, :LazyQuotes ^Bool, :TrimLeadingSpace ^Bool, :ReuseRecord ^Bool, :TrailingComma ^Bool}"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/csv/reader.go:168:18) r])

JOKER FUNC csv.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo return type: *Writer\n\nJoker return type: {:Comma ^ABEND042(cannot find typename csv.rune), :UseCRLF ^Bool}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/csv/writer.go:31:18) w])

JOKER FUNC debug.FreeOSMemory has:
;; (defn FreeOSMemory
;;   "FreeOSMemory forces a garbage collection followed by an\nattempt to return as much memory to the operating system\nas possible. (Even if this is not called, the runtime gradually\nreturns memory to the operating system in a background task.)\n"
;;   {:added "1.0"
;;    :go "freeOSMemory()"}
;;   [])

JOKER FUNC debug.PrintStack has:
;; (defn PrintStack
;;   "PrintStack prints to standard error the stack trace returned by runtime.Stack.\n"
;;   {:added "1.0"
;;    :go "printStack()"}
;;   [])

JOKER FUNC debug.ReadGCStats has:
;; (defn ReadGCStats
;;   "ReadGCStats reads statistics about garbage collection into stats.\nThe number of entries in the pause history is system-dependent;\nstats.Pause slice will be reused if large enough, reallocated otherwise.\nReadGCStats may use the full capacity of the stats.Pause slice.\nIf stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles\nsummarizing the distribution of pause time. For example, if\nlen(stats.PauseQuantiles) is 5, it will be filled with the minimum,\n25%, 50%, 75%, and maximum pause times.\n"
;;   {:added "1.0"
;;    :go "readGCStats(stats)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/runtime/debug/garbage.go:31:24) stats])

JOKER FUNC debug.SetGCPercent has:
(defn ^Int SetGCPercent
  "SetGCPercent sets the garbage collection target percentage:\na collection is triggered when the ratio of freshly allocated data\nto live data remaining after the previous collection reaches this percentage.\nSetGCPercent returns the previous setting.\nThe initial setting is the value of the GOGC environment variable\nat startup, or 100 if the variable is not set.\nA negative percentage disables garbage collection.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetGCPercent(percent)"}
  [^Int percent])

JOKER FUNC debug.SetMaxStack has:
(defn ^Int SetMaxStack
  "SetMaxStack sets the maximum amount of memory that\ncan be used by a single goroutine stack.\nIf any goroutine exceeds this limit while growing its stack,\nthe program crashes.\nSetMaxStack returns the previous setting.\nThe initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.\n\nSetMaxStack is useful mainly for limiting the damage done by\ngoroutines that enter an infinite recursion. It only limits future\nstack growth.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxStack(bytes)"}
  [^Int bytes])

JOKER FUNC debug.SetMaxThreads has:
(defn ^Int SetMaxThreads
  "SetMaxThreads sets the maximum number of operating system\nthreads that the Go program can use. If it attempts to use more than\nthis many, the program crashes.\nSetMaxThreads returns the previous setting.\nThe initial setting is 10,000 threads.\n\nThe limit controls the number of operating system threads, not the number\nof goroutines. A Go program creates a new thread only when a goroutine\nis ready to run but all the existing threads are blocked in system calls, cgo calls,\nor are locked to other goroutines due to use of runtime.LockOSThread.\n\nSetMaxThreads is useful mainly for limiting the damage done by\nprograms that create an unbounded number of threads. The idea is\nto take down the program before it takes down the operating system.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxThreads(threads)"}
  [^Int threads])

JOKER FUNC debug.SetPanicOnFault has:
(defn ^Bool SetPanicOnFault
  "SetPanicOnFault controls the runtime's behavior when a program faults\nat an unexpected (non-nil) address. Such faults are typically caused by\nbugs such as runtime memory corruption, so the default response is to crash\nthe program. Programs working with memory-mapped files or unsafe\nmanipulation of memory may cause faults at non-nil addresses in less\ndramatic situations; SetPanicOnFault allows such programs to request\nthat the runtime trigger only a panic, not a crash.\nSetPanicOnFault applies only to the current goroutine.\nIt returns the previous setting.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "debug.SetPanicOnFault(enabled)"}
  [^Bool enabled])

JOKER FUNC debug.SetTraceback has:
;; (defn SetTraceback
;;   "SetTraceback sets the amount of detail printed by the runtime in\nthe traceback it prints before exiting due to an unrecovered panic\nor an internal runtime error.\nThe level argument takes the same values as the GOTRACEBACK\nenvironment variable. For example, SetTraceback(\"all\") ensure\nthat the program prints all goroutines when it crashes.\nSee the package runtime documentation for details.\nIf SetTraceback is called with a level lower than that of the\nenvironment variable, the call is ignored.\n"
;;   {:added "1.0"
;;    :go "setTraceback(level)"}
;;   [^String level])

JOKER FUNC debug.Stack has:
(defn Stack
  "Stack returns a formatted stack trace of the goroutine that calls it.\nIt calls runtime.Stack with a large enough buffer to capture the entire trace.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "stack()"}
  [])

JOKER FUNC debug.WriteHeapDump has:
;; (defn WriteHeapDump
;;   "WriteHeapDump writes a description of the heap and the objects in\nit to the given file descriptor.\n\nWriteHeapDump suspends the execution of all goroutines until the heap\ndump is completely written.  Thus, the file descriptor must not be\nconnected to a pipe or socket whose other end is in the same Go\nprocess; instead, use a temporary file or network socket.\n\nThe heap dump format is defined at https://golang.org/s/go15heapdump.\n"
;;   {:added "1.0"
;;    :go "writeHeapDump(fd)"}
;;   [^ABEND885(unrecognized type uintptr at: GO.link/src/runtime/debug/garbage.go:157:23) fd])

JOKER FUNC des.NewCipher has:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/des/cipher.go:29:29) Error]"
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/des/cipher.go:29:20) key])

JOKER FUNC des.NewTripleDESCipher has:
;; (defn NewTripleDESCipher
;;   "NewTripleDESCipher creates and returns a new cipher.Block.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/des/cipher.go:73:38) Error]"
;;   {:added "1.0"
;;    :go "newTripleDESCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/des/cipher.go:73:29) key])

JOKER FUNC doc.Examples has:
;; (defn Examples
;;   "Examples returns the examples found in the files, sorted by Name field.\nThe Order fields record the order in which the examples were encountered.\n\nPlayable Examples must be in a package whose name ends in \"_test\".\nAn Example is \"playable\" (the Play field is non-nil) in either of these\ncircumstances:\n  - The example function is self-contained: the function references only\n    identifiers from other packages (or predeclared identifiers, such as\n    \"int\") and the test file does not include a dot import.\n  - The entire test file is the example: the file contains exactly one\n    example function, zero test or benchmark functions, and at least one\n    top-level function, type, variable, or constant declaration other\n    than the example function.\n\nGo return type: []*Example\n\nJoker return type: (vector-of {:Name ^String, :Doc ^String, :Code ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/example.go:25:14), :Play ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/example.go:26:15), :Comments ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/example.go:27:17)), :Output ^String, :Unordered ^Bool, :EmptyOutput ^Bool, :Order ^Int})"
;;   {:added "1.0"
;;    :go "examples(files)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/go/doc/example.go:47:21) files])

JOKER FUNC doc.IsPredeclared has:
(defn ^Bool IsPredeclared
  "IsPredeclared reports whether s is a predeclared identifier.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "doc.IsPredeclared(s)"}
  [^String s])

JOKER FUNC doc.New has:
;; (defn New
;;   "New computes the package documentation for the given package AST.\nNew takes ownership of the AST pkg and may edit or overwrite it.\n\nGo return type: *Package\n\nJoker return type: {:Doc ^String, :Name ^String, :ImportPath ^String, :Imports ^(vector-of String), :Filenames ^(vector-of String), :Notes ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/doc/doc.go:20:13), :Bugs ^(vector-of String), :Consts ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/doc.go:37:9)}), :Types ^(vector-of {:Doc ^String, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/doc.go:46:8), :Consts ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/doc.go:37:9)}), :Vars ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/doc.go:37:9)}), :Funcs ^(vector-of {:Doc ^String, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/doc.go:59:8), :Recv ^String, :Orig ^String, :Level ^Int}), :Methods ^(vector-of {:Doc ^String, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/doc.go:59:8), :Recv ^String, :Orig ^String, :Level ^Int})}), :Vars ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/doc.go:37:9)}), :Funcs ^(vector-of {:Doc ^String, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/doc.go:59:8), :Recv ^String, :Orig ^String, :Level ^Int})}"
;;   {:added "1.0"
;;    :go "new(pkg, importPath, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/doc/doc.go:94:14) pkg, ^String importPath, ^ABEND885(unrecognized type Mode at: GO.link/src/go/doc/doc.go:94:52) mode])

JOKER FUNC doc.Synopsis has:
(defn ^String Synopsis
  "Synopsis returns a cleaned version of the first sentence in s.\nThat sentence ends after the first period followed by space and\nnot preceded by exactly one uppercase letter. The result string\nhas no \\n, \\r, or \\t characters and uses only single spaces between\nwords. If s starts with any of the IllegalPrefixes, the result\nis the empty string.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "doc.Synopsis(s)"}
  [^String s])

JOKER FUNC doc.ToHTML has:
;; (defn ToHTML
;;   "ToHTML converts comment text to formatted HTML.\nThe comment was prepared by DocReader,\nso it is known not to have leading, trailing blank lines\nnor to have trailing spaces at the end of lines.\nThe comment markers have already been removed.\n\nEach span of unindented non-blank lines is converted into\na single paragraph. There is one exception to the rule: a span that\nconsists of a single line, is followed by another paragraph span,\nbegins with a capital letter, and contains no punctuation\nother than parentheses and commas is formatted as a heading.\n\nA span of indented lines is converted into a <pre> block,\nwith the common indent prefix removed.\n\nURLs in the comment text are converted into links; if the URL also appears\nin the words map, the link is taken from the map (if the corresponding map\nvalue is the empty string, the URL is not converted into a link).\n\nGo identifiers that appear in the words map are italicized; if the corresponding\nmap value is not the empty string, it is considered a URL and the word is converted\ninto a link.\n"
;;   {:added "1.0"
;;    :go "toHTML(w, text, words)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/comment.go:308:15) w, ^String text, ^ABEND881(unrecognized Expr type *ast.MapType at: GO.link/src/go/doc/comment.go:308:45) words])

JOKER FUNC doc.ToText has:
;; (defn ToText
;;   "ToText prepares comment text for presentation in textual output.\nIt wraps paragraphs of text to width or fewer Unicode code points\nand then prefixes each line with the indent. In preformatted sections\n(such as program text), it prefixes each non-blank line with preIndent.\n"
;;   {:added "1.0"
;;    :go "toText(w, text, indent, preIndent, width)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/comment.go:422:15) w, ^String text, ^String indent, ^String preIndent, ^Int width])

JOKER FUNC draw.Draw has:
;; (defn Draw
;;   "Draw calls DrawMask with a nil mask.\n"
;;   {:added "1.0"
;;    :go "draw(dst, r, src, sp, op)"}
;;   [^ABEND885(unrecognized type Image at: GO.link/src/image/draw/draw.go:100:15) dst, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:100:24) r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:100:45) src, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:100:61) sp, ^ABEND885(unrecognized type Op at: GO.link/src/image/draw/draw.go:100:77) op])

JOKER FUNC draw.DrawMask has:
;; (defn DrawMask
;;   "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r\nin dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.\n"
;;   {:added "1.0"
;;    :go "drawMask(dst, r, src, sp, mask, mp, op)"}
;;   [^ABEND885(unrecognized type Image at: GO.link/src/image/draw/draw.go:106:19) dst, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:106:28) r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:106:49) src, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:106:65) sp, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:106:83) mask, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:106:99) mp, ^ABEND885(unrecognized type Op at: GO.link/src/image/draw/draw.go:106:115) op])

JOKER FUNC driver.IsScanValue has:
;; (defn ^Bool IsScanValue
;;   "IsScanValue is equivalent to IsValue.\nIt exists for compatibility.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "driver.IsScanValue(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/database/sql/driver/types.go:188:20) v])

JOKER FUNC driver.IsValue has:
;; (defn ^Bool IsValue
;;   "IsValue reports whether v is a valid Value parameter type.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "driver.IsValue(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/database/sql/driver/types.go:175:16) v])

JOKER FUNC dsa.GenerateKey has:
;; (defn ^Error GenerateKey
;;   "GenerateKey generates a public&private key pair. The Parameters of the\nPrivateKey must already be valid (see GenerateParameters).\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateKey(priv, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/dsa/dsa.go:153:23) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/dsa/dsa.go:153:41) rand])

JOKER FUNC dsa.GenerateParameters has:
;; (defn ^Error GenerateParameters
;;   "GenerateParameters puts a random, valid set of DSA parameters into params.\nThis function can take many seconds, even on fast machines.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateParameters(params, rand, sizes)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/dsa/dsa.go:59:32) params, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/dsa/dsa.go:59:50) rand, ^ABEND885(unrecognized type ParameterSizes at: GO.link/src/crypto/dsa/dsa.go:59:67) sizes])

JOKER FUNC dsa.Sign has:
;; (defn Sign
;;   "Sign signs an arbitrary length hash (which should be the result of hashing a\nlarger message) using the private key, priv. It returns the signature as a\npair of integers. The security of the private key depends on the entropy of\nrand.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nBe aware that calling Sign with an attacker-controlled PrivateKey may\nrequire an arbitrary amount of CPU.\n\nGo return type: (r *..., s *..., err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/dsa/dsa.go:199:65) ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/dsa/dsa.go:199:65) Error]"
;;   {:added "1.0"
;;    :go "sign(rand, priv, hash)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/dsa/dsa.go:199:16) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/dsa/dsa.go:199:32) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/dsa/dsa.go:199:50) hash])

JOKER FUNC dsa.Verify has:
;; (defn ^Bool Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. It\nreports whether the signature is valid.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "dsa.Verify(pub, hash, r, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/dsa/dsa.go:267:17) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/dsa/dsa.go:267:34) hash, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/dsa/dsa.go:267:47) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/dsa/dsa.go:267:47) s])

JOKER FUNC dwarf.New has:
;; (defn New
;;   "New returns a new Data object initialized from the given parameters.\nRather than calling this function directly, clients should typically use\nthe DWARF method of the File type of the appropriate package debug/elf,\ndebug/macho, or debug/pe.\n\nThe []byte arguments are the data from the corresponding debug section\nin the object file; for example, for an ELF object, abbrev is the contents of\nthe \".debug_abbrev\" section.\n\nGo return type: (*Data, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "new(abbrev, aranges, frame, info, line, pubnames, ranges, str)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68) abbrev, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68) aranges, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68) frame, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68) info, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68) line, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68) pubnames, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68) ranges, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68) str])

JOKER FUNC ecdsa.GenerateKey has:
;; (defn GenerateKey
;;   "GenerateKey generates a public and private key pair.\n\nGo return type: (*PrivateKey, error)\n\nJoker return type: [{:D ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:57:5)} Error]"
;;   {:added "1.0"
;;    :go "generateKey(c, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:105:20) c, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:105:41) rand])

JOKER FUNC ecdsa.Sign has:
;; (defn Sign
;;   "Sign signs a hash (which should be the result of hashing a larger message)\nusing the private key, priv. If the hash is longer than the bit-length of the\nprivate key's curve order, the hash will be truncated to that length.  It\nreturns the signature as a pair of integers. The security of the private key\ndepends on the entropy of rand.\n\nGo return type: (r *..., s *..., err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:156:65) ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:156:65) Error]"
;;   {:added "1.0"
;;    :go "sign(rand, priv, hash)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:156:16) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:156:32) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/ecdsa/ecdsa.go:156:50) hash])

JOKER FUNC ecdsa.Verify has:
;; (defn ^Bool Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. Its\nreturn value records whether the signature is valid.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ecdsa.Verify(pub, hash, r, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:234:17) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/ecdsa/ecdsa.go:234:34) hash, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:234:47) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:234:47) s])

JOKER FUNC elf.NewFile has:
;; (defn NewFile
;;   "NewFile creates a new File for accessing an ELF binary in an underlying reader.\nThe ELF binary is expected to start at position 0 in the ReaderAt.\n\nGo return type: (*File, error)\n\nJoker return type: [{:Sections ^(vector-of {}), :Progs ^(vector-of {})} Error]"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/elf/file.go:235:16) r])

JOKER FUNC elf.Open has:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as an ELF binary.\n\nGo return type: (*File, error)\n\nJoker return type: [{:Sections ^(vector-of {}), :Progs ^(vector-of {})} Error]"
  {:added "1.0"
   :go "open(name)"}
  [^String name])

JOKER FUNC elf.R_INFO has:
;; (defn R_INFO
;;   "Go return type: uint64\n\nJoker return type: ABEND042(cannot find typename elf.uint64)"
;;   {:added "1.0"
;;    :go "r_INFO(sym, typ)"}
;;   [^Int sym, ^Int typ])

JOKER FUNC elf.R_INFO32 has:
(defn ^Int R_INFO32
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "elf.R_INFO32(sym, typ)"}
  [^Int sym, ^Int typ])

JOKER FUNC elf.R_SYM32 has:
(defn ^Int R_SYM32
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "elf.R_SYM32(info)"}
  [^Int info])

JOKER FUNC elf.R_SYM64 has:
;; (defn ^Int R_SYM64
;;   "Go return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "elf.R_SYM64(info)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/debug/elf/elf.go:2925:19) info])

JOKER FUNC elf.R_TYPE32 has:
(defn ^Int R_TYPE32
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "elf.R_TYPE32(info)"}
  [^Int info])

JOKER FUNC elf.R_TYPE64 has:
;; (defn ^Int R_TYPE64
;;   "Go return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "elf.R_TYPE64(info)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/debug/elf/elf.go:2926:20) info])

JOKER FUNC elf.ST_BIND has:
;; (defn ^Int ST_BIND
;;   "Go return type: SymBind\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "elf.ST_BIND(info)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/debug/elf/elf.go:2839:19) info])

JOKER FUNC elf.ST_INFO has:
;; (defn ST_INFO
;;   "Go return type: uint8\n\nJoker return type: ABEND042(cannot find typename elf.uint8)"
;;   {:added "1.0"
;;    :go "sT_INFO(bind, typ)"}
;;   [^ABEND885(unrecognized type SymBind at: GO.link/src/debug/elf/elf.go:2841:19) bind, ^ABEND885(unrecognized type SymType at: GO.link/src/debug/elf/elf.go:2841:32) typ])

JOKER FUNC elf.ST_TYPE has:
;; (defn ^Int ST_TYPE
;;   "Go return type: SymType\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "elf.ST_TYPE(info)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/debug/elf/elf.go:2840:19) info])

JOKER FUNC elf.ST_VISIBILITY has:
;; (defn ^Int ST_VISIBILITY
;;   "Go return type: SymVis\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "elf.ST_VISIBILITY(other)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/debug/elf/elf.go:2844:26) other])

JOKER FUNC elliptic.GenerateKey has:
;; (defn GenerateKey
;;   "GenerateKey returns a public/private key pair. The private key is\ngenerated using the given reader, which must return random data.\n\nGo return type: (priv []int, x *..., y *..., err error)\n\nJoker return type: [(vector-of Int) ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/elliptic/elliptic.go:276:67) ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/elliptic/elliptic.go:276:67) Error]"
;;   {:added "1.0"
;;    :go "generateKey(curve, rand)"}
;;   [^ABEND885(unrecognized type Curve at: GO.link/src/crypto/elliptic/elliptic.go:276:24) curve, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/elliptic/elliptic.go:276:36) rand])

JOKER FUNC elliptic.Marshal has:
;; (defn Marshal
;;   "Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "marshal(curve, x, y)"}
;;   [^ABEND885(unrecognized type Curve at: GO.link/src/crypto/elliptic/elliptic.go:305:20) curve, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/elliptic/elliptic.go:305:32) x, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/elliptic/elliptic.go:305:32) y])

JOKER FUNC elliptic.P224 has:
;; (defn P224
;;   "P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p224()"}
;;   [])

JOKER FUNC elliptic.P256 has:
;; (defn P256
;;   "P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p256()"}
;;   [])

JOKER FUNC elliptic.P384 has:
;; (defn P384
;;   "P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p384()"}
;;   [])

JOKER FUNC elliptic.P521 has:
;; (defn P521
;;   "P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p521()"}
;;   [])

JOKER FUNC elliptic.Unmarshal has:
;; (defn Unmarshal
;;   "Unmarshal converts a point, serialized by Marshal, into an x, y pair.\nIt is an error if the point is not in uncompressed form or is not on the curve.\nOn error, x = nil.\n\nGo return type: (x *..., y *...)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/elliptic/elliptic.go:321:49) ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/elliptic/elliptic.go:321:49)]"
;;   {:added "1.0"
;;    :go "unmarshal(curve, data)"}
;;   [^ABEND885(unrecognized type Curve at: GO.link/src/crypto/elliptic/elliptic.go:321:22) curve, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/elliptic/elliptic.go:321:34) data])

JOKER FUNC errors.New has:
(defn ^Error New
  "New returns an error that formats as the given text.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "errors.New(text)"}
  [^String text])

JOKER FUNC exec.Command has:
;; (defn Command
;;   "Command returns the Cmd struct to execute the named program with\nthe given arguments.\n\nIt sets only the Path and Args in the returned structure.\n\nIf name contains no path separators, Command uses LookPath to\nresolve name to a complete path if possible. Otherwise it uses name\ndirectly as Path.\n\nThe returned Cmd's Args field is constructed from the command name\nfollowed by the elements of arg, so arg should not include the\ncommand name itself. For example, Command(\"echo\", \"hello\").\nArgs[0] is always name, not the possibly resolved Path.\n\nGo return type: *Cmd\n\nJoker return type: {:Path ^String, :Args ^(vector-of String), :Env ^(vector-of String), :Dir ^String, :Stdin ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:93:8), :Stdout ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:110:9), :Stderr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:111:9), :ExtraFiles ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:118:16)), :SysProcAttr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:122:15), :Process ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:125:11), :ProcessState ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:129:16)}"
;;   {:added "1.0"
;;    :go "command(name, arg)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/os/exec/exec.go:155:31) arg])

JOKER FUNC exec.CommandContext has:
;; (defn CommandContext
;;   "CommandContext is like Command but includes a context.\n\nThe provided context is used to kill the process (by calling\nos.Process.Kill) if the context becomes done before the command\ncompletes on its own.\n\nGo return type: *Cmd\n\nJoker return type: {:Path ^String, :Args ^(vector-of String), :Env ^(vector-of String), :Dir ^String, :Stdin ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:93:8), :Stdout ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:110:9), :Stderr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:111:9), :ExtraFiles ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:118:16)), :SysProcAttr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:122:15), :Process ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:125:11), :ProcessState ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:129:16)}"
;;   {:added "1.0"
;;    :go "commandContext(ctx, name, arg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:175:25) ctx, ^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/os/exec/exec.go:175:59) arg])

JOKER FUNC exec.LookPath has:
(defn LookPath
  "LookPath searches for an executable named file in the\ndirectories named by the PATH environment variable.\nIf file contains a slash, it is tried directly and the PATH is not consulted.\nThe result may be an absolute path or a path relative to the current directory.\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "lookPath(file)"}
  [^String file])

JOKER FUNC expvar.Do has:
;; (defn Do
;;   "Do calls f for each exported variable.\nThe global variable map is locked during the iteration,\nbut existing entries may be concurrently updated.\n"
;;   {:added "1.0"
;;    :go "do(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/expvar/expvar.go:306:11) f])

JOKER FUNC expvar.Get has:
;; (defn Get
;;   "Get retrieves a named exported variable. It returns nil if the name has\nnot been registered.\n\nGo return type: Var\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/expvar/expvar.go:40:10)"
;;   {:added "1.0"
;;    :go "get(name)"}
;;   [^String name])

JOKER FUNC expvar.Handler has:
;; (defn Handler
;;   "Handler returns the expvar HTTP Handler.\n\nThis is only needed to install the handler in a non-standard location.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/expvar/expvar.go:332:16)"
;;   {:added "1.0"
;;    :go "handler()"}
;;   [])

JOKER FUNC expvar.NewFloat has:
;; (defn NewFloat
;;   "Go return type: *Float\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newFloat(name)"}
;;   [^String name])

JOKER FUNC expvar.NewInt has:
;; (defn NewInt
;;   "Go return type: *Int\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newInt(name)"}
;;   [^String name])

JOKER FUNC expvar.NewMap has:
;; (defn NewMap
;;   "Go return type: *Map\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newMap(name)"}
;;   [^String name])

JOKER FUNC expvar.NewString has:
;; (defn NewString
;;   "Go return type: *String\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newString(name)"}
;;   [^String name])

JOKER FUNC expvar.Publish has:
;; (defn Publish
;;   "Publish declares a named exported variable. This should be called from a\npackage's init function when it creates its Vars. If the name is already\nregistered then this will log.Panic.\n"
;;   {:added "1.0"
;;    :go "publish(name, v)"}
;;   [^String name, ^ABEND885(unrecognized type Var at: GO.link/src/expvar/expvar.go:259:29) v])

JOKER FUNC fcgi.ProcessEnv has:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "processEnv(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/fcgi/child.go:358:19) r])

JOKER FUNC fcgi.Serve has:
;; (defn ^Error Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fcgi.Serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/fcgi/child.go:331:14) l, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/fcgi/child.go:331:36) handler])

JOKER FUNC filepath.Abs has:
(defn Abs
  "Abs returns an absolute representation of path.\nIf the path is not absolute it will be joined with the current\nworking directory to turn it into an absolute path. The absolute\npath name for a given file is not guaranteed to be unique.\nAbs calls Clean on the result.\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "abs(path)"}
  [^String path])

JOKER FUNC filepath.Base has:
(defn ^String Base
  "Base returns the last element of path.\nTrailing path separators are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of separators, Base returns a single separator.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Base(path)"}
  [^String path])

JOKER FUNC filepath.Clean has:
(defn ^String Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple Separator elements with a single one.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path,\n\t   assuming Separator is '/'.\n\nThe returned path ends in a slash only if it represents a root directory,\nsuch as \"/\" on Unix or `C:\\` on Windows.\n\nFinally, any occurrences of slash are replaced by Separator.\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Clean(path)"}
  [^String path])

JOKER FUNC filepath.Dir has:
(defn ^String Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element, Dir calls Clean on the path and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of separators, Dir returns a single separator.\nThe returned path does not end in a separator unless it is the root directory.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Dir(path)"}
  [^String path])

JOKER FUNC filepath.EvalSymlinks has:
(defn EvalSymlinks
  "EvalSymlinks returns the path name after the evaluation of any symbolic\nlinks.\nIf path is relative the result will be relative to the current directory,\nunless one of the components is an absolute symbolic link.\nEvalSymlinks calls Clean on the result.\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "evalSymlinks(path)"}
  [^String path])

JOKER FUNC filepath.Ext has:
(defn ^String Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final element of path; it is empty if there is\nno dot.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Ext(path)"}
  [^String path])

JOKER FUNC filepath.FromSlash has:
(defn ^String FromSlash
  "FromSlash returns the result of replacing each slash ('/') character\nin path with a separator character. Multiple slashes are replaced\nby multiple separators.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.FromSlash(path)"}
  [^String path])

JOKER FUNC filepath.Glob has:
(defn Glob
  "Glob returns the names of all files matching pattern or nil\nif there is no matching file. The syntax of patterns is the same\nas in Match. The pattern may describe hierarchical names such as\n/usr/*/bin/ed (assuming the Separator is '/').\n\nGlob ignores file system errors such as I/O errors reading directories.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo return type: (matches []string, err error)\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "glob(pattern)"}
  [^String pattern])

JOKER FUNC filepath.HasPrefix has:
(defn ^Bool HasPrefix
  "HasPrefix exists for historical compatibility and should not be used.\n\nDeprecated: HasPrefix does not respect path boundaries and\ndoes not ignore case when required.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "filepath.HasPrefix(p, prefix)"}
  [^String p, ^String prefix])

JOKER FUNC filepath.IsAbs has:
(defn ^Bool IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "filepath.IsAbs(path)"}
  [^String path])

JOKER FUNC filepath.Join has:
;; (defn ^String Join
;;   "Join joins any number of path elements into a single path, adding\na Separator if necessary. Join calls Clean on the result; in particular,\nall empty strings are ignored.\nOn Windows, the result is a UNC path if and only if the first path\nelement is a UNC path.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "filepath.Join(elem)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/path/filepath/path.go:209:16) elem])

JOKER FUNC filepath.Match has:
(defn Match
  "Match reports whether name matches the shell file name pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-Separator characters\n\t\t'?'         matches any single non-Separator character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nOn Windows, escaping is disabled. Instead, '\\\\' is treated as\npath separator.\n\nGo return type: (matched bool, err error)\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "match(pattern, name)"}
  [^String pattern, ^String name])

JOKER FUNC filepath.Rel has:
(defn Rel
  "Rel returns a relative path that is lexically equivalent to targpath when\njoined to basepath with an intervening separator. That is,\nJoin(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.\nOn success, the returned path will always be relative to basepath,\neven if basepath and targpath share no elements.\nAn error is returned if targpath can't be made relative to basepath or if\nknowing the current working directory would be necessary to compute it.\nRel calls Clean on the result.\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "rel(basepath, targpath)"}
  [^String basepath, ^String targpath])

JOKER FUNC filepath.Split has:
(defn Split
  "Split splits path immediately following the final Separator,\nseparating it into a directory and file name component.\nIf there is no Separator in path, Split returns an empty dir\nand file set to path.\nThe returned values have the property that path = dir+file.\n\nGo return type: (dir string, file string)\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "split(path)"}
  [^String path])

JOKER FUNC filepath.SplitList has:
(defn SplitList
  "SplitList splits a list of paths joined by the OS-specific ListSeparator,\nusually found in PATH or GOPATH environment variables.\nUnlike strings.Split, SplitList returns an empty slice when passed an empty\nstring.\n\nGo return type: []string\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitList(path)"}
  [^String path])

JOKER FUNC filepath.ToSlash has:
(defn ^String ToSlash
  "ToSlash returns the result of replacing each separator character\nin path with a slash ('/') character. Multiple separators are\nreplaced by multiple slashes.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.ToSlash(path)"}
  [^String path])

JOKER FUNC filepath.VolumeName has:
(defn ^String VolumeName
  "VolumeName returns leading volume name.\nGiven \"C:\\foo\\bar\" it returns \"C:\" on Windows.\nGiven \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\".\nOn other platforms it returns \"\".\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.VolumeName(path)"}
  [^String path])

JOKER FUNC filepath.Walk has:
;; (defn ^Error Walk
;;   "Walk walks the file tree rooted at root, calling walkFn for each file or\ndirectory in the tree, including root. All errors that arise visiting files\nand directories are filtered by walkFn. The files are walked in lexical\norder, which makes the output deterministic but means that for very\nlarge directories Walk can be inefficient.\nWalk does not follow symbolic links.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "filepath.Walk(root, walkFn)"}
;;   [^String root, ^ABEND885(unrecognized type WalkFunc at: GO.link/src/path/filepath/path.go:399:31) walkFn])

JOKER FUNC flag.Arg has:
(defn ^String Arg
  "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument\nafter flags have been processed. Arg returns an empty string if the\nrequested element does not exist.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "flag.Arg(i)"}
  [^Int i])

JOKER FUNC flag.Args has:
(defn Args
  "Args returns the non-flag command-line arguments.\n\nGo return type: []string\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "args()"}
  [])

JOKER FUNC flag.Bool has:
(defn ^Bool Bool
  "Bool defines a bool flag with specified name, default value, and usage string.\nThe return value is the address of a bool variable that stores the value of the flag.\n\nGo return type: *bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "flag.Bool(name, value, usage)"}
  [^String name, ^Bool value, ^String usage])

JOKER FUNC flag.BoolVar has:
;; (defn BoolVar
;;   "BoolVar defines a bool flag with specified name, default value, and usage string.\nThe argument p points to a bool variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "boolVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:583:16) p, ^String name, ^Bool value, ^String usage])

JOKER FUNC flag.Duration has:
;; (defn Duration
;;   "Duration defines a time.Duration flag with specified name, default value, and usage string.\nThe return value is the address of a time.Duration variable that stores the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo return type: *...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/flag/flag.go:783:64)"
;;   {:added "1.0"
;;    :go "duration(name, value, usage)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/flag/flag.go:783:34) value, ^String usage])

JOKER FUNC flag.DurationVar has:
;; (defn DurationVar
;;   "DurationVar defines a time.Duration flag with specified name, default value, and usage string.\nThe argument p points to a time.Duration variable in which to store the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n"
;;   {:added "1.0"
;;    :go "durationVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:767:20) p, ^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/flag/flag.go:767:55) value, ^String usage])

JOKER FUNC flag.Float64 has:
;; (defn Float64
;;   "Float64 defines a float64 flag with specified name, default value, and usage string.\nThe return value is the address of a float64 variable that stores the value of the flag.\n\nGo return type: *float64\n\nJoker return type: ABEND042(cannot find typename flag.float64)"
;;   {:added "1.0"
;;    :go "float64(name, value, usage)"}
;;   [^String name, ^ABEND885(unrecognized type float64 at: GO.link/src/flag/flag.go:753:33) value, ^String usage])

JOKER FUNC flag.Float64Var has:
;; (defn Float64Var
;;   "Float64Var defines a float64 flag with specified name, default value, and usage string.\nThe argument p points to a float64 variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "float64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:739:19) p, ^String name, ^ABEND885(unrecognized type float64 at: GO.link/src/flag/flag.go:739:48) value, ^String usage])

JOKER FUNC flag.Int has:
(defn ^Int Int
  "Int defines an int flag with specified name, default value, and usage string.\nThe return value is the address of an int variable that stores the value of the flag.\n\nGo return type: *int\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.Int(name, value, usage)"}
  [^String name, ^Int value, ^String usage])

JOKER FUNC flag.Int64 has:
(defn ^Int Int64
  "Int64 defines an int64 flag with specified name, default value, and usage string.\nThe return value is the address of an int64 variable that stores the value of the flag.\n\nGo return type: *int\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.Int64(name, value, usage)"}
  [^String name, ^Int value, ^String usage])

JOKER FUNC flag.Int64Var has:
;; (defn Int64Var
;;   "Int64Var defines an int64 flag with specified name, default value, and usage string.\nThe argument p points to an int64 variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "int64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:635:17) p, ^String name, ^Int value, ^String usage])

JOKER FUNC flag.IntVar has:
;; (defn IntVar
;;   "IntVar defines an int flag with specified name, default value, and usage string.\nThe argument p points to an int variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "intVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:609:15) p, ^String name, ^Int value, ^String usage])

JOKER FUNC flag.Lookup has:
;; (defn Lookup
;;   "Lookup returns the Flag structure of the named command-line flag,\nreturning nil if none exists.\n\nGo return type: *Flag\n\nJoker return type: {:Name ^String, :Usage ^String, :Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/flag/flag.go:248:12), :DefValue ^String}"
;;   {:added "1.0"
;;    :go "lookup(name)"}
;;   [^String name])

JOKER FUNC flag.NArg has:
(defn ^Int NArg
  "NArg is the number of arguments remaining after flags have been processed.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NArg()"}
  [])

JOKER FUNC flag.NFlag has:
(defn ^Int NFlag
  "NFlag returns the number of command-line flags that have been set.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NFlag()"}
  [])

JOKER FUNC flag.NewFlagSet has:
;; (defn NewFlagSet
;;   "NewFlagSet returns a new, empty flag set with the specified name and\nerror handling property. If the name is not empty, it will be printed\nin the default usage message and in error messages.\n\nGo return type: *FlagSet\n\nJoker return type: {:Usage ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/flag/flag.go:280:8)}"
;;   {:added "1.0"
;;    :go "newFlagSet(name, errorHandling)"}
;;   [^String name, ^ABEND885(unrecognized type ErrorHandling at: GO.link/src/flag/flag.go:981:44) errorHandling])

JOKER FUNC flag.Parse has:
;; (defn Parse
;;   "Parse parses the command-line flags from os.Args[1:]. Must be called\nafter all flags are defined and before flags are accessed by the program.\n"
;;   {:added "1.0"
;;    :go "parse()"}
;;   [])

JOKER FUNC flag.Parsed has:
(defn ^Bool Parsed
  "Parsed reports whether the command-line flags have been parsed.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "flag.Parsed()"}
  [])

JOKER FUNC flag.PrintDefaults has:
;; (defn PrintDefaults
;;   "PrintDefaults prints, to standard error unless configured otherwise,\na usage message showing the default settings of all defined\ncommand-line flags.\nFor an integer valued flag x, the default output has the form\n\t-x int\n\t\tusage-message-for-x (default 7)\nThe usage message will appear on a separate line for anything but\na bool flag with a one-byte name. For bool flags, the type is\nomitted and if the flag name is one byte the usage message appears\non the same line. The parenthetical default is omitted if the\ndefault is the zero value for the type. The listed type, here int,\ncan be changed by placing a back-quoted name in the flag's usage\nstring; the first such item in the message is taken to be a parameter\nname to show in the message and the back quotes are stripped from\nthe message when displayed. For instance, given\n\tflag.String(\"I\", \"\", \"search `directory` for include files\")\nthe output will be\n\t-I directory\n\t\tsearch directory for include files.\n"
;;   {:added "1.0"
;;    :go "printDefaults()"}
;;   [])

JOKER FUNC flag.Set has:
(defn ^Error Set
  "Set sets the value of the named command-line flag.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "flag.Set(name, value)"}
  [^String name, ^String value])

JOKER FUNC flag.String has:
(defn ^String String
  "String defines a string flag with specified name, default value, and usage string.\nThe return value is the address of a string variable that stores the value of the flag.\n\nGo return type: *string\n\nJoker return type: String"
  {:added "1.0"
   :go "flag.String(name, value, usage)"}
  [^String name, ^String value, ^String usage])

JOKER FUNC flag.StringVar has:
;; (defn StringVar
;;   "StringVar defines a string flag with specified name, default value, and usage string.\nThe argument p points to a string variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "stringVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:713:18) p, ^String name, ^String value, ^String usage])

JOKER FUNC flag.Uint has:
(defn ^Int Uint
  "Uint defines a uint flag with specified name, default value, and usage string.\nThe return value is the address of a uint variable that stores the value of the flag.\n\nGo return type: *int\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.Uint(name, value, usage)"}
  [^String name, ^Int value, ^String usage])

JOKER FUNC flag.Uint64 has:
;; (defn Uint64
;;   "Uint64 defines a uint64 flag with specified name, default value, and usage string.\nThe return value is the address of a uint64 variable that stores the value of the flag.\n\nGo return type: *uint64\n\nJoker return type: ABEND042(cannot find typename flag.uint64)"
;;   {:added "1.0"
;;    :go "uint64(name, value, usage)"}
;;   [^String name, ^ABEND885(unrecognized type uint64 at: GO.link/src/flag/flag.go:701:32) value, ^String usage])

JOKER FUNC flag.Uint64Var has:
;; (defn Uint64Var
;;   "Uint64Var defines a uint64 flag with specified name, default value, and usage string.\nThe argument p points to a uint64 variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "uint64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:687:18) p, ^String name, ^ABEND885(unrecognized type uint64 at: GO.link/src/flag/flag.go:687:46) value, ^String usage])

JOKER FUNC flag.UintVar has:
;; (defn UintVar
;;   "UintVar defines a uint flag with specified name, default value, and usage string.\nThe argument p points to a uint variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "uintVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:661:16) p, ^String name, ^Int value, ^String usage])

JOKER FUNC flag.UnquoteUsage has:
;; (defn UnquoteUsage
;;   "UnquoteUsage extracts a back-quoted name from the usage\nstring for a flag and returns it and the un-quoted usage.\nGiven \"a `name` to show\" it returns (\"name\", \"a name to show\").\nIf there are no back quotes, the name is an educated guess of the\ntype of the flag's value, or the empty string if the flag is boolean.\n\nGo return type: (name string, usage string)\n\nJoker return type: [String String]"
;;   {:added "1.0"
;;    :go "unquoteUsage(flag)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:422:24) flag])

JOKER FUNC flag.Var has:
;; (defn Var
;;   "Var defines a flag with the specified name and usage string. The type and\nvalue of the flag are represented by the first argument, of type Value, which\ntypically holds a user-defined implementation of Value. For instance, the\ncaller could create a flag that turns a comma-separated string into a slice\nof strings by giving the slice the methods of Value; in particular, Set would\ndecompose the comma-separated string into the slice.\n"
;;   {:added "1.0"
;;    :go "var(value, name, usage)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/flag/flag.go:819:16) value, ^String name, ^String usage])

JOKER FUNC flag.Visit has:
;; (defn Visit
;;   "Visit visits the command-line flags in lexicographical order, calling fn\nfor each. It visits only those flags that have been set.\n"
;;   {:added "1.0"
;;    :go "visit(fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/flag/flag.go:364:15) fn])

JOKER FUNC flag.VisitAll has:
;; (defn VisitAll
;;   "VisitAll visits the command-line flags in lexicographical order, calling\nfn for each. It visits all flags, even those not set.\n"
;;   {:added "1.0"
;;    :go "visitAll(fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/flag/flag.go:350:18) fn])

JOKER FUNC flate.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new ReadCloser that can be used\nto read the uncompressed version of r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser\nwhen finished reading.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/flate/inflate.go:796:29)"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/flate/inflate.go:796:18) r])

JOKER FUNC flate.NewReaderDict has:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but initializes the reader\nwith a preset dictionary. The returned Reader behaves as if\nthe uncompressed data stream started with the given dictionary,\nwhich has already been read. NewReaderDict is typically used\nto read data compressed by NewWriterDict.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/flate/inflate.go:815:46)"
;;   {:added "1.0"
;;    :go "newReaderDict(r, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/flate/inflate.go:815:22) r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/compress/flate/inflate.go:815:38) dict])

JOKER FUNC flate.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer compressing data at the given level.\nFollowing zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\nhigher levels typically run slower but compress more. Level 0\n(NoCompression) does not attempt any compression; it only adds the\nnecessary DEFLATE framing.\nLevel -1 (DefaultCompression) uses the default compression level.\nLevel -2 (HuffmanOnly) will use Huffman compression only, giving\na very fast compression for all types of input, but sacrificing considerable\ncompression efficiency.\n\nIf level is in the range [-2, 9] then the error returned will be nil.\nOtherwise the error returned will be non-nil.\n\nGo return type: (*Writer, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newWriter(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/flate/deflate.go:666:18) w, ^Int level])

JOKER FUNC flate.NewWriterDict has:
;; (defn NewWriterDict
;;   "NewWriterDict is like NewWriter but initializes the new\nWriter with a preset dictionary. The returned Writer behaves\nas if the dictionary had been written to it without producing\nany compressed output. The compressed data written to w\ncan only be decompressed by a Reader initialized with the\nsame dictionary.\n\nGo return type: (*Writer, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newWriterDict(w, level, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/flate/deflate.go:680:22) w, ^Int level, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/compress/flate/deflate.go:680:49) dict])

JOKER FUNC fmt.Errorf has:
;; (defn ^Error Errorf
;;   "Errorf formats according to a format specifier and returns the string\nas a value that satisfies error.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fmt.Errorf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:211:30) a])

JOKER FUNC fmt.Fprint has:
;; (defn Fprint
;;   "Fprint formats using the default formats for its operands and writes to w.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fprint(w, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/print.go:220:15) w, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:220:28) a])

JOKER FUNC fmt.Fprintf has:
;; (defn Fprintf
;;   "Fprintf formats according to a format specifier and writes to w.\nIt returns the number of bytes written and any write error encountered.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fprintf(w, format, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/print.go:186:16) w, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:186:44) a])

JOKER FUNC fmt.Fprintln has:
;; (defn Fprintln
;;   "Fprintln formats using the default formats for its operands and writes to w.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fprintln(w, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/print.go:252:17) w, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:252:30) a])

JOKER FUNC fmt.Fscan has:
;; (defn Fscan
;;   "Fscan scans text read from r, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fscan(r, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/scan.go:121:14) r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:121:27) a])

JOKER FUNC fmt.Fscanf has:
;; (defn Fscanf
;;   "Fscanf scans text read from r, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fscanf(r, format, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/scan.go:141:15) r, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:141:43) a])

JOKER FUNC fmt.Fscanln has:
;; (defn Fscanln
;;   "Fscanln is similar to Fscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fscanln(r, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/scan.go:130:16) r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:130:29) a])

JOKER FUNC fmt.Print has:
;; (defn Print
;;   "Print formats using the default formats for its operands and writes to standard output.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "print(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:231:14) a])

JOKER FUNC fmt.Printf has:
;; (defn Printf
;;   "Printf formats according to a format specifier and writes to standard output.\nIt returns the number of bytes written and any write error encountered.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "printf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:196:30) a])

JOKER FUNC fmt.Println has:
;; (defn Println
;;   "Println formats using the default formats for its operands and writes to standard output.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "println(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:263:16) a])

JOKER FUNC fmt.Scan has:
;; (defn Scan
;;   "Scan scans text read from standard input, storing successive\nspace-separated values into successive arguments. Newlines count\nas space. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "scan(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:63:13) a])

JOKER FUNC fmt.Scanf has:
;; (defn Scanf
;;   "Scanf scans text read from standard input, storing successive\nspace-separated values into successive arguments as determined by\nthe format. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\nNewlines in the input must match newlines in the format.\nThe one exception: the verb %c always scans the next rune in the\ninput, even if it is a space (or tab etc.) or newline.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "scanf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:80:29) a])

JOKER FUNC fmt.Scanln has:
;; (defn Scanln
;;   "Scanln is similar to Scan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "scanln(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:69:15) a])

JOKER FUNC fmt.Sprint has:
;; (defn ^String Sprint
;;   "Sprint formats using the default formats for its operands and returns the resulting string.\nSpaces are added between operands when neither is a string.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprint(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:237:15) a])

JOKER FUNC fmt.Sprintf has:
;; (defn ^String Sprintf
;;   "Sprintf formats according to a format specifier and returns the resulting string.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:201:31) a])

JOKER FUNC fmt.Sprintln has:
;; (defn ^String Sprintln
;;   "Sprintln formats using the default formats for its operands and returns the resulting string.\nSpaces are always added between operands and a newline is appended.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintln(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:269:17) a])

JOKER FUNC fmt.Sscan has:
;; (defn Sscan
;;   "Sscan scans the argument string, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sscan(str, a)"}
;;   [^String str, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:99:26) a])

JOKER FUNC fmt.Sscanf has:
;; (defn Sscanf
;;   "Sscanf scans the argument string, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sscanf(str, format, a)"}
;;   [^String str, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:113:42) a])

JOKER FUNC fmt.Sscanln has:
;; (defn Sscanln
;;   "Sscanln is similar to Sscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sscanln(str, a)"}
;;   [^String str, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:105:28) a])

JOKER FUNC fnv.New128 has:
;; (defn New128
;;   "New128 returns a new 128-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/hash/fnv/fnv.go:70:15)"
;;   {:added "1.0"
;;    :go "new128()"}
;;   [])

JOKER FUNC fnv.New128a has:
;; (defn New128a
;;   "New128a returns a new 128-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/hash/fnv/fnv.go:79:16)"
;;   {:added "1.0"
;;    :go "new128a()"}
;;   [])

JOKER FUNC fnv.New32 has:
;; (defn New32
;;   "New32 returns a new 32-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/hash/fnv/fnv.go:42:14)"
;;   {:added "1.0"
;;    :go "new32()"}
;;   [])

JOKER FUNC fnv.New32a has:
;; (defn New32a
;;   "New32a returns a new 32-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/hash/fnv/fnv.go:49:15)"
;;   {:added "1.0"
;;    :go "new32a()"}
;;   [])

JOKER FUNC fnv.New64 has:
;; (defn New64
;;   "New64 returns a new 64-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/hash/fnv/fnv.go:56:14)"
;;   {:added "1.0"
;;    :go "new64()"}
;;   [])

JOKER FUNC fnv.New64a has:
;; (defn New64a
;;   "New64a returns a new 64-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/hash/fnv/fnv.go:63:15)"
;;   {:added "1.0"
;;    :go "new64a()"}
;;   [])

JOKER FUNC format.Node has:
;; (defn ^Error Node
;;   "Node formats node in canonical gofmt style and writes the result to dst.\n\nThe node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n[]ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,\nor ast.Stmt. Node does not modify node. Imports are not sorted for\nnodes representing partial source files (for instance, if the node is\nnot an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).\n\nThe function may return early (before the entire result is written)\nand return a formatting error, for instance due to an incorrect AST.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "format.Node(dst, fset, node)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/format/format.go:42:15) dst, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/format/format.go:42:31) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/format/format.go:42:52) node])

JOKER FUNC format.Source has:
;; (defn Source
;;   "Source formats src in canonical gofmt style and returns the result\nor an (I/O or syntax) error. src is expected to be a syntactically\ncorrect Go source file, or a list of Go declarations or statements.\n\nIf src is a partial source file, the leading and trailing space of src\nis applied to the result (such that it has the same leading and trailing\nspace as src), and the result is indented by the same amount as the first\nline of src containing code. Imports are not sorted for partial source files.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "source(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/format/format.go:91:17) src])

JOKER FUNC gif.Decode has:
;; (defn Decode
;;   "Decode reads a GIF image from r and returns the first embedded\nimage as an image.Image.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/reader.go:561:27) Error]"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/reader.go:561:15) r])

JOKER FUNC gif.DecodeAll has:
;; (defn DecodeAll
;;   "DecodeAll reads a GIF image from r and returns the sequential frames\nand timing information.\n\nGo return type: (*GIF, error)\n\nJoker return type: [{:Image ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/reader.go:571:11)), :Delay ^(vector-of Int), :LoopCount ^Int, :Disposal ^(vector-of Int), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/reader.go:593:9), :BackgroundIndex ^Int} Error]"
;;   {:added "1.0"
;;    :go "decodeAll(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/reader.go:601:18) r])

JOKER FUNC gif.DecodeConfig has:
;; (defn DecodeConfig
;;   "DecodeConfig returns the global color model and dimensions of a GIF image\nwithout decoding the entire image.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/reader.go:623:33) Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/reader.go:623:21) r])

JOKER FUNC gif.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in GIF format.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.Encode(w, m, o)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/writer.go:418:15) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/writer.go:418:28) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/image/gif/writer.go:418:43) o])

JOKER FUNC gif.EncodeAll has:
;; (defn ^Error EncodeAll
;;   "EncodeAll writes the images in g to w in GIF format with the\ngiven loop count and delay between frames.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.EncodeAll(w, g)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/writer.go:372:18) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/image/gif/writer.go:372:31) g])

JOKER FUNC gob.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from the io.Reader.\nIf r does not also implement io.ByteReader, it will be wrapped in a\nbufio.Reader.\n\nGo return type: *Decoder\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/gob/decoder.go:41:19) r])

JOKER FUNC gob.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that will transmit on the io.Writer.\n\nGo return type: *Encoder\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/gob/encoder.go:33:19) w])

JOKER FUNC gob.Register has:
;; (defn Register
;;   "Register records a type, identified by a value for that type, under its\ninternal type name. That name will identify the concrete type of a value\nsent or received as an interface variable. Only types that will be\ntransferred as implementations of interface values need to be registered.\nExpecting to be used only during initialization, it panics if the mapping\nbetween types and names is not a bijection.\n"
;;   {:added "1.0"
;;    :go "register(value)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/gob/type.go:836:21) value])

JOKER FUNC gob.RegisterName has:
;; (defn RegisterName
;;   "RegisterName is like Register but uses the provided name rather than the\ntype's default.\n"
;;   {:added "1.0"
;;    :go "registerName(name, value)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/gob/type.go:807:38) value])

JOKER FUNC gosym.NewLineTable has:
;; (defn NewLineTable
;;   "NewLineTable returns a new PC/line table\ncorresponding to the encoded data.\nText must be the start address of the\ncorresponding text segment.\n\nGo return type: *LineTable\n\nJoker return type: {:Data ^(vector-of Int), :PC ^ABEND042(cannot find typename gosym.uint64), :Line ^Int}"
;;   {:added "1.0"
;;    :go "newLineTable(data, text)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/gosym/pclntab.go:124:24) data, ^ABEND885(unrecognized type uint64 at: GO.link/src/debug/gosym/pclntab.go:124:37) text])

JOKER FUNC gosym.NewTable has:
;; (defn NewTable
;;   "NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF),\nreturning an in-memory representation.\nStarting with Go 1.3, the Go symbol table no longer includes symbol data.\n\nGo return type: (*Table, error)\n\nJoker return type: [{:Syms ^(vector-of {:Value ^ABEND042(cannot find typename gosym.uint64), :Type ^Int, :Name ^String, :GoType ^ABEND042(cannot find typename gosym.uint64), :Func ^{:Entry ^ABEND042(cannot find typename gosym.uint64), :End ^ABEND042(cannot find typename gosym.uint64), :Params ^(vector-of ABEND947(recursive type reference involving gosym.Sym)), :Locals ^(vector-of ABEND947(recursive type reference involving gosym.Sym)), :FrameSize ^Int, :LineTable ^{:Data ^(vector-of Int), :PC ^ABEND042(cannot find typename gosym.uint64), :Line ^Int}, :Obj ^{:Funcs ^(vector-of ABEND947(recursive type reference involving gosym.Func)), :Paths ^(vector-of ABEND947(recursive type reference involving gosym.Sym))}}}), :Funcs ^(vector-of {:Entry ^ABEND042(cannot find typename gosym.uint64), :End ^ABEND042(cannot find typename gosym.uint64), :Params ^(vector-of {:Value ^ABEND042(cannot find typename gosym.uint64), :Type ^Int, :Name ^String, :GoType ^ABEND042(cannot find typename gosym.uint64), :Func ^ABEND947(recursive type reference involving gosym.Func)}), :Locals ^(vector-of {:Value ^ABEND042(cannot find typename gosym.uint64), :Type ^Int, :Name ^String, :GoType ^ABEND042(cannot find typename gosym.uint64), :Func ^ABEND947(recursive type reference involving gosym.Func)}), :FrameSize ^Int, :LineTable ^{:Data ^(vector-of Int), :PC ^ABEND042(cannot find typename gosym.uint64), :Line ^Int}, :Obj ^{:Funcs ^(vector-of ABEND947(recursive type reference involving gosym.Func)), :Paths ^(vector-of {:Value ^ABEND042(cannot find typename gosym.uint64), :Type ^Int, :Name ^String, :GoType ^ABEND042(cannot find typename gosym.uint64), :Func ^ABEND947(recursive type reference involving gosym.Func)})}}), :Files ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/debug/gosym/symtab.go:121:8), :Objs ^(vector-of {:Funcs ^(vector-of {:Entry ^ABEND042(cannot find typename gosym.uint64), :End ^ABEND042(cannot find typename gosym.uint64), :Params ^(vector-of {:Value ^ABEND042(cannot find typename gosym.uint64), :Type ^Int, :Name ^String, :GoType ^ABEND042(cannot find typename gosym.uint64), :Func ^ABEND947(recursive type reference involving gosym.Func)}), :Locals ^(vector-of {:Value ^ABEND042(cannot find typename gosym.uint64), :Type ^Int, :Name ^String, :GoType ^ABEND042(cannot find typename gosym.uint64), :Func ^ABEND947(recursive type reference involving gosym.Func)}), :FrameSize ^Int, :LineTable ^{:Data ^(vector-of Int), :PC ^ABEND042(cannot find typename gosym.uint64), :Line ^Int}, :Obj ^ABEND947(recursive type reference involving gosym.Obj)}), :Paths ^(vector-of {:Value ^ABEND042(cannot find typename gosym.uint64), :Type ^Int, :Name ^String, :GoType ^ABEND042(cannot find typename gosym.uint64), :Func ^{:Entry ^ABEND042(cannot find typename gosym.uint64), :End ^ABEND042(cannot find typename gosym.uint64), :Params ^(vector-of ABEND947(recursive type reference involving gosym.Sym)), :Locals ^(vector-of ABEND947(recursive type reference involving gosym.Sym)), :FrameSize ^Int, :LineTable ^{:Data ^(vector-of Int), :PC ^ABEND042(cannot find typename gosym.uint64), :Line ^Int}, :Obj ^ABEND947(recursive type reference involving gosym.Obj)}})})} Error]"
;;   {:added "1.0"
;;    :go "newTable(symtab, pcln)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/gosym/symtab.go:283:22) symtab, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/debug/gosym/symtab.go:283:35) pcln])

JOKER FUNC gzip.NewReader has:
;; (defn NewReader
;;   "NewReader creates a new Reader reading the given reader.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nIt is the caller's responsibility to call Close on the Reader when done.\n\nThe Reader.Header fields will be valid in the Reader returned.\n\nGo return type: (*Reader, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/gzip/gunzip.go:92:18) r])

JOKER FUNC gzip.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer.\nWrites to the returned writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nCallers that wish to set the fields in Writer.Header must do so before\nthe first call to Write, Flush, or Close.\n\nGo return type: *Writer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/gzip/gzip.go:49:18) w])

JOKER FUNC gzip.NewWriterLevel has:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo return type: (*Writer, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newWriterLevel(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/gzip/gzip.go:60:23) w, ^Int level])

JOKER FUNC heap.Fix has:
;; (defn Fix
;;   "Fix re-establishes the heap ordering after the element at index i has changed its value.\nChanging the value of the element at index i and then calling Fix is equivalent to,\nbut less expensive than, calling Remove(h, i) followed by a Push of the new value.\nThe complexity is O(log(n)) where n = h.Len().\n"
;;   {:added "1.0"
;;    :go "fix(h, i)"}
;;   [^ABEND885(unrecognized type Interface at: GO.link/src/container/heap/heap.go:87:12) h, ^Int i])

JOKER FUNC heap.Init has:
;; (defn Init
;;   "Init establishes the heap invariants required by the other routines in this package.\nInit is idempotent with respect to the heap invariants\nand may be called whenever the heap invariants may have been invalidated.\nIts complexity is O(n) where n = h.Len().\n"
;;   {:added "1.0"
;;    :go "init(h)"}
;;   [^ABEND885(unrecognized type Interface at: GO.link/src/container/heap/heap.go:42:13) h])

JOKER FUNC heap.Pop has:
;; (defn Pop
;;   "Pop removes the minimum element (according to Less) from the heap\nand returns it. The complexity is O(log(n)) where n = h.Len().\nIt is equivalent to Remove(h, 0).\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/container/heap/heap.go:62:23)"
;;   {:added "1.0"
;;    :go "pop(h)"}
;;   [^ABEND885(unrecognized type Interface at: GO.link/src/container/heap/heap.go:62:12) h])

JOKER FUNC heap.Push has:
;; (defn Push
;;   "Push pushes the element x onto the heap. The complexity is\nO(log(n)) where n = h.Len().\n"
;;   {:added "1.0"
;;    :go "push(h, x)"}
;;   [^ABEND885(unrecognized type Interface at: GO.link/src/container/heap/heap.go:53:13) h, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/container/heap/heap.go:53:26) x])

JOKER FUNC heap.Remove has:
;; (defn Remove
;;   "Remove removes the element at index i from the heap.\nThe complexity is O(log(n)) where n = h.Len().\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/container/heap/heap.go:72:33)"
;;   {:added "1.0"
;;    :go "remove(h, i)"}
;;   [^ABEND885(unrecognized type Interface at: GO.link/src/container/heap/heap.go:72:15) h, ^Int i])

JOKER FUNC hex.Decode has:
;; (defn Decode
;;   "Decode decodes src into DecodedLen(len(src)) bytes,\nreturning the actual number of bytes written to dst.\n\nDecode expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, Decode returns the number\nof bytes decoded before the error.\n\nGo return type: (int, error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "decode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/hex/hex.go:57:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/hex/hex.go:57:22) src])

JOKER FUNC hex.DecodeString has:
(defn DecodeString
  "DecodeString returns the bytes represented by the hexadecimal string s.\n\nDecodeString expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, DecodeString returns\nthe bytes decoded before the error.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "decodeString(s)"}
  [^String s])

JOKER FUNC hex.DecodedLen has:
(defn ^Int DecodedLen
  "DecodedLen returns the length of a decoding of x source bytes.\nSpecifically, it returns x / 2.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.DecodedLen(x)"}
  [^Int x])

JOKER FUNC hex.Dump has:
;; (defn ^String Dump
;;   "Dump returns a string that contains a hex dump of the given data. The format\nof the hex dump matches the output of `hexdump -C` on the command line.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "hex.Dump(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/hex/hex.go:118:16) data])

JOKER FUNC hex.Dumper has:
;; (defn Dumper
;;   "Dumper returns a WriteCloser that writes a hex dump of all written data to\nw. The format of the dump matches the output of `hexdump -C` on the command\nline.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/hex/hex.go:204:26)"
;;   {:added "1.0"
;;    :go "dumper(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/hex/hex.go:204:15) w])

JOKER FUNC hex.Encode has:
;; (defn ^Int Encode
;;   "Encode encodes src into EncodedLen(len(src))\nbytes of dst. As a convenience, it returns the number\nof bytes written to dst, but this value is always EncodedLen(len(src)).\nEncode implements hexadecimal encoding.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "hex.Encode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/hex/hex.go:25:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/hex/hex.go:25:22) src])

JOKER FUNC hex.EncodeToString has:
;; (defn ^String EncodeToString
;;   "EncodeToString returns the hexadecimal encoding of src.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "hex.EncodeToString(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/hex/hex.go:96:25) src])

JOKER FUNC hex.EncodedLen has:
(defn ^Int EncodedLen
  "EncodedLen returns the length of an encoding of n source bytes.\nSpecifically, it returns n * 2.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.EncodedLen(n)"}
  [^Int n])

JOKER FUNC hex.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder returns an io.Reader that decodes hexadecimal characters from r.\nNewDecoder expects that r contain only an even number of hexadecimal characters.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/hex/hex.go:165:30)"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/hex/hex.go:165:19) r])

JOKER FUNC hex.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/hex/hex.go:136:30)"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/hex/hex.go:136:19) w])

JOKER FUNC hmac.Equal has:
;; (defn ^Bool Equal
;;   "Equal compares two MACs for equality without leaking timing information.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "hmac.Equal(mac1, mac2)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/hmac/hmac.go:96:23) mac1, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/hmac/hmac.go:96:23) mac2])

JOKER FUNC hmac.New has:
;; (defn New
;;   "New returns a new HMAC hash using the given hash.Hash type and key.\nNote that unlike other hash implementations in the standard library,\nthe returned Hash does not implement encoding.BinaryMarshaler\nor encoding.BinaryUnmarshaler.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/hmac/hmac.go:70:42)"
;;   {:added "1.0"
;;    :go "new(h, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/hmac/hmac.go:70:12) h, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/hmac/hmac.go:70:34) key])

JOKER FUNC html.EscapeString has:
(defn ^String EscapeString
  "EscapeString escapes special characters like \"<\" to become \"&lt;\". It\nescapes only five such characters: <, >, &, ' and \".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "html.EscapeString(s)"}
  [^String s])

JOKER FUNC html.UnescapeString has:
(defn ^String UnescapeString
  "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a\nlarger range of entities than EscapeString escapes. For example, \"&aacute;\"\nunescapes to \"á\", as does \"&#225;\" and \"&#xE1;\".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "html.UnescapeString(s)"}
  [^String s])

JOKER FUNC http.CanonicalHeaderKey has:
(defn ^String CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(s)"}
  [^String s])

JOKER FUNC http.DetectContentType has:
;; (defn ^String DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "http.DetectContentType(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/net/http/sniff.go:21:29) data])

JOKER FUNC http.Error has:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n"
;;   {:added "1.0"
;;    :go "error(w, error, code)"}
;;   [^ABEND885(unrecognized type ResponseWriter at: GO.link/src/net/http/server.go:1973:14) w, ^String error, ^Int code])

JOKER FUNC http.FileServer has:
;; (defn FileServer
;;   "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo return type: Handler\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "fileServer(root)"}
;;   [^ABEND885(unrecognized type FileSystem at: GO.link/src/net/http/fs.go:713:22) root])

JOKER FUNC http.Get has:
;; (defn Get
;;   "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo return type: (resp *Response, err error)\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "get(url)"}
;;   [^String url])

JOKER FUNC http.Handle has:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n"
;;   {:added "1.0"
;;    :go "handle(pattern, handler)"}
;;   [^String pattern, ^ABEND885(unrecognized type Handler at: GO.link/src/net/http/server.go:2401:37) handler])

JOKER FUNC http.HandleFunc has:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n"
;;   {:added "1.0"
;;    :go "handleFunc(pattern, handler)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/server.go:2406:41) handler])

JOKER FUNC http.Head has:
;; (defn Head
;;   "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo return type: (resp *Response, err error)\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "head(url)"}
;;   [^String url])

JOKER FUNC http.ListenAndServe has:
;; (defn ^Error ListenAndServe
;;   "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ListenAndServe(addr, handler)"}
;;   [^String addr, ^ABEND885(unrecognized type Handler at: GO.link/src/net/http/server.go:3002:42) handler])

JOKER FUNC http.ListenAndServeTLS has:
;; (defn ^Error ListenAndServeTLS
;;   "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ListenAndServeTLS(addr, certFile, keyFile, handler)"}
;;   [^String addr, ^String certFile, ^String keyFile, ^ABEND885(unrecognized type Handler at: GO.link/src/net/http/server.go:3012:64) handler])

JOKER FUNC http.MaxBytesReader has:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:1056:65)"
;;   {:added "1.0"
;;    :go "maxBytesReader(w, r, n)"}
;;   [^ABEND885(unrecognized type ResponseWriter at: GO.link/src/net/http/request.go:1056:23) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:1056:41) r, ^Int n])

JOKER FUNC http.NewFileTransport has:
;; (defn NewFileTransport
;;   "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo return type: RoundTripper\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/client.go:115:19)"
;;   {:added "1.0"
;;    :go "newFileTransport(fs)"}
;;   [^ABEND885(unrecognized type FileSystem at: GO.link/src/net/http/filetransport.go:30:26) fs])

JOKER FUNC http.NewRequest has:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo return type: (*Request, error)\n\nJoker return type: [{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^ABEND947(recursive type reference involving http.Request), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:115:7)}} Error]"
;;   {:added "1.0"
;;    :go "newRequest(method, url, body)"}
;;   [^String method, ^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:792:42) body])

JOKER FUNC http.NewServeMux has:
;; (defn NewServeMux
;;   "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newServeMux()"}
;;   [])

JOKER FUNC http.NotFound has:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n"
;;   {:added "1.0"
;;    :go "notFound(w, r)"}
;;   [^ABEND885(unrecognized type ResponseWriter at: GO.link/src/net/http/server.go:1981:17) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/server.go:1981:35) r])

JOKER FUNC http.NotFoundHandler has:
;; (defn NotFoundHandler
;;   "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "notFoundHandler()"}
;;   [])

JOKER FUNC http.ParseHTTPVersion has:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo return type: (major int, minor int, ok bool)\n\nJoker return type: [Int Int Bool]"
  {:added "1.0"
   :go "parseHTTPVersion(vers)"}
  [^String vers])

JOKER FUNC http.ParseTime has:
;; (defn ParseTime
;;   "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo return type: (t ..., err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/header.go:86:32) Error]"
;;   {:added "1.0"
;;    :go "parseTime(text)"}
;;   [^String text])

JOKER FUNC http.Post has:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo return type: (resp *Response, err error)\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "post(url, contentType, body)"}
;;   [^String url, ^String contentType, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/client.go:748:41) body])

JOKER FUNC http.PostForm has:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo return type: (resp *Response, err error)\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "postForm(url, data)"}
;;   [^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/client.go:785:32) data])

JOKER FUNC http.ProxyFromEnvironment has:
;; (defn ProxyFromEnvironment
;;   "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/transport.go:345:43) Error]"
;;   {:added "1.0"
;;    :go "proxyFromEnvironment(req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/transport.go:345:31) req])

JOKER FUNC http.ProxyURL has:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/transport.go:351:34)"
;;   {:added "1.0"
;;    :go "proxyURL(fixedURL)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/transport.go:351:24) fixedURL])

JOKER FUNC http.ReadRequest has:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo return type: (*Request, error)\n\nJoker return type: [{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^ABEND947(recursive type reference involving http.Request), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:115:7)}} Error]"
;;   {:added "1.0"
;;    :go "readRequest(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/request.go:942:20) b])

JOKER FUNC http.ReadResponse has:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo return type: (*Response, error)\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "readResponse(r, req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/response.go:148:21) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/response.go:148:40) req])

JOKER FUNC http.Redirect has:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n"
;;   {:added "1.0"
;;    :go "redirect(w, r, url, code)"}
;;   [^ABEND885(unrecognized type ResponseWriter at: GO.link/src/net/http/server.go:2020:17) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/server.go:2020:35) r, ^String url, ^Int code])

JOKER FUNC http.RedirectHandler has:
;; (defn RedirectHandler
;;   "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo return type: Handler\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "redirectHandler(url, code)"}
;;   [^String url, ^Int code])

JOKER FUNC http.Serve has:
;; (defn ^Error Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.Serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/server.go:2421:14) l, ^ABEND885(unrecognized type Handler at: GO.link/src/net/http/server.go:2421:36) handler])

JOKER FUNC http.ServeContent has:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n"
;;   {:added "1.0"
;;    :go "serveContent(w, req, name, modtime, content)"}
;;   [^ABEND885(unrecognized type ResponseWriter at: GO.link/src/net/http/fs.go:151:21) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/fs.go:151:41) req, ^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/fs.go:151:72) modtime, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/fs.go:151:91) content])

JOKER FUNC http.ServeFile has:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n"
;;   {:added "1.0"
;;    :go "serveFile(w, r, name)"}
;;   [^ABEND885(unrecognized type ResponseWriter at: GO.link/src/net/http/fs.go:670:18) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/fs.go:670:36) r, ^String name])

JOKER FUNC http.ServeTLS has:
;; (defn ^Error ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ServeTLS(l, handler, certFile, keyFile)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/server.go:2438:17) l, ^ABEND885(unrecognized type Handler at: GO.link/src/net/http/server.go:2438:39) handler, ^String certFile, ^String keyFile])

JOKER FUNC http.SetCookie has:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n"
;;   {:added "1.0"
;;    :go "setCookie(w, cookie)"}
;;   [^ABEND885(unrecognized type ResponseWriter at: GO.link/src/net/http/cookie.go:157:18) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/cookie.go:157:41) cookie])

JOKER FUNC http.StatusText has:
(defn ^String StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(code)"}
  [^Int code])

JOKER FUNC http.StripPrefix has:
;; (defn StripPrefix
;;   "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo return type: Handler\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "stripPrefix(prefix, h)"}
;;   [^String prefix, ^ABEND885(unrecognized type Handler at: GO.link/src/net/http/server.go:1992:35) h])

JOKER FUNC http.TimeoutHandler has:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo return type: Handler\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "timeoutHandler(h, dt, msg)"}
;;   [^ABEND885(unrecognized type Handler at: GO.link/src/net/http/server.go:3106:23) h, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/server.go:3106:35) dt, ^String msg])

JOKER FUNC httptest.NewRecorder has:
;; (defn NewRecorder
;;   "NewRecorder returns an initialized ResponseRecorder.\n\nGo return type: *ResponseRecorder\n\nJoker return type: {:Code ^Int, :HeaderMap ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/recorder.go:35:12), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/recorder.go:39:8), :Flushed ^Bool}"
;;   {:added "1.0"
;;    :go "newRecorder()"}
;;   [])

JOKER FUNC httptest.NewRequest has:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo return type: *...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/httptest.go:41:57)"
;;   {:added "1.0"
;;    :go "newRequest(method, target, body)"}
;;   [^String method, ^String target, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/httptest.go:41:45) body])

JOKER FUNC httptest.NewServer has:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo return type: *Server\n\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:28:11), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:33:7), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:37:10)}"
;;   {:added "1.0"
;;    :go "newServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:80:24) handler])

JOKER FUNC httptest.NewTLSServer has:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo return type: *Server\n\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:28:11), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:33:7), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:37:10)}"
;;   {:added "1.0"
;;    :go "newTLSServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:160:27) handler])

JOKER FUNC httptest.NewUnstartedServer has:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo return type: *Server\n\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:28:11), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:33:7), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:37:10)}"
;;   {:added "1.0"
;;    :go "newUnstartedServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:92:33) handler])

JOKER FUNC httptrace.ContextClientTrace has:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo return type: *ClientTrace\n\nJoker return type: {:GetConn ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:85:10), :GotConn ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:91:10), :PutIdleConn ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:101:14), :GotFirstResponseByte ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:105:23), :Got100Continue ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:109:17), :Got1xxResponse ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:115:17), :DNSStart ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:118:11), :DNSDone ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:121:10), :ConnectStart ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:126:15), :ConnectDone ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:133:14), :TLSHandshakeStart ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:138:20), :TLSHandshakeDone ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:143:19), :WroteHeaderField ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:148:19), :WroteHeaders ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:152:15), :Wait100Continue ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:158:18), :WroteRequest ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:163:15)}"
;;   {:added "1.0"
;;    :go "contextClientTrace(ctx)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptrace/trace.go:24:29) ctx])

JOKER FUNC httptrace.WithClientTrace has:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptrace/trace.go:34:63)"
;;   {:added "1.0"
;;    :go "withClientTrace(ctx, trace)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptrace/trace.go:34:26) ctx, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httptrace/trace.go:34:49) trace])

JOKER FUNC httputil.DumpRequest has:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequest(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/dump.go:191:22) req, ^Bool body])

JOKER FUNC httputil.DumpRequestOut has:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequestOut(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/dump.go:66:25) req, ^Bool body])

JOKER FUNC httputil.DumpResponse has:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpResponse(resp, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/dump.go:281:24) resp, ^Bool body])

JOKER FUNC httputil.NewChunkedReader has:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/httputil.go:20:36)"
;;   {:added "1.0"
;;    :go "newChunkedReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/httputil.go:20:25) r])

JOKER FUNC httputil.NewChunkedWriter has:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/httputil.go:35:36)"
;;   {:added "1.0"
;;    :go "newChunkedWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/httputil.go:35:25) w])

JOKER FUNC httputil.NewClientConn has:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo return type: *ClientConn\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/persist.go:248:22) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/persist.go:248:34) r])

JOKER FUNC httputil.NewProxyClientConn has:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo return type: *ClientConn\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newProxyClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/persist.go:265:27) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/persist.go:265:39) r])

JOKER FUNC httputil.NewServerConn has:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo return type: *ServerConn\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newServerConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/persist.go:54:22) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/persist.go:54:34) r])

JOKER FUNC httputil.NewSingleHostReverseProxy has:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo return type: *ReverseProxy\n\nJoker return type: {:Director ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httputil/reverseproxy.go:35:11), :Transport ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/reverseproxy.go:39:12), :FlushInterval ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/reverseproxy.go:45:16), :ErrorLog ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/reverseproxy.go:51:12), :BufferPool ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/httputil/reverseproxy.go:79:17), :ModifyResponse ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httputil/reverseproxy.go:67:17), :ErrorHandler ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httputil/reverseproxy.go:74:15)}"
;;   {:added "1.0"
;;    :go "newSingleHostReverseProxy(target)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/reverseproxy.go:103:39) target])

JOKER FUNC image.Decode has:
;; (defn Decode
;;   "Decode decodes an image that has been encoded in a registered format.\nThe string returned is the format name used during format registration.\nFormat registration is typically done by an init function in the codec-\nspecific package.\n\nGo return type: (Image, string, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/image.go:36:12) String Error]"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/format.go:78:15) r])

JOKER FUNC image.DecodeConfig has:
;; (defn DecodeConfig
;;   "DecodeConfig decodes the color model and dimensions of an image that has\nbeen encoded in a registered format. The string returned is the format name\nused during format registration. Format registration is typically done by\nan init function in the codec-specific package.\n\nGo return type: (Config, string, error)\n\nJoker return type: [{:ColorModel ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/image.go:30:16), :Width ^Int, :Height ^Int} String Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/format.go:92:21) r])

JOKER FUNC image.NewAlpha has:
;; (defn NewAlpha
;;   "NewAlpha returns a new Alpha image with the given bounds.\n\nGo return type: *Alpha\n\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newAlpha(r)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/image.go:567:17) r])

JOKER FUNC image.NewAlpha16 has:
;; (defn NewAlpha16
;;   "NewAlpha16 returns a new Alpha16 image with the given bounds.\n\nGo return type: *Alpha16\n\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newAlpha16(r)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/image.go:662:19) r])

JOKER FUNC image.NewCMYK has:
;; (defn NewCMYK
;;   "NewCMYK returns a new CMYK image with the given bounds.\n\nGo return type: *CMYK\n\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newCMYK(r)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/image.go:909:16) r])

JOKER FUNC image.NewGray has:
;; (defn NewGray
;;   "NewGray returns a new Gray image with the given bounds.\n\nGo return type: *Gray\n\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newGray(r)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/image.go:741:16) r])

JOKER FUNC image.NewGray16 has:
;; (defn NewGray16
;;   "NewGray16 returns a new Gray16 image with the given bounds.\n\nGo return type: *Gray16\n\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newGray16(r)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/image.go:823:18) r])

JOKER FUNC image.NewNRGBA has:
;; (defn NewNRGBA
;;   "NewNRGBA returns a new NRGBA image with the given bounds.\n\nGo return type: *NRGBA\n\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newNRGBA(r)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/image.go:363:17) r])

JOKER FUNC image.NewNRGBA64 has:
;; (defn NewNRGBA64
;;   "NewNRGBA64 returns a new NRGBA64 image with the given bounds.\n\nGo return type: *NRGBA64\n\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newNRGBA64(r)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/image.go:475:19) r])

JOKER FUNC image.NewNYCbCrA has:
;; (defn NewNYCbCrA
;;   "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample\nratio.\n\nGo return type: *NYCbCrA\n\nJoker return type: {:A ^(vector-of ABEND042(cannot find typename image.uint8)), :AStride ^Int}"
;;   {:added "1.0"
;;    :go "newNYCbCrA(r, subsampleRatio)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/ycbcr.go:278:19) r, ^ABEND885(unrecognized type YCbCrSubsampleRatio at: GO.link/src/image/ycbcr.go:278:45) subsampleRatio])

JOKER FUNC image.NewPaletted has:
;; (defn NewPaletted
;;   "NewPaletted returns a new Paletted image with the given width, height and\npalette.\n\nGo return type: *Paletted\n\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}, :Palette ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/image.go:925:10)}"
;;   {:added "1.0"
;;    :go "newPaletted(r, p)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/image.go:1019:20) r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/image.go:1019:33) p])

JOKER FUNC image.NewRGBA has:
;; (defn NewRGBA
;;   "NewRGBA returns a new RGBA image with the given bounds.\n\nGo return type: *RGBA\n\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newRGBA(r)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/image.go:152:16) r])

JOKER FUNC image.NewRGBA64 has:
;; (defn NewRGBA64
;;   "NewRGBA64 returns a new RGBA64 image with the given bounds.\n\nGo return type: *RGBA64\n\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newRGBA64(r)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/image.go:264:18) r])

JOKER FUNC image.NewUniform has:
;; (defn NewUniform
;;   "Go return type: *Uniform\n\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/names.go:25:4)}"
;;   {:added "1.0"
;;    :go "newUniform(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/names.go:50:19) c])

JOKER FUNC image.NewYCbCr has:
;; (defn NewYCbCr
;;   "NewYCbCr returns a new YCbCr image with the given bounds and subsample\nratio.\n\nGo return type: *YCbCr\n\nJoker return type: {:Y ^(vector-of ABEND042(cannot find typename image.uint8)), :Cb ^(vector-of ABEND042(cannot find typename image.uint8)), :Cr ^(vector-of ABEND042(cannot find typename image.uint8)), :YStride ^Int, :CStride ^Int, :SubsampleRatio ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newYCbCr(r, subsampleRatio)"}
;;   [^ABEND885(unrecognized type Rectangle at: GO.link/src/image/ycbcr.go:169:17) r, ^ABEND885(unrecognized type YCbCrSubsampleRatio at: GO.link/src/image/ycbcr.go:169:43) subsampleRatio])

JOKER FUNC image.Pt has:
(defn Pt
  "Pt is shorthand for Point{X, Y}.\n\nGo return type: Point\n\nJoker return type: {:X ^Int, :Y ^Int}"
  {:added "1.0"
   :go "pt(X, Y)"}
  [^Int X, ^Int Y])

JOKER FUNC image.Rect has:
(defn Rect
  "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned\nrectangle has minimum and maximum coordinates swapped if necessary so that\nit is well-formed.\n\nGo return type: Rectangle\n\nJoker return type: {:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}"
  {:added "1.0"
   :go "rect(x0, y0, x1, y1)"}
  [^Int x0, ^Int y0, ^Int x1, ^Int y1])

JOKER FUNC image.RegisterFormat has:
;; (defn RegisterFormat
;;   "RegisterFormat registers an image format for use by Decode.\nName is the name of the format, like \"jpeg\" or \"png\".\nMagic is the magic prefix that identifies the format's encoding. The magic\nstring can contain \"?\" wildcards that each match any one byte.\nDecode is the function that decodes the encoded image.\nDecodeConfig is the function that decodes just its configuration.\n"
;;   {:added "1.0"
;;    :go "registerFormat(name, magic, decode, decodeConfig)"}
;;   [^String name, ^String magic, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/image/format.go:32:48) decode, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/image/format.go:32:93) decodeConfig])

JOKER FUNC importer.Default has:
;; (defn Default
;;   "Default returns an Importer for the compiler that built the running binary.\nIf available, the result implements types.ImporterFrom.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/importer/importer.go:75:16)"
;;   {:added "1.0"
;;    :go "default()"}
;;   [])

JOKER FUNC importer.For has:
;; (defn For
;;   "For returns an Importer for importing from installed packages\nfor the compilers \"gc\" and \"gccgo\", or for importing directly\nfrom the source if the compiler argument is \"source\". In this\nlatter case, importing may fail under circumstances where the\nexported API is not entirely defined in pure Go source code\n(if the package API depends on cgo-defined entities, the type\nchecker won't have access to those).\n\nIf lookup is nil, the default package lookup mechanism for the\ngiven compiler is used, and the resulting importer attempts\nto resolve relative and absolute import paths to canonical\nimport path IDs before finding the imported file.\n\nIf lookup is non-nil, then the returned importer calls lookup\neach time it needs to resolve an import path. In this mode\nthe importer can only be invoked with canonical import paths\n(not relative or absolute ones); it is assumed that the translation\nto canonical import paths is being done by the client of the\nimporter.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/importer/importer.go:42:42)"
;;   {:added "1.0"
;;    :go "for(compiler, lookup)"}
;;   [^String compiler, ^ABEND885(unrecognized type Lookup at: GO.link/src/go/importer/importer.go:42:34) lookup])

JOKER FUNC io.Copy has:
;; (defn Copy
;;   "Copy copies from src to dst until either EOF is reached\non src or an error occurs. It returns the number of bytes\ncopied and the first error encountered while copying, if any.\n\nA successful Copy returns err == nil, not err == EOF.\nBecause Copy is defined to read from src until EOF, it does\nnot treat an EOF from Read as an error to be reported.\n\nIf src implements the WriterTo interface,\nthe copy is implemented by calling src.WriteTo(dst).\nOtherwise, if dst implements the ReaderFrom interface,\nthe copy is implemented by calling dst.ReadFrom(src).\n\nGo return type: (written int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "copy(dst, src)"}
;;   [^ABEND885(unrecognized type Writer at: GO.link/src/io/io.go:363:15) dst, ^ABEND885(unrecognized type Reader at: GO.link/src/io/io.go:363:27) src])

JOKER FUNC io.CopyBuffer has:
;; (defn CopyBuffer
;;   "CopyBuffer is identical to Copy except that it stages through the\nprovided buffer (if one is required) rather than allocating a\ntemporary one. If buf is nil, one is allocated; otherwise if it has\nzero length, CopyBuffer panics.\n\nGo return type: (written int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "copyBuffer(dst, src, buf)"}
;;   [^ABEND885(unrecognized type Writer at: GO.link/src/io/io.go:371:21) dst, ^ABEND885(unrecognized type Reader at: GO.link/src/io/io.go:371:33) src, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/io/io.go:371:45) buf])

JOKER FUNC io.CopyN has:
;; (defn CopyN
;;   "CopyN copies n bytes (or until an error) from src to dst.\nIt returns the number of bytes copied and the earliest\nerror encountered while copying.\nOn return, written == n if and only if err == nil.\n\nIf dst implements the ReaderFrom interface,\nthe copy is implemented using it.\n\nGo return type: (written int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "copyN(dst, src, n)"}
;;   [^ABEND885(unrecognized type Writer at: GO.link/src/io/io.go:339:16) dst, ^ABEND885(unrecognized type Reader at: GO.link/src/io/io.go:339:28) src, ^Int n])

JOKER FUNC io.LimitReader has:
;; (defn LimitReader
;;   "LimitReader returns a Reader that reads from r\nbut stops with EOF after n bytes.\nThe underlying implementation is a *LimitedReader.\n\nGo return type: Reader\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "limitReader(r, n)"}
;;   [^ABEND885(unrecognized type Reader at: GO.link/src/io/io.go:430:20) r, ^Int n])

JOKER FUNC io.MultiReader has:
;; (defn MultiReader
;;   "MultiReader returns a Reader that's the logical concatenation of\nthe provided input readers. They're read sequentially. Once all\ninputs have returned EOF, Read will return EOF.  If any of the readers\nreturn a non-nil, non-EOF error, Read will return that error.\n\nGo return type: Reader\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "multiReader(readers)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/io/multi.go:48:26) readers])

JOKER FUNC io.MultiWriter has:
;; (defn MultiWriter
;;   "MultiWriter creates a writer that duplicates its writes to all the\nprovided writers, similar to the Unix tee(1) command.\n\nEach write is written to each listed writer, one at a time.\nIf a listed writer returns an error, that overall write operation\nstops and returns the error; it does not continue down the list.\n\nGo return type: Writer\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)"
;;   {:added "1.0"
;;    :go "multiWriter(writers)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/io/multi.go:102:26) writers])

JOKER FUNC io.NewSectionReader has:
;; (defn NewSectionReader
;;   "NewSectionReader returns a SectionReader that reads from r\nstarting at offset off and stops with EOF after n bytes.\n\nGo return type: *SectionReader\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newSectionReader(r, off, n)"}
;;   [^ABEND885(unrecognized type ReaderAt at: GO.link/src/io/io.go:455:25) r, ^Int off, ^Int n])

JOKER FUNC io.Pipe has:
;; (defn Pipe
;;   "Pipe creates a synchronous in-memory pipe.\nIt can be used to connect code expecting an io.Reader\nwith code expecting an io.Writer.\n\nReads and Writes on the pipe are matched one to one\nexcept when multiple Reads are needed to consume a single Write.\nThat is, each Write to the PipeWriter blocks until it has satisfied\none or more Reads from the PipeReader that fully consume\nthe written data.\nThe data is copied directly from the Write to the corresponding\nRead (or Reads); there is no internal buffering.\n\nIt is safe to call Read and Write in parallel with each other or with Close.\nParallel calls to Read and parallel calls to Write are also safe:\nthe individual calls will be gated sequentially.\n\nGo return type: (*PipeReader, *PipeWriter)\n\nJoker return type: [{} {}]"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC io.ReadAtLeast has:
;; (defn ReadAtLeast
;;   "ReadAtLeast reads from r into buf until it has read at least min bytes.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading fewer than min bytes,\nReadAtLeast returns ErrUnexpectedEOF.\nIf min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\nOn return, n >= min if and only if err == nil.\nIf r returns an error having read at least min bytes, the error is dropped.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readAtLeast(r, buf, min)"}
;;   [^ABEND885(unrecognized type Reader at: GO.link/src/io/io.go:304:20) r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/io/io.go:304:32) buf, ^Int min])

JOKER FUNC io.ReadFull has:
;; (defn ReadFull
;;   "ReadFull reads exactly len(buf) bytes from r into buf.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nReadFull returns ErrUnexpectedEOF.\nOn return, n == len(buf) if and only if err == nil.\nIf r returns an error having read at least len(buf) bytes, the error is dropped.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readFull(r, buf)"}
;;   [^ABEND885(unrecognized type Reader at: GO.link/src/io/io.go:328:17) r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/io/io.go:328:29) buf])

JOKER FUNC io.TeeReader has:
;; (defn TeeReader
;;   "TeeReader returns a Reader that writes to w what it reads from r.\nAll reads from r performed through it are matched with\ncorresponding writes to w. There is no internal buffering -\nthe write must complete before the read completes.\nAny error encountered while writing is reported as a read error.\n\nGo return type: Reader\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "teeReader(r, w)"}
;;   [^ABEND885(unrecognized type Reader at: GO.link/src/io/io.go:525:18) r, ^ABEND885(unrecognized type Writer at: GO.link/src/io/io.go:525:28) w])

JOKER FUNC io.WriteString has:
;; (defn WriteString
;;   "WriteString writes the contents of the string s to w, which accepts a slice of bytes.\nIf w implements a WriteString method, it is invoked directly.\nOtherwise, w.Write is called exactly once.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "writeString(w, s)"}
;;   [^ABEND885(unrecognized type Writer at: GO.link/src/io/io.go:289:20) w, ^String s])

JOKER FUNC iotest.DataErrReader has:
;; (defn DataErrReader
;;   "DataErrReader changes the way errors are handled by a Reader. Normally, a\nReader returns an error (typically EOF) from the first Read call after the\nlast piece of data is read. DataErrReader wraps a Reader and changes its\nbehavior so the final error is returned along with the final data, instead\nof in the first call after the final data.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:45:33)"
;;   {:added "1.0"
;;    :go "dataErrReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:45:22) r])

JOKER FUNC iotest.HalfReader has:
;; (defn HalfReader
;;   "HalfReader returns a Reader that implements Read\nby reading half as many requested bytes from r.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:30:30)"
;;   {:added "1.0"
;;    :go "halfReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:30:19) r])

JOKER FUNC iotest.NewReadLogger has:
;; (defn NewReadLogger
;;   "NewReadLogger returns a reader that behaves like r except\nthat it logs (using log.Printf) each read to standard error,\nprinting the prefix and the hexadecimal data read.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/logger.go:52:48)"
;;   {:added "1.0"
;;    :go "newReadLogger(prefix, r)"}
;;   [^String prefix, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/logger.go:52:37) r])

JOKER FUNC iotest.NewWriteLogger has:
;; (defn NewWriteLogger
;;   "NewWriteLogger returns a writer that behaves like w except\nthat it logs (using log.Printf) each write to standard error,\nprinting the prefix and the hexadecimal data written.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/logger.go:30:49)"
;;   {:added "1.0"
;;    :go "newWriteLogger(prefix, w)"}
;;   [^String prefix, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/logger.go:30:38) w])

JOKER FUNC iotest.OneByteReader has:
;; (defn OneByteReader
;;   "OneByteReader returns a Reader that implements\neach non-empty Read by reading one byte from r.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:15:33)"
;;   {:added "1.0"
;;    :go "oneByteReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:15:22) r])

JOKER FUNC iotest.TimeoutReader has:
;; (defn TimeoutReader
;;   "TimeoutReader returns ErrTimeout on the second read\nwith no data. Subsequent calls to read succeed.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:75:33)"
;;   {:added "1.0"
;;    :go "timeoutReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:75:22) r])

JOKER FUNC iotest.TruncateWriter has:
;; (defn TruncateWriter
;;   "TruncateWriter returns a Writer that writes to w\nbut stops silently after n bytes.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/writer.go:11:43)"
;;   {:added "1.0"
;;    :go "truncateWriter(w, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/writer.go:11:23) w, ^Int n])

JOKER FUNC ioutil.NopCloser has:
;; (defn NopCloser
;;   "NopCloser returns a ReadCloser with a no-op Close method wrapping\nthe provided Reader r.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/io/ioutil/ioutil.go:118:29)"
;;   {:added "1.0"
;;    :go "nopCloser(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/io/ioutil/ioutil.go:118:18) r])

JOKER FUNC ioutil.ReadAll has:
;; (defn ReadAll
;;   "ReadAll reads from r until an error or EOF and returns the data it read.\nA successful call returns err == nil, not err == EOF. Because ReadAll is\ndefined to read from src until EOF, it does not treat an EOF from Read\nas an error to be reported.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "readAll(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/io/ioutil/ioutil.go:44:16) r])

JOKER FUNC ioutil.ReadDir has:
;; (defn ReadDir
;;   "ReadDir reads the directory named by dirname and returns\na list of directory entries sorted by filename.\n\nGo return type: ([]..., error)\n\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/io/ioutil/ioutil.go:96:33)) Error]"
;;   {:added "1.0"
;;    :go "readDir(dirname)"}
;;   [^String dirname])

JOKER FUNC ioutil.ReadFile has:
(defn ReadFile
  "ReadFile reads the file named by filename and returns the contents.\nA successful call returns err == nil, not err == EOF. Because ReadFile\nreads the whole file, it does not treat an EOF from Read as an error\nto be reported.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "readFile(filename)"}
  [^String filename])

JOKER FUNC ioutil.TempDir has:
(defn TempDir
  "TempDir creates a new temporary directory in the directory dir\nwith a name beginning with prefix and returns the path of the\nnew directory. If dir is the empty string, TempDir uses the\ndefault directory for temporary files (see os.TempDir).\nMultiple programs calling TempDir simultaneously\nwill not choose the same directory. It is the caller's responsibility\nto remove the directory when no longer needed.\n\nGo return type: (name string, err error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "tempDir(dir, prefix)"}
  [^String dir, ^String prefix])

JOKER FUNC ioutil.TempFile has:
;; (defn TempFile
;;   "TempFile creates a new temporary file in the directory dir,\nopens the file for reading and writing, and returns the resulting *os.File.\nThe filename is generated by taking pattern and adding a random\nstring to the end. If pattern includes a \"*\", the random string\nreplaces the last \"*\".\nIf dir is the empty string, TempFile uses the default directory\nfor temporary files (see os.TempDir).\nMultiple programs calling TempFile simultaneously\nwill not choose the same file. The caller can use f.Name()\nto find the pathname of the file. It is the caller's responsibility\nto remove the file when no longer needed.\n\nGo return type: (f *..., err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/io/ioutil/tempfile.go:50:40) Error]"
;;   {:added "1.0"
;;    :go "tempFile(dir, pattern)"}
;;   [^String dir, ^String pattern])

JOKER FUNC ioutil.WriteFile has:
;; (defn ^Error WriteFile
;;   "WriteFile writes data to a file named by filename.\nIf the file does not exist, WriteFile creates it with permissions perm;\notherwise WriteFile truncates it before writing.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ioutil.WriteFile(filename, data, perm)"}
;;   [^String filename, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/io/ioutil/ioutil.go:79:38) data, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/io/ioutil/ioutil.go:79:51) perm])

JOKER FUNC jpeg.Decode has:
;; (defn Decode
;;   "Decode reads a JPEG image from r and returns it as an image.Image.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/jpeg/reader.go:777:27) Error]"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/jpeg/reader.go:777:15) r])

JOKER FUNC jpeg.DecodeConfig has:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a JPEG image without\ndecoding the entire image.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/jpeg/reader.go:784:33) Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/jpeg/reader.go:784:21) r])

JOKER FUNC jpeg.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\noptions. Default parameters are used if a nil *Options is passed.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "jpeg.Encode(w, m, o)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/jpeg/writer.go:575:15) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/jpeg/writer.go:575:28) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/image/jpeg/writer.go:575:43) o])

JOKER FUNC json.Compact has:
;; (defn ^Error Compact
;;   "Compact appends to dst the JSON-encoded src with\ninsignificant space characters elided.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Compact(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/json/indent.go:11:18) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/json/indent.go:11:37) src])

JOKER FUNC json.HTMLEscape has:
;; (defn HTMLEscape
;;   "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029\ncharacters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029\nso that the JSON will be safe to embed inside HTML <script> tags.\nFor historical reasons, web browsers don't honor standard HTML\nescaping within <script> tags, so an alternative JSON encoding must\nbe used.\n"
;;   {:added "1.0"
;;    :go "hTMLEscape(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/json/encode.go:194:21) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/json/encode.go:194:40) src])

JOKER FUNC json.Indent has:
;; (defn ^Error Indent
;;   "Indent appends to dst an indented form of the JSON-encoded src.\nEach element in a JSON object or array begins on a new,\nindented line beginning with prefix followed by one or more\ncopies of indent according to the indentation nesting.\nThe data appended to dst does not begin with the prefix nor\nany indentation, to make it easier to embed inside other formatted JSON data.\nAlthough leading space characters (space, tab, carriage return, newline)\nat the beginning of src are dropped, trailing space characters\nat the end of src are preserved and copied to dst.\nFor example, if src has no trailing spaces, neither will dst;\nif src ends in a trailing newline, so will dst.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Indent(dst, src, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/json/indent.go:79:17) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/json/indent.go:79:36) src, ^String prefix, ^String indent])

JOKER FUNC json.Marshal has:
;; (defn Marshal
;;   "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively.\nIf an encountered value implements the Marshaler interface\nand is not a nil pointer, Marshal calls its MarshalJSON method\nto produce JSON. If no MarshalJSON method is present but the\nvalue implements encoding.TextMarshaler instead, Marshal calls\nits MarshalText method and encodes the result as a JSON string.\nThe nil pointer exception is not strictly necessary\nbut mimics a similar, necessary exception in the behavior of\nUnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers.\n\nString values encode as JSON strings coerced to valid UTF-8,\nreplacing invalid bytes with the Unicode replacement rune.\nThe angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\nto keep some browsers from misinterpreting JSON output as HTML.\nAmpersand \"&\" is also escaped to \"\\u0026\" for the same reason.\nThis escaping can be disabled using an Encoder that had SetEscapeHTML(false)\ncalled on it.\n\nArray and slice values encode as JSON arrays, except that\n[]byte encodes as a base64-encoded string, and a nil slice\nencodes as the null JSON value.\n\nStruct values encode as JSON objects.\nEach exported struct field becomes a member of the object, using the\nfield name as the object key, unless the field is omitted for one of the\nreasons given below.\n\nThe encoding of each struct field can be customized by the format string\nstored under the \"json\" key in the struct field's tag.\nThe format string gives the name of the field, possibly followed by a\ncomma-separated list of options. The name may be empty in order to\nspecify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted\nfrom the encoding if the field has an empty value, defined as\nfalse, 0, a nil pointer, a nil interface value, and any empty array,\nslice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted.\nNote that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n  // Field appears in JSON as key \"myName\".\n  Field int `json:\"myName\"`\n\n  // Field appears in JSON as key \"myName\" and\n  // the field is omitted from the object if its value is empty,\n  // as defined above.\n  Field int `json:\"myName,omitempty\"`\n\n  // Field appears in JSON as key \"Field\" (the default), but\n  // the field is skipped if empty.\n  // Note the leading comma.\n  Field int `json:\",omitempty\"`\n\n  // Field is ignored by this package.\n  Field int `json:\"-\"`\n\n  // Field appears in JSON as key \"-\".\n  Field int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a\nJSON-encoded string. It applies only to fields of string, floating point,\ninteger, or boolean types. This extra level of encoding is sometimes used\nwhen communicating with JavaScript programs:\n\n   Int64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of\nonly Unicode letters, digits, and ASCII punctuation except quotation\nmarks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields\nwere fields in the outer struct, subject to the usual Go visibility rules amended\nas described in the next paragraph.\nAn anonymous struct field with a name given in its JSON tag is treated as\nhaving that name, rather than being anonymous.\nAn anonymous struct field of interface type is treated the same as having\nthat type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when\ndeciding which field to marshal or unmarshal. If there are\nmultiple fields at the same level, and that level is the least\nnested (and would therefore be the nesting level selected by the\nusual Go rules), the following extra rules apply:\n\n1) Of those fields, if any are JSON-tagged, only tagged fields are considered,\neven if there are multiple untagged fields that would otherwise conflict.\n\n2) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1.\nPrior to Go 1.1, anonymous struct fields were ignored. To force ignoring of\nan anonymous struct field in both current and earlier versions, give the field\na JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a\nstring, an integer type, or implement encoding.TextMarshaler. The map keys\nare sorted and used as JSON object keys by applying the following rules,\nsubject to the UTF-8 coercion described for string values above:\n  - string keys are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to.\nA nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface.\nA nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON.\nAttempting to encode such a value causes Marshal to return\nan UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not\nhandle them. Passing cyclic structures to Marshal will result in\nan infinite recursion.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/json/encode.go:157:16) v])

JOKER FUNC json.MarshalIndent has:
;; (defn MarshalIndent
;;   "MarshalIndent is like Marshal but applies Indent to format the output.\nEach JSON element in the output will begin on a new line beginning with prefix\nfollowed by one or more copies of indent according to the indentation nesting.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalIndent(v, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/json/encode.go:175:22) v, ^String prefix, ^String indent])

JOKER FUNC json.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from r.\n\nThe decoder introduces its own buffering and may\nread data from r beyond the JSON values requested.\n\nGo return type: *Decoder\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/json/stream.go:31:19) r])

JOKER FUNC json.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo return type: *Encoder\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/json/stream.go:186:19) w])

JOKER FUNC json.Unmarshal has:
;; (defn ^Error Unmarshal
;;   "Unmarshal parses the JSON-encoded data and stores the result\nin the value pointed to by v. If v is nil or not a pointer,\nUnmarshal returns an InvalidUnmarshalError.\n\nUnmarshal uses the inverse of the encodings that\nMarshal uses, allocating maps, slices, and pointers as necessary,\nwith the following additional rules:\n\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of\nthe JSON being the JSON literal null. In that case, Unmarshal sets\nthe pointer to nil. Otherwise, Unmarshal unmarshals the JSON into\nthe value pointed at by the pointer. If the pointer is nil, Unmarshal\nallocates a new value for it to point to.\n\nTo unmarshal JSON into a value implementing the Unmarshaler interface,\nUnmarshal calls that value's UnmarshalJSON method, including\nwhen the input is a JSON null.\nOtherwise, if the value implements encoding.TextUnmarshaler\nand the input is a JSON quoted string, Unmarshal calls that value's\nUnmarshalText method with the unquoted form of the string.\n\nTo unmarshal JSON into a struct, Unmarshal matches incoming object\nkeys to the keys used by Marshal (either the struct field name or its tag),\npreferring an exact match but also accepting a case-insensitive match. By\ndefault, object keys which don't have a corresponding struct field are\nignored (see Decoder.DisallowUnknownFields for an alternative).\n\nTo unmarshal JSON into an interface value,\nUnmarshal stores one of these in the interface value:\n\n\tbool, for JSON booleans\n\tfloat64, for JSON numbers\n\tstring, for JSON strings\n\t[]interface{}, for JSON arrays\n\tmap[string]interface{}, for JSON objects\n\tnil for JSON null\n\nTo unmarshal a JSON array into a slice, Unmarshal resets the slice length\nto zero and then appends each element to the slice.\nAs a special case, to unmarshal an empty JSON array into a slice,\nUnmarshal replaces the slice with a new empty slice.\n\nTo unmarshal a JSON array into a Go array, Unmarshal decodes\nJSON array elements into corresponding Go array elements.\nIf the Go array is smaller than the JSON array,\nthe additional JSON array elements are discarded.\nIf the JSON array is smaller than the Go array,\nthe additional Go array elements are set to zero values.\n\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to\nuse. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal\nreuses the existing map, keeping existing entries. Unmarshal then stores\nkey-value pairs from the JSON object into the map. The map's key type must\neither be a string, an integer, or implement encoding.TextUnmarshaler.\n\nIf a JSON value is not appropriate for a given target type,\nor if a JSON number overflows the target type, Unmarshal\nskips that field and completes the unmarshaling as best it can.\nIf no more serious errors are encountered, Unmarshal returns\nan UnmarshalTypeError describing the earliest such error. In any\ncase, it's not guaranteed that all the remaining fields following\nthe problematic one will be unmarshaled into the target object.\n\nThe JSON null value unmarshals into an interface, map, pointer, or slice\nby setting that Go value to nil. Because null is often used in JSON to mean\n``not present,'' unmarshaling a JSON null into any other Go type has no effect\non the value and produces no error.\n\nWhen unmarshaling quoted strings, invalid UTF-8 or\ninvalid UTF-16 surrogate pairs are not treated as an error.\nInstead, they are replaced by the Unicode replacement\ncharacter U+FFFD.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Unmarshal(data, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/json/decode.go:96:21) data, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/json/decode.go:96:31) v])

JOKER FUNC json.Valid has:
;; (defn ^Bool Valid
;;   "Valid reports whether data is a valid JSON encoding.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "json.Valid(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/json/scanner.go:19:17) data])

JOKER FUNC jsonrpc.Dial has:
;; (defn Dial
;;   "Dial connects to a JSON-RPC server at the specified network address.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/client.go:118:38) Error]"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC jsonrpc.NewClient has:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo return type: *...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/client.go:113:42)"
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/client.go:113:21) conn])

JOKER FUNC jsonrpc.NewClientCodec has:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/client.go:37:46)"
;;   {:added "1.0"
;;    :go "newClientCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/client.go:37:26) conn])

JOKER FUNC jsonrpc.NewServerCodec has:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/server.go:37:46)"
;;   {:added "1.0"
;;    :go "newServerCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/server.go:37:26) conn])

JOKER FUNC jsonrpc.ServeConn has:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n"
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/server.go:132:21) conn])

JOKER FUNC list.New has:
;; (defn New
;;   "New returns an initialized list.\n\nGo return type: *List\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC log.Fatal has:
;; (defn Fatal
;;   "Fatal is equivalent to Print() followed by a call to os.Exit(1).\n"
;;   {:added "1.0"
;;    :go "fatal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:305:14) v])

JOKER FUNC log.Fatalf has:
;; (defn Fatalf
;;   "Fatalf is equivalent to Printf() followed by a call to os.Exit(1).\n"
;;   {:added "1.0"
;;    :go "fatalf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:311:30) v])

JOKER FUNC log.Fatalln has:
;; (defn Fatalln
;;   "Fatalln is equivalent to Println() followed by a call to os.Exit(1).\n"
;;   {:added "1.0"
;;    :go "fatalln(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:317:16) v])

JOKER FUNC log.Flags has:
(defn ^Int Flags
  "Flags returns the output flags for the standard logger.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "log.Flags()"}
  [])

JOKER FUNC log.New has:
;; (defn New
;;   "New creates a new Logger. The out variable sets the\ndestination to which log data will be written.\nThe prefix appears at the beginning of each generated log line.\nThe flag argument defines the logging properties.\n\nGo return type: *Logger\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "new(out, prefix, flag)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/log/log.go:62:14) out, ^String prefix, ^Int flag])

JOKER FUNC log.Output has:
(defn ^Error Output
  "Output writes the output for a logging event. The string s contains\nthe text to print after the prefix specified by the flags of the\nLogger. A newline is appended if the last character of s is not\nalready a newline. Calldepth is the count of the number of\nframes to skip when computing the file name and line number\nif Llongfile or Lshortfile is set; a value of 1 will print the details\nfor the caller of Output.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "log.Output(calldepth, s)"}
  [^Int calldepth, ^String s])

JOKER FUNC log.Panic has:
;; (defn Panic
;;   "Panic is equivalent to Print() followed by a call to panic().\n"
;;   {:added "1.0"
;;    :go "panic(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:323:14) v])

JOKER FUNC log.Panicf has:
;; (defn Panicf
;;   "Panicf is equivalent to Printf() followed by a call to panic().\n"
;;   {:added "1.0"
;;    :go "panicf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:330:30) v])

JOKER FUNC log.Panicln has:
;; (defn Panicln
;;   "Panicln is equivalent to Println() followed by a call to panic().\n"
;;   {:added "1.0"
;;    :go "panicln(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:337:16) v])

JOKER FUNC log.Prefix has:
(defn ^String Prefix
  "Prefix returns the output prefix for the standard logger.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "log.Prefix()"}
  [])

JOKER FUNC log.Print has:
;; (defn Print
;;   "Print calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Print.\n"
;;   {:added "1.0"
;;    :go "print(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:288:14) v])

JOKER FUNC log.Printf has:
;; (defn Printf
;;   "Printf calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Printf.\n"
;;   {:added "1.0"
;;    :go "printf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:294:30) v])

JOKER FUNC log.Println has:
;; (defn Println
;;   "Println calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Println.\n"
;;   {:added "1.0"
;;    :go "println(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:300:16) v])

JOKER FUNC log.SetFlags has:
;; (defn SetFlags
;;   "SetFlags sets the output flags for the standard logger.\n"
;;   {:added "1.0"
;;    :go "setFlags(flag)"}
;;   [^Int flag])

JOKER FUNC log.SetOutput has:
;; (defn SetOutput
;;   "SetOutput sets the output destination for the standard logger.\n"
;;   {:added "1.0"
;;    :go "setOutput(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/log/log.go:258:18) w])

JOKER FUNC log.SetPrefix has:
;; (defn SetPrefix
;;   "SetPrefix sets the output prefix for the standard logger.\n"
;;   {:added "1.0"
;;    :go "setPrefix(prefix)"}
;;   [^String prefix])

JOKER FUNC lzw.NewReader has:
;; (defn NewReader
;;   "NewReader creates a new io.ReadCloser.\nReads from the returned io.ReadCloser read and decompress data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when\nfinished reading.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. It must equal the litWidth\nused during compression.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/lzw/reader.go:239:56)"
;;   {:added "1.0"
;;    :go "newReader(r, order, litWidth)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/lzw/reader.go:239:18) r, ^ABEND885(unrecognized type Order at: GO.link/src/compress/lzw/reader.go:239:35) order, ^Int litWidth])

JOKER FUNC lzw.NewWriter has:
;; (defn NewWriter
;;   "NewWriter creates a new io.WriteCloser.\nWrites to the returned io.WriteCloser are compressed and written to w.\nIt is the caller's responsibility to call Close on the WriteCloser when\nfinished writing.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/lzw/writer.go:241:56)"
;;   {:added "1.0"
;;    :go "newWriter(w, order, litWidth)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/lzw/writer.go:241:18) w, ^ABEND885(unrecognized type Order at: GO.link/src/compress/lzw/writer.go:241:35) order, ^Int litWidth])

JOKER FUNC macho.NewFatFile has:
;; (defn NewFatFile
;;   "NewFatFile creates a new FatFile for accessing all the Mach-O images in a\nuniversal binary. The Mach-O binary is expected to start at position 0 in\nthe ReaderAt.\n\nGo return type: (*FatFile, error)\n\nJoker return type: [{:Magic ^Int, :Arches ^(vector-of {})} Error]"
;;   {:added "1.0"
;;    :go "newFatFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/macho/fat.go:45:19) r])

JOKER FUNC macho.NewFile has:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Mach-O binary in an underlying reader.\nThe Mach-O binary is expected to start at position 0 in the ReaderAt.\n\nGo return type: (*File, error)\n\nJoker return type: [{:ByteOrder ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/macho/file.go:24:12), :Loads ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/debug/macho/file.go:35:11)), :Sections ^(vector-of {:Relocs ^(vector-of {:Addr ^Int, :Value ^Int, :Type ^ABEND042(cannot find typename macho.uint8), :Len ^ABEND042(cannot find typename macho.uint8), :Pcrel ^Bool, :Extern ^Bool, :Scattered ^Bool})}), :Symtab ^{:Syms ^(vector-of {:Name ^String, :Type ^ABEND042(cannot find typename macho.uint8), :Sect ^ABEND042(cannot find typename macho.uint8), :Desc ^Int, :Value ^ABEND042(cannot find typename macho.uint64)})}, :Dysymtab ^{:IndirectSyms ^(vector-of Int)}} Error]"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/macho/file.go:228:16) r])

JOKER FUNC macho.Open has:
;; (defn Open
;;   "Open opens the named file using os.Open and prepares it for use as a Mach-O binary.\n\nGo return type: (*File, error)\n\nJoker return type: [{:ByteOrder ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/macho/file.go:24:12), :Loads ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/debug/macho/file.go:35:11)), :Sections ^(vector-of {:Relocs ^(vector-of {:Addr ^Int, :Value ^Int, :Type ^ABEND042(cannot find typename macho.uint8), :Len ^ABEND042(cannot find typename macho.uint8), :Pcrel ^Bool, :Extern ^Bool, :Scattered ^Bool})}), :Symtab ^{:Syms ^(vector-of {:Name ^String, :Type ^ABEND042(cannot find typename macho.uint8), :Sect ^ABEND042(cannot find typename macho.uint8), :Desc ^Int, :Value ^ABEND042(cannot find typename macho.uint64)})}, :Dysymtab ^{:IndirectSyms ^(vector-of Int)}} Error]"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC macho.OpenFat has:
(defn OpenFat
  "OpenFat opens the named file using os.Open and prepares it for use as a Mach-O\nuniversal binary.\n\nGo return type: (*FatFile, error)\n\nJoker return type: [{:Magic ^Int, :Arches ^(vector-of {})} Error]"
  {:added "1.0"
   :go "openFat(name)"}
  [^String name])

JOKER FUNC mail.ParseAddress has:
(defn ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo return type: (*Address, error)\n\nJoker return type: [{:Name ^String, :Address ^String} Error]"
  {:added "1.0"
   :go "parseAddress(address)"}
  [^String address])

JOKER FUNC mail.ParseAddressList has:
(defn ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n\nGo return type: ([]*Address, error)\n\nJoker return type: [(vector-of {:Name ^String, :Address ^String}) Error]"
  {:added "1.0"
   :go "parseAddressList(list)"}
  [^String list])

JOKER FUNC mail.ParseDate has:
;; (defn ParseDate
;;   "ParseDate parses an RFC 5322 date string.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/mail/message.go:95:30) Error]"
;;   {:added "1.0"
;;    :go "parseDate(date)"}
;;   [^String date])

JOKER FUNC mail.ReadMessage has:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo return type: (msg *Message, err error)\n\nJoker return type: [{:Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/mail/message.go:106:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/mail/message.go:46:9)} Error]"
;;   {:added "1.0"
;;    :go "readMessage(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/mail/message.go:52:20) r])

JOKER FUNC math.Abs has:
;; (defn Abs
;;   "Abs returns the absolute value of x.\n\nSpecial cases are:\n\tAbs(±Inf) = +Inf\n\tAbs(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "abs(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/abs.go:12:12) x])

JOKER FUNC math.Acos has:
;; (defn Acos
;;   "Acos returns the arccosine, in radians, of x.\n\nSpecial case is:\n\tAcos(x) = NaN if x < -1 or x > 1\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "acos(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/asin.go:51:13) x])

JOKER FUNC math.Acosh has:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nSpecial cases are:\n\tAcosh(+Inf) = +Inf\n\tAcosh(x) = NaN if x < 1\n\tAcosh(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "acosh(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/acosh.go:42:14) x])

JOKER FUNC math.Asin has:
;; (defn Asin
;;   "Asin returns the arcsine, in radians, of x.\n\nSpecial cases are:\n\tAsin(±0) = ±0\n\tAsin(x) = NaN if x < -1 or x > 1\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "asin(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/asin.go:19:13) x])

JOKER FUNC math.Asinh has:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nSpecial cases are:\n\tAsinh(±0) = ±0\n\tAsinh(±Inf) = ±Inf\n\tAsinh(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "asinh(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/asinh.go:39:14) x])

JOKER FUNC math.Atan has:
;; (defn Atan
;;   "Atan returns the arctangent, in radians, of x.\n\nSpecial cases are:\n     Atan(±0) = ±0\n     Atan(±Inf) = ±Pi/2\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "atan(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/atan.go:95:13) x])

JOKER FUNC math.Atan2 has:
;; (defn Atan2
;;   "Atan2 returns the arc tangent of y/x, using\nthe signs of the two to determine the quadrant\nof the return value.\n\nSpecial cases are (in order):\n\tAtan2(y, NaN) = NaN\n\tAtan2(NaN, x) = NaN\n\tAtan2(+0, x>=0) = +0\n\tAtan2(-0, x>=0) = -0\n\tAtan2(+0, x<=-0) = +Pi\n\tAtan2(-0, x<=-0) = -Pi\n\tAtan2(y>0, 0) = +Pi/2\n\tAtan2(y<0, 0) = -Pi/2\n\tAtan2(+Inf, +Inf) = +Pi/4\n\tAtan2(-Inf, +Inf) = -Pi/4\n\tAtan2(+Inf, -Inf) = 3Pi/4\n\tAtan2(-Inf, -Inf) = -3Pi/4\n\tAtan2(y, +Inf) = 0\n\tAtan2(y>0, -Inf) = +Pi\n\tAtan2(y<0, -Inf) = -Pi\n\tAtan2(+Inf, x) = +Pi/2\n\tAtan2(-Inf, x) = -Pi/2\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "atan2(y, x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/atan2.go:29:17) y, ^ABEND885(unrecognized type float64 at: GO.link/src/math/atan2.go:29:17) x])

JOKER FUNC math.Atanh has:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nSpecial cases are:\n\tAtanh(1) = +Inf\n\tAtanh(±0) = ±0\n\tAtanh(-1) = -Inf\n\tAtanh(x) = NaN if x < -1 or x > 1\n\tAtanh(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "atanh(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/atanh.go:47:14) x])

JOKER FUNC math.Cbrt has:
;; (defn Cbrt
;;   "Cbrt returns the cube root of x.\n\nSpecial cases are:\n\tCbrt(±0) = ±0\n\tCbrt(±Inf) = ±Inf\n\tCbrt(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "cbrt(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/cbrt.go:25:13) x])

JOKER FUNC math.Ceil has:
;; (defn Ceil
;;   "Ceil returns the least integer value greater than or equal to x.\n\nSpecial cases are:\n\tCeil(±0) = ±0\n\tCeil(±Inf) = ±Inf\n\tCeil(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "ceil(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/floor.go:36:13) x])

JOKER FUNC math.Copysign has:
;; (defn Copysign
;;   "Copysign returns a value with the magnitude\nof x and the sign of y.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "copysign(x, y)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/copysign.go:9:20) x, ^ABEND885(unrecognized type float64 at: GO.link/src/math/copysign.go:9:20) y])

JOKER FUNC math.Cos has:
;; (defn Cos
;;   "Cos returns the cosine of the radian argument x.\n\nSpecial cases are:\n\tCos(±Inf) = NaN\n\tCos(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "cos(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/sin.go:117:12) x])

JOKER FUNC math.Cosh has:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nSpecial cases are:\n\tCosh(±0) = 1\n\tCosh(±Inf) = +Inf\n\tCosh(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "cosh(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/sinh.go:72:13) x])

JOKER FUNC math.Dim has:
;; (defn Dim
;;   "Dim returns the maximum of x-y or 0.\n\nSpecial cases are:\n\tDim(+Inf, +Inf) = NaN\n\tDim(-Inf, -Inf) = NaN\n\tDim(x, NaN) = Dim(NaN, x) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "dim(x, y)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/dim.go:13:15) x, ^ABEND885(unrecognized type float64 at: GO.link/src/math/dim.go:13:15) y])

JOKER FUNC math.Erf has:
;; (defn Erf
;;   "Erf returns the error function of x.\n\nSpecial cases are:\n\tErf(+Inf) = 1\n\tErf(-Inf) = -1\n\tErf(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "erf(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/erf.go:188:12) x])

JOKER FUNC math.Erfc has:
;; (defn Erfc
;;   "Erfc returns the complementary error function of x.\n\nSpecial cases are:\n\tErfc(+Inf) = 0\n\tErfc(-Inf) = 2\n\tErfc(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "erfc(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/erf.go:267:13) x])

JOKER FUNC math.Erfcinv has:
;; (defn Erfcinv
;;   "Erfcinv returns the inverse of Erfc(x).\n\nSpecial cases are:\n\tErfcinv(0) = +Inf\n\tErfcinv(2) = -Inf\n\tErfcinv(x) = NaN if x < 0 or x > 2\n\tErfcinv(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "erfcinv(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/erfinv.go:125:16) x])

JOKER FUNC math.Erfinv has:
;; (defn Erfinv
;;   "Erfinv returns the inverse error function of x.\n\nSpecial cases are:\n\tErfinv(1) = +Inf\n\tErfinv(-1) = -Inf\n\tErfinv(x) = NaN if x < -1 or x > 1\n\tErfinv(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "erfinv(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/erfinv.go:76:15) x])

JOKER FUNC math.Exp has:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nSpecial cases are:\n\tExp(+Inf) = +Inf\n\tExp(NaN) = NaN\nVery large values overflow to 0 or +Inf.\nVery small values underflow to 1.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "exp(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/exp.go:14:12) x])

JOKER FUNC math.Exp2 has:
;; (defn Exp2
;;   "Exp2 returns 2**x, the base-2 exponential of x.\n\nSpecial cases are the same as Exp.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "exp2(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/exp.go:135:13) x])

JOKER FUNC math.Expm1 has:
;; (defn Expm1
;;   "Expm1 returns e**x - 1, the base-e exponential of x minus 1.\nIt is more accurate than Exp(x) - 1 when x is near zero.\n\nSpecial cases are:\n\tExpm1(+Inf) = +Inf\n\tExpm1(-Inf) = -1\n\tExpm1(NaN) = NaN\nVery large values overflow to -1 or +Inf.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "expm1(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/expm1.go:124:14) x])

JOKER FUNC math.Float32bits has:
;; (defn ^Int Float32bits
;;   "Float32bits returns the IEEE 754 binary representation of f.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "math.Float32bits(f)"}
;;   [^ABEND885(unrecognized type float32 at: GO.link/src/math/unsafe.go:10:20) f])

JOKER FUNC math.Float32frombits has:
;; (defn Float32frombits
;;   "Float32frombits returns the floating point number corresponding\nto the IEEE 754 binary representation b.\n\nGo return type: float32\n\nJoker return type: ABEND042(cannot find typename math.float32)"
;;   {:added "1.0"
;;    :go "float32frombits(b)"}
;;   [^Int b])

JOKER FUNC math.Float64bits has:
;; (defn Float64bits
;;   "Float64bits returns the IEEE 754 binary representation of f.\n\nGo return type: uint64\n\nJoker return type: ABEND042(cannot find typename math.uint64)"
;;   {:added "1.0"
;;    :go "float64bits(f)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/unsafe.go:17:20) f])

JOKER FUNC math.Float64frombits has:
;; (defn Float64frombits
;;   "Float64frombits returns the floating point number corresponding\nthe IEEE 754 binary representation b.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "float64frombits(b)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/math/unsafe.go:21:24) b])

JOKER FUNC math.Floor has:
;; (defn Floor
;;   "Floor returns the greatest integer value less than or equal to x.\n\nSpecial cases are:\n\tFloor(±0) = ±0\n\tFloor(±Inf) = ±Inf\n\tFloor(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "floor(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/floor.go:13:14) x])

JOKER FUNC math.Frexp has:
;; (defn Frexp
;;   "Frexp breaks f into a normalized fraction\nand an integral power of two.\nIt returns frac and exp satisfying f == frac × 2**exp,\nwith the absolute value of frac in the interval [½, 1).\n\nSpecial cases are:\n\tFrexp(±0) = ±0, 0\n\tFrexp(±Inf) = ±Inf, 0\n\tFrexp(NaN) = NaN, 0\n\nGo return type: (frac float64, exp int)\n\nJoker return type: [ABEND042(cannot find typename math.float64) Int]"
;;   {:added "1.0"
;;    :go "frexp(f)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/frexp.go:16:14) f])

JOKER FUNC math.Gamma has:
;; (defn Gamma
;;   "Gamma returns the Gamma function of x.\n\nSpecial cases are:\n\tGamma(+Inf) = +Inf\n\tGamma(+0) = +Inf\n\tGamma(-0) = -Inf\n\tGamma(x) = NaN for integer x < 0\n\tGamma(-Inf) = NaN\n\tGamma(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "gamma(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/gamma.go:130:14) x])

JOKER FUNC math.Hypot has:
;; (defn Hypot
;;   "Hypot returns Sqrt(p*p + q*q), taking care to avoid\nunnecessary overflow and underflow.\n\nSpecial cases are:\n\tHypot(±Inf, q) = +Inf\n\tHypot(p, ±Inf) = +Inf\n\tHypot(NaN, q) = NaN\n\tHypot(p, NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "hypot(p, q)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/hypot.go:19:17) p, ^ABEND885(unrecognized type float64 at: GO.link/src/math/hypot.go:19:17) q])

JOKER FUNC math.Ilogb has:
;; (defn ^Int Ilogb
;;   "Ilogb returns the binary exponent of x as an integer.\n\nSpecial cases are:\n\tIlogb(±Inf) = MaxInt32\n\tIlogb(0) = MinInt32\n\tIlogb(NaN) = MaxInt32\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "math.Ilogb(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/logb.go:32:14) x])

JOKER FUNC math.Inf has:
;; (defn Inf
;;   "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "inf(sign)"}
;;   [^Int sign])

JOKER FUNC math.IsInf has:
;; (defn ^Bool IsInf
;;   "IsInf reports whether f is an infinity, according to sign.\nIf sign > 0, IsInf reports whether f is positive infinity.\nIf sign < 0, IsInf reports whether f is negative infinity.\nIf sign == 0, IsInf reports whether f is either infinity.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "math.IsInf(f, sign)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/bits.go:46:14) f, ^Int sign])

JOKER FUNC math.IsNaN has:
;; (defn ^Bool IsNaN
;;   "IsNaN reports whether f is an IEEE 754 ``not-a-number'' value.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "math.IsNaN(f)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/bits.go:34:14) f])

JOKER FUNC math.J0 has:
;; (defn J0
;;   "J0 returns the order-zero Bessel function of the first kind.\n\nSpecial cases are:\n\tJ0(±Inf) = 0\n\tJ0(0) = 1\n\tJ0(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "j0(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/j0.go:76:11) x])

JOKER FUNC math.J1 has:
;; (defn J1
;;   "J1 returns the order-one Bessel function of the first kind.\n\nSpecial cases are:\n\tJ1(±Inf) = 0\n\tJ1(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "j1(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/j1.go:74:11) x])

JOKER FUNC math.Jn has:
;; (defn Jn
;;   "Jn returns the order-n Bessel function of the first kind.\n\nSpecial cases are:\n\tJn(n, ±Inf) = 0\n\tJn(n, NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "jn(n, x)"}
;;   [^Int n, ^ABEND885(unrecognized type float64 at: GO.link/src/math/jn.go:53:18) x])

JOKER FUNC math.Ldexp has:
;; (defn Ldexp
;;   "Ldexp is the inverse of Frexp.\nIt returns frac × 2**exp.\n\nSpecial cases are:\n\tLdexp(±0, exp) = ±0\n\tLdexp(±Inf, exp) = ±Inf\n\tLdexp(NaN, exp) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "ldexp(frac, exp)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/ldexp.go:14:17) frac, ^Int exp])

JOKER FUNC math.Lgamma has:
;; (defn Lgamma
;;   "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\n\nSpecial cases are:\n\tLgamma(+Inf) = +Inf\n\tLgamma(0) = +Inf\n\tLgamma(-integer) = +Inf\n\tLgamma(-Inf) = -Inf\n\tLgamma(NaN) = NaN\n\nGo return type: (lgamma float64, sign int)\n\nJoker return type: [ABEND042(cannot find typename math.float64) Int]"
;;   {:added "1.0"
;;    :go "lgamma(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/lgamma.go:174:15) x])

JOKER FUNC math.Log has:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nSpecial cases are:\n\tLog(+Inf) = +Inf\n\tLog(0) = -Inf\n\tLog(x < 0) = NaN\n\tLog(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "log(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/log.go:80:12) x])

JOKER FUNC math.Log10 has:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\nThe special cases are the same as for Log.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "log10(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/log10.go:9:14) x])

JOKER FUNC math.Log1p has:
;; (defn Log1p
;;   "Log1p returns the natural logarithm of 1 plus its argument x.\nIt is more accurate than Log(1 + x) when x is near zero.\n\nSpecial cases are:\n\tLog1p(+Inf) = +Inf\n\tLog1p(±0) = ±0\n\tLog1p(-1) = -Inf\n\tLog1p(x < -1) = NaN\n\tLog1p(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "log1p(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/log1p.go:95:14) x])

JOKER FUNC math.Log2 has:
;; (defn Log2
;;   "Log2 returns the binary logarithm of x.\nThe special cases are the same as for Log.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "log2(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/log10.go:17:13) x])

JOKER FUNC math.Logb has:
;; (defn Logb
;;   "Logb returns the binary exponent of x.\n\nSpecial cases are:\n\tLogb(±Inf) = +Inf\n\tLogb(0) = -Inf\n\tLogb(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "logb(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/logb.go:13:13) x])

JOKER FUNC math.Max has:
;; (defn Max
;;   "Max returns the larger of x or y.\n\nSpecial cases are:\n\tMax(x, +Inf) = Max(+Inf, x) = +Inf\n\tMax(x, NaN) = Max(NaN, x) = NaN\n\tMax(+0, ±0) = Max(±0, +0) = +0\n\tMax(-0, -0) = -0\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "max(x, y)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/dim.go:35:15) x, ^ABEND885(unrecognized type float64 at: GO.link/src/math/dim.go:35:15) y])

JOKER FUNC math.Min has:
;; (defn Min
;;   "Min returns the smaller of x or y.\n\nSpecial cases are:\n\tMin(x, -Inf) = Min(-Inf, x) = -Inf\n\tMin(x, NaN) = Min(NaN, x) = NaN\n\tMin(-0, ±0) = Min(±0, -0) = -0\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "min(x, y)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/dim.go:62:15) x, ^ABEND885(unrecognized type float64 at: GO.link/src/math/dim.go:62:15) y])

JOKER FUNC math.Mod has:
;; (defn Mod
;;   "Mod returns the floating-point remainder of x/y.\nThe magnitude of the result is less than y and its\nsign agrees with that of x.\n\nSpecial cases are:\n\tMod(±Inf, y) = NaN\n\tMod(NaN, y) = NaN\n\tMod(x, 0) = NaN\n\tMod(x, ±Inf) = x\n\tMod(x, NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "mod(x, y)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/mod.go:21:15) x, ^ABEND885(unrecognized type float64 at: GO.link/src/math/mod.go:21:15) y])

JOKER FUNC math.Modf has:
;; (defn Modf
;;   "Modf returns integer and fractional floating-point numbers\nthat sum to f. Both values have the same sign as f.\n\nSpecial cases are:\n\tModf(±Inf) = ±Inf, NaN\n\tModf(NaN) = NaN, NaN\n\nGo return type: (int float64, frac float64)\n\nJoker return type: [ABEND042(cannot find typename math.float64) ABEND042(cannot find typename math.float64)]"
;;   {:added "1.0"
;;    :go "modf(f)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/modf.go:13:13) f])

JOKER FUNC math.NaN has:
;; (defn NaN
;;   "NaN returns an IEEE 754 ``not-a-number'' value.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])

JOKER FUNC math.Nextafter has:
;; (defn Nextafter
;;   "Nextafter returns the next representable float64 value after x towards y.\n\nSpecial cases are:\n\tNextafter(x, x)   = x\n\tNextafter(NaN, y) = NaN\n\tNextafter(x, NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "nextafter(x, y)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/nextafter.go:35:21) x, ^ABEND885(unrecognized type float64 at: GO.link/src/math/nextafter.go:35:21) y])

JOKER FUNC math.Nextafter32 has:
;; (defn Nextafter32
;;   "Nextafter32 returns the next representable float32 value after x towards y.\n\nSpecial cases are:\n\tNextafter32(x, x)   = x\n\tNextafter32(NaN, y) = NaN\n\tNextafter32(x, NaN) = NaN\n\nGo return type: float32\n\nJoker return type: ABEND042(cannot find typename math.float32)"
;;   {:added "1.0"
;;    :go "nextafter32(x, y)"}
;;   [^ABEND885(unrecognized type float32 at: GO.link/src/math/nextafter.go:13:23) x, ^ABEND885(unrecognized type float32 at: GO.link/src/math/nextafter.go:13:23) y])

JOKER FUNC math.Pow has:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\n\nSpecial cases are (in order):\n\tPow(x, ±0) = 1 for any x\n\tPow(1, y) = 1 for any y\n\tPow(x, 1) = x for any x\n\tPow(NaN, y) = NaN\n\tPow(x, NaN) = NaN\n\tPow(±0, y) = ±Inf for y an odd integer < 0\n\tPow(±0, -Inf) = +Inf\n\tPow(±0, +Inf) = +0\n\tPow(±0, y) = +Inf for finite y < 0 and not an odd integer\n\tPow(±0, y) = ±0 for y an odd integer > 0\n\tPow(±0, y) = +0 for finite y > 0 and not an odd integer\n\tPow(-1, ±Inf) = 1\n\tPow(x, +Inf) = +Inf for |x| > 1\n\tPow(x, -Inf) = +0 for |x| > 1\n\tPow(x, +Inf) = +0 for |x| < 1\n\tPow(x, -Inf) = +Inf for |x| < 1\n\tPow(+Inf, y) = +Inf for y > 0\n\tPow(+Inf, y) = +0 for y < 0\n\tPow(-Inf, y) = Pow(-0, -y)\n\tPow(x, y) = NaN for finite x < 0 and finite non-integer y\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "pow(x, y)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/pow.go:38:15) x, ^ABEND885(unrecognized type float64 at: GO.link/src/math/pow.go:38:15) y])

JOKER FUNC math.Pow10 has:
;; (defn Pow10
;;   "Pow10 returns 10**n, the base-10 exponential of n.\n\nSpecial cases are:\n\tPow10(n) =    0 for n < -323\n\tPow10(n) = +Inf for n > 308\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "pow10(n)"}
;;   [^Int n])

JOKER FUNC math.Remainder has:
;; (defn Remainder
;;   "Remainder returns the IEEE 754 floating-point remainder of x/y.\n\nSpecial cases are:\n\tRemainder(±Inf, y) = NaN\n\tRemainder(NaN, y) = NaN\n\tRemainder(x, 0) = NaN\n\tRemainder(x, ±Inf) = x\n\tRemainder(x, NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "remainder(x, y)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/remainder.go:37:21) x, ^ABEND885(unrecognized type float64 at: GO.link/src/math/remainder.go:37:21) y])

JOKER FUNC math.Round has:
;; (defn Round
;;   "Round returns the nearest integer, rounding half away from zero.\n\nSpecial cases are:\n\tRound(±0) = ±0\n\tRound(±Inf) = ±Inf\n\tRound(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "round(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/floor.go:64:14) x])

JOKER FUNC math.RoundToEven has:
;; (defn RoundToEven
;;   "RoundToEven returns the nearest integer, rounding ties to even.\n\nSpecial cases are:\n\tRoundToEven(±0) = ±0\n\tRoundToEven(±Inf) = ±Inf\n\tRoundToEven(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "roundToEven(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/floor.go:101:20) x])

JOKER FUNC math.Signbit has:
;; (defn ^Bool Signbit
;;   "Signbit returns true if x is negative or negative zero.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "math.Signbit(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/signbit.go:8:16) x])

JOKER FUNC math.Sin has:
;; (defn Sin
;;   "Sin returns the sine of the radian argument x.\n\nSpecial cases are:\n\tSin(±0) = ±0\n\tSin(±Inf) = NaN\n\tSin(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "sin(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/sin.go:172:12) x])

JOKER FUNC math.Sincos has:
;; (defn Sincos
;;   "Sincos returns Sin(x), Cos(x).\n\nSpecial cases are:\n\tSincos(±0) = ±0, 1\n\tSincos(±Inf) = NaN, NaN\n\tSincos(NaN) = NaN, NaN\n\nGo return type: (sin float64, cos float64)\n\nJoker return type: [ABEND042(cannot find typename math.float64) ABEND042(cannot find typename math.float64)]"
;;   {:added "1.0"
;;    :go "sincos(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/sincos.go:17:15) x])

JOKER FUNC math.Sinh has:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nSpecial cases are:\n\tSinh(±0) = ±0\n\tSinh(±Inf) = ±Inf\n\tSinh(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "sinh(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/sinh.go:25:13) x])

JOKER FUNC math.Sqrt has:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\n\nSpecial cases are:\n\tSqrt(+Inf) = +Inf\n\tSqrt(±0) = ±0\n\tSqrt(x < 0) = NaN\n\tSqrt(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "sqrt(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/sqrt.go:92:13) x])

JOKER FUNC math.Tan has:
;; (defn Tan
;;   "Tan returns the tangent of the radian argument x.\n\nSpecial cases are:\n\tTan(±0) = ±0\n\tTan(±Inf) = NaN\n\tTan(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "tan(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/tan.go:82:12) x])

JOKER FUNC math.Tanh has:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nSpecial cases are:\n\tTanh(±0) = ±0\n\tTanh(±Inf) = ±1\n\tTanh(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "tanh(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/tanh.go:74:13) x])

JOKER FUNC math.Trunc has:
;; (defn Trunc
;;   "Trunc returns the integer value of x.\n\nSpecial cases are:\n\tTrunc(±0) = ±0\n\tTrunc(±Inf) = ±Inf\n\tTrunc(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "trunc(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/floor.go:48:14) x])

JOKER FUNC math.Y0 has:
;; (defn Y0
;;   "Y0 returns the order-zero Bessel function of the second kind.\n\nSpecial cases are:\n\tY0(+Inf) = 0\n\tY0(0) = -Inf\n\tY0(x < 0) = NaN\n\tY0(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "y0(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/j0.go:154:11) x])

JOKER FUNC math.Y1 has:
;; (defn Y1
;;   "Y1 returns the order-one Bessel function of the second kind.\n\nSpecial cases are:\n\tY1(+Inf) = 0\n\tY1(0) = -Inf\n\tY1(x < 0) = NaN\n\tY1(NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "y1(x)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/math/j1.go:154:11) x])

JOKER FUNC math.Yn has:
;; (defn Yn
;;   "Yn returns the order-n Bessel function of the second kind.\n\nSpecial cases are:\n\tYn(n, +Inf) = 0\n\tYn(n ≥ 0, 0) = -Inf\n\tYn(n < 0, 0) = +Inf if n is odd, -Inf if n is even\n\tYn(n, x < 0) = NaN\n\tYn(n, NaN) = NaN\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "yn(n, x)"}
;;   [^Int n, ^ABEND885(unrecognized type float64 at: GO.link/src/math/jn.go:233:18) x])

JOKER FUNC md5.New has:
;; (defn New
;;   "New returns a new hash.Hash computing the MD5 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/md5/md5.go:130:12)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC md5.Sum has:
;; (defn Sum
;;   "Sum returns the MD5 checksum of the data.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/md5/md5.go:204:15) data])

JOKER FUNC mime.AddExtensionType has:
(defn ^Error AddExtensionType
  "AddExtensionType sets the MIME type associated with\nthe extension ext to typ. The extension should begin with\na leading dot, as in \".html\".\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "mime.AddExtensionType(ext, typ)"}
  [^String ext, ^String typ])

JOKER FUNC mime.ExtensionsByType has:
(defn ExtensionsByType
  "ExtensionsByType returns the extensions known to be associated with the MIME\ntype typ. The returned extensions will each begin with a leading dot, as in\n\".html\". When typ has no associated extensions, ExtensionsByType returns an\nnil slice.\n\nGo return type: ([]string, error)\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "extensionsByType(typ)"}
  [^String typ])

JOKER FUNC mime.FormatMediaType has:
;; (defn ^String FormatMediaType
;;   "FormatMediaType serializes mediatype t and the parameters\nparam as a media type conforming to RFC 2045 and RFC 2616.\nThe type and parameter names are written in lower-case.\nWhen any of the arguments result in a standard violation then\nFormatMediaType returns the empty string.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "mime.FormatMediaType(t, param)"}
;;   [^String t, ^ABEND881(unrecognized Expr type *ast.MapType at: GO.link/src/mime/mediatype.go:20:38) param])

JOKER FUNC mime.ParseMediaType has:
;; (defn ParseMediaType
;;   "ParseMediaType parses a media type value and any optional\nparameters, per RFC 1521.  Media types are the values in\nContent-Type and Content-Disposition headers (RFC 2183).\nOn success, ParseMediaType returns the media type converted\nto lowercase and trimmed of white space and a non-nil map.\nIf there is an error parsing the optional parameter,\nthe media type will be returned along with the error\nErrInvalidMediaParameter.\nThe returned map, params, maps from the lowercase\nattribute to the attribute value with its case preserved.\n\nGo return type: (mediatype string, params ..., err error)\n\nJoker return type: [String ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/mediatype.go:111:57) Error]"
;;   {:added "1.0"
;;    :go "parseMediaType(v)"}
;;   [^String v])

JOKER FUNC mime.TypeByExtension has:
(defn ^String TypeByExtension
  "TypeByExtension returns the MIME type associated with the file extension ext.\nThe extension ext should begin with a leading dot, as in \".html\".\nWhen ext has no associated type, TypeByExtension returns \"\".\n\nExtensions are looked up first case-sensitively, then case-insensitively.\n\nThe built-in table is small but on unix it is augmented by the local\nsystem's mime.types file(s) if available under one or more of these\nnames:\n\n  /etc/mime.types\n  /etc/apache2/mime.types\n  /etc/apache/mime.types\n\nOn Windows, MIME types are extracted from the registry.\n\nText types have the charset parameter set to \"utf-8\" by default.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "mime.TypeByExtension(ext)"}
  [^String ext])

JOKER FUNC multipart.NewReader has:
;; (defn NewReader
;;   "NewReader creates a new multipart Reader reading from r using the\ngiven MIME boundary.\n\nThe boundary is usually obtained from the \"boundary\" parameter of\nthe message's \"Content-Type\" header. Use mime.ParseMediaType to\nparse such headers.\n\nGo return type: *Reader\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newReader(r, boundary)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/mime/multipart/multipart.go:99:18) r, ^String boundary])

JOKER FUNC multipart.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new multipart Writer with a random boundary,\nwriting to w.\n\nGo return type: *Writer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/mime/multipart/writer.go:27:18) w])

JOKER FUNC net.CIDRMask has:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo return type: IPMask\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "cIDRMask(ones, bits)"}
  [^Int ones, ^Int bits])

JOKER FUNC net.Dial has:
;; (defn Dial
;;   "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo return type: (Conn, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.DialIP has:
;; (defn DialIP
;;   "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo return type: (*IPConn, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialIP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/iprawsock.go:211:42) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/iprawsock.go:211:42) raddr])

JOKER FUNC net.DialTCP has:
;; (defn DialTCP
;;   "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo return type: (*TCPConn, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialTCP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/tcpsock.go:206:43) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/tcpsock.go:206:43) raddr])

JOKER FUNC net.DialTimeout has:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo return type: (Conn, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "dialTimeout(network, address, timeout)"}
;;   [^String network, ^String address, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/dial.go:313:51) timeout])

JOKER FUNC net.DialUDP has:
;; (defn DialUDP
;;   "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo return type: (*UDPConn, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialUDP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/udpsock.go:205:43) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/udpsock.go:205:43) raddr])

JOKER FUNC net.DialUnix has:
;; (defn DialUnix
;;   "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo return type: (*UnixConn, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialUnix(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/unixsock.go:200:44) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/unixsock.go:200:44) raddr])

JOKER FUNC net.FileConn has:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo return type: (c Conn, err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "fileConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/file.go:21:17) f])

JOKER FUNC net.FileListener has:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo return type: (ln Listener, err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:365:15) Error]"
;;   {:added "1.0"
;;    :go "fileListener(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/file.go:33:21) f])

JOKER FUNC net.FilePacketConn has:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo return type: (c PacketConn, err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:303:17) Error]"
;;   {:added "1.0"
;;    :go "filePacketConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/file.go:45:23) f])

JOKER FUNC net.IPv4 has:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo return type: IP\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "iPv4(a, b, c, d)"}
  [^Byte a, ^Byte b, ^Byte c, ^Byte d])

JOKER FUNC net.IPv4Mask has:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo return type: IPMask\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "iPv4Mask(a, b, c, d)"}
  [^Byte a, ^Byte b, ^Byte c, ^Byte d])

JOKER FUNC net.InterfaceAddrs has:
;; (defn InterfaceAddrs
;;   "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo return type: ([]Addr, error)\n\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:105:11)) Error]"
;;   {:added "1.0"
;;    :go "interfaceAddrs()"}
;;   [])

JOKER FUNC net.InterfaceByIndex has:
(defn InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo return type: (*Interface, error)\n\nJoker return type: [{:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int} Error]"
  {:added "1.0"
   :go "interfaceByIndex(index)"}
  [^Int index])

JOKER FUNC net.InterfaceByName has:
(defn InterfaceByName
  "InterfaceByName returns the interface specified by name.\n\nGo return type: (*Interface, error)\n\nJoker return type: [{:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int} Error]"
  {:added "1.0"
   :go "interfaceByName(name)"}
  [^String name])

JOKER FUNC net.Interfaces has:
(defn Interfaces
  "Interfaces returns a list of the system's network interfaces.\n\nGo return type: ([]Interface, error)\n\nJoker return type: [(vector-of {:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int}) Error]"
  {:added "1.0"
   :go "interfaces()"}
  [])

JOKER FUNC net.JoinHostPort has:
(defn ^String JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "net.JoinHostPort(host, port)"}
  [^String host, ^String port])

JOKER FUNC net.Listen has:
;; (defn Listen
;;   "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo return type: (Listener, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:365:15) Error]"
;;   {:added "1.0"
;;    :go "listen(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ListenIP has:
;; (defn ListenIP
;;   "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo return type: (*IPConn, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenIP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/iprawsock.go:230:37) laddr])

JOKER FUNC net.ListenMulticastUDP has:
;; (defn ListenMulticastUDP
;;   "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo return type: (*UDPConn, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenMulticastUDP(network, ifi, gaddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/udpsock.go:265:45) ifi, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/udpsock.go:265:63) gaddr])

JOKER FUNC net.ListenPacket has:
;; (defn ListenPacket
;;   "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo return type: (PacketConn, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:303:17) Error]"
;;   {:added "1.0"
;;    :go "listenPacket(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ListenTCP has:
;; (defn ListenTCP
;;   "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo return type: (*TCPListener, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenTCP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/tcpsock.go:323:38) laddr])

JOKER FUNC net.ListenUDP has:
;; (defn ListenUDP
;;   "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo return type: (*UDPConn, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUDP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/udpsock.go:231:38) laddr])

JOKER FUNC net.ListenUnix has:
;; (defn ListenUnix
;;   "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo return type: (*UnixListener, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUnix(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/unixsock.go:314:39) laddr])

JOKER FUNC net.ListenUnixgram has:
;; (defn ListenUnixgram
;;   "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo return type: (*UnixConn, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUnixgram(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/unixsock.go:334:43) laddr])

JOKER FUNC net.LookupAddr has:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo return type: (names []string, err error)\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupAddr(addr)"}
  [^String addr])

JOKER FUNC net.LookupCNAME has:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo return type: (cname string, err error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "lookupCNAME(host)"}
  [^String host])

JOKER FUNC net.LookupHost has:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo return type: (addrs []string, err error)\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupHost(host)"}
  [^String host])

JOKER FUNC net.LookupIP has:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo return type: ([]IP, error)\n\nJoker return type: [(vector-of (vector-of Int)) Error]"
  {:added "1.0"
   :go "lookupIP(host)"}
  [^String host])

JOKER FUNC net.LookupMX has:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo return type: ([]*MX, error)\n\nJoker return type: [(vector-of {:Host ^String, :Pref ^Int}) Error]"
  {:added "1.0"
   :go "lookupMX(name)"}
  [^String name])

JOKER FUNC net.LookupNS has:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo return type: ([]*NS, error)\n\nJoker return type: [(vector-of {:Host ^String}) Error]"
  {:added "1.0"
   :go "lookupNS(name)"}
  [^String name])

JOKER FUNC net.LookupPort has:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo return type: (port int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "lookupPort(network, service)"}
  [^String network, ^String service])

JOKER FUNC net.LookupSRV has:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker return type: [String (vector-of {:Target ^String, :Port ^Int, :Priority ^Int, :Weight ^Int}) Error]"
  {:added "1.0"
   :go "lookupSRV(service, proto, name)"}
  [^String service, ^String proto, ^String name])

JOKER FUNC net.LookupTXT has:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo return type: ([]string, error)\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupTXT(name)"}
  [^String name])

JOKER FUNC net.ParseCIDR has:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo return type: (IP, *IPNet, error)\n\nJoker return type: [(vector-of Int) {:IP ^(vector-of Int), :Mask ^(vector-of Int)} Error]"
  {:added "1.0"
   :go "parseCIDR(s)"}
  [^String s])

JOKER FUNC net.ParseIP has:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo return type: IP\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "parseIP(s)"}
  [^String s])

JOKER FUNC net.ParseMAC has:
(defn ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo return type: (hw HardwareAddr, err error)\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "parseMAC(s)"}
  [^String s])

JOKER FUNC net.Pipe has:
;; (defn Pipe
;;   "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo return type: (Conn, Conn)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:113:11) ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:113:11)]"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC net.ResolveIPAddr has:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo return type: (*IPAddr, error)\n\nJoker return type: [{:IP ^(vector-of Int), :Zone ^String} Error]"
  {:added "1.0"
   :go "resolveIPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveTCPAddr has:
(defn ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo return type: (*TCPAddr, error)\n\nJoker return type: [{:IP ^(vector-of Int), :Port ^Int, :Zone ^String} Error]"
  {:added "1.0"
   :go "resolveTCPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveUDPAddr has:
(defn ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo return type: (*UDPAddr, error)\n\nJoker return type: [{:IP ^(vector-of Int), :Port ^Int, :Zone ^String} Error]"
  {:added "1.0"
   :go "resolveUDPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveUnixAddr has:
(defn ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo return type: (*UnixAddr, error)\n\nJoker return type: [{:Name ^String, :Net ^String} Error]"
  {:added "1.0"
   :go "resolveUnixAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.SplitHostPort has:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo return type: (host string, port string, err error)\n\nJoker return type: [String String Error]"
  {:added "1.0"
   :go "splitHostPort(hostport)"}
  [^String hostport])

JOKER FUNC os.Chdir has:
(defn ^Error Chdir
  "Chdir changes the current working directory to the named directory.\nIf there is an error, it will be of type *PathError.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chdir(dir)"}
  [^String dir])

JOKER FUNC os.Chmod has:
;; (defn ^Error Chmod
;;   "Chmod changes the mode of the named file to mode.\nIf the file is a symbolic link, it changes the mode of the link's target.\nIf there is an error, it will be of type *PathError.\n\nA different subset of the mode bits are used, depending on the\noperating system.\n\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and\nModeSticky are used.\n\nOn Windows, the mode must be non-zero but otherwise only the 0200\nbit (owner writable) of mode is used; it controls whether the\nfile's read-only attribute is set or cleared. attribute. The other\nbits are currently unused. Use mode 0400 for a read-only file and\n0600 for a readable+writable file.\n\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,\nand ModeTemporary are used.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.Chmod(name, mode)"}
;;   [^String name, ^ABEND885(unrecognized type FileMode at: GO.link/src/os/file.go:402:30) mode])

JOKER FUNC os.Chown has:
(defn ^Error Chown
  "Chown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link's target.\nA uid or gid of -1 means to not change that value.\nIf there is an error, it will be of type *PathError.\n\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\nEPLAN9 error, wrapped in *PathError.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chown(name, uid, gid)"}
  [^String name, ^Int uid, ^Int gid])

JOKER FUNC os.Chtimes has:
;; (defn ^Error Chtimes
;;   "Chtimes changes the access and modification times of the named\nfile, similar to the Unix utime() or utimes() functions.\n\nThe underlying filesystem may truncate or round the values to a\nless precise time unit.\nIf there is an error, it will be of type *PathError.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.Chtimes(name, atime, mtime)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/file_posix.go:140:33) atime, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/file_posix.go:140:50) mtime])

JOKER FUNC os.Clearenv has:
;; (defn Clearenv
;;   "Clearenv deletes all environment variables.\n"
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])

JOKER FUNC os.Create has:
(defn Create
  "Create creates the named file with mode 0666 (before umask), truncating\nit if it already exists. If successful, methods on the returned\nFile can be used for I/O; the associated file descriptor has mode\nO_RDWR.\nIf there is an error, it will be of type *PathError.\n\nGo return type: (*File, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "create(name)"}
  [^String name])

JOKER FUNC os.Environ has:
(defn Environ
  "Environ returns a copy of strings representing the environment,\nin the form \"key=value\".\n\nGo return type: []string\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "environ()"}
  [])

JOKER FUNC os.Executable has:
(defn Executable
  "Executable returns the path name for the executable that started\nthe current process. There is no guarantee that the path is still\npointing to the correct executable. If a symlink was used to start\nthe process, depending on the operating system, the result might\nbe the symlink or the path it pointed to. If a stable result is\nneeded, path/filepath.EvalSymlinks might help.\n\nExecutable returns an absolute path unless an error occurred.\n\nThe main use case is finding resources located relative to an\nexecutable.\n\nExecutable is not supported on nacl.\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "executable()"}
  [])

JOKER FUNC os.Exit has:
;; (defn Exit
;;   "Exit causes the current program to exit with the given status code.\nConventionally, code zero indicates success, non-zero an error.\nThe program terminates immediately; deferred functions are not run.\n"
;;   {:added "1.0"
;;    :go "exit(code)"}
;;   [^Int code])

JOKER FUNC os.Expand has:
;; (defn ^String Expand
;;   "Expand replaces ${var} or $var in the string based on the mapping function.\nFor example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "os.Expand(s, mapping)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/os/env.go:16:31) mapping])

JOKER FUNC os.ExpandEnv has:
(defn ^String ExpandEnv
  "ExpandEnv replaces ${var} or $var in the string according to the values\nof the current environment variables. References to undefined\nvariables are replaced by the empty string.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "os.ExpandEnv(s)"}
  [^String s])

JOKER FUNC os.FindProcess has:
(defn FindProcess
  "FindProcess looks for a running process by its pid.\n\nThe Process it returns can be used to obtain information\nabout the underlying operating system process.\n\nOn Unix systems, FindProcess always succeeds and returns a Process\nfor the given pid, regardless of whether the process exists.\n\nGo return type: (*Process, error)\n\nJoker return type: [{:Pid ^Int} Error]"
  {:added "1.0"
   :go "findProcess(pid)"}
  [^Int pid])

JOKER FUNC os.Getegid has:
(defn ^Int Getegid
  "Getegid returns the numeric effective group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getegid()"}
  [])

JOKER FUNC os.Getenv has:
(defn ^String Getenv
  "Getenv retrieves the value of the environment variable named by the key.\nIt returns the value, which will be empty if the variable is not present.\nTo distinguish between an empty value and an unset value, use LookupEnv.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "os.Getenv(key)"}
  [^String key])

JOKER FUNC os.Geteuid has:
(defn ^Int Geteuid
  "Geteuid returns the numeric effective user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Geteuid()"}
  [])

JOKER FUNC os.Getgid has:
(defn ^Int Getgid
  "Getgid returns the numeric group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getgid()"}
  [])

JOKER FUNC os.Getgroups has:
(defn Getgroups
  "Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n\nOn Windows, it returns syscall.EWINDOWS. See the os/user package\nfor a possible alternative.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "getgroups()"}
  [])

JOKER FUNC os.Getpagesize has:
(defn ^Int Getpagesize
  "Getpagesize returns the underlying system's memory page size.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpagesize()"}
  [])

JOKER FUNC os.Getpid has:
(defn ^Int Getpid
  "Getpid returns the process id of the caller.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpid()"}
  [])

JOKER FUNC os.Getppid has:
(defn ^Int Getppid
  "Getppid returns the process id of the caller's parent.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getppid()"}
  [])

JOKER FUNC os.Getuid has:
(defn ^Int Getuid
  "Getuid returns the numeric user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getuid()"}
  [])

JOKER FUNC os.Getwd has:
(defn Getwd
  "Getwd returns a rooted path name corresponding to the\ncurrent directory. If the current directory can be\nreached via multiple paths (due to symbolic links),\nGetwd may return any one of them.\n\nGo return type: (dir string, err error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "getwd()"}
  [])

JOKER FUNC os.Hostname has:
(defn Hostname
  "Hostname returns the host name reported by the kernel.\n\nGo return type: (name string, err error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "hostname()"}
  [])

JOKER FUNC os.IsExist has:
;; (defn ^Bool IsExist
;;   "IsExist returns a boolean indicating whether the error is known to report\nthat a file or directory already exists. It is satisfied by ErrExist as\nwell as some syscall errors.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsExist(err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:68:18) err])

JOKER FUNC os.IsNotExist has:
;; (defn ^Bool IsNotExist
;;   "IsNotExist returns a boolean indicating whether the error is known to\nreport that a file or directory does not exist. It is satisfied by\nErrNotExist as well as some syscall errors.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsNotExist(err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:75:21) err])

JOKER FUNC os.IsPathSeparator has:
;; (defn ^Bool IsPathSeparator
;;   "IsPathSeparator reports whether c is a directory separator character.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsPathSeparator(c)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/os/path_unix.go:15:24) c])

JOKER FUNC os.IsPermission has:
;; (defn ^Bool IsPermission
;;   "IsPermission returns a boolean indicating whether the error is known to\nreport that permission is denied. It is satisfied by ErrPermission as well\nas some syscall errors.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsPermission(err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:82:23) err])

JOKER FUNC os.IsTimeout has:
;; (defn ^Bool IsTimeout
;;   "IsTimeout returns a boolean indicating whether the error is known\nto report that a timeout occurred.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsTimeout(err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:88:20) err])

JOKER FUNC os.Lchown has:
(defn ^Error Lchown
  "Lchown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link itself.\nIf there is an error, it will be of type *PathError.\n\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped\nin *PathError.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Lchown(name, uid, gid)"}
  [^String name, ^Int uid, ^Int gid])

JOKER FUNC os.Link has:
(defn ^Error Link
  "Link creates newname as a hard link to the oldname file.\nIf there is an error, it will be of type *LinkError.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Link(oldname, newname)"}
  [^String oldname, ^String newname])

JOKER FUNC os.LookupEnv has:
(defn LookupEnv
  "LookupEnv retrieves the value of the environment variable named\nby the key. If the variable is present in the environment the\nvalue (which may be empty) is returned and the boolean is true.\nOtherwise the returned value will be empty and the boolean will\nbe false.\n\nGo return type: (string, bool)\n\nJoker return type: [String Bool]"
  {:added "1.0"
   :go "lookupEnv(key)"}
  [^String key])

JOKER FUNC os.Lstat has:
;; (defn Lstat
;;   "Lstat returns a FileInfo describing the named file.\nIf the file is a symbolic link, the returned FileInfo\ndescribes the symbolic link. Lstat makes no attempt to follow the link.\nIf there is an error, it will be of type *PathError.\n\nGo return type: (FileInfo, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/os/types.go:21:15) Error]"
;;   {:added "1.0"
;;    :go "lstat(name)"}
;;   [^String name])

JOKER FUNC os.Mkdir has:
;; (defn ^Error Mkdir
;;   "Mkdir creates a new directory with the specified name and permission\nbits (before umask).\nIf there is an error, it will be of type *PathError.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.Mkdir(name, perm)"}
;;   [^String name, ^ABEND885(unrecognized type FileMode at: GO.link/src/os/file.go:215:30) perm])

JOKER FUNC os.MkdirAll has:
;; (defn ^Error MkdirAll
;;   "MkdirAll creates a directory named path,\nalong with any necessary parents, and returns nil,\nor else returns an error.\nThe permission bits perm (before umask) are used for all\ndirectories that MkdirAll creates.\nIf path is already a directory, MkdirAll does nothing\nand returns nil.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.MkdirAll(path, perm)"}
;;   [^String path, ^ABEND885(unrecognized type FileMode at: GO.link/src/os/path.go:19:33) perm])

JOKER FUNC os.NewFile has:
;; (defn NewFile
;;   "NewFile returns a new File with the given file descriptor and\nname. The returned value will be nil if fd is not a valid file\ndescriptor. On Unix systems, if the file descriptor is in\nnon-blocking mode, NewFile will attempt to return a pollable File\n(one for which the SetDeadline methods work).\n\nGo return type: *File\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newFile(fd, name)"}
;;   [^ABEND885(unrecognized type uintptr at: GO.link/src/os/file_unix.go:81:17) fd, ^String name])

JOKER FUNC os.NewSyscallError has:
;; (defn ^Error NewSyscallError
;;   "NewSyscallError returns, as an error, a new SyscallError\nwith the given system call name and error details.\nAs a convenience, if err is nil, NewSyscallError returns nil.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.NewSyscallError(syscall, err)"}
;;   [^String syscall, ^ABEND885(unrecognized type error at: GO.link/src/os/error.go:58:42) err])

JOKER FUNC os.Open has:
(defn Open
  "Open opens the named file for reading. If successful, methods on\nthe returned file can be used for reading; the associated file\ndescriptor has mode O_RDONLY.\nIf there is an error, it will be of type *PathError.\n\nGo return type: (*File, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "open(name)"}
  [^String name])

JOKER FUNC os.OpenFile has:
;; (defn OpenFile
;;   "OpenFile is the generalized open call; most users will use Open\nor Create instead. It opens the named file with specified flag\n(O_RDONLY etc.) and perm (before umask), if applicable. If successful,\nmethods on the returned File can be used for I/O.\nIf there is an error, it will be of type *PathError.\n\nGo return type: (*File, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "openFile(name, flag, perm)"}
;;   [^String name, ^Int flag, ^ABEND885(unrecognized type FileMode at: GO.link/src/os/file.go:282:43) perm])

JOKER FUNC os.Pipe has:
(defn Pipe
  "Pipe returns a connected pair of Files; reads from r return bytes written to w.\nIt returns the files and an error, if any.\n\nGo return type: (r *File, w *File, err error)\n\nJoker return type: [{} {} Error]"
  {:added "1.0"
   :go "pipe()"}
  [])

JOKER FUNC os.Readlink has:
(defn Readlink
  "Readlink returns the destination of the named symbolic link.\nIf there is an error, it will be of type *PathError.\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "readlink(name)"}
  [^String name])

JOKER FUNC os.Remove has:
(defn ^Error Remove
  "Remove removes the named file or (empty) directory.\nIf there is an error, it will be of type *PathError.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Remove(name)"}
  [^String name])

JOKER FUNC os.RemoveAll has:
(defn ^Error RemoveAll
  "RemoveAll removes path and any children it contains.\nIt removes everything it can but returns the first error\nit encounters. If the path does not exist, RemoveAll\nreturns nil (no error).\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.RemoveAll(path)"}
  [^String path])

JOKER FUNC os.Rename has:
(defn ^Error Rename
  "Rename renames (moves) oldpath to newpath.\nIf newpath already exists and is not a directory, Rename replaces it.\nOS-specific restrictions may apply when oldpath and newpath are in different directories.\nIf there is an error, it will be of type *LinkError.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Rename(oldpath, newpath)"}
  [^String oldpath, ^String newpath])

JOKER FUNC os.SameFile has:
;; (defn ^Bool SameFile
;;   "SameFile reports whether fi1 and fi2 describe the same file.\nFor example, on Unix this means that the device and inode fields\nof the two underlying structures are identical; on other systems\nthe decision may be based on the path names.\nSameFile only applies to results returned by this package's Stat.\nIt returns false in other cases.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.SameFile(fi1, fi2)"}
;;   [^ABEND885(unrecognized type FileInfo at: GO.link/src/os/types.go:117:24) fi1, ^ABEND885(unrecognized type FileInfo at: GO.link/src/os/types.go:117:24) fi2])

JOKER FUNC os.Setenv has:
(defn ^Error Setenv
  "Setenv sets the value of the environment variable named by the key.\nIt returns an error, if any.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Setenv(key, value)"}
  [^String key, ^String value])

JOKER FUNC os.StartProcess has:
;; (defn StartProcess
;;   "StartProcess starts a new process with the program, arguments and attributes\nspecified by name, argv and attr. The argv slice will become os.Args in the\nnew process, so it normally starts with the program name.\n\nIf the calling goroutine has locked the operating system thread\nwith runtime.LockOSThread and modified any inheritable OS-level\nthread state (for example, Linux or Plan 9 name spaces), the new\nprocess will inherit the caller's thread state.\n\nStartProcess is a low-level interface. The os/exec package provides\nhigher-level interfaces.\n\nIf there is an error, it will be of type *PathError.\n\nGo return type: (*Process, error)\n\nJoker return type: [{:Pid ^Int} Error]"
;;   {:added "1.0"
;;    :go "startProcess(name, argv, attr)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/os/exec.go:100:37) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/os/exec.go:100:52) attr])

JOKER FUNC os.Stat has:
;; (defn Stat
;;   "Stat returns a FileInfo describing the named file.\nIf there is an error, it will be of type *PathError.\n\nGo return type: (FileInfo, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/os/types.go:21:15) Error]"
;;   {:added "1.0"
;;    :go "stat(name)"}
;;   [^String name])

JOKER FUNC os.Symlink has:
(defn ^Error Symlink
  "Symlink creates newname as a symbolic link to oldname.\nIf there is an error, it will be of type *LinkError.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Symlink(oldname, newname)"}
  [^String oldname, ^String newname])

JOKER FUNC os.TempDir has:
(defn ^String TempDir
  "TempDir returns the default directory to use for temporary files.\n\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp.\nOn Windows, it uses GetTempPath, returning the first non-empty\nvalue from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.\nOn Plan 9, it returns /tmp.\n\nThe directory is neither guaranteed to exist nor have accessible\npermissions.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "os.TempDir()"}
  [])

JOKER FUNC os.Truncate has:
(defn ^Error Truncate
  "Truncate changes the size of the named file.\nIf the file is a symbolic link, it changes the size of the link's target.\nIf there is an error, it will be of type *PathError.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Truncate(name, size)"}
  [^String name, ^Int size])

JOKER FUNC os.Unsetenv has:
(defn ^Error Unsetenv
  "Unsetenv unsets a single environment variable.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Unsetenv(key)"}
  [^String key])

JOKER FUNC os.UserCacheDir has:
(defn UserCacheDir
  "UserCacheDir returns the default root directory to use for user-specific\ncached data. Users should create their own application-specific subdirectory\nwithin this one and use that.\n\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by\nhttps://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html if\nnon-empty, else $HOME/.cache.\nOn Darwin, it returns $HOME/Library/Caches.\nOn Windows, it returns %LocalAppData%.\nOn Plan 9, it returns $home/lib/cache.\n\nIf the location cannot be determined (for example, $HOME is not defined),\nthen it will return an error.\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "userCacheDir()"}
  [])

JOKER FUNC parse.IsEmptyTree has:
;; (defn ^Bool IsEmptyTree
;;   "IsEmptyTree reports whether this tree (node) is empty of everything but space.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "parse.IsEmptyTree(n)"}
;;   [^ABEND885(unrecognized type Node at: GO.link/src/text/template/parse/parse.go:252:20) n])

JOKER FUNC parse.New has:
;; (defn New
;;   "New allocates a new parse tree with the given name.\n\nGo return type: *Tree\n\nJoker return type: {:Name ^String, :ParseName ^String, :Root ^{:Nodes ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/text/template/parse/node.go:21:11))}}"
;;   {:added "1.0"
;;    :go "new(name, funcs)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/text/template/parse/parse.go:125:29) funcs])

JOKER FUNC parse.NewIdentifier has:
(defn NewIdentifier
  "NewIdentifier returns a new IdentifierNode with the given identifier name.\n\nGo return type: *IdentifierNode\n\nJoker return type: {:Ident ^String}"
  {:added "1.0"
   :go "newIdentifier(ident)"}
  [^String ident])

JOKER FUNC parse.Parse has:
;; (defn Parse
;;   "Parse returns a map from template name to parse.Tree, created by parsing the\ntemplates described in the argument string. The top-level template will be\ngiven the specified name. If an error is encountered, parsing stops and an\nempty map is returned with the error.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/text/template/parse/parse.go:51:88) Error]"
;;   {:added "1.0"
;;    :go "parse(name, text, leftDelim, rightDelim, funcs)"}
;;   [^String name, ^String text, ^String leftDelim, ^String rightDelim, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/text/template/parse/parse.go:51:60) funcs])

JOKER FUNC parser.ParseDir has:
;; (defn ParseDir
;;   "ParseDir calls ParseFile for all files with names ending in \".go\" in the\ndirectory specified by path and returns a map of package name -> package\nAST with all the packages found.\n\nIf filter != nil, only the files with os.FileInfo entries passing through\nthe filter (and ending in \".go\") are considered. The mode bits are passed\nto ParseFile unchanged. Position information is recorded in fset, which\nmust not be nil.\n\nIf the directory couldn't be read, a nil map and the respective error are\nreturned. If a parse error occurred, a non-nil but incomplete map and the\nfirst error encountered are returned.\n\nGo return type: (pkgs ..., first error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/parser/interface.go:135:97) Error]"
;;   {:added "1.0"
;;    :go "parseDir(fset, path, filter, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/parser/interface.go:135:20) fset, ^String path, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/go/parser/interface.go:135:56) filter, ^ABEND885(unrecognized type Mode at: GO.link/src/go/parser/interface.go:135:85) mode])

JOKER FUNC parser.ParseExpr has:
;; (defn ParseExpr
;;   "ParseExpr is a convenience function for obtaining the AST of an expression x.\nThe position information recorded in the AST is undefined. The filename used\nin error messages is the empty string.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/parser/interface.go:230:27) Error]"
;;   {:added "1.0"
;;    :go "parseExpr(x)"}
;;   [^String x])

JOKER FUNC parser.ParseExprFrom has:
;; (defn ParseExprFrom
;;   "ParseExprFrom is a convenience function for parsing an expression.\nThe arguments have the same meaning as for ParseFile, but the source must\nbe a valid Go (type or value) expression. Specifically, fset must not\nbe nil.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/parser/interface.go:176:87) Error]"
;;   {:added "1.0"
;;    :go "parseExprFrom(fset, filename, src, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/parser/interface.go:176:25) fset, ^String filename, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/parser/interface.go:176:62) src, ^ABEND885(unrecognized type Mode at: GO.link/src/go/parser/interface.go:176:80) mode])

JOKER FUNC parser.ParseFile has:
;; (defn ParseFile
;;   "ParseFile parses the source code of a single Go source file and returns\nthe corresponding ast.File node. The source code may be provided via\nthe filename of the source file, or via the src parameter.\n\nIf src != nil, ParseFile parses the source from src and the filename is\nonly used when recording position information. The type of the argument\nfor the src parameter must be string, []byte, or io.Reader.\nIf src == nil, ParseFile parses the file specified by filename.\n\nThe mode parameter controls the amount of source text parsed and other\noptional parser functionality. Position information is recorded in the\nfile set fset, which must not be nil.\n\nIf the source couldn't be read, the returned AST is nil and the error\nindicates the specific failure. If the source was read but syntax\nerrors were found, the result is a partial AST (with ast.Bad* nodes\nrepresenting the fragments of erroneous source code). Multiple errors\nare returned via a scanner.ErrorList which is sorted by file position.\n\nGo return type: (f *..., err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/parser/interface.go:80:86) Error]"
;;   {:added "1.0"
;;    :go "parseFile(fset, filename, src, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/parser/interface.go:80:21) fset, ^String filename, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/parser/interface.go:80:58) src, ^ABEND885(unrecognized type Mode at: GO.link/src/go/parser/interface.go:80:76) mode])

JOKER FUNC path.Base has:
(defn ^String Base
  "Base returns the last element of path.\nTrailing slashes are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of slashes, Base returns \"/\".\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Base(path)"}
  [^String path])

JOKER FUNC path.Clean has:
(defn ^String Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple slashes with a single slash.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path.\n\nThe returned path ends in a slash only if it is the root \"/\".\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Clean(path)"}
  [^String path])

JOKER FUNC path.Dir has:
(defn ^String Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element using Split, the path is Cleaned and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of slashes followed by non-slash bytes, Dir\nreturns a single slash. In any other case, the returned path does not end in a\nslash.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Dir(path)"}
  [^String path])

JOKER FUNC path.Ext has:
(defn ^String Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final slash-separated element of path;\nit is empty if there is no dot.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Ext(path)"}
  [^String path])

JOKER FUNC path.IsAbs has:
(defn ^Bool IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "path.IsAbs(path)"}
  [^String path])

JOKER FUNC path.Join has:
;; (defn ^String Join
;;   "Join joins any number of path elements into a single path, adding a\nseparating slash if necessary. The result is Cleaned; in particular,\nall empty strings are ignored.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "path.Join(elem)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/path/path.go:155:16) elem])

JOKER FUNC path.Match has:
(defn Match
  "Match reports whether name matches the shell pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-/ characters\n\t\t'?'         matches any single non-/ character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo return type: (matched bool, err error)\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "match(pattern, name)"}
  [^String pattern, ^String name])

JOKER FUNC path.Split has:
(defn Split
  "Split splits path immediately following the final slash,\nseparating it into a directory and file name component.\nIf there is no slash in path, Split returns an empty dir and\nfile set to path.\nThe returned values have the property that path = dir+file.\n\nGo return type: (dir string, file string)\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "split(path)"}
  [^String path])

JOKER FUNC pe.NewFile has:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a PE binary in an underlying reader.\n\nGo return type: (*File, error)\n\nJoker return type: [{:OptionalHeader ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/debug/pe/file.go:25:17), :Sections ^(vector-of {:Relocs ^(vector-of {:VirtualAddress ^Int, :SymbolTableIndex ^Int, :Type ^Int})}), :Symbols ^(vector-of {:Name ^String, :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND042(cannot find typename pe.uint8)}), :COFFSymbols ^(vector-of {:Name ^(vector-of ABEND042(cannot find typename pe.uint8)), :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND042(cannot find typename pe.uint8), :NumberOfAuxSymbols ^ABEND042(cannot find typename pe.uint8)}), :StringTable ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/pe/file.go:69:16) r])

JOKER FUNC pe.Open has:
;; (defn Open
;;   "Open opens the named file using os.Open and prepares it for use as a PE binary.\n\nGo return type: (*File, error)\n\nJoker return type: [{:OptionalHeader ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/debug/pe/file.go:25:17), :Sections ^(vector-of {:Relocs ^(vector-of {:VirtualAddress ^Int, :SymbolTableIndex ^Int, :Type ^Int})}), :Symbols ^(vector-of {:Name ^String, :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND042(cannot find typename pe.uint8)}), :COFFSymbols ^(vector-of {:Name ^(vector-of ABEND042(cannot find typename pe.uint8)), :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND042(cannot find typename pe.uint8), :NumberOfAuxSymbols ^ABEND042(cannot find typename pe.uint8)}), :StringTable ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC pem.Decode has:
;; (defn Decode
;;   "Decode will find the next PEM formatted block (certificate, private key\netc) in the input. It returns that block and the remainder of the input. If\nno PEM data is found, p is nil and the whole of the input is returned in\nrest.\n\nGo return type: (p *Block, rest []int)\n\nJoker return type: [{:Type ^String, :Headers ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/encoding/pem/pem.go:29:10), :Bytes ^(vector-of Int)} (vector-of Int)]"
;;   {:added "1.0"
;;    :go "decode(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/pem/pem.go:78:18) data])

JOKER FUNC pem.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the PEM encoding of b to out.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pem.Encode(out, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/pem/pem.go:256:17) out, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/pem/pem.go:256:30) b])

JOKER FUNC pem.EncodeToMemory has:
;; (defn EncodeToMemory
;;   "EncodeToMemory returns the PEM encoding of b.\n\nIf b has invalid headers and cannot be encoded,\nEncodeToMemory returns nil. If it is important to\nreport details about this error case, use Encode instead.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "encodeToMemory(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/pem/pem.go:326:23) b])

JOKER FUNC plan9obj.NewFile has:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Plan 9 binary in an underlying reader.\nThe Plan 9 binary is expected to start at position 0 in the ReaderAt.\n\nGo return type: (*File, error)\n\nJoker return type: [{:Sections ^(vector-of {})} Error]"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/plan9obj/file.go:135:16) r])

JOKER FUNC plan9obj.Open has:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.\n\nGo return type: (*File, error)\n\nJoker return type: [{:Sections ^(vector-of {})} Error]"
  {:added "1.0"
   :go "open(name)"}
  [^String name])

JOKER FUNC plugin.Open has:
(defn Open
  "Open opens a Go plugin.\nIf a path has already been opened, then the existing *Plugin is returned.\nIt is safe for concurrent use by multiple goroutines.\n\nGo return type: (*Plugin, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "open(path)"}
  [^String path])

JOKER FUNC png.Decode has:
;; (defn Decode
;;   "Decode reads a PNG image from r and returns it as an image.Image.\nThe type of Image returned depends on the PNG contents.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/png/reader.go:952:27) Error]"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/png/reader.go:952:15) r])

JOKER FUNC png.DecodeConfig has:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a PNG image without\ndecoding the entire image.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/png/reader.go:976:33) Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/png/reader.go:976:21) r])

JOKER FUNC png.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in PNG format. Any Image may be\nencoded, but images that are not image.NRGBA might be encoded lossily.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "png.Encode(w, m)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/png/writer.go:523:15) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/png/writer.go:523:28) m])

JOKER FUNC pprof.Cmdline has:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n"
;;   {:added "1.0"
;;    :go "cmdline(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:83:16) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/pprof/pprof.go:83:39) r])

JOKER FUNC pprof.Handler has:
;; (defn Handler
;;   "Handler returns an HTTP handler that serves the named profile.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:221:27)"
;;   {:added "1.0"
;;    :go "handler(name)"}
;;   [^String name])

JOKER FUNC pprof.Index has:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n"
;;   {:added "1.0"
;;    :go "index(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:264:14) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/pprof/pprof.go:264:37) r])

JOKER FUNC pprof.Profile has:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n"
;;   {:added "1.0"
;;    :go "profile(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:116:16) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/pprof/pprof.go:116:39) r])

JOKER FUNC pprof.Symbol has:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n"
;;   {:added "1.0"
;;    :go "symbol(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:174:15) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/pprof/pprof.go:174:38) r])

JOKER FUNC pprof.Trace has:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n"
;;   {:added "1.0"
;;    :go "trace(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:145:14) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/pprof/pprof.go:145:37) r])

JOKER FUNC pprof.Do has:
;; (defn Do
;;   "Do calls f with a copy of the parent context with the\ngiven labels added to the parent's label map.\nEach key/value pair in labels is inserted into the label map in the\norder provided, overriding any previous value for the same key.\nThe augmented label map will be set for the duration of the call to f\nand restored once f returns.\n"
;;   {:added "1.0"
;;    :go "do(ctx, labels, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/runtime.go:31:13) ctx, ^ABEND885(unrecognized type LabelSet at: GO.link/src/runtime/pprof/runtime.go:31:37) labels, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/runtime/pprof/runtime.go:31:49) f])

JOKER FUNC pprof.ForLabels has:
;; (defn ForLabels
;;   "ForLabels invokes f with each label set on the context.\nThe function f should return true to continue iteration or false to stop iteration early.\n"
;;   {:added "1.0"
;;    :go "forLabels(ctx, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/label.go:78:20) ctx, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/runtime/pprof/label.go:78:39) f])

JOKER FUNC pprof.Label has:
;; (defn Label
;;   "Label returns the value of the label with the given key on ctx, and a boolean indicating\nwhether that label exists.\n\nGo return type: (string, bool)\n\nJoker return type: [String Bool]"
;;   {:added "1.0"
;;    :go "label(ctx, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/label.go:70:16) ctx, ^String key])

JOKER FUNC pprof.Labels has:
;; (defn Labels
;;   "Labels takes an even number of strings representing key-value pairs\nand makes a LabelSet containing them.\nA label overwrites a prior label with the same key.\n\nGo return type: LabelSet\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "labels(args)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/runtime/pprof/label.go:57:18) args])

JOKER FUNC pprof.Lookup has:
;; (defn Lookup
;;   "Lookup returns the profile with the given name, or nil if no such profile exists.\n\nGo return type: *Profile\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "lookup(name)"}
;;   [^String name])

JOKER FUNC pprof.NewProfile has:
;; (defn NewProfile
;;   "NewProfile creates a new profile with the given name.\nIf a profile with that name already exists, NewProfile panics.\nThe convention is to use a 'import/path.' prefix to create\nseparate name spaces for each package.\nFor compatibility with various tools that read pprof data,\nprofile names should not contain spaces.\n\nGo return type: *Profile\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newProfile(name)"}
;;   [^String name])

JOKER FUNC pprof.Profiles has:
(defn Profiles
  "Profiles returns a slice of all the known profiles, sorted by name.\n\nGo return type: []*Profile\n\nJoker return type: (vector-of {})"
  {:added "1.0"
   :go "profiles()"}
  [])

JOKER FUNC pprof.SetGoroutineLabels has:
;; (defn SetGoroutineLabels
;;   "SetGoroutineLabels sets the current goroutine's labels to match ctx.\nThis is a lower-level API than Do, which should be used instead when possible.\n"
;;   {:added "1.0"
;;    :go "setGoroutineLabels(ctx)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/runtime.go:20:29) ctx])

JOKER FUNC pprof.StartCPUProfile has:
;; (defn ^Error StartCPUProfile
;;   "StartCPUProfile enables CPU profiling for the current process.\nWhile profiling, the profile will be buffered and written to w.\nStartCPUProfile returns an error if profiling is already enabled.\n\nOn Unix-like systems, StartCPUProfile does not work by default for\nGo code built with -buildmode=c-archive or -buildmode=c-shared.\nStartCPUProfile relies on the SIGPROF signal, but that signal will\nbe delivered to the main program's SIGPROF signal handler (if any)\nnot to the one used by Go. To make it work, call os/signal.Notify\nfor syscall.SIGPROF, but note that doing so may break any profiling\nbeing done by the main program.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.StartCPUProfile(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/pprof.go:740:24) w])

JOKER FUNC pprof.StopCPUProfile has:
;; (defn StopCPUProfile
;;   "StopCPUProfile stops the current CPU profile, if any.\nStopCPUProfile only returns after all the writes for the\nprofile have completed.\n"
;;   {:added "1.0"
;;    :go "stopCPUProfile()"}
;;   [])

JOKER FUNC pprof.WithLabels has:
;; (defn WithLabels
;;   "WithLabels returns a new context.Context with the given labels added.\nA label overwrites a prior label with the same key.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/label.go:39:55)"
;;   {:added "1.0"
;;    :go "withLabels(ctx, labels)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/label.go:39:21) ctx, ^ABEND885(unrecognized type LabelSet at: GO.link/src/runtime/pprof/label.go:39:45) labels])

JOKER FUNC pprof.WriteHeapProfile has:
;; (defn ^Error WriteHeapProfile
;;   "WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0).\nIt is preserved for backwards compatibility.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.WriteHeapProfile(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/pprof.go:520:25) w])

JOKER FUNC printer.Fprint has:
;; (defn ^Error Fprint
;;   "Fprint \"pretty-prints\" an AST node to output.\nIt calls Config.Fprint with default settings.\nNote that gofmt uses tabs for indentation but spaces for alignment;\nuse format.Node (package go/format) for output that matches gofmt.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "printer.Fprint(output, fset, node)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/printer/printer.go:1359:20) output, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/printer/printer.go:1359:36) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/printer/printer.go:1359:57) node])

JOKER FUNC quick.Check has:
;; (defn ^Error Check
;;   "Check looks for an input to f, any function that returns bool,\nsuch that f returns false. It calls f repeatedly, with arbitrary\nvalues for each argument. If f returns false on a given input,\nCheck returns that input as a *CheckError.\nFor example:\n\n\tfunc TestOddMultipleOfThree(t *testing.T) {\n\t\tf := func(x int) bool {\n\t\t\ty := OddMultipleOfThree(x)\n\t\t\treturn y%2 == 1 && y%3 == 0\n\t\t}\n\t\tif err := quick.Check(f, nil); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.Check(f, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/testing/quick/quick.go:262:14) f, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/testing/quick/quick.go:262:34) config])

JOKER FUNC quick.CheckEqual has:
;; (defn ^Error CheckEqual
;;   "CheckEqual looks for an input on which f and g return different results.\nIt calls f and g repeatedly with arbitrary values for each argument.\nIf f and g return different answers, CheckEqual returns a *CheckEqualError\ndescribing the input and the outputs.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.CheckEqual(f, g, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/testing/quick/quick.go:301:22) f, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/testing/quick/quick.go:301:22) g, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/testing/quick/quick.go:301:42) config])

JOKER FUNC quick.Value has:
;; (defn Value
;;   "Value returns an arbitrary value of the given type.\nIf the type implements the Generator interface, that will be used.\nNote: To create arbitrary values for structs, all the fields must be exported.\n\nGo return type: (value ..., ok bool)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/quick/quick.go:59:52) Bool]"
;;   {:added "1.0"
;;    :go "value(t, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/quick/quick.go:59:14) t, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/testing/quick/quick.go:59:33) rand])

JOKER FUNC quotedprintable.NewReader has:
;; (defn NewReader
;;   "NewReader returns a quoted-printable reader, decoding from r.\n\nGo return type: *Reader\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/mime/quotedprintable/reader.go:24:18) r])

JOKER FUNC quotedprintable.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo return type: *Writer\n\nJoker return type: {:Binary ^Bool}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/mime/quotedprintable/writer.go:24:18) w])

JOKER FUNC rand.ExpFloat64 has:
;; (defn ExpFloat64
;;   "ExpFloat64 returns an exponentially distributed float64 in the range\n(0, +math.MaxFloat64] with an exponential distribution whose rate parameter\n(lambda) is 1 and whose mean is 1/lambda (1) from the default Source.\nTo produce a distribution with a different rate parameter,\ncallers can adjust the output using:\n\n sample = ExpFloat64() / desiredRateParameter\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename rand.float64)"
;;   {:added "1.0"
;;    :go "expFloat64()"}
;;   [])

JOKER FUNC rand.Float32 has:
;; (defn Float32
;;   "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: float32\n\nJoker return type: ABEND042(cannot find typename rand.float32)"
;;   {:added "1.0"
;;    :go "float32()"}
;;   [])

JOKER FUNC rand.Float64 has:
;; (defn Float64
;;   "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename rand.float64)"
;;   {:added "1.0"
;;    :go "float64()"}
;;   [])

JOKER FUNC rand.Int has:
(defn ^Int Int
  "Int returns a non-negative pseudo-random int from the default Source.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Int()"}
  [])

JOKER FUNC rand.Int31 has:
(defn ^Int Int31
  "Int31 returns a non-negative pseudo-random 31-bit integer as an int32\nfrom the default Source.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Int31()"}
  [])

JOKER FUNC rand.Int31n has:
(defn ^Int Int31n
  "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Int31n(n)"}
  [^Int n])

JOKER FUNC rand.Int63 has:
(defn ^Int Int63
  "Int63 returns a non-negative pseudo-random 63-bit integer as an int64\nfrom the default Source.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Int63()"}
  [])

JOKER FUNC rand.Int63n has:
(defn ^Int Int63n
  "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Int63n(n)"}
  [^Int n])

JOKER FUNC rand.Intn has:
(defn ^Int Intn
  "Intn returns, as an int, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Intn(n)"}
  [^Int n])

JOKER FUNC rand.New has:
;; (defn New
;;   "New returns a new Rand that uses random values from src\nto generate other random values.\n\nGo return type: *Rand\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "new(src)"}
;;   [^ABEND885(unrecognized type Source at: GO.link/src/math/rand/rand.go:67:14) src])

JOKER FUNC rand.NewSource has:
;; (defn NewSource
;;   "NewSource returns a new pseudo-random Source seeded with the given value.\nUnlike the default Source used by top-level functions, this source is not\nsafe for concurrent use by multiple goroutines.\n\nGo return type: Source\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/math/rand/rand.go:25:13)"
;;   {:added "1.0"
;;    :go "newSource(seed)"}
;;   [^Int seed])

JOKER FUNC rand.NewZipf has:
;; (defn NewZipf
;;   "NewZipf returns a Zipf variate generator.\nThe generator generates values k ∈ [0, imax]\nsuch that P(k) is proportional to (v + k) ** (-s).\nRequirements: s > 1 and v >= 1.\n\nGo return type: *Zipf\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newZipf(r, s, v, imax)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/math/rand/zipf.go:39:16) r, ^ABEND885(unrecognized type float64 at: GO.link/src/math/rand/zipf.go:39:25) s, ^ABEND885(unrecognized type float64 at: GO.link/src/math/rand/zipf.go:39:36) v, ^ABEND885(unrecognized type uint64 at: GO.link/src/math/rand/zipf.go:39:50) imax])

JOKER FUNC rand.NormFloat64 has:
;; (defn NormFloat64
;;   "NormFloat64 returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with\nstandard normal distribution (mean = 0, stddev = 1)\nfrom the default Source.\nTo produce a different normal distribution, callers can\nadjust the output using:\n\n sample = NormFloat64() * desiredStdDev + desiredMean\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename rand.float64)"
;;   {:added "1.0"
;;    :go "normFloat64()"}
;;   [])

JOKER FUNC rand.Perm has:
(defn Perm
  "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n)\nfrom the default Source.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "perm(n)"}
  [^Int n])

JOKER FUNC rand.Read has:
;; (defn Read
;;   "Read generates len(p) random bytes from the default Source and\nwrites them into p. It always returns len(p) and a nil error.\nRead, unlike the Rand.Read method, is safe for concurrent use.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "read(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/math/rand/rand.go:351:13) p])

JOKER FUNC rand.Seed has:
;; (defn Seed
;;   "Seed uses the provided seed value to initialize the default Source to a\ndeterministic state. If Seed is not called, the generator behaves as\nif seeded by Seed(1). Seed values that have the same remainder when\ndivided by 2^31-1 generate the same pseudo-random sequence.\nSeed, unlike the Rand.Seed method, is safe for concurrent use.\n"
;;   {:added "1.0"
;;    :go "seed(seed)"}
;;   [^Int seed])

JOKER FUNC rand.Shuffle has:
;; (defn Shuffle
;;   "Shuffle pseudo-randomizes the order of elements using the default Source.\nn is the number of elements. Shuffle panics if n < 0.\nswap swaps the elements with indexes i and j.\n"
;;   {:added "1.0"
;;    :go "shuffle(n, swap)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/math/rand/rand.go:346:26) swap])

JOKER FUNC rand.Uint32 has:
(defn ^Int Uint32
  "Uint32 returns a pseudo-random 32-bit value as a uint32\nfrom the default Source.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Uint32()"}
  [])

JOKER FUNC rand.Uint64 has:
;; (defn Uint64
;;   "Uint64 returns a pseudo-random 64-bit value as a uint64\nfrom the default Source.\n\nGo return type: uint64\n\nJoker return type: ABEND042(cannot find typename rand.uint64)"
;;   {:added "1.0"
;;    :go "uint64()"}
;;   [])

JOKER FUNC rand.Int has:
;; (defn Int
;;   "Int returns a uniform random value in [0, max). It panics if max <= 0.\n\nGo return type: (n *..., err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rand/util.go:106:44) Error]"
;;   {:added "1.0"
;;    :go "int(rand, max)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rand/util.go:106:15) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rand/util.go:106:30) max])

JOKER FUNC rand.Prime has:
;; (defn Prime
;;   "Prime returns a number, p, of the given size, such that p is prime\nwith high probability.\nPrime will return error for any error returned by rand.Read or if bits < 2.\n\nGo return type: (p *..., err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rand/util.go:31:42) Error]"
;;   {:added "1.0"
;;    :go "prime(rand, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rand/util.go:31:17) rand, ^Int bits])

JOKER FUNC rand.Read has:
;; (defn Read
;;   "Read is a helper function that calls Reader.Read using io.ReadFull.\nOn return, n == len(b) if and only if err == nil.\n\nGo return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "read(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rand/rand.go:23:13) b])

JOKER FUNC rc4.NewCipher has:
;; (defn NewCipher
;;   "NewCipher creates and returns a new Cipher. The key argument should be the\nRC4 key, at least 1 byte and at most 256 bytes.\n\nGo return type: (*Cipher, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rc4/rc4.go:31:20) key])

JOKER FUNC reflect.Append has:
;; (defn Append
;;   "Append appends the values x to a slice s and returns the resulting slice.\nAs in Go, each x's value must be assignable to the slice's element type.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "append(s, x)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/reflect/value.go:1890:15) s, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/reflect/value.go:1890:24) x])

JOKER FUNC reflect.AppendSlice has:
;; (defn AppendSlice
;;   "AppendSlice appends a slice t to a slice s and returns the resulting slice.\nThe slices s and t must have the same element type.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "appendSlice(s, t)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/reflect/value.go:1901:23) s, ^ABEND885(unrecognized type Value at: GO.link/src/reflect/value.go:1901:23) t])

JOKER FUNC reflect.ArrayOf has:
;; (defn ArrayOf
;;   "ArrayOf returns the array type with the given count and element type.\nFor example, if t represents int, ArrayOf(5, t) represents [5]int.\n\nIf the resulting type would be larger than the available address space,\nArrayOf panics.\n\nGo return type: Type\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "arrayOf(count, elem)"}
;;   [^Int count, ^ABEND885(unrecognized type Type at: GO.link/src/reflect/type.go:2836:30) elem])

JOKER FUNC reflect.ChanOf has:
;; (defn ChanOf
;;   "ChanOf returns the channel type with the given direction and element type.\nFor example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.\n\nThe gc runtime imposes a limit of 64 kB on channel element types.\nIf t's size is equal to or exceeds this limit, ChanOf panics.\n\nGo return type: Type\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "chanOf(dir, t)"}
;;   [^ABEND885(unrecognized type ChanDir at: GO.link/src/reflect/type.go:1779:17) dir, ^ABEND885(unrecognized type Type at: GO.link/src/reflect/type.go:1779:28) t])

JOKER FUNC reflect.Copy has:
;; (defn ^Int Copy
;;   "Copy copies the contents of src into dst until either\ndst has been filled or src has been exhausted.\nIt returns the number of elements copied.\nDst and src each must have kind Slice or Array, and\ndst and src must have the same element type.\n\nAs a special case, src can have kind String if the element type of dst is kind Uint8.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "reflect.Copy(dst, src)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/reflect/value.go:1917:20) dst, ^ABEND885(unrecognized type Value at: GO.link/src/reflect/value.go:1917:20) src])

JOKER FUNC reflect.DeepEqual has:
;; (defn ^Bool DeepEqual
;;   "DeepEqual reports whether x and y are ``deeply equal,'' defined as follows.\nTwo values of identical type are deeply equal if one of the following cases applies.\nValues of distinct types are never deeply equal.\n\nArray values are deeply equal when their corresponding elements are deeply equal.\n\nStruct values are deeply equal if their corresponding fields,\nboth exported and unexported, are deeply equal.\n\nFunc values are deeply equal if both are nil; otherwise they are not deeply equal.\n\nInterface values are deeply equal if they hold deeply equal concrete values.\n\nMap values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they are the same map object or their corresponding keys\n(matched using Go equality) map to deeply equal values.\n\nPointer values are deeply equal if they are equal using Go's == operator\nor if they point to deeply equal values.\n\nSlice values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they point to the same initial entry of the same underlying array\n(that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.\nNote that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))\nare not deeply equal.\n\nOther values - numbers, bools, strings, and channels - are deeply equal\nif they are equal using Go's == operator.\n\nIn general DeepEqual is a recursive relaxation of Go's == operator.\nHowever, this idea is impossible to implement without some inconsistency.\nSpecifically, it is possible for a value to be unequal to itself,\neither because it is of func type (uncomparable in general)\nor because it is a floating-point NaN value (not equal to itself in floating-point comparison),\nor because it is an array, struct, or interface containing\nsuch a value.\nOn the other hand, pointer values are always equal to themselves,\neven if they point at or contain such problematic values,\nbecause they compare equal using Go's == operator, and that\nis a sufficient condition to be deeply equal, regardless of content.\nDeepEqual has been defined so that the same short-cut applies\nto slices and maps: if x and y are the same slice or the same map,\nthey are deeply equal regardless of content.\n\nAs DeepEqual traverses the data values it may find a cycle. The\nsecond and subsequent times that DeepEqual compares two pointer\nvalues that have been compared before, it treats the values as\nequal rather than examining the values to which they point.\nThis ensures that DeepEqual terminates.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "reflect.DeepEqual(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/deepequal.go:187:21) x, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/deepequal.go:187:21) y])

JOKER FUNC reflect.FuncOf has:
;; (defn FuncOf
;;   "FuncOf returns the function type with the given argument and result types.\nFor example if k represents int and e represents string,\nFuncOf([]Type{k}, []Type{e}, false) represents func(int) string.\n\nThe variadic argument controls whether the function is variadic. FuncOf\npanics if the in[len(in)-1] does not represent a slice and variadic is\ntrue.\n\nGo return type: Type\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "funcOf(in, out, variadic)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/reflect/type.go:1924:21) in, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/reflect/type.go:1924:21) out, ^Bool variadic])

JOKER FUNC reflect.Indirect has:
;; (defn Indirect
;;   "Indirect returns the value that v points to.\nIf v is a nil pointer, Indirect returns a zero Value.\nIf v is not a pointer, Indirect returns v.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "indirect(v)"}
;;   [^ABEND885(unrecognized type Value at: GO.link/src/reflect/value.go:2173:17) v])

JOKER FUNC reflect.MakeChan has:
;; (defn MakeChan
;;   "MakeChan creates a new channel with the specified type and buffer size.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "makeChan(typ, buffer)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/value.go:2139:19) typ, ^Int buffer])

JOKER FUNC reflect.MakeFunc has:
;; (defn MakeFunc
;;   "MakeFunc returns a new function of the given Type\nthat wraps the function fn. When called, that new function\ndoes the following:\n\n\t- converts its arguments to a slice of Values.\n\t- runs results := fn(args).\n\t- returns the results as a slice of Values, one per formal result.\n\nThe implementation fn can assume that the argument Value slice\nhas the number and type of arguments given by typ.\nIf typ describes a variadic function, the final Value is itself\na slice representing the variadic arguments, as in the\nbody of a variadic function. The result Value slice returned by fn\nmust have the number and type of results given by typ.\n\nThe Value.Call method allows the caller to invoke a typed function\nin terms of Values; in contrast, MakeFunc allows the caller to implement\na typed function in terms of Values.\n\nThe Examples section of the documentation includes an illustration\nof how to use MakeFunc to build a swap function for different types.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "makeFunc(typ, fn)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/makefunc.go:48:19) typ, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/reflect/makefunc.go:48:28) fn])

JOKER FUNC reflect.MakeMap has:
;; (defn MakeMap
;;   "MakeMap creates a new map with the specified type.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "makeMap(typ)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/value.go:2155:18) typ])

JOKER FUNC reflect.MakeMapWithSize has:
;; (defn MakeMapWithSize
;;   "MakeMapWithSize creates a new map with the specified type\nand initial space for approximately n elements.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "makeMapWithSize(typ, n)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/value.go:2161:26) typ, ^Int n])

JOKER FUNC reflect.MakeSlice has:
;; (defn MakeSlice
;;   "MakeSlice creates a new zero-initialized slice value\nfor the specified slice type, length, and capacity.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "makeSlice(typ, len, cap)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/value.go:2120:20) typ, ^Int len, ^Int cap])

JOKER FUNC reflect.MapOf has:
;; (defn MapOf
;;   "MapOf returns the map type with the given key and element types.\nFor example, if k represents int and e represents string,\nMapOf(k, e) represents map[int]string.\n\nIf the key type is not a valid map key type (that is, if it does\nnot implement Go's == operator), MapOf panics.\n\nGo return type: Type\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "mapOf(key, elem)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/type.go:1836:22) key, ^ABEND885(unrecognized type Type at: GO.link/src/reflect/type.go:1836:22) elem])

JOKER FUNC reflect.New has:
;; (defn New
;;   "New returns a Value representing a pointer to a new zero value\nfor the specified type. That is, the returned Value's Type is PtrTo(typ).\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "new(typ)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/value.go:2215:14) typ])

JOKER FUNC reflect.NewAt has:
;; (defn NewAt
;;   "NewAt returns a Value representing a pointer to a value of the\nspecified type, using p as that pointer.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newAt(typ, p)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/value.go:2227:16) typ, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/reflect/value.go:2227:24) p])

JOKER FUNC reflect.PtrTo has:
;; (defn PtrTo
;;   "PtrTo returns the pointer type with element t.\nFor example, if t represents type Foo, PtrTo(t) represents *Foo.\n\nGo return type: Type\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "ptrTo(t)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/type.go:1386:14) t])

JOKER FUNC reflect.Select has:
;; (defn Select
;;   "Select executes a select operation described by the list of cases.\nLike the Go select statement, it blocks until at least one of the cases\ncan proceed, makes a uniform pseudo-random choice,\nand then executes that case. It returns the index of the chosen case\nand, if that case was a receive operation, the value received and a\nboolean indicating whether the value corresponds to a send on the channel\n(as opposed to a zero value received because the channel is closed).\n\nGo return type: (chosen int, recv Value, recvOK bool)\n\nJoker return type: [Int {} Bool]"
;;   {:added "1.0"
;;    :go "select(cases)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/reflect/value.go:2025:19) cases])

JOKER FUNC reflect.SliceOf has:
;; (defn SliceOf
;;   "SliceOf returns the slice type with element type t.\nFor example, if t represents int, SliceOf(t) represents []int.\n\nGo return type: Type\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "sliceOf(t)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/type.go:2232:16) t])

JOKER FUNC reflect.StructOf has:
;; (defn StructOf
;;   "StructOf returns the struct type containing fields.\nThe Offset and Index fields are ignored and computed as they would be\nby the compiler.\n\nStructOf currently does not generate wrapper methods for embedded\nfields and panics if passed unexported StructFields.\nThese limitations may be lifted in a future version.\n\nGo return type: Type\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "structOf(fields)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/reflect/type.go:2349:22) fields])

JOKER FUNC reflect.Swapper has:
;; (defn Swapper
;;   "Swapper returns a function that swaps the elements in the provided\nslice.\n\nSwapper panics if the provided interface is not a slice.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/reflect/swapper.go:13:33)"
;;   {:added "1.0"
;;    :go "swapper(slice)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/swapper.go:13:20) slice])

JOKER FUNC reflect.TypeOf has:
;; (defn TypeOf
;;   "TypeOf returns the reflection Type that represents the dynamic type of i.\nIf i is a nil interface value, TypeOf returns nil.\n\nGo return type: Type\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "typeOf(i)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:1376:15) i])

JOKER FUNC reflect.ValueOf has:
;; (defn ValueOf
;;   "ValueOf returns a new Value initialized to the concrete value\nstored in the interface i. ValueOf(nil) returns the zero Value.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "valueOf(i)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/value.go:2182:16) i])

JOKER FUNC reflect.Zero has:
;; (defn Zero
;;   "Zero returns a Value representing the zero value for the specified type.\nThe result is different from the zero value of the Value struct,\nwhich represents no value at all.\nFor example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.\nThe returned value is neither addressable nor settable.\n\nGo return type: Value\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "zero(typ)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/reflect/value.go:2201:15) typ])

JOKER FUNC regexp.Compile has:
(defn Compile
  "Compile parses a regular expression and returns, if successful,\na Regexp object that can be used to match against text.\n\nWhen matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses the one that a backtracking search would have found first.\nThis so-called leftmost-first matching is the same semantics\nthat Perl, Python, and other implementations use, although this\npackage implements it without the expense of backtracking.\nFor POSIX leftmost-longest matching, see CompilePOSIX.\n\nGo return type: (*Regexp, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "compile(expr)"}
  [^String expr])

JOKER FUNC regexp.CompilePOSIX has:
(defn CompilePOSIX
  "CompilePOSIX is like Compile but restricts the regular expression\nto POSIX ERE (egrep) syntax and changes the match semantics to\nleftmost-longest.\n\nThat is, when matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses a match that is as long as possible.\nThis so-called leftmost-longest matching is the same semantics\nthat early regular expression implementations used and that POSIX\nspecifies.\n\nHowever, there can be multiple leftmost-longest matches, with different\nsubmatch choices, and here this package diverges from POSIX.\nAmong the possible leftmost-longest matches, this package chooses\nthe one that a backtracking search would have found first, while POSIX\nspecifies that the match be chosen to maximize the length of the first\nsubexpression, then the second, and so on from left to right.\nThe POSIX rule is computationally prohibitive and not even well-defined.\nSee https://swtch.com/~rsc/regexp/regexp2.html#posix for details.\n\nGo return type: (*Regexp, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "compilePOSIX(expr)"}
  [^String expr])

JOKER FUNC regexp.Match has:
;; (defn Match
;;   "MatchString reports whether the byte slice b\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo return type: (matched bool, err error)\n\nJoker return type: [Bool Error]"
;;   {:added "1.0"
;;    :go "match(pattern, b)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/regexp/regexp.go:475:30) b])

JOKER FUNC regexp.MatchReader has:
;; (defn MatchReader
;;   "MatchReader reports whether the text returned by the RuneReader\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo return type: (matched bool, err error)\n\nJoker return type: [Bool Error]"
;;   {:added "1.0"
;;    :go "matchReader(pattern, r)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/regexp/regexp.go:453:36) r])

JOKER FUNC regexp.MatchString has:
(defn MatchString
  "MatchString reports whether the string s\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo return type: (matched bool, err error)\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "matchString(pattern, s)"}
  [^String pattern, ^String s])

JOKER FUNC regexp.MustCompile has:
;; (defn MustCompile
;;   "MustCompile is like Compile but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo return type: *Regexp\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "mustCompile(str)"}
;;   [^String str])

JOKER FUNC regexp.MustCompilePOSIX has:
;; (defn MustCompilePOSIX
;;   "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo return type: *Regexp\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "mustCompilePOSIX(str)"}
;;   [^String str])

JOKER FUNC regexp.QuoteMeta has:
(defn ^String QuoteMeta
  "QuoteMeta returns a string that escapes all regular expression metacharacters\ninside the argument text; the returned string is a regular expression matching\nthe literal text.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "regexp.QuoteMeta(s)"}
  [^String s])

JOKER FUNC ring.New has:
;; (defn New
;;   "New creates a ring of n elements.\n\nGo return type: *Ring\n\nJoker return type: {:Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/container/ring/ring.go:16:13)}"
;;   {:added "1.0"
;;    :go "new(n)"}
;;   [^Int n])

JOKER FUNC rpc.Accept has:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n"
;;   {:added "1.0"
;;    :go "accept(lis)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/server.go:692:17) lis])

JOKER FUNC rpc.Dial has:
(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo return type: (*Client, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dial(network, address)"}
  [^String network, ^String address])

JOKER FUNC rpc.DialHTTP has:
(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo return type: (*Client, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dialHTTP(network, address)"}
  [^String network, ^String address])

JOKER FUNC rpc.DialHTTPPath has:
(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo return type: (*Client, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dialHTTPPath(network, address, path)"}
  [^String network, ^String address, ^String path])

JOKER FUNC rpc.HandleHTTP has:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n"
;;   {:added "1.0"
;;    :go "handleHTTP()"}
;;   [])

JOKER FUNC rpc.NewClient has:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo return type: *Client\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/client.go:193:21) conn])

JOKER FUNC rpc.NewClientWithCodec has:
;; (defn NewClientWithCodec
;;   "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo return type: *Client\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newClientWithCodec(codec)"}
;;   [^ABEND885(unrecognized type ClientCodec at: GO.link/src/net/rpc/client.go:201:31) codec])

JOKER FUNC rpc.NewServer has:
;; (defn NewServer
;;   "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newServer()"}
;;   [])

JOKER FUNC rpc.Register has:
;; (defn ^Error Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(rcvr)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/rpc/server.go:642:20) rcvr])

JOKER FUNC rpc.RegisterName has:
;; (defn ^Error RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(name, rcvr)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/rpc/server.go:646:37) rcvr])

JOKER FUNC rpc.ServeCodec has:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n"
;;   {:added "1.0"
;;    :go "serveCodec(codec)"}
;;   [^ABEND885(unrecognized type ServerCodec at: GO.link/src/net/rpc/server.go:679:23) codec])

JOKER FUNC rpc.ServeConn has:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n"
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/server.go:673:21) conn])

JOKER FUNC rpc.ServeRequest has:
;; (defn ^Error ServeRequest
;;   "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.ServeRequest(codec)"}
;;   [^ABEND885(unrecognized type ServerCodec at: GO.link/src/net/rpc/server.go:685:25) codec])

JOKER FUNC rsa.DecryptOAEP has:
;; (defn DecryptOAEP
;;   "OAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter, if not nil, is used to blind the private-key operation\nand avoid timing side-channel attacks. Blinding is purely internal to this\nfunction – the random data need not match that used when encrypting.\n\nThe label parameter must match the value given when encrypting. See\nEncryptOAEP for details.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "decryptOAEP(hash, random, priv, ciphertext, label)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:569:23) hash, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:569:41) random, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/rsa.go:569:57) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/rsa.go:569:81) ciphertext, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/rsa.go:569:95) label])

JOKER FUNC rsa.DecryptPKCS1v15 has:
;; (defn DecryptPKCS1v15
;;   "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n\nNote that whether this function returns an error or not discloses secret\ninformation. If an attacker can cause this function to run repeatedly and\nlearn whether each instance returned an error then they can decrypt and\nforge signatures as if they had the private key. See\nDecryptPKCS1v15SessionKey for a way of solving this problem.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "decryptPKCS1v15(rand, priv, ciphertext)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:76:27) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:76:43) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pkcs1v15.go:76:67) ciphertext])

JOKER FUNC rsa.DecryptPKCS1v15SessionKey has:
;; (defn ^Error DecryptPKCS1v15SessionKey
;;   "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\nIt returns an error if the ciphertext is the wrong length or if the\nciphertext is greater than the public modulus. Otherwise, no error is\nreturned. If the padding is valid, the resulting plaintext message is copied\ninto key. Otherwise, key is unchanged. These alternatives occur in constant\ntime. It is intended that the user of this function generate a random\nsession key beforehand and continue the protocol with the resulting value.\nThis will remove any possibility that an attacker can learn any information\nabout the plaintext.\nSee ``Chosen Ciphertext Attacks Against Protocols Based on the RSA\nEncryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n(Crypto '98).\n\nNote that if the session key is too small then it may be possible for an\nattacker to brute-force it. If they can do that then they can learn whether\na random value was used (because it'll be different for the same ciphertext)\nand thus whether the padding was correct. This defeats the point of this\nfunction. Using at least a 16-byte key will protect against this attack.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.DecryptPKCS1v15SessionKey(rand, priv, ciphertext, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:109:37) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:109:53) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pkcs1v15.go:109:77) ciphertext, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pkcs1v15.go:109:89) key])

JOKER FUNC rsa.EncryptOAEP has:
;; (defn EncryptOAEP
;;   "EncryptOAEP encrypts the given message with RSA-OAEP.\n\nOAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same ciphertext.\n\nThe label parameter may contain arbitrary data that will not be encrypted,\nbut which gives important context to the message. For example, if a given\npublic key is used to decrypt two types of messages then distinct label\nvalues could be used to ensure that a ciphertext for one purpose cannot be\nused for another by an attacker. If not required it can be empty.\n\nThe message must be no longer than the length of the public modulus minus\ntwice the hash length, minus a further 2.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "encryptOAEP(hash, random, pub, msg, label)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:376:23) hash, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:376:41) random, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/rsa.go:376:56) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/rsa.go:376:72) msg, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/rsa.go:376:86) label])

JOKER FUNC rsa.EncryptPKCS1v15 has:
;; (defn EncryptPKCS1v15
;;   "EncryptPKCS1v15 encrypts the given message with RSA and the padding\nscheme from PKCS#1 v1.5.  The message must be no longer than the\nlength of the public modulus minus 11 bytes.\n\nThe rand parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same\nciphertext.\n\nWARNING: use of this function to encrypt plaintexts other than\nsession keys is dangerous. Use RSA OAEP in new protocols.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "encryptPKCS1v15(rand, pub, msg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:39:27) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:39:42) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pkcs1v15.go:39:58) msg])

JOKER FUNC rsa.GenerateKey has:
;; (defn GenerateKey
;;   "GenerateKey generates an RSA keypair of the given bit size using the\nrandom source random (for example, crypto/rand.Reader).\n\nGo return type: (*PrivateKey, error)\n\nJoker return type: [{:D ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:90:13), :Primes ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:91:15)), :Precomputed ^{:Dp ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:150:10), :Dq ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:150:10), :Qinv ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:151:10), :CRTValues ^(vector-of {:Exp ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:162:9), :Coeff ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:163:9), :R ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:164:9)})}} Error]"
;;   {:added "1.0"
;;    :go "generateKey(random, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:207:25) random, ^Int bits])

JOKER FUNC rsa.GenerateMultiPrimeKey has:
;; (defn GenerateMultiPrimeKey
;;   "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\nsize and the given random source, as suggested in [1]. Although the public\nkeys are compatible (actually, indistinguishable) from the 2-prime case,\nthe private keys are not. Thus it may not be possible to export multi-prime\nprivate keys in certain formats or to subsequently import them into other\ncode.\n\nTable 1 in [2] suggests maximum numbers of primes for a given size.\n\n[1] US patent 4405829 (1972, expired)\n[2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n\nGo return type: (*PrivateKey, error)\n\nJoker return type: [{:D ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:90:13), :Primes ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:91:15)), :Precomputed ^{:Dp ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:150:10), :Dq ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:150:10), :Qinv ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:151:10), :CRTValues ^(vector-of {:Exp ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:162:9), :Coeff ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:163:9), :R ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:164:9)})}} Error]"
;;   {:added "1.0"
;;    :go "generateMultiPrimeKey(random, nprimes, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:222:35) random, ^Int nprimes, ^Int bits])

JOKER FUNC rsa.SignPKCS1v15 has:
;; (defn SignPKCS1v15
;;   "SignPKCS1v15 calculates the signature of hashed using\nRSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must\nbe the result of hashing the input message using the given hash\nfunction. If hash is zero, hashed is signed directly. This isn't\nadvisable except for interoperability.\n\nIf rand is not nil then RSA blinding will be used to avoid timing\nside-channel attacks.\n\nThis function is deterministic. Thus, if the set of possible\nmessages is small, an attacker may be able to build a map from\nmessages to signatures and identify the signed messages. As ever,\nsignatures provide authenticity, not confidentiality.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "signPKCS1v15(rand, priv, hash, hashed)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:232:24) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:232:40) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:232:58) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pkcs1v15.go:232:78) hashed])

JOKER FUNC rsa.SignPSS has:
;; (defn SignPSS
;;   "SignPSS calculates the signature of hashed using RSASSA-PSS [1].\nNote that hashed must be the result of hashing the input message using the\ngiven hash function. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "signPSS(rand, priv, hash, hashed, opts)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pss.go:249:19) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pss.go:249:35) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pss.go:249:53) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pss.go:249:73) hashed, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pss.go:249:86) opts])

JOKER FUNC rsa.VerifyPKCS1v15 has:
;; (defn ^Error VerifyPKCS1v15
;;   "VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. If hash is zero then hashed is used directly. This\nisn't advisable except for interoperability.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPKCS1v15(pub, hash, hashed, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:268:25) pub, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:268:42) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pkcs1v15.go:268:62) hashed, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pkcs1v15.go:268:74) sig])

JOKER FUNC rsa.VerifyPSS has:
;; (defn ^Error VerifyPSS
;;   "VerifyPSS verifies a PSS signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPSS(pub, hash, hashed, sig, opts)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pss.go:274:20) pub, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pss.go:274:37) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pss.go:274:57) hashed, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pss.go:274:69) sig, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pss.go:274:82) opts])

JOKER FUNC runtime.BlockProfile has:
;; (defn BlockProfile
;;   "BlockProfile returns n, the number of records in the current blocking profile.\nIf len(p) >= n, BlockProfile copies the profile into p and returns n, true.\nIf len(p) < n, BlockProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.blockprofile flag instead\nof calling BlockProfile directly.\n\nGo return type: (n int, ok bool)\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "blockProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:634:21) p])

JOKER FUNC runtime.Breakpoint has:
;; (defn Breakpoint
;;   "Breakpoint executes a breakpoint trap.\n"
;;   {:added "1.0"
;;    :go "breakpoint()"}
;;   [])

JOKER FUNC runtime.CPUProfile has:
(defn CPUProfile
  "CPUProfile panics.\nIt formerly provided raw access to chunks of\na pprof-format profile generated by the runtime.\nThe details of generating that format have changed,\nso this functionality has been removed.\n\nDeprecated: use the runtime/pprof package,\nor the handlers in the net/http/pprof package,\nor the testing package's -test.cpuprofile flag instead.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "cPUProfile()"}
  [])

JOKER FUNC runtime.Caller has:
;; (defn Caller
;;   "Caller reports file and line number information about function invocations on\nthe calling goroutine's stack. The argument skip is the number of stack frames\nto ascend, with 0 identifying the caller of Caller.  (For historical reasons the\nmeaning of skip differs between Caller and Callers.) The return values report the\nprogram counter, file name, and line number within the file of the corresponding\ncall. The boolean ok is false if it was not possible to recover the information.\n\nGo return type: (pc uintptr, file string, line int, ok bool)\n\nJoker return type: [ABEND042(cannot find typename runtime.uintptr) String Int Bool]"
;;   {:added "1.0"
;;    :go "caller(skip)"}
;;   [^Int skip])

JOKER FUNC runtime.Callers has:
;; (defn ^Int Callers
;;   "Callers fills the slice pc with the return program counters of function invocations\non the calling goroutine's stack. The argument skip is the number of stack frames\nto skip before recording in pc, with 0 identifying the frame for Callers itself and\n1 identifying the caller of Callers.\nIt returns the number of entries written to pc.\n\nTo translate these PCs into symbolic information such as function\nnames and line numbers, use CallersFrames. CallersFrames accounts\nfor inlined functions and adjusts the return program counters into\ncall program counters. Iterating over the returned slice of PCs\ndirectly is discouraged, as is using FuncForPC on any of the\nreturned PCs, since these cannot account for inlining or return\nprogram counter adjustment.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Callers(skip, pc)"}
;;   [^Int skip, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/extern.go:211:27) pc])

JOKER FUNC runtime.CallersFrames has:
;; (defn CallersFrames
;;   "CallersFrames takes a slice of PC values returned by Callers and\nprepares to return function/file/line information.\nDo not change the slice until you are done with the Frames.\n\nGo return type: *Frames\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "callersFrames(callers)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/symtab.go:91:28) callers])

JOKER FUNC runtime.FuncForPC has:
;; (defn FuncForPC
;;   "FuncForPC returns a *Func describing the function that contains the\ngiven program counter address, or else nil.\n\nIf pc represents multiple functions because of inlining, it returns\nthe *Func describing the outermost function.\n\nGo return type: *Func\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "funcForPC(pc)"}
;;   [^ABEND885(unrecognized type uintptr at: GO.link/src/runtime/symtab.go:609:19) pc])

JOKER FUNC runtime.GC has:
;; (defn GC
;;   "GC runs a garbage collection and blocks the caller until the\ngarbage collection is complete. It may also block the entire\nprogram.\n"
;;   {:added "1.0"
;;    :go "gC()"}
;;   [])

JOKER FUNC runtime.GOMAXPROCS has:
(defn ^Int GOMAXPROCS
  "GOMAXPROCS sets the maximum number of CPUs that can be executing\nsimultaneously and returns the previous setting. If n < 1, it does not\nchange the current setting.\nThe number of logical CPUs on the local machine can be queried with NumCPU.\nThis call will go away when the scheduler improves.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.GOMAXPROCS(n)"}
  [^Int n])

JOKER FUNC runtime.GOROOT has:
(defn ^String GOROOT
  "GOROOT returns the root of the Go tree. It uses the\nGOROOT environment variable, if set at process start,\nor else the root used during the Go build.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.GOROOT()"}
  [])

JOKER FUNC runtime.Goexit has:
;; (defn Goexit
;;   "Goexit terminates the goroutine that calls it. No other goroutine is affected.\nGoexit runs all deferred calls before terminating the goroutine. Because Goexit\nis not a panic, any recover calls in those deferred functions will return nil.\n\nCalling Goexit from the main goroutine terminates that goroutine\nwithout func main returning. Since func main has not returned,\nthe program continues execution of other goroutines.\nIf all other goroutines exit, the program crashes.\n"
;;   {:added "1.0"
;;    :go "goexit()"}
;;   [])

JOKER FUNC runtime.GoroutineProfile has:
;; (defn GoroutineProfile
;;   "GoroutineProfile returns n, the number of records in the active goroutine stack profile.\nIf len(p) >= n, GoroutineProfile copies the profile into p and returns n, true.\nIf len(p) < n, GoroutineProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling GoroutineProfile directly.\n\nGo return type: (n int, ok bool)\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "goroutineProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:720:25) p])

JOKER FUNC runtime.Gosched has:
;; (defn Gosched
;;   "Gosched yields the processor, allowing other goroutines to run. It does not\nsuspend the current goroutine, so execution resumes automatically.\n"
;;   {:added "1.0"
;;    :go "gosched()"}
;;   [])

JOKER FUNC runtime.KeepAlive has:
;; (defn KeepAlive
;;   "KeepAlive marks its argument as currently reachable.\nThis ensures that the object is not freed, and its finalizer is not run,\nbefore the point in the program where KeepAlive is called.\n\nA very simplified example showing where KeepAlive is required:\n\ttype File struct { d int }\n\td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n\t// ... do something if err != nil ...\n\tp := &File{d}\n\truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n\tvar buf [10]byte\n\tn, err := syscall.Read(p.d, buf[:])\n\t// Ensure p is not finalized until Read returns.\n\truntime.KeepAlive(p)\n\t// No more uses of p after this point.\n\nWithout the KeepAlive call, the finalizer could run at the start of\nsyscall.Read, closing the file descriptor before syscall.Read makes\nthe actual system call.\n"
;;   {:added "1.0"
;;    :go "keepAlive(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/runtime/mfinal.go:446:18) x])

JOKER FUNC runtime.LockOSThread has:
;; (defn LockOSThread
;;   "LockOSThread wires the calling goroutine to its current operating system thread.\nThe calling goroutine will always execute in that thread,\nand no other goroutine will execute in it,\nuntil the calling goroutine has made as many calls to\nUnlockOSThread as to LockOSThread.\nIf the calling goroutine exits without unlocking the thread,\nthe thread will be terminated.\n\nAll init functions are run on the startup thread. Calling LockOSThread\nfrom an init function will cause the main function to be invoked on\nthat thread.\n\nA goroutine should call LockOSThread before calling OS services or\nnon-Go library functions that depend on per-thread state.\n"
;;   {:added "1.0"
;;    :go "lockOSThread()"}
;;   [])

JOKER FUNC runtime.MemProfile has:
;; (defn MemProfile
;;   "MemProfile returns a profile of memory allocated and freed per allocation\nsite.\n\nMemProfile returns n, the number of records in the current memory profile.\nIf len(p) >= n, MemProfile copies the profile into p and returns n, true.\nIf len(p) < n, MemProfile does not change p and returns n, false.\n\nIf inuseZero is true, the profile includes allocation records\nwhere r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.\nThese are sites where memory was allocated, but it has all\nbeen released back to the runtime.\n\nThe returned profile may be up to two garbage collection cycles old.\nThis is to avoid skewing the profile toward allocations; because\nallocations happen in real time but frees are delayed until the garbage\ncollector performs sweeping, the profile only accounts for allocations\nthat have had a chance to be freed by the garbage collector.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.memprofile flag instead\nof calling MemProfile directly.\n\nGo return type: (n int, ok bool)\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "memProfile(p, inuseZero)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:543:19) p, ^Bool inuseZero])

JOKER FUNC runtime.MutexProfile has:
;; (defn MutexProfile
;;   "MutexProfile returns n, the number of records in the current mutex profile.\nIf len(p) >= n, MutexProfile copies the profile into p and returns n, true.\nOtherwise, MutexProfile does not change p, and returns n, false.\n\nMost clients should use the runtime/pprof package\ninstead of calling MutexProfile directly.\n\nGo return type: (n int, ok bool)\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "mutexProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:669:21) p])

JOKER FUNC runtime.NumCPU has:
(defn ^Int NumCPU
  "NumCPU returns the number of logical CPUs usable by the current process.\n\nThe set of available CPUs is checked by querying the operating system\nat process startup. Changes to operating system CPU allocation after\nprocess startup are not reflected.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumCPU()"}
  [])

JOKER FUNC runtime.NumCgoCall has:
(defn ^Int NumCgoCall
  "NumCgoCall returns the number of cgo calls made by the current process.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumCgoCall()"}
  [])

JOKER FUNC runtime.NumGoroutine has:
(defn ^Int NumGoroutine
  "NumGoroutine returns the number of goroutines that currently exist.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumGoroutine()"}
  [])

JOKER FUNC runtime.ReadMemStats has:
;; (defn ReadMemStats
;;   "ReadMemStats populates m with memory allocator statistics.\n\nThe returned memory allocator statistics are up to date as of the\ncall to ReadMemStats. This is in contrast with a heap profile,\nwhich is a snapshot as of the most recently completed garbage\ncollection cycle.\n"
;;   {:added "1.0"
;;    :go "readMemStats(m)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/runtime/mstats.go:457:21) m])

JOKER FUNC runtime.ReadTrace has:
(defn ReadTrace
  "ReadTrace returns the next chunk of binary tracing data, blocking until data\nis available. If tracing is turned off and all the data accumulated while it\nwas on has been returned, ReadTrace returns nil. The caller must copy the\nreturned data before calling ReadTrace again.\nReadTrace must be called from one goroutine at a time.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "readTrace()"}
  [])

JOKER FUNC runtime.SetBlockProfileRate has:
;; (defn SetBlockProfileRate
;;   "SetBlockProfileRate controls the fraction of goroutine blocking events\nthat are reported in the blocking profile. The profiler aims to sample\nan average of one blocking event per rate nanoseconds spent blocked.\n\nTo include every blocking event in the profile, pass rate = 1.\nTo turn off profiling entirely, pass rate <= 0.\n"
;;   {:added "1.0"
;;    :go "setBlockProfileRate(rate)"}
;;   [^Int rate])

JOKER FUNC runtime.SetCPUProfileRate has:
;; (defn SetCPUProfileRate
;;   "SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\nIf hz <= 0, SetCPUProfileRate turns off profiling.\nIf the profiler is on, the rate cannot be changed without first turning it off.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.cpuprofile flag instead of calling\nSetCPUProfileRate directly.\n"
;;   {:added "1.0"
;;    :go "setCPUProfileRate(hz)"}
;;   [^Int hz])

JOKER FUNC runtime.SetCgoTraceback has:
;; (defn SetCgoTraceback
;;   "SetCgoTraceback records three C functions to use to gather\ntraceback information from C code and to convert that traceback\ninformation into symbolic information. These are used when printing\nstack traces for a program that uses cgo.\n\nThe traceback and context functions may be called from a signal\nhandler, and must therefore use only async-signal safe functions.\nThe symbolizer function may be called while the program is\ncrashing, and so must be cautious about using memory.  None of the\nfunctions may call back into Go.\n\nThe context function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t Context;\n\t};\n\nIf the Context field is 0, the context function is being called to\nrecord the current traceback context. It should record in the\nContext field whatever information is needed about the current\npoint of execution to later produce a stack trace, probably the\nstack pointer and PC. In this case the context function will be\ncalled from C code.\n\nIf the Context field is not 0, then it is a value returned by a\nprevious call to the context function. This case is called when the\ncontext is no longer needed; that is, when the Go code is returning\nto its C code caller. This permits the context function to release\nany associated resources.\n\nWhile it would be correct for the context function to record a\ncomplete a stack trace whenever it is called, and simply copy that\nout in the traceback function, in a typical program the context\nfunction will be called many times without ever recording a\ntraceback for that context. Recording a complete stack trace in a\ncall to the context function is likely to be inefficient.\n\nThe traceback function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext    uintptr\n\t\tSigContext uintptr\n\t\tBuf        *uintptr\n\t\tMax        uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t  Context;\n\t\tuintptr_t  SigContext;\n\t\tuintptr_t* Buf;\n\t\tuintptr_t  Max;\n\t};\n\nThe Context field will be zero to gather a traceback from the\ncurrent program execution point. In this case, the traceback\nfunction will be called from C code.\n\nOtherwise Context will be a value previously returned by a call to\nthe context function. The traceback function should gather a stack\ntrace from that saved point in the program execution. The traceback\nfunction may be called from an execution thread other than the one\nthat recorded the context, but only when the context is known to be\nvalid and unchanging. The traceback function may also be called\ndeeper in the call stack on the same thread that recorded the\ncontext. The traceback function may be called multiple times with\nthe same Context value; it will usually be appropriate to cache the\nresult, if possible, the first time this is called for a specific\ncontext value.\n\nIf the traceback function is called from a signal handler on a Unix\nsystem, SigContext will be the signal context argument passed to\nthe signal handler (a C ucontext_t* cast to uintptr_t). This may be\nused to start tracing at the point where the signal occurred. If\nthe traceback function is not called from a signal handler,\nSigContext will be zero.\n\nBuf is where the traceback information should be stored. It should\nbe PC values, such that Buf[0] is the PC of the caller, Buf[1] is\nthe PC of that function's caller, and so on.  Max is the maximum\nnumber of entries to store.  The function should store a zero to\nindicate the top of the stack, or that the caller is on a different\nstack, presumably a Go stack.\n\nUnlike runtime.Callers, the PC values returned should, when passed\nto the symbolizer function, return the file/line of the call\ninstruction.  No additional subtraction is required or appropriate.\n\nOn all platforms, the traceback function is invoked when a call from\nGo to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,\nand freebsd/amd64, the traceback function is also invoked when a\nsignal is received by a thread that is executing a cgo call. The\ntraceback function should not make assumptions about when it is\ncalled, as future versions of Go may make additional calls.\n\nThe symbolizer function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tPC      uintptr // program counter to fetch information for\n\t\tFile    *byte   // file name (NUL terminated)\n\t\tLineno  uintptr // line number\n\t\tFunc    *byte   // function name (NUL terminated)\n\t\tEntry   uintptr // function entry point\n\t\tMore    uintptr // set non-zero if more info for this PC\n\t\tData    uintptr // unused by runtime, available for function\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t PC;\n\t\tchar*     File;\n\t\tuintptr_t Lineno;\n\t\tchar*     Func;\n\t\tuintptr_t Entry;\n\t\tuintptr_t More;\n\t\tuintptr_t Data;\n\t};\n\nThe PC field will be a value returned by a call to the traceback\nfunction.\n\nThe first time the function is called for a particular traceback,\nall the fields except PC will be 0. The function should fill in the\nother fields if possible, setting them to 0/nil if the information\nis not available. The Data field may be used to store any useful\ninformation across calls. The More field should be set to non-zero\nif there is more information for this PC, zero otherwise. If More\nis set non-zero, the function will be called again with the same\nPC, and may return different information (this is intended for use\nwith inlined functions). If More is zero, the function will be\ncalled with the next PC value in the traceback. When the traceback\nis complete, the function will be called once more with PC set to\nzero; this may be used to free any information. Each call will\nleave the fields of the struct set to the same values they had upon\nreturn, except for the PC field when the More field is zero. The\nfunction must not keep a copy of the struct pointer between calls.\n\nWhen calling SetCgoTraceback, the version argument is the version\nnumber of the structs that the functions expect to receive.\nCurrently this must be zero.\n\nThe symbolizer function may be nil, in which case the results of\nthe traceback function will be displayed as numbers. If the\ntraceback function is nil, the symbolizer function will never be\ncalled. The context function may be nil, in which case the\ntraceback function will only be called with the context field set\nto zero.  If the context function is nil, then calls from Go to C\nto Go will not show a traceback for the C portion of the call stack.\n\nSetCgoTraceback should be called only once, ideally from an init function.\n"
;;   {:added "1.0"
;;    :go "setCgoTraceback(version, traceback, context, symbolizer)"}
;;   [^Int version, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/traceback.go:1198:66) traceback, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/traceback.go:1198:66) context, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/traceback.go:1198:66) symbolizer])

JOKER FUNC runtime.SetFinalizer has:
;; (defn SetFinalizer
;;   "SetFinalizer sets the finalizer associated with obj to the provided\nfinalizer function. When the garbage collector finds an unreachable block\nwith an associated finalizer, it clears the association and runs\nfinalizer(obj) in a separate goroutine. This makes obj reachable again,\nbut now without an associated finalizer. Assuming that SetFinalizer\nis not called again, the next time the garbage collector sees\nthat obj is unreachable, it will free obj.\n\nSetFinalizer(obj, nil) clears any finalizer associated with obj.\n\nThe argument obj must be a pointer to an object allocated by calling\nnew, by taking the address of a composite literal, or by taking the\naddress of a local variable.\nThe argument finalizer must be a function that takes a single argument\nto which obj's type can be assigned, and can have arbitrary ignored return\nvalues. If either of these is not true, SetFinalizer may abort the\nprogram.\n\nFinalizers are run in dependency order: if A points at B, both have\nfinalizers, and they are otherwise unreachable, only the finalizer\nfor A runs; once A is freed, the finalizer for B can run.\nIf a cyclic structure includes a block with a finalizer, that\ncycle is not guaranteed to be garbage collected and the finalizer\nis not guaranteed to run, because there is no ordering that\nrespects the dependencies.\n\nThe finalizer is scheduled to run at some arbitrary time after the\nprogram can no longer reach the object to which obj points.\nThere is no guarantee that finalizers will run before a program exits,\nso typically they are useful only for releasing non-memory resources\nassociated with an object during a long-running program.\nFor example, an os.File object could use a finalizer to close the\nassociated operating system file descriptor when a program discards\nan os.File without calling Close, but it would be a mistake\nto depend on a finalizer to flush an in-memory I/O buffer such as a\nbufio.Writer, because the buffer would not be flushed at program exit.\n\nIt is not guaranteed that a finalizer will run if the size of *obj is\nzero bytes.\n\nIt is not guaranteed that a finalizer will run for objects allocated\nin initializers for package-level variables. Such objects may be\nlinker-allocated, not heap-allocated.\n\nA finalizer may run as soon as an object becomes unreachable.\nIn order to use finalizers correctly, the program must ensure that\nthe object is reachable until it is no longer required.\nObjects stored in global variables, or that can be found by tracing\npointers from a global variable, are reachable. For other objects,\npass the object to a call of the KeepAlive function to mark the\nlast point in the function where the object must be reachable.\n\nFor example, if p points to a struct that contains a file descriptor d,\nand p has a finalizer that closes that file descriptor, and if the last\nuse of p in a function is a call to syscall.Write(p.d, buf, size), then\np may be unreachable as soon as the program enters syscall.Write. The\nfinalizer may run at that moment, closing p.d, causing syscall.Write\nto fail because it is writing to a closed file descriptor (or, worse,\nto an entirely different file descriptor opened by a different goroutine).\nTo avoid this problem, call runtime.KeepAlive(p) after the call to\nsyscall.Write.\n\nA single goroutine runs all finalizers for a program, sequentially.\nIf a finalizer must run for a long time, it should do so by starting\na new goroutine.\n"
;;   {:added "1.0"
;;    :go "setFinalizer(obj, finalizer)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/runtime/mfinal.go:309:23) obj, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/runtime/mfinal.go:309:46) finalizer])

JOKER FUNC runtime.SetMutexProfileFraction has:
(defn ^Int SetMutexProfileFraction
  "SetMutexProfileFraction controls the fraction of mutex contention events\nthat are reported in the mutex profile. On average 1/rate events are\nreported. The previous rate is returned.\n\nTo turn off profiling entirely, pass rate 0.\nTo just read the current rate, pass rate < 0.\n(For n>1 the details of sampling may change.)\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.SetMutexProfileFraction(rate)"}
  [^Int rate])

JOKER FUNC runtime.Stack has:
;; (defn ^Int Stack
;;   "Stack formats a stack trace of the calling goroutine into buf\nand returns the number of bytes written to buf.\nIf all is true, Stack formats stack traces of all other goroutines\ninto buf after the trace for the current goroutine.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Stack(buf, all)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:780:16) buf, ^Bool all])

JOKER FUNC runtime.StartTrace has:
(defn ^Error StartTrace
  "StartTrace enables tracing for the current process.\nWhile tracing, the data will be buffered and available via ReadTrace.\nStartTrace returns an error if tracing is already enabled.\nMost clients should use the runtime/trace package or the testing package's\n-test.trace flag instead of calling StartTrace directly.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "runtime.StartTrace()"}
  [])

JOKER FUNC runtime.StopTrace has:
;; (defn StopTrace
;;   "StopTrace stops tracing, if it was previously enabled.\nStopTrace only returns after all the reads for the trace have completed.\n"
;;   {:added "1.0"
;;    :go "stopTrace()"}
;;   [])

JOKER FUNC runtime.ThreadCreateProfile has:
;; (defn ThreadCreateProfile
;;   "ThreadCreateProfile returns n, the number of records in the thread creation profile.\nIf len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true.\nIf len(p) < n, ThreadCreateProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling ThreadCreateProfile directly.\n\nGo return type: (n int, ok bool)\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "threadCreateProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:698:28) p])

JOKER FUNC runtime.UnlockOSThread has:
;; (defn UnlockOSThread
;;   "UnlockOSThread undoes an earlier call to LockOSThread.\nIf this drops the number of active LockOSThread calls on the\ncalling goroutine to zero, it unwires the calling goroutine from\nits fixed operating system thread.\nIf there are no active LockOSThread calls, this is a no-op.\n\nBefore calling UnlockOSThread, the caller must ensure that the OS\nthread is suitable for running other goroutines. If the caller made\nany permanent changes to the state of the thread that would affect\nother goroutines, it should not call this function and thus leave\nthe goroutine locked to the OS thread until the goroutine (and\nhence the thread) exits.\n"
;;   {:added "1.0"
;;    :go "unlockOSThread()"}
;;   [])

JOKER FUNC runtime.Version has:
(defn ^String Version
  "Version returns the Go tree's version string.\nIt is either the commit hash and date at the time of the build or,\nwhen possible, a release tag like \"go1.3\".\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.Version()"}
  [])

JOKER FUNC runtime._ExternalCode has:
;; (defn _ExternalCode
;;   ""
;;   {:added "1.0"
;;    :go "_ExternalCode()"}
;;   [])

JOKER FUNC runtime._GC has:
;; (defn _GC
;;   ""
;;   {:added "1.0"
;;    :go "_GC()"}
;;   [])

JOKER FUNC runtime._LostExternalCode has:
;; (defn _LostExternalCode
;;   ""
;;   {:added "1.0"
;;    :go "_LostExternalCode()"}
;;   [])

JOKER FUNC runtime._LostSIGPROFDuringAtomic64 has:
;; (defn _LostSIGPROFDuringAtomic64
;;   ""
;;   {:added "1.0"
;;    :go "_LostSIGPROFDuringAtomic64()"}
;;   [])

JOKER FUNC runtime._System has:
;; (defn _System
;;   ""
;;   {:added "1.0"
;;    :go "_System()"}
;;   [])

JOKER FUNC runtime._VDSO has:
;; (defn _VDSO
;;   ""
;;   {:added "1.0"
;;    :go "_VDSO()"}
;;   [])

JOKER FUNC runtime._cgo_panic_internal has:
;; (defn _cgo_panic_internal
;;   ""
;;   {:added "1.0"
;;    :go "_cgo_panic_internal(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/runtime/cgocallback.go:11:28) p])

JOKER FUNC scanner.TokenString has:
;; (defn ^String TokenString
;;   "TokenString returns a printable string for a token or Unicode character.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "scanner.TokenString(tok)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/text/scanner/scanner.go:98:22) tok])

JOKER FUNC scanner.PrintError has:
;; (defn PrintError
;;   "PrintError is a utility function that prints a list of errors to w,\none error per line, if the err parameter is an ErrorList. Otherwise\nit prints the err string.\n"
;;   {:added "1.0"
;;    :go "printError(w, err)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/scanner/errors.go:116:19) w, ^ABEND885(unrecognized type error at: GO.link/src/go/scanner/errors.go:116:34) err])

JOKER FUNC sha1.New has:
;; (defn New
;;   "New returns a new hash.Hash computing the SHA1 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/sha1/sha1.go:120:12)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC sha1.Sum has:
;; (defn Sum
;;   "Sum returns the SHA-1 checksum of the data.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha1/sha1.go:260:15) data])

JOKER FUNC sha256.New has:
;; (defn New
;;   "New returns a new hash.Hash computing the SHA256 checksum. The Hash\nalso implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/sha256/sha256.go:180:12)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC sha256.New224 has:
;; (defn New224
;;   "New224 returns a new hash.Hash computing the SHA224 checksum.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/sha256/sha256.go:187:15)"
;;   {:added "1.0"
;;    :go "new224()"}
;;   [])

JOKER FUNC sha256.Sum224 has:
;; (defn Sum224
;;   "Sum224 returns the SHA224 checksum of the data.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum224(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha256/sha256.go:281:18) data])

JOKER FUNC sha256.Sum256 has:
;; (defn Sum256
;;   "Sum256 returns the SHA256 checksum of the data.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum256(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha256/sha256.go:273:18) data])

JOKER FUNC sha512.New has:
;; (defn New
;;   "New returns a new hash.Hash computing the SHA-512 checksum.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/sha512/sha512.go:224:12)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC sha512.New384 has:
;; (defn New384
;;   "New384 returns a new hash.Hash computing the SHA-384 checksum.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/sha512/sha512.go:245:15)"
;;   {:added "1.0"
;;    :go "new384()"}
;;   [])

JOKER FUNC sha512.New512_224 has:
;; (defn New512_224
;;   "New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/sha512/sha512.go:231:19)"
;;   {:added "1.0"
;;    :go "new512_224()"}
;;   [])

JOKER FUNC sha512.New512_256 has:
;; (defn New512_256
;;   "New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/sha512/sha512.go:238:19)"
;;   {:added "1.0"
;;    :go "new512_256()"}
;;   [])

JOKER FUNC sha512.Sum384 has:
;; (defn Sum384
;;   "Sum384 returns the SHA384 checksum of the data.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum384(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha512/sha512.go:351:18) data])

JOKER FUNC sha512.Sum512 has:
;; (defn Sum512
;;   "Sum512 returns the SHA512 checksum of the data.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum512(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha512/sha512.go:343:18) data])

JOKER FUNC sha512.Sum512_224 has:
;; (defn Sum512_224
;;   "Sum512_224 returns the Sum512/224 checksum of the data.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum512_224(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha512/sha512.go:361:22) data])

JOKER FUNC sha512.Sum512_256 has:
;; (defn Sum512_256
;;   "Sum512_256 returns the Sum512/256 checksum of the data.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum512_256(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha512/sha512.go:371:22) data])

JOKER FUNC signal.Ignore has:
;; (defn Ignore
;;   "Ignore causes the provided signals to be ignored. If they are received by\nthe program, nothing will happen. Ignore undoes the effect of any prior\ncalls to Notify for the provided signals.\nIf no signals are provided, all incoming signals will be ignored.\n"
;;   {:added "1.0"
;;    :go "ignore(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/os/signal/signal.go:85:17) sig])

JOKER FUNC signal.Ignored has:
;; (defn ^Bool Ignored
;;   "Ignored reports whether sig is currently ignored.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "signal.Ignored(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/signal/signal.go:90:18) sig])

JOKER FUNC signal.Notify has:
;; (defn Notify
;;   "Notify causes package signal to relay incoming signals to c.\nIf no signals are provided, all incoming signals will be relayed to c.\nOtherwise, just the provided signals will.\n\nPackage signal will not block sending to c: the caller must ensure\nthat c has sufficient buffer space to keep up with the expected\nsignal rate. For a channel used for notification of just one signal value,\na buffer of size 1 is sufficient.\n\nIt is allowed to call Notify multiple times with the same channel:\neach call expands the set of signals sent to that channel.\nThe only way to remove signals from the set is to call Stop.\n\nIt is allowed to call Notify multiple times with different channels\nand the same signals: each channel receives copies of incoming\nsignals independently.\n"
;;   {:added "1.0"
;;    :go "notify(c, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.ChanType at: GO.link/src/os/signal/signal.go:111:15) c, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/os/signal/signal.go:111:37) sig])

JOKER FUNC signal.Reset has:
;; (defn Reset
;;   "Reset undoes the effect of any prior calls to Notify for the provided\nsignals.\nIf no signals are provided, all signal handlers will be reset.\n"
;;   {:added "1.0"
;;    :go "reset(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/os/signal/signal.go:155:16) sig])

JOKER FUNC signal.Stop has:
;; (defn Stop
;;   "Stop causes package signal to stop relaying incoming signals to c.\nIt undoes the effect of all prior calls to Notify using c.\nWhen Stop returns, it is guaranteed that c will receive no more signals.\n"
;;   {:added "1.0"
;;    :go "stop(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ChanType at: GO.link/src/os/signal/signal.go:162:13) c])

JOKER FUNC smtp.CRAMMD5Auth has:
;; (defn CRAMMD5Auth
;;   "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo return type: Auth\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/smtp/auth.go:15:11)"
;;   {:added "1.0"
;;    :go "cRAMMD5Auth(username, secret)"}
;;   [^String username, ^String secret])

JOKER FUNC smtp.Dial has:
;; (defn Dial
;;   "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo return type: (*Client, error)\n\nJoker return type: [{:Text ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/smtp/smtp.go:33:8)} Error]"
;;   {:added "1.0"
;;    :go "dial(addr)"}
;;   [^String addr])

JOKER FUNC smtp.NewClient has:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo return type: (*Client, error)\n\nJoker return type: [{:Text ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/smtp/smtp.go:33:8)} Error]"
;;   {:added "1.0"
;;    :go "newClient(conn, host)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/smtp/smtp.go:62:21) conn, ^String host])

JOKER FUNC smtp.PlainAuth has:
;; (defn PlainAuth
;;   "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo return type: Auth\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/smtp/auth.go:15:11)"
;;   {:added "1.0"
;;    :go "plainAuth(identity, username, password, host)"}
;;   [^String identity, ^String username, ^String password, ^String host])

JOKER FUNC smtp.SendMail has:
;; (defn ^Error SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "smtp.SendMail(addr, a, from, to, msg)"}
;;   [^String addr, ^ABEND885(unrecognized type Auth at: GO.link/src/net/smtp/smtp.go:319:30) a, ^String from, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/net/smtp/smtp.go:319:52) to, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/net/smtp/smtp.go:319:66) msg])

JOKER FUNC sort.Float64s has:
;; (defn Float64s
;;   "Float64s sorts a slice of float64s in increasing order\n(not-a-number values are treated as less than other values).\n"
;;   {:added "1.0"
;;    :go "float64s(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/sort.go:311:17) a])

JOKER FUNC sort.Float64sAreSorted has:
;; (defn ^Bool Float64sAreSorted
;;   "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order\n(not-a-number values are treated as less than other values).\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.Float64sAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/sort.go:321:26) a])

JOKER FUNC sort.Ints has:
;; (defn Ints
;;   "Ints sorts a slice of ints in increasing order.\n"
;;   {:added "1.0"
;;    :go "ints(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/sort.go:307:13) a])

JOKER FUNC sort.IntsAreSorted has:
;; (defn ^Bool IntsAreSorted
;;   "IntsAreSorted tests whether a slice of ints is sorted in increasing order.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.IntsAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/sort.go:317:22) a])

JOKER FUNC sort.IsSorted has:
;; (defn ^Bool IsSorted
;;   "IsSorted reports whether data is sorted.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.IsSorted(data)"}
;;   [^ABEND885(unrecognized type Interface at: GO.link/src/sort/sort.go:256:20) data])

JOKER FUNC sort.Reverse has:
;; (defn Reverse
;;   "Reverse returns the reverse order for data.\n\nGo return type: Interface\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/sort/sort.go:14:16)"
;;   {:added "1.0"
;;    :go "reverse(data)"}
;;   [^ABEND885(unrecognized type Interface at: GO.link/src/sort/sort.go:251:19) data])

JOKER FUNC sort.Search has:
;; (defn ^Int Search
;;   "Search uses binary search to find and return the smallest index i\nin [0, n) at which f(i) is true, assuming that on the range [0, n),\nf(i) == true implies f(i+1) == true. That is, Search requires that\nf is false for some (possibly empty) prefix of the input range [0, n)\nand then true for the (possibly empty) remainder; Search returns\nthe first true index. If there is no such index, Search returns n.\n(Note that the \"not found\" return value is not -1 as in, for instance,\nstrings.Index.)\nSearch calls f(i) only for i in the range [0, n).\n\nA common use of Search is to find the index i for a value x in\na sorted, indexable data structure such as an array or slice.\nIn this case, the argument f, typically a closure, captures the value\nto be searched for, and how the data structure is indexed and\nordered.\n\nFor instance, given a slice data sorted in ascending order,\nthe call Search(len(data), func(i int) bool { return data[i] >= 23 })\nreturns the smallest index i such that data[i] >= 23. If the caller\nwants to find whether 23 is in the slice, it must test data[i] == 23\nseparately.\n\nSearching data sorted in descending order would use the <=\noperator instead of the >= operator.\n\nTo complete the example above, the following code tries to find the value\nx in an integer slice data sorted in ascending order:\n\n\tx := 23\n\ti := sort.Search(len(data), func(i int) bool { return data[i] >= x })\n\tif i < len(data) && data[i] == x {\n\t\t// x is present at data[i]\n\t} else {\n\t\t// x is not present in data,\n\t\t// but i is the index where it would be inserted.\n\t}\n\nAs a more whimsical example, this program guesses your number:\n\n\tfunc GuessingGame() {\n\t\tvar s string\n\t\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\t\tanswer := sort.Search(100, func(i int) bool {\n\t\t\tfmt.Printf(\"Is your number <= %d? \", i)\n\t\t\tfmt.Scanf(\"%s\", &s)\n\t\t\treturn s != \"\" && s[0] == 'y'\n\t\t})\n\t\tfmt.Printf(\"Your number is %d.\\n\", answer)\n\t}\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.Search(n, f)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/sort/search.go:59:22) f])

JOKER FUNC sort.SearchFloat64s has:
;; (defn ^Int SearchFloat64s
;;   "SearchFloat64s searches for x in a sorted slice of float64s and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchFloat64s(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/search.go:92:23) a, ^ABEND885(unrecognized type float64 at: GO.link/src/sort/search.go:92:36) x])

JOKER FUNC sort.SearchInts has:
;; (defn ^Int SearchInts
;;   "SearchInts searches for x in a sorted slice of ints and returns the index\nas specified by Search. The return value is the index to insert x if x is\nnot present (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchInts(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/search.go:83:19) a, ^Int x])

JOKER FUNC sort.SearchStrings has:
;; (defn ^Int SearchStrings
;;   "SearchStrings searches for x in a sorted slice of strings and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchStrings(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/search.go:101:22) a, ^String x])

JOKER FUNC sort.Slice has:
;; (defn Slice
;;   "Slice sorts the provided slice given the provided less function.\n\nThe sort is not guaranteed to be stable. For a stable sort, use\nSliceStable.\n\nThe function panics if the provided interface is not a slice.\n"
;;   {:added "1.0"
;;    :go "slice(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/sort/slice.go:17:18) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/sort/slice.go:17:36) less])

JOKER FUNC sort.SliceIsSorted has:
;; (defn ^Bool SliceIsSorted
;;   "SliceIsSorted tests whether a slice is sorted.\n\nThe function panics if the provided interface is not a slice.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.SliceIsSorted(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/sort/slice.go:37:26) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/sort/slice.go:37:44) less])

JOKER FUNC sort.SliceStable has:
;; (defn SliceStable
;;   "SliceStable sorts the provided slice given the provided less\nfunction while keeping the original order of equal elements.\n\nThe function panics if the provided interface is not a slice.\n"
;;   {:added "1.0"
;;    :go "sliceStable(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/sort/slice.go:28:24) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/sort/slice.go:28:42) less])

JOKER FUNC sort.Sort has:
;; (defn Sort
;;   "Sort sorts data.\nIt makes one call to data.Len to determine n, and O(n*log(n)) calls to\ndata.Less and data.Swap. The sort is not guaranteed to be stable.\n"
;;   {:added "1.0"
;;    :go "sort(data)"}
;;   [^ABEND885(unrecognized type Interface at: GO.link/src/sort/sort.go:216:16) data])

JOKER FUNC sort.Stable has:
;; (defn Stable
;;   "Stable sorts data while keeping the original order of equal elements.\n\nIt makes one call to data.Len to determine n, O(n*log(n)) calls to\ndata.Less and O(n*log(n)*log(n)) calls to data.Swap.\n"
;;   {:added "1.0"
;;    :go "stable(data)"}
;;   [^ABEND885(unrecognized type Interface at: GO.link/src/sort/sort.go:356:18) data])

JOKER FUNC sort.Strings has:
;; (defn Strings
;;   "Strings sorts a slice of strings in increasing order.\n"
;;   {:added "1.0"
;;    :go "strings(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/sort.go:314:16) a])

JOKER FUNC sort.StringsAreSorted has:
;; (defn ^Bool StringsAreSorted
;;   "StringsAreSorted tests whether a slice of strings is sorted in increasing order.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.StringsAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/sort.go:324:25) a])

JOKER FUNC sql.Drivers has:
(defn Drivers
  "Drivers returns a sorted list of the names of the registered drivers.\n\nGo return type: []string\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "drivers()"}
  [])

JOKER FUNC sql.Named has:
;; (defn Named
;;   "Named provides a more concise way to create NamedArg values.\n\nExample usage:\n\n    db.ExecContext(ctx, `\n        delete from Invoice\n        where\n            TimeCreated < @end\n            and TimeCreated >= @start;`,\n        sql.Named(\"start\", startTime),\n        sql.Named(\"end\", endTime),\n    )\n\nGo return type: NamedArg\n\nJoker return type: {:_Named_Fields_Required ^{}, :Name ^String, :Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/database/sql/sql.go:95:8)}"
;;   {:added "1.0"
;;    :go "named(name, value)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/database/sql/sql.go:110:31) value])

JOKER FUNC sql.Open has:
(defn Open
  "Open opens a database specified by its database driver name and a\ndriver-specific data source name, usually consisting of at least a\ndatabase name and connection information.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpen may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the Open\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo return type: (*DB, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "open(driverName, dataSourceName)"}
  [^String driverName, ^String dataSourceName])

JOKER FUNC sql.OpenDB has:
;; (defn OpenDB
;;   "OpenDB opens a database using a Connector, allowing drivers to\nbypass a string based data source name.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpenDB may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the OpenDB\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo return type: *DB\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "openDB(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/database/sql/sql.go:660:15) c])

JOKER FUNC sql.Register has:
;; (defn Register
;;   "Register makes a database driver available by the provided name.\nIf Register is called twice with the same name or if driver is nil,\nit panics.\n"
;;   {:added "1.0"
;;    :go "register(name, driver)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/database/sql/sql.go:44:35) driver])

JOKER FUNC strconv.AppendBool has:
;; (defn AppendBool
;;   "AppendBool appends \"true\" or \"false\", according to the value of b,\nto dst and returns the extended buffer.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendBool(dst, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/atob.go:30:21) dst, ^Bool b])

JOKER FUNC strconv.AppendFloat has:
;; (defn AppendFloat
;;   "AppendFloat appends the string form of the floating-point number f,\nas generated by FormatFloat, to dst and returns the extended buffer.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendFloat(dst, f, fmt, prec, bitSize)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/ftoa.go:51:22) dst, ^ABEND885(unrecognized type float64 at: GO.link/src/strconv/ftoa.go:51:32) f, ^Byte fmt, ^Int prec, ^Int bitSize])

JOKER FUNC strconv.AppendInt has:
;; (defn AppendInt
;;   "AppendInt appends the string form of the integer i,\nas generated by FormatInt, to dst and returns the extended buffer.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendInt(dst, i, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/itoa.go:40:20) dst, ^Int i, ^Int base])

JOKER FUNC strconv.AppendQuote has:
;; (defn AppendQuote
;;   "AppendQuote appends a double-quoted Go string literal representing s,\nas generated by Quote, to dst and returns the extended buffer.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuote(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:117:22) dst, ^String s])

JOKER FUNC strconv.AppendQuoteRune has:
;; (defn AppendQuoteRune
;;   "AppendQuoteRune appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRune, to dst and returns the extended buffer.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteRune(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:156:26) dst, ^ABEND885(unrecognized type rune at: GO.link/src/strconv/quote.go:156:36) r])

JOKER FUNC strconv.AppendQuoteRuneToASCII has:
;; (defn AppendQuoteRuneToASCII
;;   "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToASCII, to dst and returns the extended buffer.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteRuneToASCII(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:170:33) dst, ^ABEND885(unrecognized type rune at: GO.link/src/strconv/quote.go:170:43) r])

JOKER FUNC strconv.AppendQuoteRuneToGraphic has:
;; (defn AppendQuoteRuneToGraphic
;;   "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToGraphic, to dst and returns the extended buffer.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteRuneToGraphic(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:184:35) dst, ^ABEND885(unrecognized type rune at: GO.link/src/strconv/quote.go:184:45) r])

JOKER FUNC strconv.AppendQuoteToASCII has:
;; (defn AppendQuoteToASCII
;;   "AppendQuoteToASCII appends a double-quoted Go string literal representing s,\nas generated by QuoteToASCII, to dst and returns the extended buffer.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteToASCII(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:130:29) dst, ^String s])

JOKER FUNC strconv.AppendQuoteToGraphic has:
;; (defn AppendQuoteToGraphic
;;   "AppendQuoteToGraphic appends a double-quoted Go string literal representing s,\nas generated by QuoteToGraphic, to dst and returns the extended buffer.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteToGraphic(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:143:31) dst, ^String s])

JOKER FUNC strconv.AppendUint has:
;; (defn AppendUint
;;   "AppendUint appends the string form of the unsigned integer i,\nas generated by FormatUint, to dst and returns the extended buffer.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendUint(dst, i, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/itoa.go:50:21) dst, ^ABEND885(unrecognized type uint64 at: GO.link/src/strconv/itoa.go:50:31) i, ^Int base])

JOKER FUNC strconv.Atoi has:
(defn Atoi
  "Atoi returns the result of ParseInt(s, 10, 0) converted to type int.\n\nGo return type: (int, error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "atoi(s)"}
  [^String s])

JOKER FUNC strconv.CanBackquote has:
(defn ^Bool CanBackquote
  "CanBackquote reports whether the string s can be represented\nunchanged as a single-line backquoted string without control\ncharacters other than tab.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strconv.CanBackquote(s)"}
  [^String s])

JOKER FUNC strconv.FormatBool has:
(defn ^String FormatBool
  "FormatBool returns \"true\" or \"false\" according to the value of b.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatBool(b)"}
  [^Bool b])

JOKER FUNC strconv.FormatFloat has:
;; (defn ^String FormatFloat
;;   "FormatFloat converts the floating-point number f to a string,\naccording to the format fmt and precision prec. It rounds the\nresult assuming that the original was obtained from a floating-point\nvalue of bitSize bits (32 for float32, 64 for float64).\n\nThe format fmt is one of\n'b' (-ddddp±ddd, a binary exponent),\n'e' (-d.dddde±dd, a decimal exponent),\n'E' (-d.ddddE±dd, a decimal exponent),\n'f' (-ddd.dddd, no exponent),\n'g' ('e' for large exponents, 'f' otherwise), or\n'G' ('E' for large exponents, 'f' otherwise).\n\nThe precision prec controls the number of digits (excluding the exponent)\nprinted by the 'e', 'E', 'f', 'g', and 'G' formats.\nFor 'e', 'E', and 'f' it is the number of digits after the decimal point.\nFor 'g' and 'G' it is the maximum number of significant digits (trailing\nzeros are removed).\nThe special precision -1 uses the smallest number of digits\nnecessary such that ParseFloat will return f exactly.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.FormatFloat(f, fmt, prec, bitSize)"}
;;   [^ABEND885(unrecognized type float64 at: GO.link/src/strconv/ftoa.go:45:20) f, ^Byte fmt, ^Int prec, ^Int bitSize])

JOKER FUNC strconv.FormatInt has:
(defn ^String FormatInt
  "FormatInt returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatInt(i, base)"}
  [^Int i, ^Int base])

JOKER FUNC strconv.FormatUint has:
;; (defn ^String FormatUint
;;   "FormatUint returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.FormatUint(i, base)"}
;;   [^ABEND885(unrecognized type uint64 at: GO.link/src/strconv/itoa.go:14:19) i, ^Int base])

JOKER FUNC strconv.IsGraphic has:
;; (defn ^Bool IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, and Zs.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "strconv.IsGraphic(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/strconv/quote.go:520:18) r])

JOKER FUNC strconv.IsPrint has:
;; (defn ^Bool IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go, with\nthe same definition as unicode.IsPrint: letters, numbers, punctuation,\nsymbols and ASCII space.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "strconv.IsPrint(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/strconv/quote.go:474:16) r])

JOKER FUNC strconv.Itoa has:
(defn ^String Itoa
  "Itoa is shorthand for FormatInt(int64(i), 10).\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Itoa(i)"}
  [^Int i])

JOKER FUNC strconv.ParseBool has:
(defn ParseBool
  "ParseBool returns the boolean value represented by the string.\nIt accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\nAny other value returns an error.\n\nGo return type: (bool, error)\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "parseBool(str)"}
  [^String str])

JOKER FUNC strconv.ParseFloat has:
;; (defn ParseFloat
;;   "ParseFloat converts the string s to a floating-point number\nwith the precision specified by bitSize: 32 for float32, or 64 for float64.\nWhen bitSize=32, the result still has type float64, but it will be\nconvertible to float32 without changing its value.\n\nIf s is well-formed and near a valid floating point number,\nParseFloat returns the nearest floating point number rounded\nusing IEEE754 unbiased rounding.\n\nThe errors that ParseFloat returns have concrete type *NumError\nand include err.Num = s.\n\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but is more than 1/2 ULP\naway from the largest floating point number of the given size,\nParseFloat returns f = ±Inf, err.Err = ErrRange.\n\nGo return type: (float64, error)\n\nJoker return type: [ABEND042(cannot find typename strconv.float64) Error]"
;;   {:added "1.0"
;;    :go "parseFloat(s, bitSize)"}
;;   [^String s, ^Int bitSize])

JOKER FUNC strconv.ParseInt has:
(defn ParseInt
  "ParseInt interprets a string s in the given base (0, 2 to 36) and\nbit size (0 to 64) and returns the corresponding value i.\n\nIf base == 0, the base is implied by the string's prefix:\nbase 16 for \"0x\", base 8 for \"0\", and base 10 otherwise.\nFor bases 1, below 0 or above 36 an error is returned.\n\nThe bitSize argument specifies the integer type\nthat the result must fit into. Bit sizes 0, 8, 16, 32, and 64\ncorrespond to int, int8, int16, int32, and int64.\nFor a bitSize below 0 or above 64 an error is returned.\n\nThe errors that ParseInt returns have concrete type *NumError\nand include err.Num = s. If s is empty or contains invalid\ndigits, err.Err = ErrSyntax and the returned value is 0;\nif the value corresponding to s cannot be represented by a\nsigned integer of the given size, err.Err = ErrRange and the\nreturned value is the maximum magnitude integer of the\nappropriate bitSize and sign.\n\nGo return type: (i int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "parseInt(s, base, bitSize)"}
  [^String s, ^Int base, ^Int bitSize])

JOKER FUNC strconv.ParseUint has:
;; (defn ParseUint
;;   "ParseUint is like ParseInt but for unsigned numbers.\n\nGo return type: (uint64, error)\n\nJoker return type: [ABEND042(cannot find typename strconv.uint64) Error]"
;;   {:added "1.0"
;;    :go "parseUint(s, base, bitSize)"}
;;   [^String s, ^Int base, ^Int bitSize])

JOKER FUNC strconv.Quote has:
(defn ^String Quote
  "Quote returns a double-quoted Go string literal representing s. The\nreturned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\ncontrol characters and non-printable characters as defined by\nIsPrint.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Quote(s)"}
  [^String s])

JOKER FUNC strconv.QuoteRune has:
;; (defn ^String QuoteRune
;;   "QuoteRune returns a single-quoted Go character literal representing the\nrune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\nfor control characters and non-printable characters as defined by IsPrint.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRune(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/strconv/quote.go:150:18) r])

JOKER FUNC strconv.QuoteRuneToASCII has:
;; (defn ^String QuoteRuneToASCII
;;   "QuoteRuneToASCII returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsPrint.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRuneToASCII(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/strconv/quote.go:164:25) r])

JOKER FUNC strconv.QuoteRuneToGraphic has:
;; (defn ^String QuoteRuneToGraphic
;;   "QuoteRuneToGraphic returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsGraphic.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRuneToGraphic(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/strconv/quote.go:178:27) r])

JOKER FUNC strconv.QuoteToASCII has:
(defn ^String QuoteToASCII
  "QuoteToASCII returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsPrint.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToASCII(s)"}
  [^String s])

JOKER FUNC strconv.QuoteToGraphic has:
(defn ^String QuoteToGraphic
  "QuoteToGraphic returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsGraphic.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToGraphic(s)"}
  [^String s])

JOKER FUNC strconv.Unquote has:
(defn Unquote
  "Unquote interprets s as a single-quoted, double-quoted,\nor backquoted Go string literal, returning the string value\nthat s quotes.  (If s is single-quoted, it would be a Go\ncharacter literal; Unquote returns the corresponding\none-character string.)\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "unquote(s)"}
  [^String s])

JOKER FUNC strconv.UnquoteChar has:
;; (defn UnquoteChar
;;   "UnquoteChar decodes the first character or byte in the escaped string\nor character literal represented by the string s.\nIt returns four values:\n\n\t1) value, the decoded Unicode code point or byte value;\n\t2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n\t3) tail, the remainder of the string after the character; and\n\t4) an error that will be nil if the character is syntactically valid.\n\nThe second argument, quote, specifies the type of literal being parsed\nand therefore which escaped quote character is permitted.\nIf set to a single quote, it permits the sequence \\' and disallows unescaped '.\nIf set to a double quote, it permits \\\" and disallows unescaped \".\nIf set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\n\nGo return type: (value rune, multibyte bool, tail string, err error)\n\nJoker return type: [ABEND042(cannot find typename strconv.rune) Bool String Error]"
;;   {:added "1.0"
;;    :go "unquoteChar(s, quote)"}
;;   [^String s, ^Byte quote])

JOKER FUNC strings.Compare has:
(defn ^Int Compare
  "Compare returns an integer comparing two strings lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n\nCompare is included only for symmetry with package bytes.\nIt is usually clearer and always faster to use the built-in\nstring comparison operators ==, <, >, and so on.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Compare(a, b)"}
  [^String a, ^String b])

JOKER FUNC strings.Contains has:
(defn ^Bool Contains
  "Contains reports whether substr is within s.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.Contains(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.ContainsAny has:
(defn ^Bool ContainsAny
  "ContainsAny reports whether any Unicode code points in chars are within s.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.ContainsAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.ContainsRune has:
;; (defn ^Bool ContainsRune
;;   "ContainsRune reports whether the Unicode code point r is within s.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "strings.ContainsRune(s, r)"}
;;   [^String s, ^ABEND885(unrecognized type rune at: GO.link/src/strings/strings.go:108:31) r])

JOKER FUNC strings.Count has:
(defn ^Int Count
  "Count counts the number of non-overlapping instances of substr in s.\nIf substr is an empty string, Count returns 1 + the number of Unicode code points in s.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Count(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.EqualFold has:
(defn ^Bool EqualFold
  "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.EqualFold(s, t)"}
  [^String s, ^String t])

JOKER FUNC strings.Fields has:
(defn Fields
  "Fields splits the string s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of substrings of s or an\nempty slice if s contains only white space.\n\nGo return type: []string\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "fields(s)"}
  [^String s])

JOKER FUNC strings.FieldsFunc has:
;; (defn FieldsFunc
;;   "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\nand returns an array of slices of s. If all code points in s satisfy f(c) or the\nstring is empty, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo return type: []string\n\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "fieldsFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/strings/strings.go:378:29) f])

JOKER FUNC strings.HasPrefix has:
(defn ^Bool HasPrefix
  "HasPrefix tests whether the string s begins with prefix.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.HasPrefix(s, prefix)"}
  [^String s, ^String prefix])

JOKER FUNC strings.HasSuffix has:
(defn ^Bool HasSuffix
  "HasSuffix tests whether the string s ends with suffix.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.HasSuffix(s, suffix)"}
  [^String s, ^String suffix])

JOKER FUNC strings.Index has:
(defn ^Int Index
  "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Index(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.IndexAny has:
(defn ^Int IndexAny
  "IndexAny returns the index of the first instance of any Unicode code point\nfrom chars in s, or -1 if no Unicode code point from chars is present in s.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.IndexByte has:
(defn ^Int IndexByte
  "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexByte(s, c)"}
  [^String s, ^Byte c])

JOKER FUNC strings.IndexFunc has:
;; (defn ^Int IndexFunc
;;   "IndexFunc returns the index into s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.IndexFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/strings/strings.go:713:28) f])

JOKER FUNC strings.IndexRune has:
;; (defn ^Int IndexRune
;;   "IndexRune returns the index of the first instance of the Unicode code point\nr, or -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.IndexRune(s, r)"}
;;   [^String s, ^ABEND885(unrecognized type rune at: GO.link/src/strings/strings.go:153:28) r])

JOKER FUNC strings.Join has:
;; (defn ^String Join
;;   "Join concatenates the elements of a to create a single string. The separator string\nsep is placed between elements in the resulting string.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Join(a, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/strings/strings.go:420:13) a, ^String sep])

JOKER FUNC strings.LastIndex has:
(defn ^Int LastIndex
  "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndex(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.LastIndexAny has:
(defn ^Int LastIndexAny
  "LastIndexAny returns the index of the last instance of any Unicode code\npoint from chars in s, or -1 if no Unicode code point from chars is\npresent in s.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.LastIndexByte has:
(defn ^Int LastIndexByte
  "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexByte(s, c)"}
  [^String s, ^Byte c])

JOKER FUNC strings.LastIndexFunc has:
;; (defn ^Int LastIndexFunc
;;   "LastIndexFunc returns the index into s of the last\nUnicode code point satisfying f(c), or -1 if none do.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.LastIndexFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/strings/strings.go:719:32) f])

JOKER FUNC strings.Map has:
;; (defn ^String Map
;;   "Map returns a copy of the string s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the string with no replacement.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Map(mapping, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/strings/strings.go:462:18) mapping, ^String s])

JOKER FUNC strings.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from s.\nIt is similar to bytes.NewBufferString but more efficient and read-only.\n\nGo return type: *Reader\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newReader(s)"}
;;   [^String s])

JOKER FUNC strings.NewReplacer has:
;; (defn NewReplacer
;;   "NewReplacer returns a new Replacer from a list of old, new string\npairs. Replacements are performed in the order they appear in the\ntarget string, without overlapping matches.\n\nGo return type: *Replacer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newReplacer(oldnew)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/strings/replace.go:24:25) oldnew])

JOKER FUNC strings.Repeat has:
(defn ^String Repeat
  "Repeat returns a new string consisting of count copies of the string s.\n\nIt panics if count is negative or if\nthe result of (len(s) * count) overflows.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Repeat(s, count)"}
  [^String s, ^Int count])

JOKER FUNC strings.Replace has:
(defn ^String Replace
  "Replace returns a copy of the string s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the string\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune string.\nIf n < 0, there is no limit on the number of replacements.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Replace(s, old, new, n)"}
  [^String s, ^String old, ^String new, ^Int n])

JOKER FUNC strings.Split has:
(defn Split
  "Split slices s into all substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nIf s does not contain sep and sep is not empty, Split returns a\nslice of length 1 whose only element is s.\n\nIf sep is empty, Split splits after each UTF-8 sequence. If both s\nand sep are empty, Split returns an empty slice.\n\nIt is equivalent to SplitN with a count of -1.\n\nGo return type: []string\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "split(s, sep)"}
  [^String s, ^String sep])

JOKER FUNC strings.SplitAfter has:
(defn SplitAfter
  "SplitAfter slices s into all substrings after each instance of sep and\nreturns a slice of those substrings.\n\nIf s does not contain sep and sep is not empty, SplitAfter returns\na slice of length 1 whose only element is s.\n\nIf sep is empty, SplitAfter splits after each UTF-8 sequence. If\nboth s and sep are empty, SplitAfter returns an empty slice.\n\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo return type: []string\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitAfter(s, sep)"}
  [^String s, ^String sep])

JOKER FUNC strings.SplitAfterN has:
(defn SplitAfterN
  "SplitAfterN slices s into substrings after each instance of sep and\nreturns a slice of those substrings.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for SplitAfter.\n\nGo return type: []string\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitAfterN(s, sep, n)"}
  [^String s, ^String sep, ^Int n])

JOKER FUNC strings.SplitN has:
(defn SplitN
  "SplitN slices s into substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for Split.\n\nGo return type: []string\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitN(s, sep, n)"}
  [^String s, ^String sep, ^Int n])

JOKER FUNC strings.Title has:
(defn ^String Title
  "Title returns a copy of the string s with all Unicode letters that begin words\nmapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Title(s)"}
  [^String s])

JOKER FUNC strings.ToLower has:
(defn ^String ToLower
  "ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToLower(s)"}
  [^String s])

JOKER FUNC strings.ToLowerSpecial has:
;; (defn ^String ToLowerSpecial
;;   "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToLowerSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/strings/strings.go:626:23) c, ^String s])

JOKER FUNC strings.ToTitle has:
(defn ^String ToTitle
  "ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToTitle(s)"}
  [^String s])

JOKER FUNC strings.ToTitleSpecial has:
;; (defn ^String ToTitleSpecial
;;   "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToTitleSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/strings/strings.go:632:23) c, ^String s])

JOKER FUNC strings.ToUpper has:
(defn ^String ToUpper
  "ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToUpper(s)"}
  [^String s])

JOKER FUNC strings.ToUpperSpecial has:
;; (defn ^String ToUpperSpecial
;;   "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToUpperSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/strings/strings.go:620:23) c, ^String s])

JOKER FUNC strings.Trim has:
(defn ^String Trim
  "Trim returns a slice of the string s with all leading and\ntrailing Unicode code points contained in cutset removed.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Trim(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimFunc has:
;; (defn ^String TrimFunc
;;   "TrimFunc returns a slice of the string s with all leading\nand trailing Unicode code points c satisfying f(c) removed.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/strings/strings.go:707:27) f])

JOKER FUNC strings.TrimLeft has:
(defn ^String TrimLeft
  "TrimLeft returns a slice of the string s with all leading\nUnicode code points contained in cutset removed.\n\nTo remove a prefix, use TrimPrefix instead.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimLeft(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimLeftFunc has:
;; (defn ^String TrimLeftFunc
;;   "TrimLeftFunc returns a slice of the string s with all leading\nUnicode code points c satisfying f(c) removed.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimLeftFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/strings/strings.go:684:31) f])

JOKER FUNC strings.TrimPrefix has:
(defn ^String TrimPrefix
  "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimPrefix(s, prefix)"}
  [^String s, ^String prefix])

JOKER FUNC strings.TrimRight has:
(defn ^String TrimRight
  "TrimRight returns a slice of the string s, with all trailing\nUnicode code points contained in cutset removed.\n\nTo remove a suffix, use TrimSuffix instead.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimRight(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimRightFunc has:
;; (defn ^String TrimRightFunc
;;   "TrimRightFunc returns a slice of the string s with all trailing\nUnicode code points c satisfying f(c) removed.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimRightFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/strings/strings.go:694:32) f])

JOKER FUNC strings.TrimSpace has:
(defn ^String TrimSpace
  "TrimSpace returns a slice of the string s, with all leading\nand trailing white space removed, as defined by Unicode.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSpace(s)"}
  [^String s])

JOKER FUNC strings.TrimSuffix has:
(defn ^String TrimSuffix
  "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSuffix(s, suffix)"}
  [^String s, ^String suffix])

JOKER FUNC subtle.ConstantTimeByteEq has:
;; (defn ^Int ConstantTimeByteEq
;;   "ConstantTimeByteEq returns 1 if x == y and 0 otherwise.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "subtle.ConstantTimeByteEq(x, y)"}
;;   [^ABEND885(unrecognized type uint8 at: GO.link/src/crypto/subtle/constant_time.go:31:30) x, ^ABEND885(unrecognized type uint8 at: GO.link/src/crypto/subtle/constant_time.go:31:30) y])

JOKER FUNC subtle.ConstantTimeCompare has:
;; (defn ^Int ConstantTimeCompare
;;   "ConstantTimeCompare returns 1 if and only if the two slices, x\nand y, have equal contents. The time taken is a function of the length of\nthe slices and is independent of the contents.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "subtle.ConstantTimeCompare(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/subtle/constant_time.go:12:31) x, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/subtle/constant_time.go:12:31) y])

JOKER FUNC subtle.ConstantTimeCopy has:
;; (defn ConstantTimeCopy
;;   "ConstantTimeCopy copies the contents of y into x (a slice of equal length)\nif v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v\ntakes any other value.\n"
;;   {:added "1.0"
;;    :go "constantTimeCopy(v, x, y)"}
;;   [^Int v, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/subtle/constant_time.go:43:35) x, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/subtle/constant_time.go:43:35) y])

JOKER FUNC subtle.ConstantTimeEq has:
(defn ^Int ConstantTimeEq
  "ConstantTimeEq returns 1 if x == y and 0 otherwise.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeEq(x, y)"}
  [^Int x, ^Int y])

JOKER FUNC subtle.ConstantTimeLessOrEq has:
(defn ^Int ConstantTimeLessOrEq
  "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise.\nIts behavior is undefined if x or y are negative or > 2**31 - 1.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeLessOrEq(x, y)"}
  [^Int x, ^Int y])

JOKER FUNC subtle.ConstantTimeSelect has:
(defn ^Int ConstantTimeSelect
  "ConstantTimeSelect returns x if v is 1 and y if v is 0.\nIts behavior is undefined if v takes any other value.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeSelect(v, x, y)"}
  [^Int v, ^Int x, ^Int y])

JOKER FUNC suffixarray.New has:
;; (defn New
;;   "New creates a new Index for data.\nIndex creation time is O(N*log(N)) for N = len(data).\n\nGo return type: *Index\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "new(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/index/suffixarray/suffixarray.go:35:15) data])

JOKER FUNC sync.NewCond has:
;; (defn NewCond
;;   "NewCond returns a new Cond with Locker l.\n\nGo return type: *Cond\n\nJoker return type: {:L ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/sync/mutex.go:31:13)}"
;;   {:added "1.0"
;;    :go "newCond(l)"}
;;   [^ABEND885(unrecognized type Locker at: GO.link/src/sync/cond.go:32:16) l])

JOKER FUNC syntax.Compile has:
;; (defn Compile
;;   "Compile compiles the regexp into a program to be executed.\nThe regexp should have been simplified already (returned from re.Simplify).\n\nGo return type: (*Prog, error)\n\nJoker return type: [{:Inst ^(vector-of {:Op ^ABEND042(cannot find typename syntax.uint8), :Out ^Int, :Arg ^Int, :Rune ^(vector-of ABEND042(cannot find typename syntax.rune))}), :Start ^Int, :NumCap ^Int} Error]"
;;   {:added "1.0"
;;    :go "compile(re)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/regexp/syntax/compile.go:80:17) re])

JOKER FUNC syntax.EmptyOpContext has:
;; (defn EmptyOpContext
;;   "EmptyOpContext returns the zero-width assertions\nsatisfied at the position between the runes r1 and r2.\nPassing r1 == -1 indicates that the position is\nat the beginning of the text.\nPassing r2 == -1 indicates that the position is\nat the end of the text.\n\nGo return type: EmptyOp\n\nJoker return type: ABEND042(cannot find typename syntax.uint8)"
;;   {:added "1.0"
;;    :go "emptyOpContext(r1, r2)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/regexp/syntax/prog.go:79:28) r1, ^ABEND885(unrecognized type rune at: GO.link/src/regexp/syntax/prog.go:79:28) r2])

JOKER FUNC syntax.IsWordChar has:
;; (defn ^Bool IsWordChar
;;   "IsWordChar reports whether r is consider a ``word character''\nduring the evaluation of the \\b and \\B zero-width assertions.\nThese assertions are ASCII-only: the word characters are [A-Za-z0-9_].\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "syntax.IsWordChar(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/regexp/syntax/prog.go:107:19) r])

JOKER FUNC syntax.Parse has:
;; (defn Parse
;;   "Parse parses a regular expression string s, controlled by the specified\nFlags, and returns a regular expression parse tree. The syntax is\ndescribed in the top-level comment.\n\nGo return type: (*Regexp, error)\n\nJoker return type: [{:Op ^ABEND042(cannot find typename syntax.uint8), :Flags ^Int, :Sub ^(vector-of ABEND947(recursive type reference involving syntax.Regexp)), :Sub0 ^(vector-of ABEND947(recursive type reference involving syntax.Regexp)), :Rune ^(vector-of ABEND042(cannot find typename syntax.rune)), :Rune0 ^(vector-of ABEND042(cannot find typename syntax.rune)), :Min ^Int, :Max ^Int, :Cap ^Int, :Name ^String} Error]"
;;   {:added "1.0"
;;    :go "parse(s, flags)"}
;;   [^String s, ^ABEND885(unrecognized type Flags at: GO.link/src/regexp/syntax/parse.go:701:28) flags])

JOKER FUNC syscall.Accept has:
;; (defn Accept
;;   "Go return type: (nfd int, sa Sockaddr, err error)\n\nJoker return type: [Int ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "accept(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.Access has:
(defn ^Error Access
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Access(path, mode)"}
  [^String path, ^Int mode])

JOKER FUNC syscall.Adjtime has:
;; (defn ^Error Adjtime
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Adjtime(delta, olddelta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:311:20) delta, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:311:39) olddelta])

JOKER FUNC syscall.Bind has:
;; (defn ^Error Bind
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Bind(fd, sa)"}
;;   [^Int fd, ^ABEND885(unrecognized type Sockaddr at: GO.link/src/syscall/syscall_unix.go:227:22) sa])

JOKER FUNC syscall.BpfBuflen has:
(defn BpfBuflen
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: (int, error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "bpfBuflen(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfDatalink has:
(defn BpfDatalink
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: (int, error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "bpfDatalink(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfHeadercmpl has:
(defn BpfHeadercmpl
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: (int, error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "bpfHeadercmpl(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfInterface has:
(defn BpfInterface
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "bpfInterface(fd, name)"}
  [^Int fd, ^String name])

JOKER FUNC syscall.BpfJump has:
;; (defn BpfJump
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: *BpfInsn\n\nJoker return type: {:Code ^Int, :Jt ^ABEND042(cannot find typename syscall.uint8), :Jf ^ABEND042(cannot find typename syscall.uint8), :K ^Int}"
;;   {:added "1.0"
;;    :go "bpfJump(code, k, jt, jf)"}
;;   [^Int code, ^Int k, ^Int jt, ^Int jf])

JOKER FUNC syscall.BpfStats has:
(defn BpfStats
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: (*BpfStat, error)\n\nJoker return type: [{:Recv ^Int, :Drop ^Int} Error]"
  {:added "1.0"
   :go "bpfStats(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfStmt has:
;; (defn BpfStmt
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: *BpfInsn\n\nJoker return type: {:Code ^Int, :Jt ^ABEND042(cannot find typename syscall.uint8), :Jf ^ABEND042(cannot find typename syscall.uint8), :K ^Int}"
;;   {:added "1.0"
;;    :go "bpfStmt(code, k)"}
;;   [^Int code, ^Int k])

JOKER FUNC syscall.BpfTimeout has:
(defn BpfTimeout
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: (*Timeval, error)\n\nJoker return type: [{:Sec ^Int, :Usec ^Int, :Pad_cgo_0 ^(vector-of Int)} Error]"
  {:added "1.0"
   :go "bpfTimeout(fd)"}
  [^Int fd])

JOKER FUNC syscall.BytePtrFromString has:
(defn BytePtrFromString
  "BytePtrFromString returns a pointer to a NUL-terminated array of\nbytes containing the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo return type: (*int, error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "bytePtrFromString(s)"}
  [^String s])

JOKER FUNC syscall.ByteSliceFromString has:
(defn ByteSliceFromString
  "ByteSliceFromString returns a NUL-terminated slice of bytes\ncontaining the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "byteSliceFromString(s)"}
  [^String s])

JOKER FUNC syscall.Chdir has:
(defn ^Error Chdir
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chdir(path)"}
  [^String path])

JOKER FUNC syscall.CheckBpfVersion has:
(defn ^Error CheckBpfVersion
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.CheckBpfVersion(fd)"}
  [^Int fd])

JOKER FUNC syscall.Chflags has:
(defn ^Error Chflags
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chflags(path, flags)"}
  [^String path, ^Int flags])

JOKER FUNC syscall.Chmod has:
(defn ^Error Chmod
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chmod(path, mode)"}
  [^String path, ^Int mode])

JOKER FUNC syscall.Chown has:
(defn ^Error Chown
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chown(path, uid, gid)"}
  [^String path, ^Int uid, ^Int gid])

JOKER FUNC syscall.Chroot has:
(defn ^Error Chroot
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chroot(path)"}
  [^String path])

JOKER FUNC syscall.Clearenv has:
;; (defn Clearenv
;;   ""
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])

JOKER FUNC syscall.Close has:
(defn ^Error Close
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Close(fd)"}
  [^Int fd])

JOKER FUNC syscall.CloseOnExec has:
;; (defn CloseOnExec
;;   ""
;;   {:added "1.0"
;;    :go "closeOnExec(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.CmsgLen has:
(defn ^Int CmsgLen
  "CmsgLen returns the value to store in the Len field of the Cmsghdr\nstructure, taking into account any necessary alignment.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgLen(datalen)"}
  [^Int datalen])

JOKER FUNC syscall.CmsgSpace has:
(defn ^Int CmsgSpace
  "CmsgSpace returns the number of bytes an ancillary element with\npayload of the passed data length occupies.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgSpace(datalen)"}
  [^Int datalen])

JOKER FUNC syscall.Connect has:
;; (defn ^Error Connect
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Connect(fd, sa)"}
;;   [^Int fd, ^ABEND885(unrecognized type Sockaddr at: GO.link/src/syscall/syscall_unix.go:235:25) sa])

JOKER FUNC syscall.Dup has:
(defn Dup
  "Go return type: (nfd int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "dup(fd)"}
  [^Int fd])

JOKER FUNC syscall.Dup2 has:
(defn ^Error Dup2
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Dup2(from, to)"}
  [^Int from, ^Int to])

JOKER FUNC syscall.Environ has:
(defn Environ
  "Go return type: []string\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "environ()"}
  [])

JOKER FUNC syscall.Exchangedata has:
(defn ^Error Exchangedata
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Exchangedata(path1, path2, options)"}
  [^String path1, ^String path2, ^Int options])

JOKER FUNC syscall.Exec has:
;; (defn ^Error Exec
;;   "Exec invokes the execve(2) system call.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Exec(argv0, argv, envv)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/exec_unix.go:254:30) argv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/exec_unix.go:254:45) envv])

JOKER FUNC syscall.Exit has:
;; (defn Exit
;;   ""
;;   {:added "1.0"
;;    :go "exit(code)"}
;;   [^Int code])

JOKER FUNC syscall.Fchdir has:
(defn ^Error Fchdir
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchdir(fd)"}
  [^Int fd])

JOKER FUNC syscall.Fchflags has:
(defn ^Error Fchflags
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchflags(fd, flags)"}
  [^Int fd, ^Int flags])

JOKER FUNC syscall.Fchmod has:
(defn ^Error Fchmod
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchmod(fd, mode)"}
  [^Int fd, ^Int mode])

JOKER FUNC syscall.Fchown has:
(defn ^Error Fchown
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchown(fd, uid, gid)"}
  [^Int fd, ^Int uid, ^Int gid])

JOKER FUNC syscall.FcntlFlock has:
;; (defn ^Error FcntlFlock
;;   "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.FcntlFlock(fd, cmd, lk)"}
;;   [^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/flock.go:16:20) fd, ^Int cmd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/flock.go:16:41) lk])

JOKER FUNC syscall.Flock has:
(defn ^Error Flock
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Flock(fd, how)"}
  [^Int fd, ^Int how])

JOKER FUNC syscall.FlushBpf has:
(defn ^Error FlushBpf
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.FlushBpf(fd)"}
  [^Int fd])

JOKER FUNC syscall.ForkExec has:
;; (defn ForkExec
;;   "Combination of fork and exec, careful to be thread safe.\n\nGo return type: (pid int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "forkExec(argv0, argv, attr)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/exec_unix.go:235:34) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/exec_unix.go:235:49) attr])

JOKER FUNC syscall.Fpathconf has:
(defn Fpathconf
  "Go return type: (val int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "fpathconf(fd, name)"}
  [^Int fd, ^Int name])

JOKER FUNC syscall.Fstat has:
;; (defn ^Error Fstat
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Fstat(fd, stat)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:508:25) stat])

JOKER FUNC syscall.Fstatfs has:
;; (defn ^Error Fstatfs
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Fstatfs(fd, stat)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:518:27) stat])

JOKER FUNC syscall.Fsync has:
(defn ^Error Fsync
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fsync(fd)"}
  [^Int fd])

JOKER FUNC syscall.Ftruncate has:
(defn ^Error Ftruncate
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ftruncate(fd, length)"}
  [^Int fd, ^Int length])

JOKER FUNC syscall.Futimes has:
;; (defn ^Error Futimes
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Futimes(fd, tv)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:533:25) tv])

JOKER FUNC syscall.Getdirentries has:
;; (defn Getdirentries
;;   "Go return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "getdirentries(fd, buf, basep)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:548:32) buf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:548:46) basep])

JOKER FUNC syscall.Getdtablesize has:
(defn ^Int Getdtablesize
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getdtablesize()"}
  [])

JOKER FUNC syscall.Getegid has:
(defn ^Int Getegid
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getegid()"}
  [])

JOKER FUNC syscall.Getenv has:
(defn Getenv
  "Go return type: (value string, found bool)\n\nJoker return type: [String Bool]"
  {:added "1.0"
   :go "getenv(key)"}
  [^String key])

JOKER FUNC syscall.Geteuid has:
(defn ^Int Geteuid
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Geteuid()"}
  [])

JOKER FUNC syscall.Getfsstat has:
;; (defn Getfsstat
;;   "Go return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "getfsstat(buf, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_darwin.go:176:20) buf, ^Int flags])

JOKER FUNC syscall.Getgid has:
(defn ^Int Getgid
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getgid()"}
  [])

JOKER FUNC syscall.Getgroups has:
(defn Getgroups
  "Go return type: (gids []int, err error)\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "getgroups()"}
  [])

JOKER FUNC syscall.Getpagesize has:
(defn ^Int Getpagesize
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpagesize()"}
  [])

JOKER FUNC syscall.Getpeername has:
;; (defn Getpeername
;;   "Go return type: (sa Sockaddr, err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "getpeername(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.Getpgid has:
(defn Getpgid
  "Go return type: (pgid int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getpgid(pid)"}
  [^Int pid])

JOKER FUNC syscall.Getpgrp has:
(defn ^Int Getpgrp
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpgrp()"}
  [])

JOKER FUNC syscall.Getpid has:
(defn ^Int Getpid
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpid()"}
  [])

JOKER FUNC syscall.Getppid has:
(defn ^Int Getppid
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getppid()"}
  [])

JOKER FUNC syscall.Getpriority has:
(defn Getpriority
  "Go return type: (prio int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getpriority(which, who)"}
  [^Int which, ^Int who])

JOKER FUNC syscall.Getrlimit has:
;; (defn ^Error Getrlimit
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Getrlimit(which, lim)"}
;;   [^Int which, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:643:31) lim])

JOKER FUNC syscall.Getrusage has:
;; (defn ^Error Getrusage
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Getrusage(who, rusage)"}
;;   [^Int who, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:653:32) rusage])

JOKER FUNC syscall.Getsid has:
(defn Getsid
  "Go return type: (sid int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getsid(pid)"}
  [^Int pid])

JOKER FUNC syscall.Getsockname has:
;; (defn Getsockname
;;   "Go return type: (sa Sockaddr, err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "getsockname(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.GetsockoptByte has:
(defn GetsockoptByte
  "Go return type: (value int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getsockoptByte(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptICMPv6Filter has:
(defn GetsockoptICMPv6Filter
  "Go return type: (*ICMPv6Filter, error)\n\nJoker return type: [{:Filt ^(vector-of Int)} Error]"
  {:added "1.0"
   :go "getsockoptICMPv6Filter(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPMreq has:
(defn GetsockoptIPMreq
  "Go return type: (*IPMreq, error)\n\nJoker return type: [{:Multiaddr ^(vector-of Int), :Interface ^(vector-of Int)} Error]"
  {:added "1.0"
   :go "getsockoptIPMreq(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPv6MTUInfo has:
;; (defn GetsockoptIPv6MTUInfo
;;   "Go return type: (*IPv6MTUInfo, error)\n\nJoker return type: [{:Addr ^{:Len ^ABEND042(cannot find typename syscall.uint8), :Family ^ABEND042(cannot find typename syscall.uint8), :Port ^Int, :Flowinfo ^Int, :Addr ^(vector-of Int), :Scope_id ^Int}, :Mtu ^Int} Error]"
;;   {:added "1.0"
;;    :go "getsockoptIPv6MTUInfo(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPv6Mreq has:
(defn GetsockoptIPv6Mreq
  "Go return type: (*IPv6Mreq, error)\n\nJoker return type: [{:Multiaddr ^(vector-of Int), :Interface ^Int} Error]"
  {:added "1.0"
   :go "getsockoptIPv6Mreq(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptInet4Addr has:
(defn GetsockoptInet4Addr
  "Go return type: (value []int, err error)\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "getsockoptInet4Addr(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptInt has:
(defn GetsockoptInt
  "Go return type: (value int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getsockoptInt(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.Gettimeofday has:
;; (defn ^Error Gettimeofday
;;   "sysnb\tgettimeofday(tp *Timeval) (sec int64, usec int32, err error)\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Gettimeofday(tv)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_darwin_amd64.go:18:22) tv])

JOKER FUNC syscall.Getuid has:
(defn ^Int Getuid
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getuid()"}
  [])

JOKER FUNC syscall.Getwd has:
(defn Getwd
  "Go return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "getwd()"}
  [])

JOKER FUNC syscall.Issetugid has:
(defn ^Bool Issetugid
  "Go return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "syscall.Issetugid()"}
  [])

JOKER FUNC syscall.Kevent has:
;; (defn Kevent
;;   "Go return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "kevent(kq, changes, events, timeout)"}
;;   [^Int kq, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:439:37) changes, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:439:37) events, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_bsd.go:439:57) timeout])

JOKER FUNC syscall.Kill has:
;; (defn ^Error Kill
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Kill(pid, signum)"}
;;   [^Int pid, ^ABEND885(unrecognized type Signal at: GO.link/src/syscall/syscall_darwin.go:230:27) signum])

JOKER FUNC syscall.Kqueue has:
(defn Kqueue
  "Go return type: (fd int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "kqueue()"}
  [])

JOKER FUNC syscall.Lchown has:
(defn ^Error Lchown
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Lchown(path, uid, gid)"}
  [^String path, ^Int uid, ^Int gid])

JOKER FUNC syscall.Link has:
(defn ^Error Link
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Link(path, link)"}
  [^String path, ^String link])

JOKER FUNC syscall.Listen has:
(defn ^Error Listen
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Listen(s, backlog)"}
  [^Int s, ^Int backlog])

JOKER FUNC syscall.Lstat has:
;; (defn ^Error Lstat
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Lstat(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:746:30) stat])

JOKER FUNC syscall.Mkdir has:
(defn ^Error Mkdir
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkdir(path, mode)"}
  [^String path, ^Int mode])

JOKER FUNC syscall.Mkfifo has:
(defn ^Error Mkfifo
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkfifo(path, mode)"}
  [^String path, ^Int mode])

JOKER FUNC syscall.Mknod has:
(defn ^Error Mknod
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mknod(path, mode, dev)"}
  [^String path, ^Int mode, ^Int dev])

JOKER FUNC syscall.Mlock has:
;; (defn ^Error Mlock
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:806:14) b])

JOKER FUNC syscall.Mlockall has:
(defn ^Error Mlockall
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mlockall(flags)"}
  [^Int flags])

JOKER FUNC syscall.Mmap has:
(defn Mmap
  "Go return type: (data []int, err error)\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "mmap(fd, offset, length, prot, flags)"}
  [^Int fd, ^Int offset, ^Int length, ^Int prot, ^Int flags])

JOKER FUNC syscall.Mprotect has:
;; (defn ^Error Mprotect
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mprotect(b, prot)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:832:17) b, ^Int prot])

JOKER FUNC syscall.Munlock has:
;; (defn ^Error Munlock
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Munlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:848:16) b])

JOKER FUNC syscall.Munlockall has:
(defn ^Error Munlockall
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Munlockall()"}
  [])

JOKER FUNC syscall.Munmap has:
;; (defn ^Error Munmap
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Munmap(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:552:15) b])

JOKER FUNC syscall.NsecToTimespec has:
(defn NsecToTimespec
  "NsecToTimespec takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timespec value.\n\nGo return type: Timespec\n\nJoker return type: {:Sec ^Int, :Nsec ^Int}"
  {:added "1.0"
   :go "nsecToTimespec(nsec)"}
  [^Int nsec])

JOKER FUNC syscall.NsecToTimeval has:
(defn NsecToTimeval
  "NsecToTimeval takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timeval value.\n\nGo return type: Timeval\n\nJoker return type: {:Sec ^Int, :Usec ^Int, :Pad_cgo_0 ^(vector-of Int)}"
  {:added "1.0"
   :go "nsecToTimeval(nsec)"}
  [^Int nsec])

JOKER FUNC syscall.Open has:
(defn Open
  "Go return type: (fd int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "open(path, mode, perm)"}
  [^String path, ^Int mode, ^Int perm])

JOKER FUNC syscall.ParseDirent has:
;; (defn ParseDirent
;;   "ParseDirent parses up to max directory entries in buf,\nappending the names to names. It returns the number of\nbytes consumed from buf, the number of entries added\nto names, and the new names slice.\n\nGo return type: (consumed int, count int, newnames []string)\n\nJoker return type: [Int Int (vector-of String)]"
;;   {:added "1.0"
;;    :go "parseDirent(buf, max, names)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/dirent.go:64:22) buf, ^Int max, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/dirent.go:64:45) names])

JOKER FUNC syscall.ParseRoutingMessage has:
;; (defn ParseRoutingMessage
;;   "ParseRoutingMessage parses b as routing messages and returns the\nslice containing the RoutingMessage interfaces.\n\nDeprecated: Use golang.org/x/net/route instead.\n\nGo return type: (msgs []RoutingMessage, err error)\n\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/route_bsd.go:201:21)) Error]"
;;   {:added "1.0"
;;    :go "parseRoutingMessage(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/route_bsd.go:331:28) b])

JOKER FUNC syscall.ParseRoutingSockaddr has:
;; (defn ParseRoutingSockaddr
;;   "ParseRoutingSockaddr parses msg's payload as raw sockaddrs and\nreturns the slice containing the Sockaddr interfaces.\n\nDeprecated: Use golang.org/x/net/route instead.\n\nGo return type: ([]Sockaddr, error)\n\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15)) Error]"
;;   {:added "1.0"
;;    :go "parseRoutingSockaddr(msg)"}
;;   [^ABEND885(unrecognized type RoutingMessage at: GO.link/src/syscall/route_bsd.go:358:31) msg])

JOKER FUNC syscall.ParseSocketControlMessage has:
;; (defn ParseSocketControlMessage
;;   "ParseSocketControlMessage parses b as an array of socket control\nmessages.\n\nGo return type: ([]SocketControlMessage, error)\n\nJoker return type: [(vector-of {:Header ^{:Len ^Int, :Level ^Int, :Type ^Int}, :Data ^(vector-of Int)}) Error]"
;;   {:added "1.0"
;;    :go "parseSocketControlMessage(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/sockcmsg_unix.go:49:34) b])

JOKER FUNC syscall.ParseUnixRights has:
;; (defn ParseUnixRights
;;   "ParseUnixRights decodes a socket control message that contains an\ninteger array of open file descriptors from another process.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "parseUnixRights(m)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/sockcmsg_unix.go:91:24) m])

JOKER FUNC syscall.Pathconf has:
(defn Pathconf
  "Go return type: (val int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "pathconf(path, name)"}
  [^String path, ^Int name])

JOKER FUNC syscall.Pipe has:
;; (defn ^Error Pipe
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Pipe(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_darwin.go:168:13) p])

JOKER FUNC syscall.Pread has:
;; (defn Pread
;;   "Go return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "pread(fd, p, offset)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:906:22) p, ^Int offset])

JOKER FUNC syscall.PtraceAttach has:
(defn ^Error PtraceAttach
  "sys   ptrace(request int, pid int, addr uintptr, data uintptr) (err error)\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceAttach(pid)"}
  [^Int pid])

JOKER FUNC syscall.PtraceDetach has:
(defn ^Error PtraceDetach
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceDetach(pid)"}
  [^Int pid])

JOKER FUNC syscall.Pwrite has:
;; (defn Pwrite
;;   "Go return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "pwrite(fd, p, offset)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:923:23) p, ^Int offset])

JOKER FUNC syscall.RawSyscall has:
;; (defn RawSyscall
;;   "Go return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker return type: [ABEND042(cannot find typename syscall.uintptr) ABEND042(cannot find typename syscall.uintptr) ABEND042(cannot find typename syscall.uintptr)]"
;;   {:added "1.0"
;;    :go "rawSyscall(trap, a1, a2, a3)"}
;;   [^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:31:34) trap, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:31:34) a1, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:31:34) a2, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:31:34) a3])

JOKER FUNC syscall.RawSyscall6 has:
;; (defn RawSyscall6
;;   "Go return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker return type: [ABEND042(cannot find typename syscall.uintptr) ABEND042(cannot find typename syscall.uintptr) ABEND042(cannot find typename syscall.uintptr)]"
;;   {:added "1.0"
;;    :go "rawSyscall6(trap, a1, a2, a3, a4, a5, a6)"}
;;   [^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47) trap, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47) a1, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47) a2, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47) a3, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47) a4, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47) a5, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47) a6])

JOKER FUNC syscall.Read has:
;; (defn Read
;;   "Go return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "read(fd, p)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_unix.go:171:21) p])

JOKER FUNC syscall.ReadDirent has:
;; (defn ReadDirent
;;   "Go return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readDirent(fd, buf)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:65:29) buf])

JOKER FUNC syscall.Readlink has:
;; (defn Readlink
;;   "Go return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readlink(path, buf)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:957:32) buf])

JOKER FUNC syscall.Recvfrom has:
;; (defn Recvfrom
;;   "Go return type: (n int, from Sockaddr, err error)\n\nJoker return type: [Int ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "recvfrom(fd, p, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_unix.go:259:25) p, ^Int flags])

JOKER FUNC syscall.Recvmsg has:
;; (defn Recvmsg
;;   "Go return type: (n int, oobn int, recvflags int, from Sockaddr, err error)\n\nJoker return type: [Int Int Int ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "recvmsg(fd, p, oob, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:358:29) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:358:29) oob, ^Int flags])

JOKER FUNC syscall.Rename has:
(defn ^Error Rename
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rename(from, to)"}
  [^String from, ^String to])

JOKER FUNC syscall.Revoke has:
(defn ^Error Revoke
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Revoke(path)"}
  [^String path])

JOKER FUNC syscall.Rmdir has:
(defn ^Error Rmdir
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rmdir(path)"}
  [^String path])

JOKER FUNC syscall.RouteRIB has:
(defn RouteRIB
  "RouteRIB returns routing information base, as known as RIB,\nwhich consists of network facility information, states and\nparameters.\n\nDeprecated: Use golang.org/x/net/route instead.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "routeRIB(facility, param)"}
  [^Int facility, ^Int param])

JOKER FUNC syscall.Seek has:
(defn Seek
  "Go return type: (newoffset int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "seek(fd, offset, whence)"}
  [^Int fd, ^Int offset, ^Int whence])

JOKER FUNC syscall.Select has:
;; (defn ^Error Select
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Select(n, r, w, e, timeout)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:1040:22) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:1040:32) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:1040:42) e, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:1040:58) timeout])

JOKER FUNC syscall.Sendfile has:
;; (defn Sendfile
;;   "Go return type: (written int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sendfile(outfd, infd, offset, count)"}
;;   [^Int outfd, ^Int infd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_unix.go:334:43) offset, ^Int count])

JOKER FUNC syscall.Sendmsg has:
;; (defn ^Error Sendmsg
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendmsg(fd, p, oob, to, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:394:29) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:394:29) oob, ^ABEND885(unrecognized type Sockaddr at: GO.link/src/syscall/syscall_bsd.go:394:40) to, ^Int flags])

JOKER FUNC syscall.SendmsgN has:
;; (defn SendmsgN
;;   "Go return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sendmsgN(fd, p, oob, to, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:399:30) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:399:30) oob, ^ABEND885(unrecognized type Sockaddr at: GO.link/src/syscall/syscall_bsd.go:399:41) to, ^Int flags])

JOKER FUNC syscall.Sendto has:
;; (defn ^Error Sendto
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendto(fd, p, flags, to)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_unix.go:271:23) p, ^Int flags, ^ABEND885(unrecognized type Sockaddr at: GO.link/src/syscall/syscall_unix.go:271:45) to])

JOKER FUNC syscall.SetBpf has:
;; (defn ^Error SetBpf
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetBpf(fd, i)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/bpf_bsd.go:146:23) i])

JOKER FUNC syscall.SetBpfBuflen has:
(defn SetBpfBuflen
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: (int, error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "setBpfBuflen(fd, l)"}
  [^Int fd, ^Int l])

JOKER FUNC syscall.SetBpfDatalink has:
(defn SetBpfDatalink
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: (int, error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "setBpfDatalink(fd, t)"}
  [^Int fd, ^Int t])

JOKER FUNC syscall.SetBpfHeadercmpl has:
(defn ^Error SetBpfHeadercmpl
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfHeadercmpl(fd, f)"}
  [^Int fd, ^Int f])

JOKER FUNC syscall.SetBpfImmediate has:
(defn ^Error SetBpfImmediate
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfImmediate(fd, m)"}
  [^Int fd, ^Int m])

JOKER FUNC syscall.SetBpfInterface has:
(defn ^Error SetBpfInterface
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfInterface(fd, name)"}
  [^Int fd, ^String name])

JOKER FUNC syscall.SetBpfPromisc has:
(defn ^Error SetBpfPromisc
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfPromisc(fd, m)"}
  [^Int fd, ^Int m])

JOKER FUNC syscall.SetBpfTimeout has:
;; (defn ^Error SetBpfTimeout
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetBpfTimeout(fd, tv)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/bpf_bsd.go:118:31) tv])

JOKER FUNC syscall.SetKevent has:
;; (defn SetKevent
;;   ""
;;   {:added "1.0"
;;    :go "setKevent(k, fd, mode, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_darwin_amd64.go:35:18) k, ^Int fd, ^Int mode, ^Int flags])

JOKER FUNC syscall.SetNonblock has:
(defn ^Error SetNonblock
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetNonblock(fd, nonblocking)"}
  [^Int fd, ^Bool nonblocking])

JOKER FUNC syscall.Setegid has:
(defn ^Error Setegid
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setegid(egid)"}
  [^Int egid])

JOKER FUNC syscall.Setenv has:
(defn ^Error Setenv
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setenv(key, value)"}
  [^String key, ^String value])

JOKER FUNC syscall.Seteuid has:
(defn ^Error Seteuid
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Seteuid(euid)"}
  [^Int euid])

JOKER FUNC syscall.Setgid has:
(defn ^Error Setgid
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setgid(gid)"}
  [^Int gid])

JOKER FUNC syscall.Setgroups has:
;; (defn ^Error Setgroups
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setgroups(gids)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:53:21) gids])

JOKER FUNC syscall.Setlogin has:
(defn ^Error Setlogin
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setlogin(name)"}
  [^String name])

JOKER FUNC syscall.Setpgid has:
(defn ^Error Setpgid
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpgid(pid, pgid)"}
  [^Int pid, ^Int pgid])

JOKER FUNC syscall.Setpriority has:
(defn ^Error Setpriority
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpriority(which, who, prio)"}
  [^Int which, ^Int who, ^Int prio])

JOKER FUNC syscall.Setprivexec has:
(defn ^Error Setprivexec
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setprivexec(flag)"}
  [^Int flag])

JOKER FUNC syscall.Setregid has:
(defn ^Error Setregid
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setregid(rgid, egid)"}
  [^Int rgid, ^Int egid])

JOKER FUNC syscall.Setreuid has:
(defn ^Error Setreuid
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setreuid(ruid, euid)"}
  [^Int ruid, ^Int euid])

JOKER FUNC syscall.Setrlimit has:
;; (defn ^Error Setrlimit
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setrlimit(which, lim)"}
;;   [^Int which, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:1145:31) lim])

JOKER FUNC syscall.Setsid has:
(defn Setsid
  "Go return type: (pid int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "setsid()"}
  [])

JOKER FUNC syscall.SetsockoptByte has:
(defn ^Error SetsockoptByte
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptByte(fd, level, opt, value)"}
  [^Int fd, ^Int level, ^Int opt, ^Byte value])

JOKER FUNC syscall.SetsockoptICMPv6Filter has:
;; (defn ^Error SetsockoptICMPv6Filter
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptICMPv6Filter(fd, level, opt, filter)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_unix.go:300:56) filter])

JOKER FUNC syscall.SetsockoptIPMreq has:
;; (defn ^Error SetsockoptIPMreq
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptIPMreq(fd, level, opt, mreq)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_unix.go:292:48) mreq])

JOKER FUNC syscall.SetsockoptIPv6Mreq has:
;; (defn ^Error SetsockoptIPv6Mreq
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptIPv6Mreq(fd, level, opt, mreq)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_unix.go:296:50) mreq])

JOKER FUNC syscall.SetsockoptInet4Addr has:
;; (defn ^Error SetsockoptInet4Addr
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptInet4Addr(fd, level, opt, value)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_unix.go:288:52) value])

JOKER FUNC syscall.SetsockoptInt has:
(defn ^Error SetsockoptInt
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptInt(fd, level, opt, value)"}
  [^Int fd, ^Int level, ^Int opt, ^Int value])

JOKER FUNC syscall.SetsockoptLinger has:
;; (defn ^Error SetsockoptLinger
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptLinger(fd, level, opt, l)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_unix.go:304:45) l])

JOKER FUNC syscall.SetsockoptString has:
(defn ^Error SetsockoptString
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptString(fd, level, opt, s)"}
  [^Int fd, ^Int level, ^Int opt, ^String s])

JOKER FUNC syscall.SetsockoptTimeval has:
;; (defn ^Error SetsockoptTimeval
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptTimeval(fd, level, opt, tv)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_unix.go:312:47) tv])

JOKER FUNC syscall.Settimeofday has:
;; (defn ^Error Settimeofday
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Settimeofday(tp)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:1166:22) tp])

JOKER FUNC syscall.Setuid has:
(defn ^Error Setuid
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setuid(uid)"}
  [^Int uid])

JOKER FUNC syscall.Shutdown has:
(defn ^Error Shutdown
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Shutdown(s, how)"}
  [^Int s, ^Int how])

JOKER FUNC syscall.SlicePtrFromStrings has:
;; (defn SlicePtrFromStrings
;;   "SlicePtrFromStrings converts a slice of strings to a slice of\npointers to NUL-terminated byte arrays. If any string contains\na NUL byte, it returns (nil, EINVAL).\n\nGo return type: ([]*int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "slicePtrFromStrings(ss)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/exec_unix.go:83:29) ss])

JOKER FUNC syscall.Socket has:
(defn Socket
  "Go return type: (fd int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "socket(domain, typ, proto)"}
  [^Int domain, ^Int typ, ^Int proto])

JOKER FUNC syscall.Socketpair has:
(defn Socketpair
  "Go return type: (fd []int, err error)\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "socketpair(domain, typ, proto)"}
  [^Int domain, ^Int typ, ^Int proto])

JOKER FUNC syscall.StartProcess has:
;; (defn StartProcess
;;   "StartProcess wraps ForkExec for package os.\n\nGo return type: (pid int, handle uintptr, err error)\n\nJoker return type: [Int ABEND042(cannot find typename syscall.uintptr) Error]"
;;   {:added "1.0"
;;    :go "startProcess(argv0, argv, attr)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/exec_unix.go:240:38) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/exec_unix.go:240:53) attr])

JOKER FUNC syscall.Stat has:
;; (defn ^Error Stat
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Stat(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:1186:29) stat])

JOKER FUNC syscall.Statfs has:
;; (defn ^Error Statfs
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Statfs(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:1201:31) stat])

JOKER FUNC syscall.StringBytePtr has:
(defn ^Int StringBytePtr
  "StringBytePtr returns a pointer to a NUL-terminated array of bytes.\nIf s contains a NUL byte this function panics instead of returning\nan error.\n\nDeprecated: Use BytePtrFromString instead.\n\nGo return type: *int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.StringBytePtr(s)"}
  [^String s])

JOKER FUNC syscall.StringByteSlice has:
(defn StringByteSlice
  "StringByteSlice converts a string to a NUL-terminated []byte,\nIf s contains a NUL byte this function panics instead of\nreturning an error.\n\nDeprecated: Use ByteSliceFromString instead.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "stringByteSlice(s)"}
  [^String s])

JOKER FUNC syscall.StringSlicePtr has:
;; (defn StringSlicePtr
;;   "StringSlicePtr converts a slice of strings to a slice of pointers\nto NUL-terminated byte arrays. If any string contains a NUL byte\nthis function panics instead of returning an error.\n\nDeprecated: Use SlicePtrFromStrings instead.\n\nGo return type: []*int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "stringSlicePtr(ss)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/exec_unix.go:71:24) ss])

JOKER FUNC syscall.Symlink has:
(defn ^Error Symlink
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Symlink(path, link)"}
  [^String path, ^String link])

JOKER FUNC syscall.Sync has:
(defn ^Error Sync
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Sync()"}
  [])

JOKER FUNC syscall.Syscall has:
;; (defn Syscall
;;   "Go return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker return type: [ABEND042(cannot find typename syscall.uintptr) ABEND042(cannot find typename syscall.uintptr) ABEND042(cannot find typename syscall.uintptr)]"
;;   {:added "1.0"
;;    :go "syscall(trap, a1, a2, a3)"}
;;   [^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:29:31) trap, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:29:31) a1, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:29:31) a2, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:29:31) a3])

JOKER FUNC syscall.Syscall6 has:
;; (defn Syscall6
;;   "Go return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker return type: [ABEND042(cannot find typename syscall.uintptr) ABEND042(cannot find typename syscall.uintptr) ABEND042(cannot find typename syscall.uintptr)]"
;;   {:added "1.0"
;;    :go "syscall6(trap, a1, a2, a3, a4, a5, a6)"}
;;   [^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44) trap, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44) a1, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44) a2, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44) a3, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44) a4, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44) a5, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44) a6])

JOKER FUNC syscall.Syscall9 has:
;; (defn Syscall9
;;   "Go return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker return type: [ABEND042(cannot find typename syscall.uintptr) ABEND042(cannot find typename syscall.uintptr) ABEND042(cannot find typename syscall.uintptr)]"
;;   {:added "1.0"
;;    :go "syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9)"}
;;   [^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56) trap, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56) a1, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56) a2, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56) a3, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56) a4, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56) a5, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56) a6, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56) a7, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56) a8, ^ABEND885(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56) a9])

JOKER FUNC syscall.Sysctl has:
(defn Sysctl
  "Go return type: (value string, err error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "sysctl(name)"}
  [^String name])

JOKER FUNC syscall.SysctlUint32 has:
(defn SysctlUint32
  "Go return type: (value int, err error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "sysctlUint32(name)"}
  [^String name])

JOKER FUNC syscall.TimespecToNsec has:
;; (defn ^Int TimespecToNsec
;;   "TimespecToNsec converts a Timespec value into a number of\nnanoseconds since the Unix epoch.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "syscall.TimespecToNsec(ts)"}
;;   [^ABEND885(unrecognized type Timespec at: GO.link/src/syscall/timestruct.go:11:24) ts])

JOKER FUNC syscall.TimevalToNsec has:
;; (defn ^Int TimevalToNsec
;;   "TimevalToNsec converts a Timeval value into a number of nanoseconds\nsince the Unix epoch.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "syscall.TimevalToNsec(tv)"}
;;   [^ABEND885(unrecognized type Timeval at: GO.link/src/syscall/timestruct.go:27:23) tv])

JOKER FUNC syscall.Truncate has:
(defn ^Error Truncate
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Truncate(path, length)"}
  [^String path, ^Int length])

JOKER FUNC syscall.Umask has:
(defn ^Int Umask
  "Go return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Umask(newmask)"}
  [^Int newmask])

JOKER FUNC syscall.Undelete has:
(defn ^Error Undelete
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Undelete(path)"}
  [^String path])

JOKER FUNC syscall.UnixRights has:
;; (defn UnixRights
;;   "UnixRights encodes a set of open file descriptors into a socket\ncontrol message for sending to another process.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "unixRights(fds)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/syscall/sockcmsg_unix.go:74:21) fds])

JOKER FUNC syscall.Unlink has:
(defn ^Error Unlink
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unlink(path)"}
  [^String path])

JOKER FUNC syscall.Unmount has:
(defn ^Error Unmount
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unmount(path, flags)"}
  [^String path, ^Int flags])

JOKER FUNC syscall.Unsetenv has:
(defn ^Error Unsetenv
  "Go return type: error\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unsetenv(key)"}
  [^String key])

JOKER FUNC syscall.Utimes has:
;; (defn ^Error Utimes
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Utimes(path, tv)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:502:29) tv])

JOKER FUNC syscall.UtimesNano has:
;; (defn ^Error UtimesNano
;;   "Go return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.UtimesNano(path, ts)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:509:33) ts])

JOKER FUNC syscall.Wait4 has:
;; (defn Wait4
;;   "Go return type: (wpid int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "wait4(pid, wstatus, options, rusage)"}
;;   [^Int pid, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_bsd.go:127:29) wstatus, ^Int options, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_bsd.go:127:62) rusage])

JOKER FUNC syscall.Write has:
;; (defn Write
;;   "Go return type: (n int, err error)\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "write(fd, p)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_unix.go:187:22) p])

JOKER FUNC syslog.Dial has:
;; (defn Dial
;;   "Dial establishes a connection to a log daemon by connecting to\naddress raddr on the specified network. Each write to the returned\nwriter sends a log message with the facility and severity\n(from priority) and tag. If tag is empty, the os.Args[0] is used.\nIf network is empty, Dial will connect to the local syslog server.\nOtherwise, see the documentation for net.Dial for valid values\nof network and raddr.\n\nGo return type: (*Writer, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dial(network, raddr, priority, tag)"}
;;   [^String network, ^String raddr, ^ABEND885(unrecognized type Priority at: GO.link/src/log/syslog/syslog.go:118:43) priority, ^String tag])

JOKER FUNC syslog.New has:
;; (defn New
;;   "New establishes a new connection to the system log daemon. Each\nwrite to the returned writer sends a log message with the given\npriority (a combination of the syslog facility and severity) and\nprefix tag. If tag is empty, the os.Args[0] is used.\n\nGo return type: (*Writer, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "new(priority, tag)"}
;;   [^ABEND885(unrecognized type Priority at: GO.link/src/log/syslog/syslog.go:107:19) priority, ^String tag])

JOKER FUNC syslog.NewLogger has:
;; (defn NewLogger
;;   "NewLogger creates a log.Logger whose output is written to the\nsystem log service with the specified priority, a combination of\nthe syslog facility and severity. The logFlag argument is the flag\nset passed through to log.New to create the Logger.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/log/syslog/syslog.go:309:43) Error]"
;;   {:added "1.0"
;;    :go "newLogger(p, logFlag)"}
;;   [^ABEND885(unrecognized type Priority at: GO.link/src/log/syslog/syslog.go:309:18) p, ^Int logFlag])

JOKER FUNC tabwriter.NewWriter has:
;; (defn NewWriter
;;   "NewWriter allocates and initializes a new tabwriter.Writer.\nThe parameters are the same as for the Init function.\n\nGo return type: *Writer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newWriter(output, minwidth, tabwidth, padding, padchar, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/text/tabwriter/tabwriter.go:597:23) output, ^Int minwidth, ^Int tabwidth, ^Int padding, ^Byte padchar, ^Int flags])

JOKER FUNC tar.FileInfoHeader has:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated Header from fi.\nIf fi describes a symlink, FileInfoHeader records link as the link target.\nIf fi describes a directory, a slash is appended to the name.\n\nSince os.FileInfo's Name method only returns the base name of\nthe file it describes, it may be necessary to modify Header.Name\nto provide the full path name of the file.\n\nGo return type: (*Header, error)\n\nJoker return type: [{:Typeflag ^Int, :Name ^String, :Linkname ^String, :Size ^Int, :Mode ^Int, :Uid ^Int, :Gid ^Int, :Uname ^String, :Gname ^String, :ModTime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/tar/common.go:161:13), :AccessTime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/tar/common.go:162:13), :ChangeTime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/tar/common.go:163:13), :Devmajor ^Int, :Devminor ^Int, :Xattrs ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/archive/tar/common.go:179:9), :PAXRecords ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/archive/tar/common.go:191:13), :Format ^Int} Error]"
;;   {:added "1.0"
;;    :go "fileInfoHeader(fi, link)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/tar/common.go:629:24) fi, ^String link])

JOKER FUNC tar.NewReader has:
;; (defn NewReader
;;   "NewReader creates a new Reader reading from r.\n\nGo return type: *Reader\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/tar/reader.go:39:18) r])

JOKER FUNC tar.NewWriter has:
;; (defn NewWriter
;;   "NewWriter creates a new Writer writing to w.\n\nGo return type: *Writer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/tar/writer.go:33:18) w])

JOKER FUNC template.HTMLEscape has:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n"
;;   {:added "1.0"
;;    :go "hTMLEscape(w, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/text/template/funcs.go:510:19) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/text/template/funcs.go:510:32) b])

JOKER FUNC template.HTMLEscapeString has:
(defn ^String HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(s)"}
  [^String s])

JOKER FUNC template.HTMLEscaper has:
;; (defn ^String HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(args)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/text/template/funcs.go:550:23) args])

JOKER FUNC template.IsTrue has:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo return type: (truth bool, ok bool)\n\nJoker return type: [Bool Bool]"
;;   {:added "1.0"
;;    :go "isTrue(val)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/text/template/exec.go:302:17) val])

JOKER FUNC template.JSEscape has:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n"
;;   {:added "1.0"
;;    :go "jSEscape(w, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/text/template/funcs.go:568:17) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/text/template/funcs.go:568:30) b])

JOKER FUNC template.JSEscapeString has:
(defn ^String JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(s)"}
  [^String s])

JOKER FUNC template.JSEscaper has:
;; (defn ^String JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(args)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/text/template/funcs.go:635:21) args])

JOKER FUNC template.Must has:
;; (defn Must
;;   "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable\ninitializations such as\n\tvar t = template.Must(template.New(\"name\").Parse(\"text\"))\n\nGo return type: *Template\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "must(t, err)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/text/template/helper.go:21:13) t, ^ABEND885(unrecognized type error at: GO.link/src/text/template/helper.go:21:28) err])

JOKER FUNC template.New has:
;; (defn New
;;   "New allocates a new, undefined template with the given name.\n\nGo return type: *Template\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "new(name)"}
;;   [^String name])

JOKER FUNC template.ParseFiles has:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the base name and\nparsed contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo return type: (*Template, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "parseFiles(filenames)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/text/template/helper.go:37:27) filenames])

JOKER FUNC template.ParseGlob has:
(defn ParseGlob
  "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo return type: (*Template, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "parseGlob(pattern)"}
  [^String pattern])

JOKER FUNC template.URLQueryEscaper has:
;; (defn ^String URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(args)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/text/template/funcs.go:641:27) args])

JOKER FUNC template.HTMLEscape has:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n"
;;   {:added "1.0"
;;    :go "hTMLEscape(w, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/html/template/escape.go:855:19) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/html/template/escape.go:855:32) b])

JOKER FUNC template.HTMLEscapeString has:
(defn ^String HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(s)"}
  [^String s])

JOKER FUNC template.HTMLEscaper has:
;; (defn ^String HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(args)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/html/template/escape.go:866:23) args])

JOKER FUNC template.IsTrue has:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo return type: (truth bool, ok bool)\n\nJoker return type: [Bool Bool]"
;;   {:added "1.0"
;;    :go "isTrue(val)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/html/template/template.go:487:17) val])

JOKER FUNC template.JSEscape has:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n"
;;   {:added "1.0"
;;    :go "jSEscape(w, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/html/template/escape.go:871:17) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/html/template/escape.go:871:30) b])

JOKER FUNC template.JSEscapeString has:
(defn ^String JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(s)"}
  [^String s])

JOKER FUNC template.JSEscaper has:
;; (defn ^String JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(args)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/html/template/escape.go:882:21) args])

JOKER FUNC template.Must has:
;; (defn Must
;;   "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable initializations\nsuch as\n\tvar t = template.Must(template.New(\"name\").Parse(\"html\"))\n\nGo return type: *Template\n\nJoker return type: {:Tree ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/html/template/template.go:27:14)}"
;;   {:added "1.0"
;;    :go "must(t, err)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/html/template/template.go:370:13) t, ^ABEND885(unrecognized type error at: GO.link/src/html/template/template.go:370:28) err])

JOKER FUNC template.New has:
;; (defn New
;;   "New allocates a new HTML template with the given name.\n\nGo return type: *Template\n\nJoker return type: {:Tree ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/html/template/template.go:27:14)}"
;;   {:added "1.0"
;;    :go "new(name)"}
;;   [^String name])

JOKER FUNC template.ParseFiles has:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the (base) name and\n(parsed) contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo return type: (*Template, error)\n\nJoker return type: [{:Tree ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/html/template/template.go:27:14)} Error]"
;;   {:added "1.0"
;;    :go "parseFiles(filenames)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/html/template/template.go:386:27) filenames])

JOKER FUNC template.ParseGlob has:
;; (defn ParseGlob
;;   "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo return type: (*Template, error)\n\nJoker return type: [{:Tree ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/html/template/template.go:27:14)} Error]"
;;   {:added "1.0"
;;    :go "parseGlob(pattern)"}
;;   [^String pattern])

JOKER FUNC template.URLQueryEscaper has:
;; (defn ^String URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(args)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/html/template/escape.go:888:27) args])

JOKER FUNC testing.AllocsPerRun has:
;; (defn AllocsPerRun
;;   "AllocsPerRun returns the average number of allocations during calls to f.\nAlthough the return value has type float64, it will always be an integral value.\n\nTo compute the number of allocations, the function will first be run once as\na warm-up. The average number of allocations over the specified number of\nruns will then be measured and returned.\n\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore\nit before returning.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename testing.float64)"
;;   {:added "1.0"
;;    :go "allocsPerRun(runs, f)"}
;;   [^Int runs, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/testing/allocs.go:20:31) f])

JOKER FUNC testing.Benchmark has:
;; (defn Benchmark
;;   "Benchmark benchmarks a single function. Useful for creating\ncustom benchmarks that do not use the \"go test\" command.\n\nIf f calls Run, the result will be an estimate of running all its\nsubbenchmarks that don't call Run in sequence in a single benchmark.\n\nGo return type: BenchmarkResult\n\nJoker return type: {:N ^Int, :T ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/benchmark.go:298:12), :Bytes ^Int, :MemAllocs ^ABEND042(cannot find typename testing.uint64), :MemBytes ^ABEND042(cannot find typename testing.uint64)}"
;;   {:added "1.0"
;;    :go "benchmark(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/testing/benchmark.go:649:18) f])

JOKER FUNC testing.CoverMode has:
(defn ^String CoverMode
  "CoverMode reports what the test coverage mode is set to. The\nvalues are \"set\", \"count\", or \"atomic\". The return value will be\nempty if test coverage is not enabled.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "testing.CoverMode()"}
  [])

JOKER FUNC testing.Coverage has:
;; (defn Coverage
;;   "Coverage reports the current code coverage as a fraction in the range [0, 1].\nIf coverage is not enabled, Coverage returns 0.\n\nWhen running a large set of sequential test cases, checking Coverage after each one\ncan be useful for identifying which test cases exercise new code paths.\nIt is not a replacement for the reports generated by 'go test -cover' and\n'go tool cover'.\n\nGo return type: float64\n\nJoker return type: ABEND042(cannot find typename testing.float64)"
;;   {:added "1.0"
;;    :go "coverage()"}
;;   [])

JOKER FUNC testing.Main has:
;; (defn Main
;;   "Main is an internal function, part of the implementation of the \"go test\" command.\nIt was exported because it is cross-package and predates \"internal\" packages.\nIt is no longer used by \"go test\" but preserved, as much as possible, for other\nsystems that simulate \"go test\" using Main, but Main sometimes cannot be updated as\nnew functionality is added to the testing package.\nSystems simulating \"go test\" should be updated to use MainStart.\n"
;;   {:added "1.0"
;;    :go "main(matchString, tests, benchmarks, examples)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/testing/testing.go:961:23) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:961:66) tests, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:961:93) benchmarks, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:961:123) examples])

JOKER FUNC testing.MainStart has:
;; (defn MainStart
;;   "MainStart is meant for use by tests generated by 'go test'.\nIt is not meant to be called directly and is not subject to the Go 1 compatibility document.\nIt may change signature from release to release.\n\nGo return type: *M\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "mainStart(deps, tests, benchmarks, examples)"}
;;   [^ABEND885(unrecognized type testDeps at: GO.link/src/testing/testing.go:995:21) deps, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:995:37) tests, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:995:64) benchmarks, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:995:94) examples])

JOKER FUNC testing.RegisterCover has:
;; (defn RegisterCover
;;   "RegisterCover records the coverage data accumulators for the tests.\nNOTE: This function is internal to the testing infrastructure and may change.\nIt is not covered (yet) by the Go 1 compatibility guidelines.\n"
;;   {:added "1.0"
;;    :go "registerCover(c)"}
;;   [^ABEND885(unrecognized type Cover at: GO.link/src/testing/cover.go:67:22) c])

JOKER FUNC testing.RunBenchmarks has:
;; (defn RunBenchmarks
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n"
;;   {:added "1.0"
;;    :go "runBenchmarks(matchString, benchmarks)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/testing/benchmark.go:377:32) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/benchmark.go:377:80) benchmarks])

JOKER FUNC testing.RunExamples has:
;; (defn ^Bool RunExamples
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "testing.RunExamples(matchString, examples)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/testing/example.go:25:30) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/example.go:25:76) examples])

JOKER FUNC testing.RunTests has:
;; (defn ^Bool RunTests
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "testing.RunTests(matchString, tests)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/testing/testing.go:1091:27) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:1091:70) tests])

JOKER FUNC testing.Short has:
(defn ^Bool Short
  "Short reports whether the -test.short flag is set.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "testing.Short()"}
  [])

JOKER FUNC testing.Verbose has:
(defn ^Bool Verbose
  "Verbose reports whether the -test.v flag is set.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "testing.Verbose()"}
  [])

JOKER FUNC textproto.CanonicalMIMEHeaderKey has:
(defn ^String CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(s)"}
  [^String s])

JOKER FUNC textproto.Dial has:
(defn Dial
  "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo return type: (*Conn, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dial(network, addr)"}
  [^String network, ^String addr])

JOKER FUNC textproto.NewConn has:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo return type: *Conn\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/textproto/textproto.go:66:19) conn])

JOKER FUNC textproto.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo return type: *Reader\n\nJoker return type: {:R ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/textproto/reader.go:19:7)}"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/textproto/reader.go:29:18) r])

JOKER FUNC textproto.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo return type: *Writer\n\nJoker return type: {:W ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/textproto/writer.go:16:7)}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/textproto/writer.go:21:18) w])

JOKER FUNC textproto.TrimBytes has:
;; (defn TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimBytes(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/net/textproto/textproto.go:137:18) b])

JOKER FUNC textproto.TrimString has:
(defn ^String TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.TrimString(s)"}
  [^String s])

JOKER FUNC time.After has:
;; (defn After
;;   "After waits for the duration to elapse and then sends the current time\non the returned channel.\nIt is equivalent to NewTimer(d).C.\nThe underlying Timer is not recovered by the garbage collector\nuntil the timer fires. If efficiency is a concern, use NewTimer\ninstead and call Timer.Stop if the timer is no longer needed.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/sleep.go:152:24)"
;;   {:added "1.0"
;;    :go "after(d)"}
;;   [^ABEND885(unrecognized type Duration at: GO.link/src/time/sleep.go:152:14) d])

JOKER FUNC time.AfterFunc has:
;; (defn AfterFunc
;;   "AfterFunc waits for the duration to elapse and then calls f\nin its own goroutine. It returns a Timer that can\nbe used to cancel the call using its Stop method.\n\nGo return type: *Timer\n\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/sleep.go:50:4)}"
;;   {:added "1.0"
;;    :go "afterFunc(d, f)"}
;;   [^ABEND885(unrecognized type Duration at: GO.link/src/time/sleep.go:159:18) d, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/time/sleep.go:159:30) f])

JOKER FUNC time.Date has:
;; (defn Date
;;   "Date returns the Time corresponding to\n\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside\ntheir usual ranges and will be normalized during the conversion.\nFor example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times.\nFor example, in the United States, March 13, 2011 2:15am never occurred,\nwhile November 6, 2011 1:15am occurred twice. In such cases, the\nchoice of time zone, and therefore the time, is not well-defined.\nDate returns a time that is correct in one of the two zones involved\nin the transition, but it does not guarantee which.\n\nDate panics if loc is nil.\n\nGo return type: Time\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "date(year, month, day, hour, min, sec, nsec, loc)"}
;;   [^Int year, ^ABEND885(unrecognized type Month at: GO.link/src/time/time.go:1326:27) month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/time/time.go:1326:69) loc])

JOKER FUNC time.FixedZone has:
;; (defn FixedZone
;;   "FixedZone returns a Location that always uses\nthe given zone name and offset (seconds east of UTC).\n\nGo return type: *Location\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "fixedZone(name, offset)"}
;;   [^String name, ^Int offset])

JOKER FUNC time.LoadLocation has:
(defn LoadLocation
  "LoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC.\nIf the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file\nin the IANA Time Zone database, such as \"America/New_York\".\n\nThe time zone database needed by LoadLocation may not be\npresent on all systems, especially non-Unix systems.\nLoadLocation looks in the directory or uncompressed zip file\nnamed by the ZONEINFO environment variable, if any, then looks in\nknown installation locations on Unix systems,\nand finally looks in $GOROOT/lib/time/zoneinfo.zip.\n\nGo return type: (*Location, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "loadLocation(name)"}
  [^String name])

JOKER FUNC time.LoadLocationFromTZData has:
;; (defn LoadLocationFromTZData
;;   "LoadLocationFromTZData returns a Location with the given name\ninitialized from the IANA Time Zone database-formatted data.\nThe data should be in the format of a standard IANA time zone file\n(for example, the content of /etc/localtime on Unix systems).\n\nGo return type: (*Location, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "loadLocationFromTZData(name, data)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/time/zoneinfo_read.go:86:47) data])

JOKER FUNC time.NewTicker has:
;; (defn NewTicker
;;   "NewTicker returns a new Ticker containing a channel that will send the\ntime with a period specified by the duration argument.\nIt adjusts the intervals or drops ticks to make up for slow receivers.\nThe duration d must be greater than zero; if not, NewTicker will panic.\nStop the ticker to release associated resources.\n\nGo return type: *Ticker\n\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/tick.go:12:4)}"
;;   {:added "1.0"
;;    :go "newTicker(d)"}
;;   [^ABEND885(unrecognized type Duration at: GO.link/src/time/tick.go:21:18) d])

JOKER FUNC time.NewTimer has:
;; (defn NewTimer
;;   "NewTimer creates a new Timer that will send\nthe current time on its channel after at least duration d.\n\nGo return type: *Timer\n\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/sleep.go:50:4)}"
;;   {:added "1.0"
;;    :go "newTimer(d)"}
;;   [^ABEND885(unrecognized type Duration at: GO.link/src/time/sleep.go:85:17) d])

JOKER FUNC time.Now has:
;; (defn Now
;;   "Now returns the current local time.\n\nGo return type: Time\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "now()"}
;;   [])

JOKER FUNC time.Parse has:
(defn Parse
  "Parse parses a formatted string and returns the time value it represents.\nThe layout defines the format by showing how the reference time,\ndefined to be\n\tMon Jan 2 15:04:05 -0700 MST 2006\nwould be interpreted if it were the value; it serves as an example of\nthe input format. The same interpretation will then be made to the\ninput string.\n\nPredefined layouts ANSIC, UnixDate, RFC3339 and others describe standard\nand convenient representations of the reference time. For more information\nabout the formats and the definition of the reference time, see the\ndocumentation for ANSIC and the other constants defined by this package.\nAlso, the executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nElements omitted from the value are assumed to be zero or, when\nzero is impossible, one, so parsing \"3:04pm\" returns the time\ncorresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is\n0, this time is before the zero Time).\nYears must be in the range 0000..9999. The day of the week is checked\nfor syntax but it is otherwise ignored.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds\nto a time zone used by the current location (Local), then Parse uses that\nlocation and zone in the returned time. Otherwise it records the time as\nbeing in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation\nhas a defined offset in the current location, then that offset is used.\nThe zone abbreviation \"UTC\" is recognized as UTC regardless of location.\nIf the zone abbreviation is unknown, Parse records the time as being\nin a fabricated location with the given zone abbreviation and a zero offset.\nThis choice means that such a time can be parsed and reformatted with the\nsame layout losslessly, but the exact instant used in the representation will\ndiffer by the actual zone offset. To avoid such problems, prefer time layouts\nthat use a numeric zone offset, or use ParseInLocation.\n\nGo return type: (Time, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "parse(layout, value)"}
  [^String layout, ^String value])

JOKER FUNC time.ParseDuration has:
(defn ParseDuration
  "ParseDuration parses a duration string.\nA duration string is a possibly signed sequence of\ndecimal numbers, each with optional fraction and a unit suffix,\nsuch as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".\n\nGo return type: (Duration, error)\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "parseDuration(s)"}
  [^String s])

JOKER FUNC time.ParseInLocation has:
;; (defn ParseInLocation
;;   "ParseInLocation is like Parse but differs in two important ways.\nFirst, in the absence of time zone information, Parse interprets a time as UTC;\nParseInLocation interprets the time as in the given location.\nSecond, when given a zone offset or abbreviation, Parse tries to match it\nagainst the Local location; ParseInLocation uses the given location.\n\nGo return type: (Time, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "parseInLocation(layout, value, loc)"}
;;   [^String layout, ^String value, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/time/format.go:782:48) loc])

JOKER FUNC time.Since has:
;; (defn ^Int Since
;;   "Since returns the time elapsed since t.\nIt is shorthand for time.Now().Sub(t).\n\nGo return type: Duration\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "time.Since(t)"}
;;   [^ABEND885(unrecognized type Time at: GO.link/src/time/time.go:910:14) t])

JOKER FUNC time.Sleep has:
;; (defn Sleep
;;   "Sleep pauses the current goroutine for at least the duration d.\nA negative or zero duration causes Sleep to return immediately.\n"
;;   {:added "1.0"
;;    :go "sleep(d)"}
;;   [^ABEND885(unrecognized type Duration at: GO.link/src/time/sleep.go:9:14) d])

JOKER FUNC time.Tick has:
;; (defn Tick
;;   "Tick is a convenience wrapper for NewTicker providing access to the ticking\nchannel only. While Tick is useful for clients that have no need to shut down\nthe Ticker, be aware that without a way to shut it down the underlying\nTicker cannot be recovered by the garbage collector; it \"leaks\".\nUnlike NewTicker, Tick will return nil if d <= 0.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/tick.go:54:23)"
;;   {:added "1.0"
;;    :go "tick(d)"}
;;   [^ABEND885(unrecognized type Duration at: GO.link/src/time/tick.go:54:13) d])

JOKER FUNC time.Unix has:
;; (defn Unix
;;   "Unix returns the local Time corresponding to the given Unix time,\nsec seconds and nsec nanoseconds since January 1, 1970 UTC.\nIt is valid to pass nsec outside the range [0, 999999999].\nNot all sec values have a corresponding time value. One such\nvalue is 1<<63-1 (the largest int64 value).\n\nGo return type: Time\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "unix(sec, nsec)"}
;;   [^Int sec, ^Int nsec])

JOKER FUNC time.Until has:
;; (defn ^Int Until
;;   "Until returns the duration until t.\nIt is shorthand for t.Sub(time.Now()).\n\nGo return type: Duration\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "time.Until(t)"}
;;   [^ABEND885(unrecognized type Time at: GO.link/src/time/time.go:916:14) t])

JOKER FUNC tls.Client has:
;; (defn Client
;;   "Client returns a new TLS client side connection\nusing conn as the underlying transport.\nThe config cannot be nil: users must set either ServerName or\nInsecureSkipVerify in the config.\n\nGo return type: *Conn\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "client(conn, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/tls.go:39:18) conn, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:39:35) config])

JOKER FUNC tls.Dial has:
;; (defn Dial
;;   "Dial connects to the given network address using net.Dial\nand then initiates a TLS handshake, returning the resulting\nTLS connection.\nDial interprets a nil configuration as equivalent to\nthe zero configuration; see the documentation of Config\nfor the defaults.\n\nGo return type: (*Conn, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dial(network, addr, config)"}
;;   [^String network, ^String addr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:169:40) config])

JOKER FUNC tls.DialWithDialer has:
;; (defn DialWithDialer
;;   "DialWithDialer connects to the given network address using dialer.Dial and\nthen initiates a TLS handshake, returning the resulting TLS connection. Any\ntimeout or deadline given in the dialer apply to connection and TLS\nhandshake as a whole.\n\nDialWithDialer interprets a nil configuration as equivalent to the zero\nconfiguration; see the documentation of Config for the defaults.\n\nGo return type: (*Conn, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialWithDialer(dialer, network, addr, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:98:28) dialer, ^String network, ^String addr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:98:70) config])

JOKER FUNC tls.Listen has:
;; (defn Listen
;;   "Listen creates a TLS listener accepting connections on the\ngiven network address using net.Listen.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/tls.go:74:53) Error]"
;;   {:added "1.0"
;;    :go "listen(network, laddr, config)"}
;;   [^String network, ^String laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:74:43) config])

JOKER FUNC tls.LoadX509KeyPair has:
;; (defn LoadX509KeyPair
;;   "LoadX509KeyPair reads and parses a public/private key pair from a pair\nof files. The files must contain PEM encoded data. The certificate file\nmay contain intermediate certificates following the leaf certificate to\nform a certificate chain. On successful return, Certificate.Leaf will\nbe nil because the parsed form of the certificate is not retained.\n\nGo return type: (Certificate, error)\n\nJoker return type: [{:Certificate ^(vector-of (vector-of Int)), :PrivateKey ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/common.go:813:13), :OCSPStaple ^(vector-of Int), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :Leaf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/common.go:824:8)} Error]"
;;   {:added "1.0"
;;    :go "loadX509KeyPair(certFile, keyFile)"}
;;   [^String certFile, ^String keyFile])

JOKER FUNC tls.NewLRUClientSessionCache has:
;; (defn NewLRUClientSessionCache
;;   "NewLRUClientSessionCache returns a ClientSessionCache with the given\ncapacity that uses an LRU strategy. If capacity is < 1, a default capacity\nis used instead.\n\nGo return type: ClientSessionCache\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/tls/common.go:215:25)"
;;   {:added "1.0"
;;    :go "newLRUClientSessionCache(capacity)"}
;;   [^Int capacity])

JOKER FUNC tls.NewListener has:
;; (defn NewListener
;;   "NewListener creates a Listener which accepts connections from an inner\nListener and wraps each connection with Server.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo return type: ...\n\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/tls.go:63:54)"
;;   {:added "1.0"
;;    :go "newListener(inner, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/tls.go:63:24) inner, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:63:45) config])

JOKER FUNC tls.Server has:
;; (defn Server
;;   "Server returns a new TLS server side connection\nusing conn as the underlying transport.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo return type: *Conn\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "server(conn, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/tls.go:31:18) conn, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:31:35) config])

JOKER FUNC tls.X509KeyPair has:
;; (defn X509KeyPair
;;   "X509KeyPair parses a public/private key pair from a pair of\nPEM encoded data. On successful return, Certificate.Leaf will be nil because\nthe parsed form of the certificate is not retained.\n\nGo return type: (Certificate, error)\n\nJoker return type: [{:Certificate ^(vector-of (vector-of Int)), :PrivateKey ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/common.go:813:13), :OCSPStaple ^(vector-of Int), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :Leaf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/common.go:824:8)} Error]"
;;   {:added "1.0"
;;    :go "x509KeyPair(certPEMBlock, keyPEMBlock)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/tls/tls.go:193:44) certPEMBlock, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/tls/tls.go:193:44) keyPEMBlock])

JOKER FUNC token.Lookup has:
(defn ^Int Lookup
  "Lookup maps an identifier to its keyword token or IDENT (if not a keyword).\n\nGo return type: Token\n\nJoker return type: Int"
  {:added "1.0"
   :go "token.Lookup(ident)"}
  [^String ident])

JOKER FUNC token.NewFileSet has:
;; (defn NewFileSet
;;   "NewFileSet creates a new file set.\n\nGo return type: *FileSet\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newFileSet()"}
;;   [])

JOKER FUNC trace.IsEnabled has:
(defn ^Bool IsEnabled
  "IsEnabled returns whether tracing is enabled.\nThe information is advisory only. The tracing status\nmay have changed by the time this function returns.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "trace.IsEnabled()"}
  [])

JOKER FUNC trace.Log has:
;; (defn Log
;;   "Log emits a one-off event with the given category and message.\nCategory can be empty and the API assumes there are only a handful of\nunique categories in the system.\n"
;;   {:added "1.0"
;;    :go "log(ctx, category, message)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:91:14) ctx, ^String category, ^String message])

JOKER FUNC trace.Logf has:
;; (defn Logf
;;   "Logf is like Log, but the value is formatted using the specified format spec.\n"
;;   {:added "1.0"
;;    :go "logf(ctx, category, format, args)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:97:15) ctx, ^String category, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/runtime/trace/annotation.go:97:62) args])

JOKER FUNC trace.NewTask has:
;; (defn NewTask
;;   "NewTask creates a task instance with the type taskType and returns\nit along with a Context that carries the task.\nIf the input context contains a task, the new task is its subtask.\n\nThe taskType is used to classify task instances. Analysis tools\nlike the Go execution tracer may assume there are only a bounded\nnumber of unique task types in the system.\n\nThe returned end function is used to mark the task's end.\nThe trace tool measures task latency as the time between task creation\nand when the end function is called, and provides the latency\ndistribution per task type.\nIf the end function is called multiple times, only the first\ncall is used in the latency measurement.\n\n  ctx, task := trace.NewTask(ctx, \"awesomeTask\")\n  trace.WithRegion(ctx, \"preparation\", prepWork)\n  // preparation of the task\n  go func() {  // continue processing the task in a separate goroutine.\n      defer task.End()\n      trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n  }()\n\nGo return type: (ctx ..., task *Task)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:34:58) {}]"
;;   {:added "1.0"
;;    :go "newTask(pctx, taskType)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:34:19) pctx, ^String taskType])

JOKER FUNC trace.Start has:
;; (defn ^Error Start
;;   "Start enables tracing for the current program.\nWhile tracing, the trace will be buffered and written to w.\nStart returns an error if tracing is already enabled.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "trace.Start(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/trace.go:120:14) w])

JOKER FUNC trace.StartRegion has:
;; (defn StartRegion
;;   "StartRegion starts a region and returns a function for marking the\nend of the region. The returned Region's End function must be called\nfrom the same goroutine where the region was started.\nWithin each goroutine, regions must nest. That is, regions started\nafter this region must be ended before this region can be ended.\nRecommended usage is\n\n    defer trace.StartRegion(ctx, \"myTracedRegion\").End()\n\nGo return type: *Region\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "startRegion(ctx, regionType)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:149:22) ctx, ^String regionType])

JOKER FUNC trace.Stop has:
;; (defn Stop
;;   "Stop stops the current tracing, if any.\nStop only returns after all the writes for the trace have completed.\n"
;;   {:added "1.0"
;;    :go "stop()"}
;;   [])

JOKER FUNC trace.WithRegion has:
;; (defn WithRegion
;;   "WithRegion starts a region associated with its calling goroutine, runs fn,\nand then ends the region. If the context carries a task, the region is\nassociated with the task. Otherwise, the region is attached to the background\ntask.\n\nThe regionType is used to classify regions, so there should be only a\nhandful of unique region types.\n"
;;   {:added "1.0"
;;    :go "withRegion(ctx, regionType, fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:118:21) ctx, ^String regionType, ^ABEND881(unrecognized Expr type *ast.FuncType at: GO.link/src/runtime/trace/annotation.go:118:60) fn])

JOKER FUNC types.AssertableTo has:
;; (defn ^Bool AssertableTo
;;   "AssertableTo reports whether a value of type V can be asserted to have type T.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.AssertableTo(V, T)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/api.go:355:21) V, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/api.go:355:35) T])

JOKER FUNC types.AssignableTo has:
;; (defn ^Bool AssignableTo
;;   "AssignableTo reports whether a value of type V is assignable to a variable of type T.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.AssignableTo(V, T)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/api.go:361:24) V, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/api.go:361:24) T])

JOKER FUNC types.Comparable has:
;; (defn ^Bool Comparable
;;   "Comparable reports whether values of type T are comparable.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.Comparable(T)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/predicates.go:81:19) T])

JOKER FUNC types.ConvertibleTo has:
;; (defn ^Bool ConvertibleTo
;;   "ConvertibleTo reports whether a value of type V is convertible to a value of type T.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.ConvertibleTo(V, T)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/api.go:367:25) V, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/api.go:367:25) T])

JOKER FUNC types.DefPredeclaredTestFuncs has:
;; (defn DefPredeclaredTestFuncs
;;   "DefPredeclaredTestFuncs defines the assert and trace built-ins.\nThese built-ins are intended for debugging and testing of this\npackage only.\n"
;;   {:added "1.0"
;;    :go "defPredeclaredTestFuncs()"}
;;   [])

JOKER FUNC types.Default has:
;; (defn Default
;;   "Default returns the default \"typed\" type for an \"untyped\" type;\nit returns the incoming type for all other types. The default type\nfor untyped nil is untyped nil.\n\nGo return type: Type\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/types/type.go:11:11)"
;;   {:added "1.0"
;;    :go "default(typ)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/predicates.go:302:18) typ])

JOKER FUNC types.Eval has:
;; (defn Eval
;;   "Eval returns the type and, if constant, the value for the\nexpression expr, evaluated at position pos of package pkg,\nwhich must have been derived from type-checking an AST with\ncomplete position information relative to the provided file\nset.\n\nIf pkg == nil, the Universe scope is used and the provided\nposition pos is ignored. If pkg != nil, and pos is invalid,\nthe package scope is used. Otherwise, pos must belong to the\npackage.\n\nAn error is returned if pos is not within the package or\nif the node cannot be evaluated.\n\nNote: Eval should not be used instead of running Check to compute\ntypes and values, but in addition to Check. Eval will re-evaluate\nits argument each time, and it also does not know about the context\nin which an expression is used (e.g., an assignment). Thus, top-\nlevel untyped constants will return an untyped type rather then the\nrespective context-specific type.\n\nGo return type: (_ TypeAndValue, err error)\n\nJoker return type: [{:Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/types/type.go:11:11), :Value ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/api.go:259:8)} Error]"
;;   {:added "1.0"
;;    :go "eval(fset, pkg, pos, expr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/eval.go:34:16) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/eval.go:34:36) pkg, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/eval.go:34:50) pos, ^String expr])

JOKER FUNC types.ExprString has:
;; (defn ^String ExprString
;;   "ExprString returns the (possibly shortened) string representation for x.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.ExprString(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/exprstring.go:17:19) x])

JOKER FUNC types.Id has:
;; (defn ^String Id
;;   "Id returns name if it is exported, otherwise it\nreturns the name qualified with the package path.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.Id(pkg, name)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:61:13) pkg, ^String name])

JOKER FUNC types.Identical has:
;; (defn ^Bool Identical
;;   "Identical reports whether x and y are identical types.\nReceivers of Signature types are ignored.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.Identical(x, y)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/predicates.go:115:21) x, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/predicates.go:115:21) y])

JOKER FUNC types.IdenticalIgnoreTags has:
;; (defn ^Bool IdenticalIgnoreTags
;;   "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.\nReceivers of Signature types are ignored.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.IdenticalIgnoreTags(x, y)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/predicates.go:121:31) x, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/predicates.go:121:31) y])

JOKER FUNC types.Implements has:
;; (defn ^Bool Implements
;;   "Implements reports whether type V implements interface T.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.Implements(V, T)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/api.go:373:19) V, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/api.go:373:27) T])

JOKER FUNC types.IsInterface has:
;; (defn ^Bool IsInterface
;;   "IsInterface reports whether typ is an interface type.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.IsInterface(typ)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/predicates.go:75:22) typ])

JOKER FUNC types.LookupFieldOrMethod has:
;; (defn LookupFieldOrMethod
;;   "LookupFieldOrMethod looks up a field or method with given package and name\nin T and returns the corresponding *Var or *Func, an index sequence, and a\nbool indicating if there were any pointer indirections on the path to the\nfield or method. If addressable is set, T is the type of an addressable\nvariable (only matters for method lookups).\n\nThe last index entry is the field or method index in the (possibly embedded)\ntype where the entry was found, either:\n\n\t1) the list of declared methods of a named type; or\n\t2) the list of all methods (method set) of an interface type; or\n\t3) the list of fields of a struct type.\n\nThe earlier index entries are the indices of the embedded struct fields\ntraversed to get to the found entry, starting at depth 0.\n\nIf no entry is found, a nil object is returned. In this case, the returned\nindex and indirect values have the following meaning:\n\n\t- If index != nil, the index sequence points to an ambiguous entry\n\t(the same name appeared more than once at the same embedding level).\n\n\t- If indirect is set, a method with a pointer receiver type was found\n     but there was no pointer on the path from the actual receiver type to\n\tthe method's formal receiver base type, nor was the receiver addressable.\n\nGo return type: (obj Object, index []int, indirect bool)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/types/object.go:19:13) (vector-of Int) Bool]"
;;   {:added "1.0"
;;    :go "lookupFieldOrMethod(T, addressable, pkg, name)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/lookup.go:35:28) T, ^Bool addressable, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/lookup.go:35:56) pkg, ^String name])

JOKER FUNC types.MissingMethod has:
;; (defn MissingMethod
;;   "MissingMethod returns (nil, false) if V implements T, otherwise it\nreturns a missing method required by T and whether it is missing or\njust has the wrong type.\n\nFor non-interface types V, or if static is set, V implements T if all\nmethods of T are present in V. Otherwise (V is an interface and static\nis not set), MissingMethod only checks that methods of T which are also\npresent in V have matching types (e.g., for a type assertion x.(T) where\nx is of interface type V).\n\nGo return type: (method *Func, wrongType bool)\n\nJoker return type: [{} Bool]"
;;   {:added "1.0"
;;    :go "missingMethod(V, T, static)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/lookup.go:250:22) V, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/lookup.go:250:30) T, ^Bool static])

JOKER FUNC types.NewArray has:
;; (defn NewArray
;;   "NewArray returns a new array type for the given element type and length.\nA negative length indicates an unknown length.\n\nGo return type: *Array\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newArray(elem, len)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/type.go:101:20) elem, ^Int len])

JOKER FUNC types.NewChan has:
;; (defn NewChan
;;   "NewChan returns a new channel type for the given direction and element type.\n\nGo return type: *Chan\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newChan(dir, elem)"}
;;   [^ABEND885(unrecognized type ChanDir at: GO.link/src/go/types/type.go:413:18) dir, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/type.go:413:32) elem])

JOKER FUNC types.NewChecker has:
;; (defn NewChecker
;;   "NewChecker returns a new Checker instance for a given package.\nPackage files may be added incrementally via checker.Files.\n\nGo return type: *Checker\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newChecker(conf, fset, pkg, info)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/check.go:170:22) conf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/check.go:170:36) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/check.go:170:56) pkg, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/check.go:170:71) info])

JOKER FUNC types.NewConst has:
;; (defn NewConst
;;   "NewConst returns a new constant with value val.\nThe remaining arguments set the attributes found with all Objects.\n\nGo return type: *Const\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newConst(pos, pkg, name, typ, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:205:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:205:34) pkg, ^String name, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/object.go:205:61) typ, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:205:71) val])

JOKER FUNC types.NewField has:
;; (defn NewField
;;   "NewField returns a new variable representing a struct field.\nFor embedded fields, the name is the unqualified type name\n/ under which the field is accessible.\n\nGo return type: *Var\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newField(pos, pkg, name, typ, embedded)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:276:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:276:34) pkg, ^String name, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/object.go:276:61) typ, ^Bool embedded])

JOKER FUNC types.NewFunc has:
;; (defn NewFunc
;;   "NewFunc returns a new function with the given signature, representing\nthe function's type.\n\nGo return type: *Func\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newFunc(pos, pkg, name, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:301:18) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:301:33) pkg, ^String name, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:301:60) sig])

JOKER FUNC types.NewInterface has:
;; (defn NewInterface
;;   "NewInterface returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type.\nNewInterface takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nDeprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types\nto be embedded. This is necessary for interfaces that embed alias type names referring to\nnon-defined (literal) interface types.\n\nGo return type: *Interface\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newInterface(methods, embeddeds)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:266:27) methods, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:266:46) embeddeds])

JOKER FUNC types.NewInterfaceType has:
;; (defn NewInterfaceType
;;   "NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type (this property is not\nverified for defined types, which may be in the process of being set up and which don't\nhave a valid underlying type yet).\nNewInterfaceType takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nGo return type: *Interface\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newInterfaceType(methods, embeddeds)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:280:31) methods, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:280:50) embeddeds])

JOKER FUNC types.NewLabel has:
;; (defn NewLabel
;;   "NewLabel returns a new label.\n\nGo return type: *Label\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newLabel(pos, pkg, name)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:331:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:331:34) pkg, ^String name])

JOKER FUNC types.NewMap has:
;; (defn NewMap
;;   "NewMap returns a new map for the given key and element types.\n\nGo return type: *Map\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newMap(key, elem)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/type.go:386:23) key, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/type.go:386:23) elem])

JOKER FUNC types.NewMethodSet has:
;; (defn NewMethodSet
;;   "NewMethodSet returns the method set for the given type T.\nIt always returns a non-nil method set, even if it is empty.\n\nGo return type: *MethodSet\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newMethodSet(T)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/methodset.go:67:21) T])

JOKER FUNC types.NewNamed has:
;; (defn NewNamed
;;   "NewNamed returns a new named type for the given type name, underlying type, and associated methods.\nIf the given type name obj doesn't have a type yet, its type is set to the returned named type.\nThe underlying type must not be a *Named.\n\nGo return type: *Named\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newNamed(obj, underlying, methods)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/type.go:433:19) obj, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/type.go:433:41) underlying, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:433:55) methods])

JOKER FUNC types.NewPackage has:
;; (defn NewPackage
;;   "NewPackage returns a new Package for the given package path and name.\nThe package is not complete and contains no explicit imports.\n\nGo return type: *Package\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newPackage(path, name)"}
;;   [^String path, ^String name])

JOKER FUNC types.NewParam has:
;; (defn NewParam
;;   "NewParam returns a new variable representing a function parameter.\n\nGo return type: *Var\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newParam(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:269:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:269:34) pkg, ^String name, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/object.go:269:61) typ])

JOKER FUNC types.NewPkgName has:
;; (defn NewPkgName
;;   "NewPkgName returns a new PkgName object representing an imported package.\nThe remaining arguments set the attributes found with all Objects.\n\nGo return type: *PkgName\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newPkgName(pos, pkg, name, imported)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:189:21) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:189:36) pkg, ^String name, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:189:68) imported])

JOKER FUNC types.NewPointer has:
;; (defn NewPointer
;;   "NewPointer returns a new pointer type for the given element (base) type.\n\nGo return type: *Pointer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newPointer(elem)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/type.go:164:22) elem])

JOKER FUNC types.NewScope has:
;; (defn NewScope
;;   "NewScope returns a new, empty scope contained in the given parent\nscope, if any. The comment is for debugging only.\n\nGo return type: *Scope\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newScope(parent, pos, end, comment)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/scope.go:36:22) parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/scope.go:36:39) pos, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/scope.go:36:39) end, ^String comment])

JOKER FUNC types.NewSignature has:
;; (defn NewSignature
;;   "NewSignature returns a new function type for the given receiver, parameters,\nand results, either of which may be nil. If variadic is set, the function\nis variadic, it must have at least one parameter, and the last parameter\nmust be of unnamed slice type.\n\nGo return type: *Signature\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newSignature(recv, params, results, variadic)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/type.go:213:24) recv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/type.go:213:46) params, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/type.go:213:46) results, ^Bool variadic])

JOKER FUNC types.NewSlice has:
;; (defn NewSlice
;;   "NewSlice returns a new slice type for the given element type.\n\nGo return type: *Slice\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newSlice(elem)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/type.go:116:20) elem])

JOKER FUNC types.NewStruct has:
;; (defn NewStruct
;;   "NewStruct returns a new struct with the given fields and corresponding field tags.\nIf a field with index i has a tag, tags[i] must be that tag, but len(tags) may be\nonly as long as required to hold the tag with the largest index i. Consequently,\nif no field has a tag, tags may be nil.\n\nGo return type: *Struct\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newStruct(fields, tags)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:131:23) fields, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:131:36) tags])

JOKER FUNC types.NewTuple has:
;; (defn NewTuple
;;   "NewTuple returns a new tuple for the given variables.\n\nGo return type: *Tuple\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newTuple(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/go/types/type.go:177:17) x])

JOKER FUNC types.NewTypeName has:
;; (defn NewTypeName
;;   "NewTypeName returns a new type name denoting the given typ.\nThe remaining arguments set the attributes found with all Objects.\n\nThe typ argument may be a defined (Named) type or an alias type.\nIt may also be nil such that the returned TypeName can be used as\nargument for NewNamed, which will set the TypeName's type as a side-\neffect.\n\nGo return type: *TypeName\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newTypeName(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:226:22) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:226:37) pkg, ^String name, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/object.go:226:64) typ])

JOKER FUNC types.NewVar has:
;; (defn NewVar
;;   "NewVar returns a new variable.\nThe arguments set the attributes found with all Objects.\n\nGo return type: *Var\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newVar(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:264:17) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:264:32) pkg, ^String name, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/object.go:264:59) typ])

JOKER FUNC types.ObjectString has:
;; (defn ^String ObjectString
;;   "ObjectString returns the string form of obj.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.ObjectString(obj, qf)"}
;;   [^ABEND885(unrecognized type Object at: GO.link/src/go/types/object.go:450:23) obj, ^ABEND885(unrecognized type Qualifier at: GO.link/src/go/types/object.go:450:34) qf])

JOKER FUNC types.RelativeTo has:
;; (defn RelativeTo
;;   "RelativeTo(pkg) returns a Qualifier that fully qualifies members of\nall packages other than pkg.\n\nGo return type: Qualifier\n\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/go/types/typestring.go:25:16)"
;;   {:added "1.0"
;;    :go "relativeTo(pkg)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/typestring.go:29:21) pkg])

JOKER FUNC types.SelectionString has:
;; (defn ^String SelectionString
;;   "SelectionString returns the string form of s.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nExamples:\n\t\"field (T) f int\"\n\t\"method (T) f(X) Y\"\n\t\"method expr (T) f(X) Y\"\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.SelectionString(s, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/selection.go:119:24) s, ^ABEND885(unrecognized type Qualifier at: GO.link/src/go/types/selection.go:119:39) qf])

JOKER FUNC types.SizesFor has:
;; (defn SizesFor
;;   "SizesFor returns the Sizes used by a compiler for an architecture.\nThe result is nil if a compiler/architecture pair is not known.\n\nSupported architectures for compiler \"gc\":\n\"386\", \"arm\", \"arm64\", \"amd64\", \"amd64p32\", \"mips\", \"mipsle\",\n\"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"wasm\".\n\nGo return type: Sizes\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/types/sizes.go:10:12)"
;;   {:added "1.0"
;;    :go "sizesFor(compiler, arch)"}
;;   [^String compiler, ^String arch])

JOKER FUNC types.TypeString has:
;; (defn ^String TypeString
;;   "TypeString returns the string representation of typ.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo return type: string\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.TypeString(typ, qf)"}
;;   [^ABEND885(unrecognized type Type at: GO.link/src/go/types/typestring.go:65:21) typ, ^ABEND885(unrecognized type Qualifier at: GO.link/src/go/types/typestring.go:65:30) qf])

JOKER FUNC types.WriteExpr has:
;; (defn WriteExpr
;;   "WriteExpr writes the (possibly shortened) string representation for x to buf.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n"
;;   {:added "1.0"
;;    :go "writeExpr(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/exprstring.go:26:20) buf, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/exprstring.go:26:37) x])

JOKER FUNC types.WriteSignature has:
;; (defn WriteSignature
;;   "WriteSignature writes the representation of the signature sig to buf,\nwithout a leading \"func\" keyword.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n"
;;   {:added "1.0"
;;    :go "writeSignature(buf, sig, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/typestring.go:285:25) buf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/typestring.go:285:44) sig, ^ABEND885(unrecognized type Qualifier at: GO.link/src/go/types/typestring.go:285:59) qf])

JOKER FUNC types.WriteType has:
;; (defn WriteType
;;   "WriteType writes the string representation of typ to buf.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n"
;;   {:added "1.0"
;;    :go "writeType(buf, typ, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/typestring.go:74:20) buf, ^ABEND885(unrecognized type Type at: GO.link/src/go/types/typestring.go:74:39) typ, ^ABEND885(unrecognized type Qualifier at: GO.link/src/go/types/typestring.go:74:48) qf])

JOKER FUNC unicode.In has:
;; (defn ^Bool In
;;   "In reports whether the rune is a member of one of the ranges.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.In(r, ranges)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:69:11) r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: GO.link/src/unicode/graphic.go:69:24) ranges])

JOKER FUNC unicode.Is has:
;; (defn ^Bool Is
;;   "Is reports whether the rune is in the specified table of ranges.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.Is(rangeTab, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/unicode/letter.go:158:18) rangeTab, ^ABEND885(unrecognized type rune at: GO.link/src/unicode/letter.go:158:33) r])

JOKER FUNC unicode.IsControl has:
;; (defn ^Bool IsControl
;;   "IsControl reports whether the rune is a control character.\nThe C (Other) Unicode category includes more code points\nsuch as surrogates; use Is(C, r) to test for them.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsControl(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:81:18) r])

JOKER FUNC unicode.IsDigit has:
;; (defn ^Bool IsDigit
;;   "IsDigit reports whether the rune is a decimal digit.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsDigit(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/digit.go:8:16) r])

JOKER FUNC unicode.IsGraphic has:
;; (defn ^Bool IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode.\nSuch characters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, Zs.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsGraphic(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:36:18) r])

JOKER FUNC unicode.IsLetter has:
;; (defn ^Bool IsLetter
;;   "IsLetter reports whether the rune is a letter (category L).\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsLetter(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:90:17) r])

JOKER FUNC unicode.IsLower has:
;; (defn ^Bool IsLower
;;   "IsLower reports whether the rune is a lower case letter.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsLower(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/letter.go:192:16) r])

JOKER FUNC unicode.IsMark has:
;; (defn ^Bool IsMark
;;   "IsMark reports whether the rune is a mark character (category M).\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsMark(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:98:15) r])

JOKER FUNC unicode.IsNumber has:
;; (defn ^Bool IsNumber
;;   "IsNumber reports whether the rune is a number (category N).\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsNumber(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:104:17) r])

JOKER FUNC unicode.IsOneOf has:
;; (defn ^Bool IsOneOf
;;   "IsOneOf reports whether the rune is a member of one of the ranges.\nThe function \"In\" provides a nicer signature and should be used in preference to IsOneOf.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsOneOf(ranges, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/graphic.go:59:21) ranges, ^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:59:38) r])

JOKER FUNC unicode.IsPrint has:
;; (defn ^Bool IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and the\nASCII space character, from categories L, M, N, P, S and the ASCII space\ncharacter. This categorization is the same as IsGraphic except that the\nonly spacing character is ASCII space, U+0020.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsPrint(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:50:16) r])

JOKER FUNC unicode.IsPunct has:
;; (defn ^Bool IsPunct
;;   "IsPunct reports whether the rune is a Unicode punctuation character\n(category P).\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsPunct(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:113:16) r])

JOKER FUNC unicode.IsSpace has:
;; (defn ^Bool IsSpace
;;   "IsSpace reports whether the rune is a space character as defined\nby Unicode's White Space property; in the Latin-1 space\nthis is\n\t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\nOther definitions of spacing characters are set by category\nZ and property Pattern_White_Space.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsSpace(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:126:16) r])

JOKER FUNC unicode.IsSymbol has:
;; (defn ^Bool IsSymbol
;;   "IsSymbol reports whether the rune is a symbolic character.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsSymbol(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/graphic.go:139:17) r])

JOKER FUNC unicode.IsTitle has:
;; (defn ^Bool IsTitle
;;   "IsTitle reports whether the rune is a title case letter.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsTitle(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/letter.go:201:16) r])

JOKER FUNC unicode.IsUpper has:
;; (defn ^Bool IsUpper
;;   "IsUpper reports whether the rune is an upper case letter.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsUpper(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/letter.go:183:16) r])

JOKER FUNC unicode.SimpleFold has:
;; (defn SimpleFold
;;   "SimpleFold iterates over Unicode code points equivalent under\nthe Unicode-defined simple case folding. Among the code points\nequivalent to rune (including rune itself), SimpleFold returns the\nsmallest rune > r if one exists, or else the smallest rune >= 0.\nIf r is not a valid Unicode code point, SimpleFold(r) returns r.\n\nFor example:\n\tSimpleFold('A') = 'a'\n\tSimpleFold('a') = 'A'\n\n\tSimpleFold('K') = 'k'\n\tSimpleFold('k') = '\\u212A' (Kelvin symbol, K)\n\tSimpleFold('\\u212A') = 'K'\n\n\tSimpleFold('1') = '1'\n\n\tSimpleFold(-2) = -2\n\nGo return type: rune\n\nJoker return type: ABEND042(cannot find typename unicode.rune)"
;;   {:added "1.0"
;;    :go "simpleFold(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/letter.go:339:19) r])

JOKER FUNC unicode.To has:
;; (defn To
;;   "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.\n\nGo return type: rune\n\nJoker return type: ABEND042(cannot find typename unicode.rune)"
;;   {:added "1.0"
;;    :go "to(_case, r)"}
;;   [^Int _case, ^ABEND885(unrecognized type rune at: GO.link/src/unicode/letter.go:247:22) r])

JOKER FUNC unicode.ToLower has:
;; (defn ToLower
;;   "ToLower maps the rune to lower case.\n\nGo return type: rune\n\nJoker return type: ABEND042(cannot find typename unicode.rune)"
;;   {:added "1.0"
;;    :go "toLower(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/letter.go:264:16) r])

JOKER FUNC unicode.ToTitle has:
;; (defn ToTitle
;;   "ToTitle maps the rune to title case.\n\nGo return type: rune\n\nJoker return type: ABEND042(cannot find typename unicode.rune)"
;;   {:added "1.0"
;;    :go "toTitle(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/letter.go:275:16) r])

JOKER FUNC unicode.ToUpper has:
;; (defn ToUpper
;;   "ToUpper maps the rune to upper case.\n\nGo return type: rune\n\nJoker return type: ABEND042(cannot find typename unicode.rune)"
;;   {:added "1.0"
;;    :go "toUpper(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/letter.go:253:16) r])

JOKER FUNC unsafe.Alignof has:
;; (defn Alignof
;;   "Alignof takes an expression x of any type and returns the required alignment\nof a hypothetical variable v as if v was declared via var v = x.\nIt is the largest value m such that the address of v is always zero mod m.\nIt is the same as the value returned by reflect.TypeOf(x).Align().\nAs a special case, if a variable s is of struct type and f is a field\nwithin that struct, then Alignof(s.f) will return the required alignment\nof a field of that type within a struct. This case is the same as the\nvalue returned by reflect.TypeOf(s.f).FieldAlign().\n\nGo return type: uintptr\n\nJoker return type: ABEND042(cannot find typename unsafe.uintptr)"
;;   {:added "1.0"
;;    :go "alignof(x)"}
;;   [^ABEND885(unrecognized type ArbitraryType at: GO.link/src/unsafe/unsafe.go:196:16) x])

JOKER FUNC unsafe.Offsetof has:
;; (defn Offsetof
;;   "Offsetof returns the offset within the struct of the field represented by x,\nwhich must be of the form structValue.field. In other words, it returns the\nnumber of bytes between the start of the struct and the start of the field.\n\nGo return type: uintptr\n\nJoker return type: ABEND042(cannot find typename unsafe.uintptr)"
;;   {:added "1.0"
;;    :go "offsetof(x)"}
;;   [^ABEND885(unrecognized type ArbitraryType at: GO.link/src/unsafe/unsafe.go:186:17) x])

JOKER FUNC unsafe.Sizeof has:
;; (defn Sizeof
;;   "Sizeof takes an expression x of any type and returns the size in bytes\nof a hypothetical variable v as if v was declared via var v = x.\nThe size does not include any memory possibly referenced by x.\nFor instance, if x is a slice, Sizeof returns the size of the slice\ndescriptor, not the size of the memory referenced by the slice.\n\nGo return type: uintptr\n\nJoker return type: ABEND042(cannot find typename unsafe.uintptr)"
;;   {:added "1.0"
;;    :go "sizeof(x)"}
;;   [^ABEND885(unrecognized type ArbitraryType at: GO.link/src/unsafe/unsafe.go:181:15) x])

JOKER FUNC url.Parse has:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo return type: (*URL, error)\n\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^{}, :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
  {:added "1.0"
   :go "parse(rawurl)"}
  [^String rawurl])

JOKER FUNC url.ParseQuery has:
;; (defn ParseQuery
;;   "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo return type: (Values, error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13) Error]"
;;   {:added "1.0"
;;    :go "parseQuery(query)"}
;;   [^String query])

JOKER FUNC url.ParseRequestURI has:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo return type: (*URL, error)\n\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^{}, :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
  {:added "1.0"
   :go "parseRequestURI(rawurl)"}
  [^String rawurl])

JOKER FUNC url.PathEscape has:
(defn ^String PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(s)"}
  [^String s])

JOKER FUNC url.PathUnescape has:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "pathUnescape(s)"}
  [^String s])

JOKER FUNC url.QueryEscape has:
(defn ^String QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo return type: string\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(s)"}
  [^String s])

JOKER FUNC url.QueryUnescape has:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo return type: (string, error)\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "queryUnescape(s)"}
  [^String s])

JOKER FUNC url.User has:
;; (defn User
;;   "User returns a Userinfo containing the provided username\nand no password set.\n\nGo return type: *Userinfo\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "user(username)"}
;;   [^String username])

JOKER FUNC url.UserPassword has:
;; (defn UserPassword
;;   "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo return type: *Userinfo\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "userPassword(username, password)"}
;;   [^String username, ^String password])

JOKER FUNC user.Current has:
(defn Current
  "Current returns the current user.\n\nGo return type: (*User, error)\n\nJoker return type: [{:Uid ^String, :Gid ^String, :Username ^String, :Name ^String, :HomeDir ^String} Error]"
  {:added "1.0"
   :go "current()"}
  [])

JOKER FUNC user.Lookup has:
(defn Lookup
  "Lookup looks up a user by username. If the user cannot be found, the\nreturned error is of type UnknownUserError.\n\nGo return type: (*User, error)\n\nJoker return type: [{:Uid ^String, :Gid ^String, :Username ^String, :Name ^String, :HomeDir ^String} Error]"
  {:added "1.0"
   :go "lookup(username)"}
  [^String username])

JOKER FUNC user.LookupGroup has:
(defn LookupGroup
  "LookupGroup looks up a group by name. If the group cannot be found, the\nreturned error is of type UnknownGroupError.\n\nGo return type: (*Group, error)\n\nJoker return type: [{:Gid ^String, :Name ^String} Error]"
  {:added "1.0"
   :go "lookupGroup(name)"}
  [^String name])

JOKER FUNC user.LookupGroupId has:
(defn LookupGroupId
  "LookupGroupId looks up a group by groupid. If the group cannot be found, the\nreturned error is of type UnknownGroupIdError.\n\nGo return type: (*Group, error)\n\nJoker return type: [{:Gid ^String, :Name ^String} Error]"
  {:added "1.0"
   :go "lookupGroupId(gid)"}
  [^String gid])

JOKER FUNC user.LookupId has:
(defn LookupId
  "LookupId looks up a user by userid. If the user cannot be found, the\nreturned error is of type UnknownUserIdError.\n\nGo return type: (*User, error)\n\nJoker return type: [{:Uid ^String, :Gid ^String, :Username ^String, :Name ^String, :HomeDir ^String} Error]"
  {:added "1.0"
   :go "lookupId(uid)"}
  [^String uid])

JOKER FUNC utf16.Decode has:
;; (defn Decode
;;   "Decode returns the Unicode code point sequence represented\nby the UTF-16 encoding s.\n\nGo return type: []rune\n\nJoker return type: (vector-of ABEND042(cannot find typename utf16.rune))"
;;   {:added "1.0"
;;    :go "decode(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf16/utf16.go:88:15) s])

JOKER FUNC utf16.DecodeRune has:
;; (defn DecodeRune
;;   "DecodeRune returns the UTF-16 decoding of a surrogate pair.\nIf the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\nthe Unicode replacement code point U+FFFD.\n\nGo return type: rune\n\nJoker return type: ABEND042(cannot find typename utf16.rune)"
;;   {:added "1.0"
;;    :go "decodeRune(r1, r2)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/utf16/utf16.go:37:24) r1, ^ABEND885(unrecognized type rune at: GO.link/src/unicode/utf16/utf16.go:37:24) r2])

JOKER FUNC utf16.Encode has:
;; (defn Encode
;;   "Encode returns the UTF-16 encoding of the Unicode code point sequence s.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "encode(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf16/utf16.go:56:15) s])

JOKER FUNC utf16.EncodeRune has:
;; (defn EncodeRune
;;   "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\nIf the rune is not a valid Unicode code point or does not need encoding,\nEncodeRune returns U+FFFD, U+FFFD.\n\nGo return type: (r1 rune, r2 rune)\n\nJoker return type: [ABEND042(cannot find typename utf16.rune) ABEND042(cannot find typename utf16.rune)]"
;;   {:added "1.0"
;;    :go "encodeRune(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/utf16/utf16.go:47:19) r])

JOKER FUNC utf16.IsSurrogate has:
;; (defn ^Bool IsSurrogate
;;   "IsSurrogate reports whether the specified Unicode code point\ncan appear in a surrogate pair.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "utf16.IsSurrogate(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/utf16/utf16.go:30:20) r])

JOKER FUNC utf8.DecodeLastRune has:
;; (defn DecodeLastRune
;;   "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo return type: (r rune, size int)\n\nJoker return type: [ABEND042(cannot find typename utf8.rune) Int]"
;;   {:added "1.0"
;;    :go "decodeLastRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf8/utf8.go:245:23) p])

JOKER FUNC utf8.DecodeLastRuneInString has:
;; (defn DecodeLastRuneInString
;;   "DecodeLastRuneInString is like DecodeLastRune but its input is a string. If\ns is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\nit returns (RuneError, 1). Both are impossible results for correct,\nnon-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo return type: (r rune, size int)\n\nJoker return type: [ABEND042(cannot find typename utf8.rune) Int]"
;;   {:added "1.0"
;;    :go "decodeLastRuneInString(s)"}
;;   [^String s])

JOKER FUNC utf8.DecodeRune has:
;; (defn DecodeRune
;;   "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo return type: (r rune, size int)\n\nJoker return type: [ABEND042(cannot find typename utf8.rune) Int]"
;;   {:added "1.0"
;;    :go "decodeRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf8/utf8.go:149:19) p])

JOKER FUNC utf8.DecodeRuneInString has:
;; (defn DecodeRuneInString
;;   "DecodeRuneInString is like DecodeRune but its input is a string. If s is\nempty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it\nreturns (RuneError, 1). Both are impossible results for correct, non-empty\nUTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo return type: (r rune, size int)\n\nJoker return type: [ABEND042(cannot find typename utf8.rune) Int]"
;;   {:added "1.0"
;;    :go "decodeRuneInString(s)"}
;;   [^String s])

JOKER FUNC utf8.EncodeRune has:
;; (defn ^Int EncodeRune
;;   "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\nIt returns the number of bytes written.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.EncodeRune(p, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf8/utf8.go:339:19) p, ^ABEND885(unrecognized type rune at: GO.link/src/unicode/utf8/utf8.go:339:29) r])

JOKER FUNC utf8.FullRune has:
;; (defn ^Bool FullRune
;;   "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.\nAn invalid encoding is considered a full Rune since it will convert as a width-1 error rune.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "utf8.FullRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf8/utf8.go:102:17) p])

JOKER FUNC utf8.FullRuneInString has:
(defn ^Bool FullRuneInString
  "FullRuneInString is like FullRune but its input is a string.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.FullRuneInString(s)"}
  [^String s])

JOKER FUNC utf8.RuneCount has:
;; (defn ^Int RuneCount
;;   "RuneCount returns the number of runes in p. Erroneous and short\nencodings are treated as single runes of width 1 byte.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.RuneCount(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf8/utf8.go:371:18) p])

JOKER FUNC utf8.RuneCountInString has:
(defn ^Int RuneCountInString
  "RuneCountInString is like RuneCount but its input is a string.\n\nGo return type: int\n\nJoker return type: Int"
  {:added "1.0"
   :go "utf8.RuneCountInString(s)"}
  [^String s])

JOKER FUNC utf8.RuneLen has:
;; (defn ^Int RuneLen
;;   "RuneLen returns the number of bytes required to encode the rune.\nIt returns -1 if the rune is not a valid value to encode in UTF-8.\n\nGo return type: int\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.RuneLen(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/utf8/utf8.go:319:16) r])

JOKER FUNC utf8.RuneStart has:
(defn ^Bool RuneStart
  "RuneStart reports whether the byte could be the first byte of an encoded,\npossibly invalid rune. Second and subsequent bytes always have the top two\nbits set to 10.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.RuneStart(b)"}
  [^Byte b])

JOKER FUNC utf8.Valid has:
;; (defn ^Bool Valid
;;   "Valid reports whether p consists entirely of valid UTF-8-encoded runes.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "utf8.Valid(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf8/utf8.go:448:14) p])

JOKER FUNC utf8.ValidRune has:
;; (defn ^Bool ValidRune
;;   "ValidRune reports whether r can be legally encoded as UTF-8.\nCode points that are out of range or a surrogate half are illegal.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "utf8.ValidRune(r)"}
;;   [^ABEND885(unrecognized type rune at: GO.link/src/unicode/utf8/utf8.go:513:18) r])

JOKER FUNC utf8.ValidString has:
(defn ^Bool ValidString
  "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\n\nGo return type: bool\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.ValidString(s)"}
  [^String s])

JOKER FUNC x509.CreateCertificate has:
;; (defn CreateCertificate
;;   "CreateCertificate creates a new X.509v3 certificate based on a template.\nThe following members of template are used:\n\n - AuthorityKeyId\n - BasicConstraintsValid\n - CRLDistributionPoints\n - DNSNames\n - EmailAddresses\n - ExcludedDNSDomains\n - ExcludedEmailAddresses\n - ExcludedIPRanges\n - ExcludedURIDomains\n - ExtKeyUsage\n - ExtraExtensions\n - IsCA\n - IssuingCertificateURL\n - KeyUsage\n - MaxPathLen\n - MaxPathLenZero\n - NotAfter\n - NotBefore\n - OCSPServer\n - PermittedDNSDomains\n - PermittedDNSDomainsCritical\n - PermittedEmailAddresses\n - PermittedIPRanges\n - PermittedURIDomains\n - PolicyIdentifiers\n - SerialNumber\n - SignatureAlgorithm\n - Subject\n - SubjectKeyId\n - URIs\n - UnknownExtKeyUsage\n\nThe certificate is signed by parent. If parent is equal to template then the\ncertificate is self-signed. The parameter pub is the public key of the\nsignee and priv is the private key of the signer.\n\nThe returned slice is the certificate in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nThe AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,\nunless the resulting certificate is self-signed. Otherwise the value from\ntemplate will be used.\n\nGo return type: (cert []int, err error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "createCertificate(rand, template, parent, pub, priv)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2082:29) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/x509.go:2082:57) template, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/x509.go:2082:57) parent, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:2082:81) pub, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:2082:81) priv])

JOKER FUNC x509.CreateCertificateRequest has:
;; (defn CreateCertificateRequest
;;   "CreateCertificateRequest creates a new certificate request based on a\ntemplate. The following members of template are used:\n\n - Attributes\n - DNSNames\n - EmailAddresses\n - ExtraExtensions\n - IPAddresses\n - URIs\n - SignatureAlgorithm\n - Subject\n\nThe private key is the private key of the signer.\n\nThe returned slice is the certificate request in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nGo return type: (csr []int, err error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "createCertificateRequest(rand, template, priv)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2407:36) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/x509.go:2407:56) template, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:2407:82) priv])

JOKER FUNC x509.DecryptPEMBlock has:
;; (defn DecryptPEMBlock
;;   "DecryptPEMBlock takes a password encrypted PEM block and the password used to\nencrypt it and returns a slice of decrypted DER encoded bytes. It inspects\nthe DEK-Info header to determine the algorithm used for decryption. If no\nDEK-Info header is present, an error is returned. If an incorrect password\nis detected an IncorrectPasswordError is returned. Because of deficiencies\nin the encrypted-PEM format, it's not always possible to detect an incorrect\npassword. In these cases no error will be returned but the decrypted DER\nbytes will be random noise.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "decryptPEMBlock(b, password)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/pem_decrypt.go:115:24) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pem_decrypt.go:115:45) password])

JOKER FUNC x509.EncryptPEMBlock has:
;; (defn EncryptPEMBlock
;;   "EncryptPEMBlock returns a PEM block of the specified type holding the\ngiven DER-encoded data encrypted with the specified algorithm and\npassword.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/pem_decrypt.go:183:96) Error]"
;;   {:added "1.0"
;;    :go "encryptPEMBlock(rand, blockType, data, password, alg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/pem_decrypt.go:183:27) rand, ^String blockType, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pem_decrypt.go:183:71) data, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pem_decrypt.go:183:71) password, ^ABEND885(unrecognized type PEMCipher at: GO.link/src/crypto/x509/pem_decrypt.go:183:83) alg])

JOKER FUNC x509.IsEncryptedPEMBlock has:
;; (defn ^Bool IsEncryptedPEMBlock
;;   "IsEncryptedPEMBlock returns if the PEM block is password encrypted.\n\nGo return type: bool\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "x509.IsEncryptedPEMBlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/pem_decrypt.go:99:28) b])

JOKER FUNC x509.MarshalECPrivateKey has:
;; (defn MarshalECPrivateKey
;;   "MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalECPrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/sec1.go:37:30) key])

JOKER FUNC x509.MarshalPKCS1PrivateKey has:
;; (defn MarshalPKCS1PrivateKey
;;   "MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "marshalPKCS1PrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/pkcs1.go:92:33) key])

JOKER FUNC x509.MarshalPKCS1PublicKey has:
;; (defn MarshalPKCS1PublicKey
;;   "MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.\n\nGo return type: []int\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "marshalPKCS1PublicKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/pkcs1.go:148:32) key])

JOKER FUNC x509.MarshalPKCS8PrivateKey has:
;; (defn MarshalPKCS8PrivateKey
;;   "MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form.\nThe following key types are supported: *rsa.PrivateKey, *ecdsa.PrivateKey.\nUnsupported key types result in an error.\n\nSee RFC 5208.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalPKCS8PrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/pkcs8.go:63:33) key])

JOKER FUNC x509.MarshalPKIXPublicKey has:
;; (defn MarshalPKIXPublicKey
;;   "MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalPKIXPublicKey(pub)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:104:31) pub])

JOKER FUNC x509.NewCertPool has:
;; (defn NewCertPool
;;   "NewCertPool returns a new, empty CertPool.\n\nGo return type: *CertPool\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newCertPool()"}
;;   [])

JOKER FUNC x509.ParseCRL has:
;; (defn ParseCRL
;;   "ParseCRL parses a CRL from the given bytes. It's often the case that PEM\nencoded CRLs will appear where they should be DER encoded, so this function\nwill transparently handle PEM encoding as long as there isn't any leading\ngarbage.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2179:34) Error]"
;;   {:added "1.0"
;;    :go "parseCRL(crlBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:2179:24) crlBytes])

JOKER FUNC x509.ParseCertificate has:
;; (defn ParseCertificate
;;   "ParseCertificate parses a single certificate from the given ASN.1 DER data.\n\nGo return type: (*Certificate, error)\n\nJoker return type: [{:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:647:23), :Issuer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:648:22), :Subject ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:649:22), :NotBefore ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:650:22), :NotAfter ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:650:22), :KeyUsage ^Int, :Extensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:657:15)), :ExtraExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:663:20)), :UnhandledCriticalExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:673:32)), :ExtKeyUsage ^(vector-of Int), :UnknownExtKeyUsage ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:676:23)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:714:19)), :URIs ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:715:20)), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:721:33)), :ExcludedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:722:33)), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:731:22))} Error]"
;;   {:added "1.0"
;;    :go "parseCertificate(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:1562:32) asn1Data])

JOKER FUNC x509.ParseCertificateRequest has:
;; (defn ParseCertificateRequest
;;   "ParseCertificateRequest parses a single certificate request from the\ngiven ASN.1 DER data.\n\nGo return type: (*CertificateRequest, error)\n\nJoker return type: [{:Raw ^(vector-of Int), :RawTBSCertificateRequest ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :Version ^Int, :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:2274:21), :Subject ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2276:10), :Attributes ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2279:15)), :Extensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2284:15)), :ExtraExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2293:20)), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2298:19)), :URIs ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2299:20))} Error]"
;;   {:added "1.0"
;;    :go "parseCertificateRequest(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:2575:39) asn1Data])

JOKER FUNC x509.ParseCertificates has:
;; (defn ParseCertificates
;;   "ParseCertificates parses one or more certificates from the given ASN.1 DER\ndata. The certificates must be concatenated with no intermediate padding.\n\nGo return type: ([]*Certificate, error)\n\nJoker return type: [(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:647:23), :Issuer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:648:22), :Subject ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:649:22), :NotBefore ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:650:22), :NotAfter ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:650:22), :KeyUsage ^Int, :Extensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:657:15)), :ExtraExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:663:20)), :UnhandledCriticalExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:673:32)), :ExtKeyUsage ^(vector-of Int), :UnknownExtKeyUsage ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:676:23)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:714:19)), :URIs ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:715:20)), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:721:33)), :ExcludedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:722:33)), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:731:22))}) Error]"
;;   {:added "1.0"
;;    :go "parseCertificates(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:1577:33) asn1Data])

JOKER FUNC x509.ParseDERCRL has:
;; (defn ParseDERCRL
;;   "ParseDERCRL parses a DER encoded CRL from the given bytes.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2190:37) Error]"
;;   {:added "1.0"
;;    :go "parseDERCRL(derBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:2190:27) derBytes])

JOKER FUNC x509.ParseECPrivateKey has:
;; (defn ParseECPrivateKey
;;   "ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/sec1.go:32:38) Error]"
;;   {:added "1.0"
;;    :go "parseECPrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/sec1.go:32:28) der])

JOKER FUNC x509.ParsePKCS1PrivateKey has:
;; (defn ParsePKCS1PrivateKey
;;   "ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/pkcs1.go:45:41) Error]"
;;   {:added "1.0"
;;    :go "parsePKCS1PrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pkcs1.go:45:31) der])

JOKER FUNC x509.ParsePKCS1PublicKey has:
;; (defn ParsePKCS1PublicKey
;;   "ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.\n\nGo return type: (*..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/pkcs1.go:124:40) Error]"
;;   {:added "1.0"
;;    :go "parsePKCS1PublicKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pkcs1.go:124:30) der])

JOKER FUNC x509.ParsePKCS8PrivateKey has:
;; (defn ParsePKCS8PrivateKey
;;   "ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key.\nSee RFC 5208.\n\nGo return type: (key ..., err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/pkcs8.go:28:44) Error]"
;;   {:added "1.0"
;;    :go "parsePKCS8PrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pkcs8.go:28:31) der])

JOKER FUNC x509.ParsePKIXPublicKey has:
;; (defn ParsePKIXPublicKey
;;   "ParsePKIXPublicKey parses a DER encoded public key. These values are\ntypically found in PEM blocks with \"BEGIN PUBLIC KEY\".\n\nSupported key types include RSA, DSA, and ECDSA. Unknown key\ntypes result in an error.\n\nOn success, pub will be of type *rsa.PublicKey, *dsa.PublicKey,\nor *ecdsa.PublicKey.\n\nGo return type: (pub ..., err error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:55:47) Error]"
;;   {:added "1.0"
;;    :go "parsePKIXPublicKey(derBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:55:34) derBytes])

JOKER FUNC x509.SystemCertPool has:
(defn SystemCertPool
  "SystemCertPool returns a copy of the system cert pool.\n\nAny mutations to the returned pool are not written to disk and do\nnot affect any other pool.\n\nNew changes in the the system cert pool might not be reflected\nin subsequent calls.\n\nGo return type: (*CertPool, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "systemCertPool()"}
  [])

JOKER FUNC xml.CopyToken has:
;; (defn CopyToken
;;   "CopyToken returns a copy of a Token.\n\nGo return type: Token\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/xml/xml.go:55:12)"
;;   {:added "1.0"
;;    :go "copyToken(t)"}
;;   [^ABEND885(unrecognized type Token at: GO.link/src/encoding/xml/xml.go:122:18) t])

JOKER FUNC xml.Escape has:
;; (defn Escape
;;   "Escape is like EscapeText but omits the error return value.\nIt is provided for backwards compatibility with Go 1.0.\nCode targeting Go 1.1 or later should use EscapeText.\n"
;;   {:added "1.0"
;;    :go "escape(w, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/xml/xml.go:1985:15) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/xml/xml.go:1985:28) s])

JOKER FUNC xml.EscapeText has:
;; (defn ^Error EscapeText
;;   "EscapeText writes to w the properly escaped XML equivalent\nof the plain text data s.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.EscapeText(w, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/xml/xml.go:1891:19) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/xml/xml.go:1891:32) s])

JOKER FUNC xml.Marshal has:
;; (defn Marshal
;;   "Marshal returns the XML encoding of v.\n\nMarshal handles an array or slice by marshaling each of the elements.\nMarshal handles a pointer by marshaling the value it points at or, if the\npointer is nil, by writing nothing. Marshal handles an interface value by\nmarshaling the value it contains or, if the interface value is nil, by\nwriting nothing. Marshal handles all other data by writing one or more XML\nelements containing the data.\n\nThe name for the XML elements is taken from, in order of preference:\n    - the tag on the XMLName field, if the data is a struct\n    - the value of the XMLName field of type Name\n    - the tag of the struct field used to obtain the data\n    - the name of the struct field used to obtain the data\n    - the name of the marshaled type\n\nThe XML element for a struct contains marshaled elements for each of the\nexported fields of the struct, with these exceptions:\n    - the XMLName field, described above, is omitted.\n    - a field with tag \"-\" is omitted.\n    - a field with tag \"name,attr\" becomes an attribute with\n      the given name in the XML element.\n    - a field with tag \",attr\" becomes an attribute with the\n      field name in the XML element.\n    - a field with tag \",chardata\" is written as character data,\n      not as an XML element.\n    - a field with tag \",cdata\" is written as character data\n      wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.\n    - a field with tag \",innerxml\" is written verbatim, not subject\n      to the usual marshaling procedure.\n    - a field with tag \",comment\" is written as an XML comment, not\n      subject to the usual marshaling procedure. It must not contain\n      the \"--\" string within it.\n    - a field with a tag including the \"omitempty\" option is omitted\n      if the field value is empty. The empty values are false, 0, any\n      nil pointer or interface value, and any array, slice, map, or\n      string of length zero.\n    - an anonymous struct field is handled as if the fields of its\n      value were part of the outer struct.\n\nIf a field uses a tag \"a>b>c\", then the element c will be nested inside\nparent elements a and b. Fields that appear next to each other that name\nthe same parent will be enclosed in one XML element.\n\nIf the XML name for a struct field is defined by both the field tag and the\nstruct's XMLName field, the names must match.\n\nSee MarshalIndent for an example.\n\nMarshal will return an error if asked to marshal a channel, function, or map.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/xml/marshal.go:75:16) v])

JOKER FUNC xml.MarshalIndent has:
;; (defn MarshalIndent
;;   "MarshalIndent works like Marshal, but each XML element begins on a new\nindented line that starts with prefix and is followed by one or more\ncopies of indent according to the nesting depth.\n\nGo return type: ([]int, error)\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalIndent(v, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/xml/marshal.go:121:22) v, ^String prefix, ^String indent])

JOKER FUNC xml.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder creates a new XML parser reading from r.\nIf r does not implement io.ByteReader, NewDecoder will\ndo its own buffering.\n\nGo return type: *Decoder\n\nJoker return type: {:Strict ^Bool, :AutoClose ^(vector-of String), :Entity ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/encoding/xml/xml.go:195:9), :CharsetReader ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/encoding/xml/xml.go:202:16), :DefaultSpace ^String}"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/xml/xml.go:229:19) r])

JOKER FUNC xml.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo return type: *Encoder\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/xml/marshal.go:137:19) w])

JOKER FUNC xml.NewTokenDecoder has:
;; (defn NewTokenDecoder
;;   "NewTokenDecoder creates a new XML parser using an underlying token stream.\n\nGo return type: *Decoder\n\nJoker return type: {:Strict ^Bool, :AutoClose ^(vector-of String), :Entity ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/encoding/xml/xml.go:195:9), :CharsetReader ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/encoding/xml/xml.go:202:16), :DefaultSpace ^String}"
;;   {:added "1.0"
;;    :go "newTokenDecoder(t)"}
;;   [^ABEND885(unrecognized type TokenReader at: GO.link/src/encoding/xml/xml.go:241:24) t])

JOKER FUNC xml.Unmarshal has:
;; (defn ^Error Unmarshal
;;   "Unmarshal parses the XML-encoded data and stores the result in\nthe value pointed to by v, which must be an arbitrary struct,\nslice, or string. Well-formed data that does not fit into v is\ndiscarded.\n\nBecause Unmarshal uses the reflect package, it can only assign\nto exported (upper case) fields. Unmarshal uses a case-sensitive\ncomparison to match XML element names to tag values and struct\nfield names.\n\nUnmarshal maps an XML element to a struct using the following rules.\nIn the rules, the tag of a field refers to the value associated with the\nkey 'xml' in the struct field's tag (see the example above).\n\n  * If the struct has a field of type []byte or string with tag\n     \",innerxml\", Unmarshal accumulates the raw XML nested inside the\n     element in that field. The rest of the rules still apply.\n\n  * If the struct has a field named XMLName of type Name,\n     Unmarshal records the element name in that field.\n\n  * If the XMLName field has an associated tag of the form\n     \"name\" or \"namespace-URL name\", the XML element must have\n     the given name (and, optionally, name space) or else Unmarshal\n     returns an error.\n\n  * If the XML element has an attribute whose name matches a\n     struct field name with an associated tag containing \",attr\" or\n     the explicit name in a struct field tag of the form \"name,attr\",\n     Unmarshal records the attribute value in that field.\n\n  * If the XML element has an attribute not handled by the previous\n     rule and the struct has a field with an associated tag containing\n     \",any,attr\", Unmarshal records the attribute value in the first\n     such field.\n\n  * If the XML element contains character data, that data is\n     accumulated in the first struct field that has tag \",chardata\".\n     The struct field may have type []byte or string.\n     If there is no such field, the character data is discarded.\n\n  * If the XML element contains comments, they are accumulated in\n     the first struct field that has tag \",comment\".  The struct\n     field may have type []byte or string. If there is no such\n     field, the comments are discarded.\n\n  * If the XML element contains a sub-element whose name matches\n     the prefix of a tag formatted as \"a\" or \"a>b>c\", unmarshal\n     will descend into the XML structure looking for elements with the\n     given names, and will map the innermost elements to that struct\n     field. A tag starting with \">\" is equivalent to one starting\n     with the field name followed by \">\".\n\n  * If the XML element contains a sub-element whose name matches\n     a struct field's XMLName tag and the struct field has no\n     explicit name tag as per the previous rule, unmarshal maps\n     the sub-element to that struct field.\n\n  * If the XML element contains a sub-element whose name matches a\n     field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal\n     maps the sub-element to that struct field.\n\n  * If the XML element contains a sub-element that hasn't matched any\n     of the above rules and the struct has a field with tag \",any\",\n     unmarshal maps the sub-element to that struct field.\n\n  * An anonymous struct field is handled as if the fields of its\n     value were part of the outer struct.\n\n  * A struct field with tag \"-\" is never unmarshaled into.\n\nUnmarshal maps an XML element to a string or []byte by saving the\nconcatenation of that element's character data in the string or\n[]byte. The saved []byte is never nil.\n\nUnmarshal maps an attribute value to a string or []byte by saving\nthe value in the string or slice.\n\nUnmarshal maps an attribute value to an Attr by saving the attribute,\nincluding its name, in the Attr.\n\nUnmarshal maps an XML element or attribute value to a slice by\nextending the length of the slice and mapping the element or attribute\nto the newly created value.\n\nUnmarshal maps an XML element or attribute value to a bool by\nsetting it to the boolean value represented by the string. Whitespace\nis trimmed and ignored.\n\nUnmarshal maps an XML element or attribute value to an integer or\nfloating-point field by setting the field to the result of\ninterpreting the string value in decimal. There is no check for\noverflow. Whitespace is trimmed and ignored.\n\nUnmarshal maps an XML element to a Name by recording the element\nname.\n\nUnmarshal maps an XML element to a pointer by setting the pointer\nto a freshly allocated value and then mapping the element to that value.\n\nA missing element or empty attribute value will be unmarshaled as a zero value.\nIf the field is a slice, a zero value will be appended to the field. Otherwise, the\nfield will be set to its zero value.\n\nGo return type: error\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.Unmarshal(data, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/xml/read.go:127:21) data, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/xml/read.go:127:31) v])

JOKER FUNC zip.FileInfoHeader has:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated FileHeader from an\nos.FileInfo.\nBecause os.FileInfo's Name method returns only the base name of\nthe file it describes, it may be necessary to modify the Name field\nof the returned header to provide the full path name of the file.\nIf compression is desired, callers should set the FileHeader.Method\nfield; it is unset by default.\n\nGo return type: (*FileHeader, error)\n\nJoker return type: [{:Name ^String, :Comment ^String, :NonUTF8 ^Bool, :CreatorVersion ^Int, :ReaderVersion ^Int, :Flags ^Int, :Method ^Int, :Modified ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/zip/struct.go:127:15), :ModifiedTime ^Int, :ModifiedDate ^Int, :CRC32 ^Int, :CompressedSize ^Int, :UncompressedSize ^Int, :CompressedSize64 ^ABEND042(cannot find typename zip.uint64), :UncompressedSize64 ^ABEND042(cannot find typename zip.uint64), :Extra ^(vector-of Int), :ExternalAttrs ^Int} Error]"
;;   {:added "1.0"
;;    :go "fileInfoHeader(fi)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/zip/struct.go:169:24) fi])

JOKER FUNC zip.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r, which is assumed to\nhave the given size in bytes.\n\nGo return type: (*Reader, error)\n\nJoker return type: [{:File ^(vector-of {}), :Comment ^String} Error]"
;;   {:added "1.0"
;;    :go "newReader(r, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/zip/reader.go:71:18) r, ^Int size])

JOKER FUNC zip.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing a zip file to w.\n\nGo return type: *Writer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/zip/writer.go:43:18) w])

JOKER FUNC zip.OpenReader has:
(defn OpenReader
  "OpenReader will open the Zip file specified by name and return a ReadCloser.\n\nGo return type: (*ReadCloser, error)\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "openReader(name)"}
  [^String name])

JOKER FUNC zip.RegisterCompressor has:
;; (defn RegisterCompressor
;;   "RegisterCompressor registers custom compressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n"
;;   {:added "1.0"
;;    :go "registerCompressor(method, comp)"}
;;   [^Int method, ^ABEND885(unrecognized type Compressor at: GO.link/src/archive/zip/register.go:128:45) comp])

JOKER FUNC zip.RegisterDecompressor has:
;; (defn RegisterDecompressor
;;   "RegisterDecompressor allows custom decompressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n"
;;   {:added "1.0"
;;    :go "registerDecompressor(method, dcomp)"}
;;   [^Int method, ^ABEND885(unrecognized type Decompressor at: GO.link/src/archive/zip/register.go:120:48) dcomp])

JOKER FUNC zlib.NewReader has:
;; (defn NewReader
;;   "NewReader creates a new ReadCloser.\nReads from the returned ReadCloser read and decompress data from r.\nIf r does not implement io.ByteReader, the decompressor may read more\ndata than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when done.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/reader.go:70:30) Error]"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/reader.go:70:18) r])

JOKER FUNC zlib.NewReaderDict has:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but uses a preset dictionary.\nNewReaderDict ignores the dictionary if the compressed data does not refer to it.\nIf the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.\n\nThe ReadCloser returned by NewReaderDict also implements Resetter.\n\nGo return type: (..., error)\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/reader.go:79:47) Error]"
;;   {:added "1.0"
;;    :go "newReaderDict(r, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/reader.go:79:22) r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/compress/zlib/reader.go:79:38) dict])

JOKER FUNC zlib.NewWriter has:
;; (defn NewWriter
;;   "NewWriter creates a new Writer.\nWrites to the returned Writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nGo return type: *Writer\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/writer.go:43:18) w])

JOKER FUNC zlib.NewWriterLevel has:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo return type: (*Writer, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newWriterLevel(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/writer.go:54:23) w, ^Int level])

JOKER FUNC zlib.NewWriterLevelDict has:
;; (defn NewWriterLevelDict
;;   "NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to\ncompress with.\n\nThe dictionary may be nil. If not, its contents should not be modified until\nthe Writer is closed.\n\nGo return type: (*Writer, error)\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newWriterLevelDict(w, level, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/writer.go:63:27) w, ^Int level, ^ABEND881(unrecognized Expr type *ast.ArrayType at: GO.link/src/compress/zlib/writer.go:63:54) dict])

GO FUNC adler32.New has:
// func new() Object {
// 	return _adler32.New()
// }

GO FUNC aes.NewCipher has:
// func newCipher(key ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/aes/cipher.go:32:20)) Object {
// 	res1, res2 := _aes.NewCipher(key)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC ascii85.Decode has:
// func decode(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/ascii85/ascii85.go:189:22), src ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/ascii85/ascii85.go:189:22), flush bool) Object {
// 	ndst, nsrc, err := _ascii85.Decode(dst, src, flush)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(ndst)))
// 	res = res.Conjoin(MakeInt(int(nsrc)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC ascii85.NewDecoder has:
// func newDecoder(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/ascii85/ascii85.go:246:19)) Object {
// 	return _ascii85.NewDecoder(r)
// }

GO FUNC ascii85.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/ascii85/ascii85.go:93:19)) Object {
// 	return _ascii85.NewEncoder(w)
// }

GO FUNC asn1.Marshal has:
// func marshal(val ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/asn1/marshal.go:677:18)) Object {
// 	res1, res2 := _asn1.Marshal(val)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC asn1.MarshalWithParams has:
// func marshalWithParams(val ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/asn1/marshal.go:683:28), params string) Object {
// 	res1, res2 := _asn1.MarshalWithParams(val, params)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC asn1.Unmarshal has:
// func unmarshal(b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/asn1/asn1.go:1053:18), val ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/asn1/asn1.go:1053:30)) Object {
// 	rest, err := _asn1.Unmarshal(b, val)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range rest {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC asn1.UnmarshalWithParams has:
// func unmarshalWithParams(b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/asn1/asn1.go:1059:28), val ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/asn1/asn1.go:1059:40), params string) Object {
// 	rest, err := _asn1.UnmarshalWithParams(b, val, params)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range rest {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC ast.Inspect has:
// func inspect(node ABEND884(unrecognized type Node at: GO.link/src/go/ast/walk.go:384:19), f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/go/ast/walk.go:384:27)) Object {
// 	_ast.Inspect(node, f)
// 	...ABEND675: TODO...
// }

GO FUNC ast.MergePackageFiles has:
// func mergePackageFiles(pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/filter.go:344:28), mode ABEND884(unrecognized type MergeMode at: GO.link/src/go/ast/filter.go:344:43)) Object {
// 	res := _ast.MergePackageFiles(pkg, mode)
// 	map1 := EmptyArrayMap()
// 	map2 := EmptyArrayMap()
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*(*res).Doc).List {
// 		map4 := EmptyArrayMap()
// 		map4.Add(MakeKeyword("Slash"), (*elem3).Slash)
// 		map4.Add(MakeKeyword("Text"), MakeString((*elem3).Text))
// 		vec3 = vec3.Conjoin(map4)
// 	}
// 	map2.Add(MakeKeyword("List"), vec3)
// 	map1.Add(MakeKeyword("Doc"), map2)
// 	map1.Add(MakeKeyword("Package"), (*res).Package)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("NamePos"), (*(*res).Name).NamePos)
// 	map5.Add(MakeKeyword("Name"), MakeString((*(*res).Name).Name))
// 	map6 := EmptyArrayMap()
// 	map6.Add(MakeKeyword("Kind"), MakeInt(int((*(*(*res).Name).Obj).Kind)))
// 	map6.Add(MakeKeyword("Name"), MakeString((*(*(*res).Name).Obj).Name))
// 	map6.Add(MakeKeyword("Decl"), (*(*(*res).Name).Obj).Decl)
// 	map6.Add(MakeKeyword("Data"), (*(*(*res).Name).Obj).Data)
// 	map6.Add(MakeKeyword("Type"), (*(*(*res).Name).Obj).Type)
// 	map5.Add(MakeKeyword("Obj"), map6)
// 	map1.Add(MakeKeyword("Name"), map5)
// 	vec7 := EmptyVector
// 	for _, elem7 := range (*res).Decls {
// 		vec7 = vec7.Conjoin(elem7)
// 	}
// 	map1.Add(MakeKeyword("Decls"), vec7)
// 	map8 := EmptyArrayMap()
// 	map8.Add(MakeKeyword("Outer"), )
// 	map8.Add(MakeKeyword("Objects"), (*(*res).Scope).Objects)
// 	map1.Add(MakeKeyword("Scope"), map8)
// 	vec9 := EmptyVector
// 	for _, elem9 := range (*res).Imports {
// 		map10 := EmptyArrayMap()
// 		map11 := EmptyArrayMap()
// 		vec12 := EmptyVector
// 		for _, elem12 := range (*(*elem9).Doc).List {
// 			map13 := EmptyArrayMap()
// 			map13.Add(MakeKeyword("Slash"), (*elem12).Slash)
// 			map13.Add(MakeKeyword("Text"), MakeString((*elem12).Text))
// 			vec12 = vec12.Conjoin(map13)
// 		}
// 		map11.Add(MakeKeyword("List"), vec12)
// 		map10.Add(MakeKeyword("Doc"), map11)
// 		map14 := EmptyArrayMap()
// 		map14.Add(MakeKeyword("NamePos"), (*(*elem9).Name).NamePos)
// 		map14.Add(MakeKeyword("Name"), MakeString((*(*elem9).Name).Name))
// 		map15 := EmptyArrayMap()
// 		map15.Add(MakeKeyword("Kind"), MakeInt(int((*(*(*elem9).Name).Obj).Kind)))
// 		map15.Add(MakeKeyword("Name"), MakeString((*(*(*elem9).Name).Obj).Name))
// 		map15.Add(MakeKeyword("Decl"), (*(*(*elem9).Name).Obj).Decl)
// 		map15.Add(MakeKeyword("Data"), (*(*(*elem9).Name).Obj).Data)
// 		map15.Add(MakeKeyword("Type"), (*(*(*elem9).Name).Obj).Type)
// 		map14.Add(MakeKeyword("Obj"), map15)
// 		map10.Add(MakeKeyword("Name"), map14)
// 		map16 := EmptyArrayMap()
// 		map16.Add(MakeKeyword("ValuePos"), (*(*elem9).Path).ValuePos)
// 		map16.Add(MakeKeyword("Kind"), (*(*elem9).Path).Kind)
// 		map16.Add(MakeKeyword("Value"), MakeString((*(*elem9).Path).Value))
// 		map10.Add(MakeKeyword("Path"), map16)
// 		map17 := EmptyArrayMap()
// 		vec18 := EmptyVector
// 		for _, elem18 := range (*(*elem9).Comment).List {
// 			map19 := EmptyArrayMap()
// 			map19.Add(MakeKeyword("Slash"), (*elem18).Slash)
// 			map19.Add(MakeKeyword("Text"), MakeString((*elem18).Text))
// 			vec18 = vec18.Conjoin(map19)
// 		}
// 		map17.Add(MakeKeyword("List"), vec18)
// 		map10.Add(MakeKeyword("Comment"), map17)
// 		map10.Add(MakeKeyword("EndPos"), (*elem9).EndPos)
// 		vec9 = vec9.Conjoin(map10)
// 	}
// 	map1.Add(MakeKeyword("Imports"), vec9)
// 	vec20 := EmptyVector
// 	for _, elem20 := range (*res).Unresolved {
// 		map21 := EmptyArrayMap()
// 		map21.Add(MakeKeyword("NamePos"), (*elem20).NamePos)
// 		map21.Add(MakeKeyword("Name"), MakeString((*elem20).Name))
// 		map22 := EmptyArrayMap()
// 		map22.Add(MakeKeyword("Kind"), MakeInt(int((*(*elem20).Obj).Kind)))
// 		map22.Add(MakeKeyword("Name"), MakeString((*(*elem20).Obj).Name))
// 		map22.Add(MakeKeyword("Decl"), (*(*elem20).Obj).Decl)
// 		map22.Add(MakeKeyword("Data"), (*(*elem20).Obj).Data)
// 		map22.Add(MakeKeyword("Type"), (*(*elem20).Obj).Type)
// 		map21.Add(MakeKeyword("Obj"), map22)
// 		vec20 = vec20.Conjoin(map21)
// 	}
// 	map1.Add(MakeKeyword("Unresolved"), vec20)
// 	vec23 := EmptyVector
// 	for _, elem23 := range (*res).Comments {
// 		map24 := EmptyArrayMap()
// 		vec25 := EmptyVector
// 		for _, elem25 := range (*elem23).List {
// 			map26 := EmptyArrayMap()
// 			map26.Add(MakeKeyword("Slash"), (*elem25).Slash)
// 			map26.Add(MakeKeyword("Text"), MakeString((*elem25).Text))
// 			vec25 = vec25.Conjoin(map26)
// 		}
// 		map24.Add(MakeKeyword("List"), vec25)
// 		vec23 = vec23.Conjoin(map24)
// 	}
// 	map1.Add(MakeKeyword("Comments"), vec23)
// 	return map1
// }

GO FUNC ast.NewCommentMap has:
// func newCommentMap(fset ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/commentmap.go:143:25), node ABEND884(unrecognized type Node at: GO.link/src/go/ast/commentmap.go:143:46), comments ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/ast/commentmap.go:143:61)) Object {
// 	return _ast.NewCommentMap(fset, node, comments)
// }

GO FUNC ast.NewIdent has:
// func newIdent(name string) Object {
// 	res := _ast.NewIdent(name)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("NamePos"), (*res).NamePos)
// 	map1.Add(MakeKeyword("Name"), MakeString((*res).Name))
// 	map2 := EmptyArrayMap()
// 	map2.Add(MakeKeyword("Kind"), MakeInt(int((*(*res).Obj).Kind)))
// 	map2.Add(MakeKeyword("Name"), MakeString((*(*res).Obj).Name))
// 	map2.Add(MakeKeyword("Decl"), (*(*res).Obj).Decl)
// 	map2.Add(MakeKeyword("Data"), (*(*res).Obj).Data)
// 	map2.Add(MakeKeyword("Type"), (*(*res).Obj).Type)
// 	map1.Add(MakeKeyword("Obj"), map2)
// 	return map1
// }

GO FUNC ast.NewObj has:
// func newObj(kind ABEND884(unrecognized type ObjKind at: GO.link/src/go/ast/scope.go:85:18), name string) Object {
// 	res := _ast.NewObj(kind, name)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Kind"), MakeInt(int((*res).Kind)))
// 	map1.Add(MakeKeyword("Name"), MakeString((*res).Name))
// 	map1.Add(MakeKeyword("Decl"), (*res).Decl)
// 	map1.Add(MakeKeyword("Data"), (*res).Data)
// 	map1.Add(MakeKeyword("Type"), (*res).Type)
// 	return map1
// }

GO FUNC ast.NewPackage has:
// func newPackage(fset ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/resolve.go:74:22), files ABEND882(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/resolve.go:74:44), importer ABEND884(unrecognized type Importer at: GO.link/src/go/ast/resolve.go:74:71), universe ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/resolve.go:74:90)) Object {
// 	res1, res2 := _ast.NewPackage(fset, files, importer, universe)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
// 	map2 := EmptyArrayMap()
// 	map2.Add(MakeKeyword("Outer"), )
// 	map2.Add(MakeKeyword("Objects"), (*(*res1).Scope).Objects)
// 	map1.Add(MakeKeyword("Scope"), map2)
// 	map1.Add(MakeKeyword("Imports"), (*res1).Imports)
// 	map1.Add(MakeKeyword("Files"), (*res1).Files)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC ast.NewScope has:
// func newScope(outer ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/scope.go:25:21)) Object {
// 	res := _ast.NewScope(outer)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Outer"), )
// 	map1.Add(MakeKeyword("Objects"), (*res).Objects)
// 	return map1
// }

GO FUNC ast.SortImports has:
// func sortImports(fset ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/import.go:15:23), f ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/ast/import.go:15:41)) Object {
// 	_ast.SortImports(fset, f)
// 	...ABEND675: TODO...
// }

GO FUNC ast.Walk has:
// func walk(v ABEND884(unrecognized type Visitor at: GO.link/src/go/ast/walk.go:51:13), node ABEND884(unrecognized type Node at: GO.link/src/go/ast/walk.go:51:27)) Object {
// 	_ast.Walk(v, node)
// 	...ABEND675: TODO...
// }

GO FUNC atomic.AddUint64 has:
// func addUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:105:21), delta ABEND884(unrecognized type uint64 at: GO.link/src/sync/atomic/doc.go:105:36)) Object {
// 	return _atomic.AddUint64(addr, delta)
// }

GO FUNC atomic.AddUintptr has:
// func addUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:108:22), delta ABEND884(unrecognized type uintptr at: GO.link/src/sync/atomic/doc.go:108:38)) Object {
// 	return _atomic.AddUintptr(addr, delta)
// }

GO FUNC atomic.LoadPointer has:
// func loadPointer(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:126:23)) Object {
// 	return _atomic.LoadPointer(addr)
// }

GO FUNC atomic.LoadUint64 has:
// func loadUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:120:22)) Object {
// 	return _atomic.LoadUint64(addr)
// }

GO FUNC atomic.LoadUintptr has:
// func loadUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:123:23)) Object {
// 	return _atomic.LoadUintptr(addr)
// }

GO FUNC atomic.StoreInt32 has:
// func storeInt32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:129:22), val int32) Object {
// 	_atomic.StoreInt32(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC atomic.StoreInt64 has:
// func storeInt64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:132:22), val int64) Object {
// 	_atomic.StoreInt64(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC atomic.StorePointer has:
// func storePointer(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:144:24), val ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/sync/atomic/doc.go:144:45)) Object {
// 	_atomic.StorePointer(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC atomic.StoreUint32 has:
// func storeUint32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:135:23), val uint32) Object {
// 	_atomic.StoreUint32(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC atomic.StoreUint64 has:
// func storeUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:138:23), val ABEND884(unrecognized type uint64 at: GO.link/src/sync/atomic/doc.go:138:36)) Object {
// 	_atomic.StoreUint64(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC atomic.StoreUintptr has:
// func storeUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:141:24), val ABEND884(unrecognized type uintptr at: GO.link/src/sync/atomic/doc.go:141:38)) Object {
// 	_atomic.StoreUintptr(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC atomic.SwapPointer has:
// func swapPointer(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:71:23), new ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/sync/atomic/doc.go:71:44)) Object {
// 	return _atomic.SwapPointer(addr, new)
// }

GO FUNC atomic.SwapUint64 has:
// func swapUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:65:22), new ABEND884(unrecognized type uint64 at: GO.link/src/sync/atomic/doc.go:65:35)) Object {
// 	return _atomic.SwapUint64(addr, new)
// }

GO FUNC atomic.SwapUintptr has:
// func swapUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/sync/atomic/doc.go:68:23), new ABEND884(unrecognized type uintptr at: GO.link/src/sync/atomic/doc.go:68:37)) Object {
// 	return _atomic.SwapUintptr(addr, new)
// }

GO FUNC base32.NewDecoder has:
// func newDecoder(enc ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/base32/base32.go:530:21), r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base32/base32.go:530:34)) Object {
// 	return _base32.NewDecoder(enc, r)
// }

GO FUNC base32.NewEncoder has:
// func newEncoder(enc ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/base32/base32.go:259:21), w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base32/base32.go:259:34)) Object {
// 	return _base32.NewEncoder(enc, w)
// }

GO FUNC base32.NewEncoding has:
// func newEncoding(encoder string) Object {
// 	return _base32.NewEncoding(encoder)
// 	ABEND124(no public information returned)
// }

GO FUNC base64.NewDecoder has:
// func newDecoder(enc ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/base64/base64.go:603:21), r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base64/base64.go:603:34)) Object {
// 	return _base64.NewDecoder(enc, r)
// }

GO FUNC base64.NewEncoder has:
// func newEncoder(enc ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/base64/base64.go:250:21), w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/base64/base64.go:250:34)) Object {
// 	return _base64.NewEncoder(enc, w)
// }

GO FUNC base64.NewEncoding has:
// func newEncoding(encoder string) Object {
// 	return _base64.NewEncoding(encoder)
// 	ABEND124(no public information returned)
// }

GO FUNC big.NewFloat has:
// func newFloat(x ABEND884(unrecognized type float64 at: GO.link/src/math/big/float.go:82:17)) Object {
// 	return _big.NewFloat(x)
// 	ABEND124(no public information returned)
// }

GO FUNC big.NewInt has:
// func newInt(x int64) Object {
// 	return _big.NewInt(x)
// 	ABEND124(no public information returned)
// }

GO FUNC big.NewRat has:
// func newRat(a int64, b int64) Object {
// 	return _big.NewRat(a, b)
// 	ABEND124(no public information returned)
// }

GO FUNC big.ParseFloat has:
// func parseFloat(s string, base int, prec uint, mode ABEND884(unrecognized type RoundingMode at: GO.link/src/math/big/floatconv.go:278:53)) Object {
// 	_, b, err := _big.ParseFloat(s, base, prec, mode)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(MakeInt(int(b)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC binary.ReadUvarint has:
// func readUvarint(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/binary/varint.go:106:20)) Object {
// 	res1, res2 := _binary.ReadUvarint(r)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC binary.ReadVarint has:
// func readVarint(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/binary/varint.go:126:19)) Object {
// 	res1, res2 := _binary.ReadVarint(r)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(res1)))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC binary.Uvarint has:
// func uvarint(buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/binary/varint.go:60:18)) Object {
// 	res1, res2 := _binary.Uvarint(buf)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeInt(int(res2)))
// 	return res
// }

GO FUNC binary.Varint has:
// func varint(buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/binary/varint.go:94:17)) Object {
// 	res1, res2 := _binary.Varint(buf)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(res1)))
// 	res = res.Conjoin(MakeInt(int(res2)))
// 	return res
// }

GO FUNC bits.Reverse64 has:
// func reverse64(x ABEND884(unrecognized type uint64 at: GO.link/src/math/bits/bits.go:238:18)) Object {
// 	return _bits.Reverse64(x)
// }

GO FUNC bits.Reverse8 has:
// func reverse8(x ABEND884(unrecognized type uint8 at: GO.link/src/math/bits/bits.go:218:17)) Object {
// 	return _bits.Reverse8(x)
// }

GO FUNC bits.ReverseBytes64 has:
// func reverseBytes64(x ABEND884(unrecognized type uint64 at: GO.link/src/math/bits/bits.go:271:23)) Object {
// 	return _bits.ReverseBytes64(x)
// }

GO FUNC bits.RotateLeft64 has:
// func rotateLeft64(x ABEND884(unrecognized type uint64 at: GO.link/src/math/bits/bits.go:201:21), k int) Object {
// 	return _bits.RotateLeft64(x, k)
// }

GO FUNC bits.RotateLeft8 has:
// func rotateLeft8(x ABEND884(unrecognized type uint8 at: GO.link/src/math/bits/bits.go:177:20), k int) Object {
// 	return _bits.RotateLeft8(x, k)
// }

GO FUNC bufio.NewReadWriter has:
// func newReadWriter(r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/bufio/bufio.go:743:22), w ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/bufio/bufio.go:743:33)) Object {
// 	return _bufio.NewReadWriter(r, w)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.NewReader has:
// func newReader(rd ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bufio/bufio.go:61:19)) Object {
// 	return _bufio.NewReader(rd)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.NewReaderSize has:
// func newReaderSize(rd ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bufio/bufio.go:46:23), size int) Object {
// 	return _bufio.NewReaderSize(rd, size)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.NewScanner has:
// func newScanner(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bufio/scan.go:86:19)) Object {
// 	return _bufio.NewScanner(r)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bufio/bufio.go:552:18)) Object {
// 	return _bufio.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.NewWriterSize has:
// func newWriterSize(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bufio/bufio.go:536:22), size int) Object {
// 	return _bufio.NewWriterSize(w, size)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.ScanBytes has:
// func scanBytes(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bufio/scan.go:284:21), atEOF bool) Object {
// 	advance, token, err := _bufio.ScanBytes(data, atEOF)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range token {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(MakeInt(int(advance)))
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC bufio.ScanLines has:
// func scanLines(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bufio/scan.go:345:21), atEOF bool) Object {
// 	advance, token, err := _bufio.ScanLines(data, atEOF)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range token {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(MakeInt(int(advance)))
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC bufio.ScanRunes has:
// func scanRunes(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bufio/scan.go:299:21), atEOF bool) Object {
// 	advance, token, err := _bufio.ScanRunes(data, atEOF)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range token {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(MakeInt(int(advance)))
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC bufio.ScanWords has:
// func scanWords(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bufio/scan.go:390:21), atEOF bool) Object {
// 	advance, token, err := _bufio.ScanWords(data, atEOF)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range token {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(MakeInt(int(advance)))
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC build.ArchChar has:
func archChar(goarch string) Object {
	res1, res2 := _build.ArchChar(goarch)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC build.Import has:
// func import(path string, srcDir string, mode ABEND884(unrecognized type ImportMode at: GO.link/src/go/build/build.go:1270:39)) Object {
// 	res1, res2 := _build.Import(path, srcDir, mode)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Dir"), MakeString((*res1).Dir))
// 	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
// 	map1.Add(MakeKeyword("ImportComment"), MakeString((*res1).ImportComment))
// 	map1.Add(MakeKeyword("Doc"), MakeString((*res1).Doc))
// 	map1.Add(MakeKeyword("ImportPath"), MakeString((*res1).ImportPath))
// 	map1.Add(MakeKeyword("Root"), MakeString((*res1).Root))
// 	map1.Add(MakeKeyword("SrcRoot"), MakeString((*res1).SrcRoot))
// 	map1.Add(MakeKeyword("PkgRoot"), MakeString((*res1).PkgRoot))
// 	map1.Add(MakeKeyword("PkgTargetRoot"), MakeString((*res1).PkgTargetRoot))
// 	map1.Add(MakeKeyword("BinDir"), MakeString((*res1).BinDir))
// 	map1.Add(MakeKeyword("Goroot"), MakeBool((*res1).Goroot))
// 	map1.Add(MakeKeyword("PkgObj"), MakeString((*res1).PkgObj))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).AllTags {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("AllTags"), vec2)
// 	map1.Add(MakeKeyword("ConflictDir"), MakeString((*res1).ConflictDir))
// 	map1.Add(MakeKeyword("BinaryOnly"), MakeBool((*res1).BinaryOnly))
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res1).GoFiles {
// 		vec3 = vec3.Conjoin(MakeString(elem3))
// 	}
// 	map1.Add(MakeKeyword("GoFiles"), vec3)
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res1).CgoFiles {
// 		vec4 = vec4.Conjoin(MakeString(elem4))
// 	}
// 	map1.Add(MakeKeyword("CgoFiles"), vec4)
// 	vec5 := EmptyVector
// 	for _, elem5 := range (*res1).IgnoredGoFiles {
// 		vec5 = vec5.Conjoin(MakeString(elem5))
// 	}
// 	map1.Add(MakeKeyword("IgnoredGoFiles"), vec5)
// 	vec6 := EmptyVector
// 	for _, elem6 := range (*res1).InvalidGoFiles {
// 		vec6 = vec6.Conjoin(MakeString(elem6))
// 	}
// 	map1.Add(MakeKeyword("InvalidGoFiles"), vec6)
// 	vec7 := EmptyVector
// 	for _, elem7 := range (*res1).CFiles {
// 		vec7 = vec7.Conjoin(MakeString(elem7))
// 	}
// 	map1.Add(MakeKeyword("CFiles"), vec7)
// 	vec8 := EmptyVector
// 	for _, elem8 := range (*res1).CXXFiles {
// 		vec8 = vec8.Conjoin(MakeString(elem8))
// 	}
// 	map1.Add(MakeKeyword("CXXFiles"), vec8)
// 	vec9 := EmptyVector
// 	for _, elem9 := range (*res1).MFiles {
// 		vec9 = vec9.Conjoin(MakeString(elem9))
// 	}
// 	map1.Add(MakeKeyword("MFiles"), vec9)
// 	vec10 := EmptyVector
// 	for _, elem10 := range (*res1).HFiles {
// 		vec10 = vec10.Conjoin(MakeString(elem10))
// 	}
// 	map1.Add(MakeKeyword("HFiles"), vec10)
// 	vec11 := EmptyVector
// 	for _, elem11 := range (*res1).FFiles {
// 		vec11 = vec11.Conjoin(MakeString(elem11))
// 	}
// 	map1.Add(MakeKeyword("FFiles"), vec11)
// 	vec12 := EmptyVector
// 	for _, elem12 := range (*res1).SFiles {
// 		vec12 = vec12.Conjoin(MakeString(elem12))
// 	}
// 	map1.Add(MakeKeyword("SFiles"), vec12)
// 	vec13 := EmptyVector
// 	for _, elem13 := range (*res1).SwigFiles {
// 		vec13 = vec13.Conjoin(MakeString(elem13))
// 	}
// 	map1.Add(MakeKeyword("SwigFiles"), vec13)
// 	vec14 := EmptyVector
// 	for _, elem14 := range (*res1).SwigCXXFiles {
// 		vec14 = vec14.Conjoin(MakeString(elem14))
// 	}
// 	map1.Add(MakeKeyword("SwigCXXFiles"), vec14)
// 	vec15 := EmptyVector
// 	for _, elem15 := range (*res1).SysoFiles {
// 		vec15 = vec15.Conjoin(MakeString(elem15))
// 	}
// 	map1.Add(MakeKeyword("SysoFiles"), vec15)
// 	vec16 := EmptyVector
// 	for _, elem16 := range (*res1).CgoCFLAGS {
// 		vec16 = vec16.Conjoin(MakeString(elem16))
// 	}
// 	map1.Add(MakeKeyword("CgoCFLAGS"), vec16)
// 	vec17 := EmptyVector
// 	for _, elem17 := range (*res1).CgoCPPFLAGS {
// 		vec17 = vec17.Conjoin(MakeString(elem17))
// 	}
// 	map1.Add(MakeKeyword("CgoCPPFLAGS"), vec17)
// 	vec18 := EmptyVector
// 	for _, elem18 := range (*res1).CgoCXXFLAGS {
// 		vec18 = vec18.Conjoin(MakeString(elem18))
// 	}
// 	map1.Add(MakeKeyword("CgoCXXFLAGS"), vec18)
// 	vec19 := EmptyVector
// 	for _, elem19 := range (*res1).CgoFFLAGS {
// 		vec19 = vec19.Conjoin(MakeString(elem19))
// 	}
// 	map1.Add(MakeKeyword("CgoFFLAGS"), vec19)
// 	vec20 := EmptyVector
// 	for _, elem20 := range (*res1).CgoLDFLAGS {
// 		vec20 = vec20.Conjoin(MakeString(elem20))
// 	}
// 	map1.Add(MakeKeyword("CgoLDFLAGS"), vec20)
// 	vec21 := EmptyVector
// 	for _, elem21 := range (*res1).CgoPkgConfig {
// 		vec21 = vec21.Conjoin(MakeString(elem21))
// 	}
// 	map1.Add(MakeKeyword("CgoPkgConfig"), vec21)
// 	vec22 := EmptyVector
// 	for _, elem22 := range (*res1).Imports {
// 		vec22 = vec22.Conjoin(MakeString(elem22))
// 	}
// 	map1.Add(MakeKeyword("Imports"), vec22)
// 	map1.Add(MakeKeyword("ImportPos"), (*res1).ImportPos)
// 	vec23 := EmptyVector
// 	for _, elem23 := range (*res1).TestGoFiles {
// 		vec23 = vec23.Conjoin(MakeString(elem23))
// 	}
// 	map1.Add(MakeKeyword("TestGoFiles"), vec23)
// 	vec24 := EmptyVector
// 	for _, elem24 := range (*res1).TestImports {
// 		vec24 = vec24.Conjoin(MakeString(elem24))
// 	}
// 	map1.Add(MakeKeyword("TestImports"), vec24)
// 	map1.Add(MakeKeyword("TestImportPos"), (*res1).TestImportPos)
// 	vec25 := EmptyVector
// 	for _, elem25 := range (*res1).XTestGoFiles {
// 		vec25 = vec25.Conjoin(MakeString(elem25))
// 	}
// 	map1.Add(MakeKeyword("XTestGoFiles"), vec25)
// 	vec26 := EmptyVector
// 	for _, elem26 := range (*res1).XTestImports {
// 		vec26 = vec26.Conjoin(MakeString(elem26))
// 	}
// 	map1.Add(MakeKeyword("XTestImports"), vec26)
// 	map1.Add(MakeKeyword("XTestImportPos"), (*res1).XTestImportPos)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC build.ImportDir has:
// func importDir(dir string, mode ABEND884(unrecognized type ImportMode at: GO.link/src/go/build/build.go:1275:33)) Object {
// 	res1, res2 := _build.ImportDir(dir, mode)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Dir"), MakeString((*res1).Dir))
// 	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
// 	map1.Add(MakeKeyword("ImportComment"), MakeString((*res1).ImportComment))
// 	map1.Add(MakeKeyword("Doc"), MakeString((*res1).Doc))
// 	map1.Add(MakeKeyword("ImportPath"), MakeString((*res1).ImportPath))
// 	map1.Add(MakeKeyword("Root"), MakeString((*res1).Root))
// 	map1.Add(MakeKeyword("SrcRoot"), MakeString((*res1).SrcRoot))
// 	map1.Add(MakeKeyword("PkgRoot"), MakeString((*res1).PkgRoot))
// 	map1.Add(MakeKeyword("PkgTargetRoot"), MakeString((*res1).PkgTargetRoot))
// 	map1.Add(MakeKeyword("BinDir"), MakeString((*res1).BinDir))
// 	map1.Add(MakeKeyword("Goroot"), MakeBool((*res1).Goroot))
// 	map1.Add(MakeKeyword("PkgObj"), MakeString((*res1).PkgObj))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).AllTags {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("AllTags"), vec2)
// 	map1.Add(MakeKeyword("ConflictDir"), MakeString((*res1).ConflictDir))
// 	map1.Add(MakeKeyword("BinaryOnly"), MakeBool((*res1).BinaryOnly))
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res1).GoFiles {
// 		vec3 = vec3.Conjoin(MakeString(elem3))
// 	}
// 	map1.Add(MakeKeyword("GoFiles"), vec3)
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res1).CgoFiles {
// 		vec4 = vec4.Conjoin(MakeString(elem4))
// 	}
// 	map1.Add(MakeKeyword("CgoFiles"), vec4)
// 	vec5 := EmptyVector
// 	for _, elem5 := range (*res1).IgnoredGoFiles {
// 		vec5 = vec5.Conjoin(MakeString(elem5))
// 	}
// 	map1.Add(MakeKeyword("IgnoredGoFiles"), vec5)
// 	vec6 := EmptyVector
// 	for _, elem6 := range (*res1).InvalidGoFiles {
// 		vec6 = vec6.Conjoin(MakeString(elem6))
// 	}
// 	map1.Add(MakeKeyword("InvalidGoFiles"), vec6)
// 	vec7 := EmptyVector
// 	for _, elem7 := range (*res1).CFiles {
// 		vec7 = vec7.Conjoin(MakeString(elem7))
// 	}
// 	map1.Add(MakeKeyword("CFiles"), vec7)
// 	vec8 := EmptyVector
// 	for _, elem8 := range (*res1).CXXFiles {
// 		vec8 = vec8.Conjoin(MakeString(elem8))
// 	}
// 	map1.Add(MakeKeyword("CXXFiles"), vec8)
// 	vec9 := EmptyVector
// 	for _, elem9 := range (*res1).MFiles {
// 		vec9 = vec9.Conjoin(MakeString(elem9))
// 	}
// 	map1.Add(MakeKeyword("MFiles"), vec9)
// 	vec10 := EmptyVector
// 	for _, elem10 := range (*res1).HFiles {
// 		vec10 = vec10.Conjoin(MakeString(elem10))
// 	}
// 	map1.Add(MakeKeyword("HFiles"), vec10)
// 	vec11 := EmptyVector
// 	for _, elem11 := range (*res1).FFiles {
// 		vec11 = vec11.Conjoin(MakeString(elem11))
// 	}
// 	map1.Add(MakeKeyword("FFiles"), vec11)
// 	vec12 := EmptyVector
// 	for _, elem12 := range (*res1).SFiles {
// 		vec12 = vec12.Conjoin(MakeString(elem12))
// 	}
// 	map1.Add(MakeKeyword("SFiles"), vec12)
// 	vec13 := EmptyVector
// 	for _, elem13 := range (*res1).SwigFiles {
// 		vec13 = vec13.Conjoin(MakeString(elem13))
// 	}
// 	map1.Add(MakeKeyword("SwigFiles"), vec13)
// 	vec14 := EmptyVector
// 	for _, elem14 := range (*res1).SwigCXXFiles {
// 		vec14 = vec14.Conjoin(MakeString(elem14))
// 	}
// 	map1.Add(MakeKeyword("SwigCXXFiles"), vec14)
// 	vec15 := EmptyVector
// 	for _, elem15 := range (*res1).SysoFiles {
// 		vec15 = vec15.Conjoin(MakeString(elem15))
// 	}
// 	map1.Add(MakeKeyword("SysoFiles"), vec15)
// 	vec16 := EmptyVector
// 	for _, elem16 := range (*res1).CgoCFLAGS {
// 		vec16 = vec16.Conjoin(MakeString(elem16))
// 	}
// 	map1.Add(MakeKeyword("CgoCFLAGS"), vec16)
// 	vec17 := EmptyVector
// 	for _, elem17 := range (*res1).CgoCPPFLAGS {
// 		vec17 = vec17.Conjoin(MakeString(elem17))
// 	}
// 	map1.Add(MakeKeyword("CgoCPPFLAGS"), vec17)
// 	vec18 := EmptyVector
// 	for _, elem18 := range (*res1).CgoCXXFLAGS {
// 		vec18 = vec18.Conjoin(MakeString(elem18))
// 	}
// 	map1.Add(MakeKeyword("CgoCXXFLAGS"), vec18)
// 	vec19 := EmptyVector
// 	for _, elem19 := range (*res1).CgoFFLAGS {
// 		vec19 = vec19.Conjoin(MakeString(elem19))
// 	}
// 	map1.Add(MakeKeyword("CgoFFLAGS"), vec19)
// 	vec20 := EmptyVector
// 	for _, elem20 := range (*res1).CgoLDFLAGS {
// 		vec20 = vec20.Conjoin(MakeString(elem20))
// 	}
// 	map1.Add(MakeKeyword("CgoLDFLAGS"), vec20)
// 	vec21 := EmptyVector
// 	for _, elem21 := range (*res1).CgoPkgConfig {
// 		vec21 = vec21.Conjoin(MakeString(elem21))
// 	}
// 	map1.Add(MakeKeyword("CgoPkgConfig"), vec21)
// 	vec22 := EmptyVector
// 	for _, elem22 := range (*res1).Imports {
// 		vec22 = vec22.Conjoin(MakeString(elem22))
// 	}
// 	map1.Add(MakeKeyword("Imports"), vec22)
// 	map1.Add(MakeKeyword("ImportPos"), (*res1).ImportPos)
// 	vec23 := EmptyVector
// 	for _, elem23 := range (*res1).TestGoFiles {
// 		vec23 = vec23.Conjoin(MakeString(elem23))
// 	}
// 	map1.Add(MakeKeyword("TestGoFiles"), vec23)
// 	vec24 := EmptyVector
// 	for _, elem24 := range (*res1).TestImports {
// 		vec24 = vec24.Conjoin(MakeString(elem24))
// 	}
// 	map1.Add(MakeKeyword("TestImports"), vec24)
// 	map1.Add(MakeKeyword("TestImportPos"), (*res1).TestImportPos)
// 	vec25 := EmptyVector
// 	for _, elem25 := range (*res1).XTestGoFiles {
// 		vec25 = vec25.Conjoin(MakeString(elem25))
// 	}
// 	map1.Add(MakeKeyword("XTestGoFiles"), vec25)
// 	vec26 := EmptyVector
// 	for _, elem26 := range (*res1).XTestImports {
// 		vec26 = vec26.Conjoin(MakeString(elem26))
// 	}
// 	map1.Add(MakeKeyword("XTestImports"), vec26)
// 	map1.Add(MakeKeyword("XTestImportPos"), (*res1).XTestImportPos)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC bytes.Fields has:
// func fields(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:283:15)) Object {
// 	res := _bytes.Fields(s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec2 := EmptyVector
// 		for _, elem2 := range elem1 {
// 			vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 		}
// 		vec1 = vec1.Conjoin(vec2)
// 	}
// 	return vec1
// }

GO FUNC bytes.FieldsFunc has:
// func fieldsFunc(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:339:19), f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:339:29)) Object {
// 	res := _bytes.FieldsFunc(s, f)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec2 := EmptyVector
// 		for _, elem2 := range elem1 {
// 			vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 		}
// 		vec1 = vec1.Conjoin(vec2)
// 	}
// 	return vec1
// }

GO FUNC bytes.Join has:
// func join(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:387:13), sep ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:387:27)) Object {
// 	res := _bytes.Join(s, sep)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.Map has:
// func map(mapping ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:423:18), s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:423:39)) Object {
// 	res := _bytes.Map(mapping, s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.NewBuffer has:
// func newBuffer(buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/buffer.go:450:20)) Object {
// 	return _bytes.NewBuffer(buf)
// 	ABEND124(no public information returned)
// }

GO FUNC bytes.NewBufferString has:
// func newBufferString(s string) Object {
// 	return _bytes.NewBufferString(s)
// 	ABEND124(no public information returned)
// }

GO FUNC bytes.NewReader has:
// func newReader(b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/reader.go:156:18)) Object {
// 	return _bytes.NewReader(b)
// 	ABEND124(no public information returned)
// }

GO FUNC bytes.Repeat has:
// func repeat(b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:460:15), count int) Object {
// 	res := _bytes.Repeat(b, count)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.Replace has:
// func replace(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:741:26), old ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:741:26), new ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:741:26), n int) Object {
// 	res := _bytes.Replace(s, old, new, n)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.Runes has:
// func runes(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:723:14)) Object {
// 	res := _bytes.Runes(s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin()
// 	}
// 	return vec1
// }

GO FUNC bytes.Split has:
// func split(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:267:19), sep ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:267:19)) Object {
// 	res := _bytes.Split(s, sep)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec2 := EmptyVector
// 		for _, elem2 := range elem1 {
// 			vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 		}
// 		vec1 = vec1.Conjoin(vec2)
// 	}
// 	return vec1
// }

GO FUNC bytes.SplitAfter has:
// func splitAfter(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:273:24), sep ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:273:24)) Object {
// 	res := _bytes.SplitAfter(s, sep)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec2 := EmptyVector
// 		for _, elem2 := range elem1 {
// 			vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 		}
// 		vec1 = vec1.Conjoin(vec2)
// 	}
// 	return vec1
// }

GO FUNC bytes.SplitAfterN has:
// func splitAfterN(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:259:25), sep ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:259:25), n int) Object {
// 	res := _bytes.SplitAfterN(s, sep, n)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec2 := EmptyVector
// 		for _, elem2 := range elem1 {
// 			vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 		}
// 		vec1 = vec1.Conjoin(vec2)
// 	}
// 	return vec1
// }

GO FUNC bytes.SplitN has:
// func splitN(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:250:20), sep ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:250:20), n int) Object {
// 	res := _bytes.SplitN(s, sep, n)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec2 := EmptyVector
// 		for _, elem2 := range elem1 {
// 			vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 		}
// 		vec1 = vec1.Conjoin(vec2)
// 	}
// 	return vec1
// }

GO FUNC bytes.Title has:
// func title(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:536:14)) Object {
// 	res := _bytes.Title(s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.ToLower has:
// func toLower(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:484:16)) Object {
// 	res := _bytes.ToLower(s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.ToLowerSpecial has:
// func toLowerSpecial(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bytes/bytes.go:497:23), s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:497:46)) Object {
// 	res := _bytes.ToLowerSpecial(c, s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.ToTitle has:
// func toTitle(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:487:16)) Object {
// 	res := _bytes.ToTitle(s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.ToTitleSpecial has:
// func toTitleSpecial(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bytes/bytes.go:503:23), s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:503:46)) Object {
// 	res := _bytes.ToTitleSpecial(c, s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.ToUpper has:
// func toUpper(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:481:16)) Object {
// 	res := _bytes.ToUpper(s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.ToUpperSpecial has:
// func toUpperSpecial(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/bytes/bytes.go:491:23), s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:491:46)) Object {
// 	res := _bytes.ToUpperSpecial(c, s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.Trim has:
// func trim(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:699:13), cutset string) Object {
// 	res := _bytes.Trim(s, cutset)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.TrimFunc has:
// func trimFunc(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:578:17), f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:578:27)) Object {
// 	res := _bytes.TrimFunc(s, f)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.TrimLeft has:
// func trimLeft(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:705:17), cutset string) Object {
// 	res := _bytes.TrimLeft(s, cutset)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.TrimLeftFunc has:
// func trimLeftFunc(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:555:21), f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:555:31)) Object {
// 	res := _bytes.TrimLeftFunc(s, f)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.TrimPrefix has:
// func trimPrefix(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:584:27), prefix ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:584:27)) Object {
// 	res := _bytes.TrimPrefix(s, prefix)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.TrimRight has:
// func trimRight(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:711:18), cutset string) Object {
// 	res := _bytes.TrimRight(s, cutset)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.TrimRightFunc has:
// func trimRightFunc(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:565:22), f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/bytes/bytes.go:565:32)) Object {
// 	res := _bytes.TrimRightFunc(s, f)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.TrimSpace has:
// func trimSpace(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:717:18)) Object {
// 	res := _bytes.TrimSpace(s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bytes.TrimSuffix has:
// func trimSuffix(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:593:27), suffix ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/bytes/bytes.go:593:27)) Object {
// 	res := _bytes.TrimSuffix(s, suffix)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC bzip2.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/bzip2/bzip2.go:46:18)) Object {
// 	return _bzip2.NewReader(r)
// }

GO FUNC cgi.Request has:
// func request() Object {
// 	res1, res2 := _cgi.Request()
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC cgi.RequestFromMap has:
// func requestFromMap(params ABEND882(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/cgi/child.go:52:28)) Object {
// 	res1, res2 := _cgi.RequestFromMap(params)
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC cgo._cgo_panic has:
// func _cgo_panic(a ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/cgo/callbacks.go:45:19), n int32) Object {
// 	_cgo._cgo_panic(a, n)
// 	...ABEND675: TODO...
// }

GO FUNC cgo._runtime_cgocallback has:
// func _runtime_cgocallback() Object {
// 	_cgo._runtime_cgocallback()
// 	...ABEND675: TODO...
// }

GO FUNC cipher.NewCBCDecrypter has:
// func newCBCDecrypter(b ABEND884(unrecognized type Block at: GO.link/src/crypto/cipher/cbc.go:105:24), iv ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/cbc.go:105:34)) Object {
// 	return _cipher.NewCBCDecrypter(b, iv)
// }

GO FUNC cipher.NewCBCEncrypter has:
// func newCBCEncrypter(b ABEND884(unrecognized type Block at: GO.link/src/crypto/cipher/cbc.go:45:24), iv ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/cbc.go:45:34)) Object {
// 	return _cipher.NewCBCEncrypter(b, iv)
// }

GO FUNC cipher.NewCFBDecrypter has:
// func newCFBDecrypter(block ABEND884(unrecognized type Block at: GO.link/src/crypto/cipher/cfb.go:60:28), iv ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/cfb.go:60:38)) Object {
// 	return _cipher.NewCFBDecrypter(block, iv)
// }

GO FUNC cipher.NewCFBEncrypter has:
// func newCFBEncrypter(block ABEND884(unrecognized type Block at: GO.link/src/crypto/cipher/cfb.go:53:28), iv ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/cfb.go:53:38)) Object {
// 	return _cipher.NewCFBEncrypter(block, iv)
// }

GO FUNC cipher.NewCTR has:
// func newCTR(block ABEND884(unrecognized type Block at: GO.link/src/crypto/cipher/ctr.go:35:19), iv ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/ctr.go:35:29)) Object {
// 	return _cipher.NewCTR(block, iv)
// }

GO FUNC cipher.NewGCM has:
// func newGCM(cipher ABEND884(unrecognized type Block at: GO.link/src/crypto/cipher/gcm.go:83:20)) Object {
// 	res1, res2 := _cipher.NewGCM(cipher)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC cipher.NewGCMWithNonceSize has:
// func newGCMWithNonceSize(cipher ABEND884(unrecognized type Block at: GO.link/src/crypto/cipher/gcm.go:93:33), size int) Object {
// 	res1, res2 := _cipher.NewGCMWithNonceSize(cipher, size)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC cipher.NewGCMWithTagSize has:
// func newGCMWithTagSize(cipher ABEND884(unrecognized type Block at: GO.link/src/crypto/cipher/gcm.go:105:31), tagSize int) Object {
// 	res1, res2 := _cipher.NewGCMWithTagSize(cipher, tagSize)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC cipher.NewOFB has:
// func newOFB(b ABEND884(unrecognized type Block at: GO.link/src/crypto/cipher/ofb.go:21:15), iv ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/cipher/ofb.go:21:25)) Object {
// 	return _cipher.NewOFB(b, iv)
// }

GO FUNC cmplx.Abs has:
// func abs(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/abs.go:12:12)) Object {
// 	return _cmplx.Abs(x)
// }

GO FUNC cmplx.Acos has:
// func acos(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:87:13)) Object {
// 	return _cmplx.Acos(x)
// }

GO FUNC cmplx.Acosh has:
// func acosh(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:93:14)) Object {
// 	return _cmplx.Acosh(x)
// }

GO FUNC cmplx.Asin has:
// func asin(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:51:13)) Object {
// 	return _cmplx.Asin(x)
// }

GO FUNC cmplx.Asinh has:
// func asinh(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:64:14)) Object {
// 	return _cmplx.Asinh(x)
// }

GO FUNC cmplx.Atan has:
// func atan(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:135:13)) Object {
// 	return _cmplx.Atan(x)
// }

GO FUNC cmplx.Atanh has:
// func atanh(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/asin.go:155:14)) Object {
// 	return _cmplx.Atanh(x)
// }

GO FUNC cmplx.Conj has:
// func conj(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/conj.go:8:13)) Object {
// 	return _cmplx.Conj(x)
// }

GO FUNC cmplx.Cos has:
// func cos(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/sin.go:98:12)) Object {
// 	return _cmplx.Cos(x)
// }

GO FUNC cmplx.Cosh has:
// func cosh(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/sin.go:117:13)) Object {
// 	return _cmplx.Cosh(x)
// }

GO FUNC cmplx.Cot has:
// func cot(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/tan.go:177:12)) Object {
// 	return _cmplx.Cot(x)
// }

GO FUNC cmplx.Exp has:
// func exp(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/exp.go:51:12)) Object {
// 	return _cmplx.Exp(x)
// }

GO FUNC cmplx.Inf has:
// func inf() Object {
// 	return _cmplx.Inf()
// }

GO FUNC cmplx.Log has:
// func log(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/log.go:57:12)) Object {
// 	return _cmplx.Log(x)
// }

GO FUNC cmplx.Log10 has:
// func log10(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/log.go:62:14)) Object {
// 	return _cmplx.Log10(x)
// }

GO FUNC cmplx.NaN has:
// func naN() Object {
// 	return _cmplx.NaN()
// }

GO FUNC cmplx.Phase has:
// func phase(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/phase.go:11:14)) Object {
// 	return _cmplx.Phase(x)
// }

GO FUNC cmplx.Polar has:
// func polar(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/polar.go:10:14)) Object {
// 	r, θ := _cmplx.Polar(x)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC cmplx.Pow has:
// func pow(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/pow.go:49:15), y ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/pow.go:49:15)) Object {
// 	return _cmplx.Pow(x, y)
// }

GO FUNC cmplx.Rect has:
// func rect(r ABEND884(unrecognized type float64 at: GO.link/src/math/cmplx/rect.go:10:17), θ ABEND884(unrecognized type float64 at: GO.link/src/math/cmplx/rect.go:10:17)) Object {
// 	return _cmplx.Rect(r, θ)
// }

GO FUNC cmplx.Sin has:
// func sin(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/sin.go:53:12)) Object {
// 	return _cmplx.Sin(x)
// }

GO FUNC cmplx.Sinh has:
// func sinh(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/sin.go:73:13)) Object {
// 	return _cmplx.Sinh(x)
// }

GO FUNC cmplx.Sqrt has:
// func sqrt(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/sqrt.go:58:13)) Object {
// 	return _cmplx.Sqrt(x)
// }

GO FUNC cmplx.Tan has:
// func tan(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/tan.go:59:12)) Object {
// 	return _cmplx.Tan(x)
// }

GO FUNC cmplx.Tanh has:
// func tanh(x ABEND884(unrecognized type complex128 at: GO.link/src/math/cmplx/tan.go:83:13)) Object {
// 	return _cmplx.Tanh(x)
// }

GO FUNC color.CMYKToRGB has:
// func cMYKToRGB(c ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:336:27), m ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:336:27), y ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:336:27), k ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:336:27)) Object {
// 	res1, res2, res3 := _color.CMYKToRGB(c, m, y, k)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC color.ModelFunc has:
// func modelFunc(f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/image/color/color.go:147:18)) Object {
// 	return _color.ModelFunc(f)
// }

GO FUNC color.RGBToCMYK has:
// func rGBToCMYK(r ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:315:24), g ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:315:24), b ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:315:24)) Object {
// 	res1, res2, res3, res4 := _color.RGBToCMYK(r, g, b)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC color.RGBToYCbCr has:
// func rGBToYCbCr(r ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:8:25), g ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:8:25), b ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:8:25)) Object {
// 	res1, res2, res3 := _color.RGBToYCbCr(r, g, b)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC color.YCbCrToRGB has:
// func yCbCrToRGB(y ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:58:27), cb ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:58:27), cr ABEND884(unrecognized type uint8 at: GO.link/src/image/color/ycbcr.go:58:27)) Object {
// 	res1, res2, res3 := _color.YCbCrToRGB(y, cb, cr)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC constant.BinaryOp has:
// func binaryOp(x_ ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:1011:18), op ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/constant/value.go:1011:28), y_ ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:1011:44)) Object {
// 	return _constant.BinaryOp(x_, op, y_)
// }

GO FUNC constant.Bytes has:
// func bytes(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:589:14)) Object {
// 	res := _constant.Bytes(x)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC constant.Denom has:
// func denom(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:675:14)) Object {
// 	return _constant.Denom(x)
// }

GO FUNC constant.Float32Val has:
// func float32Val(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:488:19)) Object {
// 	res1, res2 := _constant.Float32Val(x)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeBool(res2))
// 	return res
// }

GO FUNC constant.Float64Val has:
// func float64Val(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:513:19)) Object {
// 	res1, res2 := _constant.Float64Val(x)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeBool(res2))
// 	return res
// }

GO FUNC constant.Imag has:
// func imag(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:723:13)) Object {
// 	return _constant.Imag(x)
// }

GO FUNC constant.Int64Val has:
// func int64Val(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:458:17)) Object {
// 	res1, res2 := _constant.Int64Val(x)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(res1)))
// 	res = res.Conjoin(MakeBool(res2))
// 	return res
// }

GO FUNC constant.MakeBool has:
// func makeBool(b bool) Object {
// 	return _constant.MakeBool(b)
// }

GO FUNC constant.MakeFloat64 has:
// func makeFloat64(x ABEND884(unrecognized type float64 at: GO.link/src/go/constant/value.go:362:20)) Object {
// 	return _constant.MakeFloat64(x)
// }

GO FUNC constant.MakeFromBytes has:
// func makeFromBytes(bytes ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/constant/value.go:621:26)) Object {
// 	return _constant.MakeFromBytes(bytes)
// }

GO FUNC constant.MakeFromLiteral has:
// func makeFromLiteral(lit string, tok ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/constant/value.go:378:38), zero uint) Object {
// 	return _constant.MakeFromLiteral(lit, tok, zero)
// }

GO FUNC constant.MakeImag has:
// func makeImag(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:697:17)) Object {
// 	return _constant.MakeImag(x)
// }

GO FUNC constant.MakeInt64 has:
// func makeInt64(x int64) Object {
// 	return _constant.MakeInt64(x)
// }

GO FUNC constant.MakeString has:
// func makeString(s string) Object {
// 	return _constant.MakeString(s)
// }

GO FUNC constant.MakeUint64 has:
// func makeUint64(x ABEND884(unrecognized type uint64 at: GO.link/src/go/constant/value.go:353:19)) Object {
// 	return _constant.MakeUint64(x)
// }

GO FUNC constant.MakeUnknown has:
// func makeUnknown() Object {
// 	return _constant.MakeUnknown()
// }

GO FUNC constant.Num has:
// func num(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:653:12)) Object {
// 	return _constant.Num(x)
// }

GO FUNC constant.Real has:
// func real(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:710:13)) Object {
// 	return _constant.Real(x)
// }

GO FUNC constant.Shift has:
// func shift(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:1191:14), op ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/constant/value.go:1191:24), s uint) Object {
// 	return _constant.Shift(x, op, s)
// }

GO FUNC constant.ToComplex has:
// func toComplex(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:814:18)) Object {
// 	return _constant.ToComplex(x)
// }

GO FUNC constant.ToFloat has:
// func toFloat(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:795:16)) Object {
// 	return _constant.ToFloat(x)
// }

GO FUNC constant.ToInt has:
// func toInt(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:741:14)) Object {
// 	return _constant.ToInt(x)
// }

GO FUNC constant.Uint64Val has:
// func uint64Val(x ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:474:18)) Object {
// 	res1, res2 := _constant.Uint64Val(x)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeBool(res2))
// 	return res
// }

GO FUNC constant.UnaryOp has:
// func unaryOp(op ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/constant/value.go:850:17), y ABEND884(unrecognized type Value at: GO.link/src/go/constant/value.go:850:32), prec uint) Object {
// 	return _constant.UnaryOp(op, y, prec)
// }

GO FUNC context.Background has:
// func background() Object {
// 	return _context.Background()
// }

GO FUNC context.TODO has:
// func tODO() Object {
// 	return _context.TODO()
// }

GO FUNC context.WithCancel has:
// func withCancel(parent ABEND884(unrecognized type Context at: GO.link/src/context/context.go:230:24)) Object {
// 	ctx, cancel := _context.WithCancel(parent)
// 	res := EmptyVector
// 	res = res.Conjoin(ctx)
// 	res = res.Conjoin(cancel)
// 	return res
// }

GO FUNC context.WithDeadline has:
// func withDeadline(parent ABEND884(unrecognized type Context at: GO.link/src/context/context.go:384:26), d ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/context/context.go:384:37)) Object {
// 	res1, res2 := _context.WithDeadline(parent, d)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(res2)
// 	return res
// }

GO FUNC context.WithTimeout has:
// func withTimeout(parent ABEND884(unrecognized type Context at: GO.link/src/context/context.go:451:25), timeout ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/context/context.go:451:42)) Object {
// 	res1, res2 := _context.WithTimeout(parent, timeout)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(res2)
// 	return res
// }

GO FUNC context.WithValue has:
// func withValue(parent ABEND884(unrecognized type Context at: GO.link/src/context/context.go:468:23), key ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:468:41), val ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:468:41)) Object {
// 	return _context.WithValue(parent, key, val)
// }

GO FUNC cookiejar.New has:
// func new(o ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/cookiejar/jar.go:77:12)) Object {
// 	_, res2 := _cookiejar.New(o)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC crc32.MakeTable has:
func makeTable(poly uint32) Object {
	res := _crc32.MakeTable(poly)
	vec1 := EmptyVector
	for _, elem1 := range (*res) {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	return vec1
}

GO FUNC crc32.New has:
// func new(tab ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/hash/crc32/crc32.go:147:14)) Object {
// 	return _crc32.New(tab)
// }

GO FUNC crc32.NewIEEE has:
// func newIEEE() Object {
// 	return _crc32.NewIEEE()
// }

GO FUNC crc64.Checksum has:
// func checksum(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/hash/crc64/crc64.go:199:20), tab ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/hash/crc64/crc64.go:199:32)) Object {
// 	return _crc64.Checksum(data, tab)
// }

GO FUNC crc64.MakeTable has:
// func makeTable(poly ABEND884(unrecognized type uint64 at: GO.link/src/hash/crc64/crc64.go:37:21)) Object {
// 	res := _crc64.MakeTable(poly)
// 	vec1 := EmptyVector
// 	for _, elem1 := range (*res) {
// 		vec1 = vec1.Conjoin()
// 	}
// 	return vec1
// }

GO FUNC crc64.New has:
// func new(tab ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/hash/crc64/crc64.go:88:14)) Object {
// 	return _crc64.New(tab)
// }

GO FUNC crc64.Update has:
// func update(crc ABEND884(unrecognized type uint64 at: GO.link/src/hash/crc64/crc64.go:181:17), tab ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/hash/crc64/crc64.go:181:29), p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/hash/crc64/crc64.go:181:39)) Object {
// 	return _crc64.Update(crc, tab, p)
// }

GO FUNC crypto.RegisterHash has:
// func registerHash(h ABEND884(unrecognized type Hash at: GO.link/src/crypto/crypto.go:100:21), f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/crypto.go:100:29)) Object {
// 	_crypto.RegisterHash(h, f)
// 	...ABEND675: TODO...
// }

GO FUNC csv.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/csv/reader.go:168:18)) Object {
// 	res := _csv.NewReader(r)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Comma"), )
// 	map1.Add(MakeKeyword("Comment"), )
// 	map1.Add(MakeKeyword("FieldsPerRecord"), MakeInt(int((*res).FieldsPerRecord)))
// 	map1.Add(MakeKeyword("LazyQuotes"), MakeBool((*res).LazyQuotes))
// 	map1.Add(MakeKeyword("TrimLeadingSpace"), MakeBool((*res).TrimLeadingSpace))
// 	map1.Add(MakeKeyword("ReuseRecord"), MakeBool((*res).ReuseRecord))
// 	map1.Add(MakeKeyword("TrailingComma"), MakeBool((*res).TrailingComma))
// 	return map1
// }

GO FUNC csv.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/csv/writer.go:31:18)) Object {
// 	res := _csv.NewWriter(w)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Comma"), )
// 	map1.Add(MakeKeyword("UseCRLF"), MakeBool((*res).UseCRLF))
// 	return map1
// }

GO FUNC debug.FreeOSMemory has:
// func freeOSMemory() Object {
// 	_debug.FreeOSMemory()
// 	...ABEND675: TODO...
// }

GO FUNC debug.PrintStack has:
// func printStack() Object {
// 	_debug.PrintStack()
// 	...ABEND675: TODO...
// }

GO FUNC debug.ReadGCStats has:
// func readGCStats(stats ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/runtime/debug/garbage.go:31:24)) Object {
// 	_debug.ReadGCStats(stats)
// 	...ABEND675: TODO...
// }

GO FUNC debug.SetTraceback has:
// func setTraceback(level string) Object {
// 	_debug.SetTraceback(level)
// 	...ABEND675: TODO...
// }

GO FUNC debug.Stack has:
func stack() Object {
	res := _debug.Stack()
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	return vec1
}

GO FUNC debug.WriteHeapDump has:
// func writeHeapDump(fd ABEND884(unrecognized type uintptr at: GO.link/src/runtime/debug/garbage.go:157:23)) Object {
// 	_debug.WriteHeapDump(fd)
// 	...ABEND675: TODO...
// }

GO FUNC des.NewCipher has:
// func newCipher(key ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/des/cipher.go:29:20)) Object {
// 	res1, res2 := _des.NewCipher(key)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC des.NewTripleDESCipher has:
// func newTripleDESCipher(key ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/des/cipher.go:73:29)) Object {
// 	res1, res2 := _des.NewTripleDESCipher(key)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC doc.Examples has:
// func examples(files ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/go/doc/example.go:47:21)) Object {
// 	res := _doc.Examples(files)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		map2 := EmptyArrayMap()
// 		map2.Add(MakeKeyword("Name"), MakeString((*elem1).Name))
// 		map2.Add(MakeKeyword("Doc"), MakeString((*elem1).Doc))
// 		map2.Add(MakeKeyword("Code"), (*elem1).Code)
// 		map2.Add(MakeKeyword("Play"), (*(*elem1).Play))
// 		vec3 := EmptyVector
// 		for _, elem3 := range (*elem1).Comments {
// 			vec3 = vec3.Conjoin((*elem3))
// 		}
// 		map2.Add(MakeKeyword("Comments"), vec3)
// 		map2.Add(MakeKeyword("Output"), MakeString((*elem1).Output))
// 		map2.Add(MakeKeyword("Unordered"), MakeBool((*elem1).Unordered))
// 		map2.Add(MakeKeyword("EmptyOutput"), MakeBool((*elem1).EmptyOutput))
// 		map2.Add(MakeKeyword("Order"), MakeInt(int((*elem1).Order)))
// 		vec1 = vec1.Conjoin(map2)
// 	}
// 	return vec1
// }

GO FUNC doc.New has:
// func new(pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/doc/doc.go:94:14), importPath string, mode ABEND884(unrecognized type Mode at: GO.link/src/go/doc/doc.go:94:52)) Object {
// 	res := _doc.New(pkg, importPath, mode)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Doc"), MakeString((*res).Doc))
// 	map1.Add(MakeKeyword("Name"), MakeString((*res).Name))
// 	map1.Add(MakeKeyword("ImportPath"), MakeString((*res).ImportPath))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Imports {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("Imports"), vec2)
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res).Filenames {
// 		vec3 = vec3.Conjoin(MakeString(elem3))
// 	}
// 	map1.Add(MakeKeyword("Filenames"), vec3)
// 	map1.Add(MakeKeyword("Notes"), (*res).Notes)
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res).Bugs {
// 		vec4 = vec4.Conjoin(MakeString(elem4))
// 	}
// 	map1.Add(MakeKeyword("Bugs"), vec4)
// 	vec5 := EmptyVector
// 	for _, elem5 := range (*res).Consts {
// 		map6 := EmptyArrayMap()
// 		map6.Add(MakeKeyword("Doc"), MakeString((*elem5).Doc))
// 		vec7 := EmptyVector
// 		for _, elem7 := range (*elem5).Names {
// 			vec7 = vec7.Conjoin(MakeString(elem7))
// 		}
// 		map6.Add(MakeKeyword("Names"), vec7)
// 		map6.Add(MakeKeyword("Decl"), (*(*elem5).Decl))
// 		vec5 = vec5.Conjoin(map6)
// 	}
// 	map1.Add(MakeKeyword("Consts"), vec5)
// 	vec8 := EmptyVector
// 	for _, elem8 := range (*res).Types {
// 		map9 := EmptyArrayMap()
// 		map9.Add(MakeKeyword("Doc"), MakeString((*elem8).Doc))
// 		map9.Add(MakeKeyword("Name"), MakeString((*elem8).Name))
// 		map9.Add(MakeKeyword("Decl"), (*(*elem8).Decl))
// 		vec10 := EmptyVector
// 		for _, elem10 := range (*elem8).Consts {
// 			map11 := EmptyArrayMap()
// 			map11.Add(MakeKeyword("Doc"), MakeString((*elem10).Doc))
// 			vec12 := EmptyVector
// 			for _, elem12 := range (*elem10).Names {
// 				vec12 = vec12.Conjoin(MakeString(elem12))
// 			}
// 			map11.Add(MakeKeyword("Names"), vec12)
// 			map11.Add(MakeKeyword("Decl"), (*(*elem10).Decl))
// 			vec10 = vec10.Conjoin(map11)
// 		}
// 		map9.Add(MakeKeyword("Consts"), vec10)
// 		vec13 := EmptyVector
// 		for _, elem13 := range (*elem8).Vars {
// 			map14 := EmptyArrayMap()
// 			map14.Add(MakeKeyword("Doc"), MakeString((*elem13).Doc))
// 			vec15 := EmptyVector
// 			for _, elem15 := range (*elem13).Names {
// 				vec15 = vec15.Conjoin(MakeString(elem15))
// 			}
// 			map14.Add(MakeKeyword("Names"), vec15)
// 			map14.Add(MakeKeyword("Decl"), (*(*elem13).Decl))
// 			vec13 = vec13.Conjoin(map14)
// 		}
// 		map9.Add(MakeKeyword("Vars"), vec13)
// 		vec16 := EmptyVector
// 		for _, elem16 := range (*elem8).Funcs {
// 			map17 := EmptyArrayMap()
// 			map17.Add(MakeKeyword("Doc"), MakeString((*elem16).Doc))
// 			map17.Add(MakeKeyword("Name"), MakeString((*elem16).Name))
// 			map17.Add(MakeKeyword("Decl"), (*(*elem16).Decl))
// 			map17.Add(MakeKeyword("Recv"), MakeString((*elem16).Recv))
// 			map17.Add(MakeKeyword("Orig"), MakeString((*elem16).Orig))
// 			map17.Add(MakeKeyword("Level"), MakeInt(int((*elem16).Level)))
// 			vec16 = vec16.Conjoin(map17)
// 		}
// 		map9.Add(MakeKeyword("Funcs"), vec16)
// 		vec18 := EmptyVector
// 		for _, elem18 := range (*elem8).Methods {
// 			map19 := EmptyArrayMap()
// 			map19.Add(MakeKeyword("Doc"), MakeString((*elem18).Doc))
// 			map19.Add(MakeKeyword("Name"), MakeString((*elem18).Name))
// 			map19.Add(MakeKeyword("Decl"), (*(*elem18).Decl))
// 			map19.Add(MakeKeyword("Recv"), MakeString((*elem18).Recv))
// 			map19.Add(MakeKeyword("Orig"), MakeString((*elem18).Orig))
// 			map19.Add(MakeKeyword("Level"), MakeInt(int((*elem18).Level)))
// 			vec18 = vec18.Conjoin(map19)
// 		}
// 		map9.Add(MakeKeyword("Methods"), vec18)
// 		vec8 = vec8.Conjoin(map9)
// 	}
// 	map1.Add(MakeKeyword("Types"), vec8)
// 	vec20 := EmptyVector
// 	for _, elem20 := range (*res).Vars {
// 		map21 := EmptyArrayMap()
// 		map21.Add(MakeKeyword("Doc"), MakeString((*elem20).Doc))
// 		vec22 := EmptyVector
// 		for _, elem22 := range (*elem20).Names {
// 			vec22 = vec22.Conjoin(MakeString(elem22))
// 		}
// 		map21.Add(MakeKeyword("Names"), vec22)
// 		map21.Add(MakeKeyword("Decl"), (*(*elem20).Decl))
// 		vec20 = vec20.Conjoin(map21)
// 	}
// 	map1.Add(MakeKeyword("Vars"), vec20)
// 	vec23 := EmptyVector
// 	for _, elem23 := range (*res).Funcs {
// 		map24 := EmptyArrayMap()
// 		map24.Add(MakeKeyword("Doc"), MakeString((*elem23).Doc))
// 		map24.Add(MakeKeyword("Name"), MakeString((*elem23).Name))
// 		map24.Add(MakeKeyword("Decl"), (*(*elem23).Decl))
// 		map24.Add(MakeKeyword("Recv"), MakeString((*elem23).Recv))
// 		map24.Add(MakeKeyword("Orig"), MakeString((*elem23).Orig))
// 		map24.Add(MakeKeyword("Level"), MakeInt(int((*elem23).Level)))
// 		vec23 = vec23.Conjoin(map24)
// 	}
// 	map1.Add(MakeKeyword("Funcs"), vec23)
// 	return map1
// }

GO FUNC doc.ToHTML has:
// func toHTML(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/comment.go:308:15), text string, words ABEND882(unrecognized Expr type *ast.MapType at: GO.link/src/go/doc/comment.go:308:45)) Object {
// 	_doc.ToHTML(w, text, words)
// 	...ABEND675: TODO...
// }

GO FUNC doc.ToText has:
// func toText(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/doc/comment.go:422:15), text string, indent string, preIndent string, width int) Object {
// 	_doc.ToText(w, text, indent, preIndent, width)
// 	...ABEND675: TODO...
// }

GO FUNC draw.Draw has:
// func draw(dst ABEND884(unrecognized type Image at: GO.link/src/image/draw/draw.go:100:15), r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:100:24), src ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:100:45), sp ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:100:61), op ABEND884(unrecognized type Op at: GO.link/src/image/draw/draw.go:100:77)) Object {
// 	_draw.Draw(dst, r, src, sp, op)
// 	...ABEND675: TODO...
// }

GO FUNC draw.DrawMask has:
// func drawMask(dst ABEND884(unrecognized type Image at: GO.link/src/image/draw/draw.go:106:19), r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:106:28), src ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:106:49), sp ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:106:65), mask ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:106:83), mp ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/draw/draw.go:106:99), op ABEND884(unrecognized type Op at: GO.link/src/image/draw/draw.go:106:115)) Object {
// 	_draw.DrawMask(dst, r, src, sp, mask, mp, op)
// 	...ABEND675: TODO...
// }

GO FUNC dsa.Sign has:
// func sign(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/dsa/dsa.go:199:16), priv ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/dsa/dsa.go:199:32), hash ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/dsa/dsa.go:199:50)) Object {
// 	r, s, err := _dsa.Sign(rand, priv, hash)
// 	res := EmptyVector
// 	res = res.Conjoin((*r))
// 	res = res.Conjoin((*s))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC dwarf.New has:
// func new(abbrev ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68), aranges ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68), frame ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68), info ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68), line ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68), pubnames ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68), ranges ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68), str ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/dwarf/open.go:41:68)) Object {
// 	_, res2 := _dwarf.New(abbrev, aranges, frame, info, line, pubnames, ranges, str)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC ecdsa.GenerateKey has:
// func generateKey(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:105:20), rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:105:41)) Object {
// 	res1, res2 := _ecdsa.GenerateKey(c, rand)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("D"), (*(*res1).D))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC ecdsa.Sign has:
// func sign(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:156:16), priv ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/ecdsa/ecdsa.go:156:32), hash ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/ecdsa/ecdsa.go:156:50)) Object {
// 	r, s, err := _ecdsa.Sign(rand, priv, hash)
// 	res := EmptyVector
// 	res = res.Conjoin((*r))
// 	res = res.Conjoin((*s))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC elf.NewFile has:
// func newFile(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/elf/file.go:235:16)) Object {
// 	res1, res2 := _elf.NewFile(r)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Sections {
// 		vec2 = vec2.Conjoin(NIL)
// 	}
// 	map1.Add(MakeKeyword("Sections"), vec2)
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res1).Progs {
// 		vec4 = vec4.Conjoin(NIL)
// 	}
// 	map1.Add(MakeKeyword("Progs"), vec4)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC elf.Open has:
func open(name string) Object {
	res1, res2 := _elf.Open(name)
	res := EmptyVector
	map1 := EmptyArrayMap()
	vec2 := EmptyVector
	for _, elem2 := range (*res1).Sections {
		vec2 = vec2.Conjoin(NIL)
	}
	map1.Add(MakeKeyword("Sections"), vec2)
	vec4 := EmptyVector
	for _, elem4 := range (*res1).Progs {
		vec4 = vec4.Conjoin(NIL)
	}
	map1.Add(MakeKeyword("Progs"), vec4)
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC elf.R_INFO has:
// func r_INFO(sym uint32, typ uint32) Object {
// 	return _elf.R_INFO(sym, typ)
// }

GO FUNC elf.ST_INFO has:
// func sT_INFO(bind ABEND884(unrecognized type SymBind at: GO.link/src/debug/elf/elf.go:2841:19), typ ABEND884(unrecognized type SymType at: GO.link/src/debug/elf/elf.go:2841:32)) Object {
// 	return _elf.ST_INFO(bind, typ)
// }

GO FUNC elliptic.GenerateKey has:
// func generateKey(curve ABEND884(unrecognized type Curve at: GO.link/src/crypto/elliptic/elliptic.go:276:24), rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/elliptic/elliptic.go:276:36)) Object {
// 	priv, x, y, err := _elliptic.GenerateKey(curve, rand)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range priv {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin((*x))
// 	res = res.Conjoin((*y))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC elliptic.Marshal has:
// func marshal(curve ABEND884(unrecognized type Curve at: GO.link/src/crypto/elliptic/elliptic.go:305:20), x ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/elliptic/elliptic.go:305:32), y ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/elliptic/elliptic.go:305:32)) Object {
// 	res := _elliptic.Marshal(curve, x, y)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC elliptic.P224 has:
// func p224() Object {
// 	return _elliptic.P224()
// }

GO FUNC elliptic.P256 has:
// func p256() Object {
// 	return _elliptic.P256()
// }

GO FUNC elliptic.P384 has:
// func p384() Object {
// 	return _elliptic.P384()
// }

GO FUNC elliptic.P521 has:
// func p521() Object {
// 	return _elliptic.P521()
// }

GO FUNC elliptic.Unmarshal has:
// func unmarshal(curve ABEND884(unrecognized type Curve at: GO.link/src/crypto/elliptic/elliptic.go:321:22), data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/elliptic/elliptic.go:321:34)) Object {
// 	x, y := _elliptic.Unmarshal(curve, data)
// 	res := EmptyVector
// 	res = res.Conjoin((*x))
// 	res = res.Conjoin((*y))
// 	return res
// }

GO FUNC exec.Command has:
// func command(name string, arg ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/os/exec/exec.go:155:31)) Object {
// 	res := _exec.Command(name, arg)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Path"), MakeString((*res).Path))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Args {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("Args"), vec2)
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res).Env {
// 		vec3 = vec3.Conjoin(MakeString(elem3))
// 	}
// 	map1.Add(MakeKeyword("Env"), vec3)
// 	map1.Add(MakeKeyword("Dir"), MakeString((*res).Dir))
// 	map1.Add(MakeKeyword("Stdin"), (*res).Stdin)
// 	map1.Add(MakeKeyword("Stdout"), (*res).Stdout)
// 	map1.Add(MakeKeyword("Stderr"), (*res).Stderr)
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res).ExtraFiles {
// 		vec4 = vec4.Conjoin((*elem4))
// 	}
// 	map1.Add(MakeKeyword("ExtraFiles"), vec4)
// 	map1.Add(MakeKeyword("SysProcAttr"), (*(*res).SysProcAttr))
// 	map1.Add(MakeKeyword("Process"), (*(*res).Process))
// 	map1.Add(MakeKeyword("ProcessState"), (*(*res).ProcessState))
// 	return map1
// }

GO FUNC exec.CommandContext has:
// func commandContext(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/os/exec/exec.go:175:25), name string, arg ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/os/exec/exec.go:175:59)) Object {
// 	res := _exec.CommandContext(ctx, name, arg)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Path"), MakeString((*res).Path))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Args {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("Args"), vec2)
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res).Env {
// 		vec3 = vec3.Conjoin(MakeString(elem3))
// 	}
// 	map1.Add(MakeKeyword("Env"), vec3)
// 	map1.Add(MakeKeyword("Dir"), MakeString((*res).Dir))
// 	map1.Add(MakeKeyword("Stdin"), (*res).Stdin)
// 	map1.Add(MakeKeyword("Stdout"), (*res).Stdout)
// 	map1.Add(MakeKeyword("Stderr"), (*res).Stderr)
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res).ExtraFiles {
// 		vec4 = vec4.Conjoin((*elem4))
// 	}
// 	map1.Add(MakeKeyword("ExtraFiles"), vec4)
// 	map1.Add(MakeKeyword("SysProcAttr"), (*(*res).SysProcAttr))
// 	map1.Add(MakeKeyword("Process"), (*(*res).Process))
// 	map1.Add(MakeKeyword("ProcessState"), (*(*res).ProcessState))
// 	return map1
// }

GO FUNC exec.LookPath has:
func lookPath(file string) Object {
	res1, res2 := _exec.LookPath(file)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC expvar.Do has:
// func do(f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/expvar/expvar.go:306:11)) Object {
// 	_expvar.Do(f)
// 	...ABEND675: TODO...
// }

GO FUNC expvar.Get has:
// func get(name string) Object {
// 	return _expvar.Get(name)
// }

GO FUNC expvar.Handler has:
// func handler() Object {
// 	return _expvar.Handler()
// }

GO FUNC expvar.NewFloat has:
// func newFloat(name string) Object {
// 	return _expvar.NewFloat(name)
// 	ABEND124(no public information returned)
// }

GO FUNC expvar.NewInt has:
// func newInt(name string) Object {
// 	return _expvar.NewInt(name)
// 	ABEND124(no public information returned)
// }

GO FUNC expvar.NewMap has:
// func newMap(name string) Object {
// 	return _expvar.NewMap(name)
// 	ABEND124(no public information returned)
// }

GO FUNC expvar.NewString has:
// func newString(name string) Object {
// 	return _expvar.NewString(name)
// 	ABEND124(no public information returned)
// }

GO FUNC expvar.Publish has:
// func publish(name string, v ABEND884(unrecognized type Var at: GO.link/src/expvar/expvar.go:259:29)) Object {
// 	_expvar.Publish(name, v)
// 	...ABEND675: TODO...
// }

GO FUNC fcgi.ProcessEnv has:
// func processEnv(r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/fcgi/child.go:358:19)) Object {
// 	return _fcgi.ProcessEnv(r)
// }

GO FUNC filepath.Abs has:
func abs(path string) Object {
	res1, res2 := _filepath.Abs(path)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC filepath.EvalSymlinks has:
func evalSymlinks(path string) Object {
	res1, res2 := _filepath.EvalSymlinks(path)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC filepath.Glob has:
func glob(pattern string) Object {
	matches, err := _filepath.Glob(pattern)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range matches {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC filepath.Match has:
func match(pattern string, name string) Object {
	matched, err := _filepath.Match(pattern, name)
	res := EmptyVector
	res = res.Conjoin(MakeBool(matched))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC filepath.Rel has:
func rel(basepath string, targpath string) Object {
	res1, res2 := _filepath.Rel(basepath, targpath)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC filepath.Split has:
func split(path string) Object {
	dir, file := _filepath.Split(path)
	res := EmptyVector
	res = res.Conjoin(MakeString(dir))
	res = res.Conjoin(MakeString(file))
	return res
}

GO FUNC filepath.SplitList has:
func splitList(path string) Object {
	res := _filepath.SplitList(path)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	return vec1
}

GO FUNC flag.Args has:
func args() Object {
	res := _flag.Args()
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	return vec1
}

GO FUNC flag.BoolVar has:
// func boolVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:583:16), name string, value bool, usage string) Object {
// 	_flag.BoolVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Duration has:
// func duration(name string, value ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/flag/flag.go:783:34), usage string) Object {
// 	return _flag.Duration(name, value, usage)
// }

GO FUNC flag.DurationVar has:
// func durationVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:767:20), name string, value ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/flag/flag.go:767:55), usage string) Object {
// 	_flag.DurationVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Float64 has:
// func float64(name string, value ABEND884(unrecognized type float64 at: GO.link/src/flag/flag.go:753:33), usage string) Object {
// 	return _flag.Float64(name, value, usage)
// }

GO FUNC flag.Float64Var has:
// func float64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:739:19), name string, value ABEND884(unrecognized type float64 at: GO.link/src/flag/flag.go:739:48), usage string) Object {
// 	_flag.Float64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Int64Var has:
// func int64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:635:17), name string, value int64, usage string) Object {
// 	_flag.Int64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.IntVar has:
// func intVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:609:15), name string, value int, usage string) Object {
// 	_flag.IntVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Lookup has:
// func lookup(name string) Object {
// 	res := _flag.Lookup(name)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Name"), MakeString((*res).Name))
// 	map1.Add(MakeKeyword("Usage"), MakeString((*res).Usage))
// 	map1.Add(MakeKeyword("Value"), (*res).Value)
// 	map1.Add(MakeKeyword("DefValue"), MakeString((*res).DefValue))
// 	return map1
// }

GO FUNC flag.NewFlagSet has:
// func newFlagSet(name string, errorHandling ABEND884(unrecognized type ErrorHandling at: GO.link/src/flag/flag.go:981:44)) Object {
// 	res := _flag.NewFlagSet(name, errorHandling)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Usage"), (*res).Usage)
// 	return map1
// }

GO FUNC flag.Parse has:
// func parse() Object {
// 	_flag.Parse()
// 	...ABEND675: TODO...
// }

GO FUNC flag.PrintDefaults has:
// func printDefaults() Object {
// 	_flag.PrintDefaults()
// 	...ABEND675: TODO...
// }

GO FUNC flag.StringVar has:
// func stringVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:713:18), name string, value string, usage string) Object {
// 	_flag.StringVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Uint64 has:
// func uint64(name string, value ABEND884(unrecognized type uint64 at: GO.link/src/flag/flag.go:701:32), usage string) Object {
// 	return _flag.Uint64(name, value, usage)
// }

GO FUNC flag.Uint64Var has:
// func uint64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:687:18), name string, value ABEND884(unrecognized type uint64 at: GO.link/src/flag/flag.go:687:46), usage string) Object {
// 	_flag.Uint64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.UintVar has:
// func uintVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:661:16), name string, value uint, usage string) Object {
// 	_flag.UintVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.UnquoteUsage has:
// func unquoteUsage(flag ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/flag/flag.go:422:24)) Object {
// 	name, usage := _flag.UnquoteUsage(flag)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeString(name))
// 	res = res.Conjoin(MakeString(usage))
// 	return res
// }

GO FUNC flag.Var has:
// func var(value ABEND884(unrecognized type Value at: GO.link/src/flag/flag.go:819:16), name string, usage string) Object {
// 	_flag.Var(value, name, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Visit has:
// func visit(fn ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/flag/flag.go:364:15)) Object {
// 	_flag.Visit(fn)
// 	...ABEND675: TODO...
// }

GO FUNC flag.VisitAll has:
// func visitAll(fn ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/flag/flag.go:350:18)) Object {
// 	_flag.VisitAll(fn)
// 	...ABEND675: TODO...
// }

GO FUNC flate.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/flate/inflate.go:796:18)) Object {
// 	return _flate.NewReader(r)
// }

GO FUNC flate.NewReaderDict has:
// func newReaderDict(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/flate/inflate.go:815:22), dict ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/compress/flate/inflate.go:815:38)) Object {
// 	return _flate.NewReaderDict(r, dict)
// }

GO FUNC flate.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/flate/deflate.go:666:18), level int) Object {
// 	_, res2 := _flate.NewWriter(w, level)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC flate.NewWriterDict has:
// func newWriterDict(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/flate/deflate.go:680:22), level int, dict ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/compress/flate/deflate.go:680:49)) Object {
// 	_, res2 := _flate.NewWriterDict(w, level, dict)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC fmt.Fprint has:
// func fprint(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/print.go:220:15), a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:220:28)) Object {
// 	n, err := _fmt.Fprint(w, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Fprintf has:
// func fprintf(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/print.go:186:16), format string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:186:44)) Object {
// 	n, err := _fmt.Fprintf(w, format, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Fprintln has:
// func fprintln(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/print.go:252:17), a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:252:30)) Object {
// 	n, err := _fmt.Fprintln(w, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Fscan has:
// func fscan(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/scan.go:121:14), a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:121:27)) Object {
// 	n, err := _fmt.Fscan(r, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Fscanf has:
// func fscanf(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/scan.go:141:15), format string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:141:43)) Object {
// 	n, err := _fmt.Fscanf(r, format, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Fscanln has:
// func fscanln(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/fmt/scan.go:130:16), a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:130:29)) Object {
// 	n, err := _fmt.Fscanln(r, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Print has:
// func print(a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:231:14)) Object {
// 	n, err := _fmt.Print(a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Printf has:
// func printf(format string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:196:30)) Object {
// 	n, err := _fmt.Printf(format, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Println has:
// func println(a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/print.go:263:16)) Object {
// 	n, err := _fmt.Println(a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Scan has:
// func scan(a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:63:13)) Object {
// 	n, err := _fmt.Scan(a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Scanf has:
// func scanf(format string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:80:29)) Object {
// 	n, err := _fmt.Scanf(format, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Scanln has:
// func scanln(a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:69:15)) Object {
// 	n, err := _fmt.Scanln(a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Sscan has:
// func sscan(str string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:99:26)) Object {
// 	n, err := _fmt.Sscan(str, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Sscanf has:
// func sscanf(str string, format string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:113:42)) Object {
// 	n, err := _fmt.Sscanf(str, format, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fmt.Sscanln has:
// func sscanln(str string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/fmt/scan.go:105:28)) Object {
// 	n, err := _fmt.Sscanln(str, a)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC fnv.New128 has:
// func new128() Object {
// 	return _fnv.New128()
// }

GO FUNC fnv.New128a has:
// func new128a() Object {
// 	return _fnv.New128a()
// }

GO FUNC fnv.New32 has:
// func new32() Object {
// 	return _fnv.New32()
// }

GO FUNC fnv.New32a has:
// func new32a() Object {
// 	return _fnv.New32a()
// }

GO FUNC fnv.New64 has:
// func new64() Object {
// 	return _fnv.New64()
// }

GO FUNC fnv.New64a has:
// func new64a() Object {
// 	return _fnv.New64a()
// }

GO FUNC format.Source has:
// func source(src ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/format/format.go:91:17)) Object {
// 	res1, res2 := _format.Source(src)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC gif.Decode has:
// func decode(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/reader.go:561:15)) Object {
// 	res1, res2 := _gif.Decode(r)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC gif.DecodeAll has:
// func decodeAll(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/reader.go:601:18)) Object {
// 	res1, res2 := _gif.DecodeAll(r)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Image {
// 		vec2 = vec2.Conjoin((*elem2))
// 	}
// 	map1.Add(MakeKeyword("Image"), vec2)
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res1).Delay {
// 		vec3 = vec3.Conjoin(MakeInt(int(elem3)))
// 	}
// 	map1.Add(MakeKeyword("Delay"), vec3)
// 	map1.Add(MakeKeyword("LoopCount"), MakeInt(int((*res1).LoopCount)))
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res1).Disposal {
// 		vec4 = vec4.Conjoin(MakeInt(int(elem4)))
// 	}
// 	map1.Add(MakeKeyword("Disposal"), vec4)
// 	map1.Add(MakeKeyword("Config"), (*res1).Config)
// 	map1.Add(MakeKeyword("BackgroundIndex"), MakeInt(int((*res1).BackgroundIndex)))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC gif.DecodeConfig has:
// func decodeConfig(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/gif/reader.go:623:21)) Object {
// 	res1, res2 := _gif.DecodeConfig(r)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC gob.NewDecoder has:
// func newDecoder(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/gob/decoder.go:41:19)) Object {
// 	return _gob.NewDecoder(r)
// 	ABEND124(no public information returned)
// }

GO FUNC gob.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/gob/encoder.go:33:19)) Object {
// 	return _gob.NewEncoder(w)
// 	ABEND124(no public information returned)
// }

GO FUNC gob.Register has:
// func register(value ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/gob/type.go:836:21)) Object {
// 	_gob.Register(value)
// 	...ABEND675: TODO...
// }

GO FUNC gob.RegisterName has:
// func registerName(name string, value ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/gob/type.go:807:38)) Object {
// 	_gob.RegisterName(name, value)
// 	...ABEND675: TODO...
// }

GO FUNC gosym.NewLineTable has:
// func newLineTable(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/gosym/pclntab.go:124:24), text ABEND884(unrecognized type uint64 at: GO.link/src/debug/gosym/pclntab.go:124:37)) Object {
// 	res := _gosym.NewLineTable(data, text)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Data {
// 		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 	}
// 	map1.Add(MakeKeyword("Data"), vec2)
// 	map1.Add(MakeKeyword("PC"), )
// 	map1.Add(MakeKeyword("Line"), MakeInt(int((*res).Line)))
// 	return map1
// }

GO FUNC gosym.NewTable has:
// func newTable(symtab ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/debug/gosym/symtab.go:283:22), pcln ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/debug/gosym/symtab.go:283:35)) Object {
// 	res1, res2 := _gosym.NewTable(symtab, pcln)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Syms {
// 		map3 := EmptyArrayMap()
// 		map3.Add(MakeKeyword("Value"), )
// 		map3.Add(MakeKeyword("Type"), MakeInt(int(elem2.Type)))
// 		map3.Add(MakeKeyword("Name"), MakeString(elem2.Name))
// 		map3.Add(MakeKeyword("GoType"), )
// 		map4 := EmptyArrayMap()
// 		map4.Add(MakeKeyword("Entry"), )
// 		map4.Add(MakeKeyword("End"), )
// 		vec5 := EmptyVector
// 		for _, elem5 := range (*elem2.Func).Params {
// 			vec5 = vec5.Conjoin()
// 		}
// 		map4.Add(MakeKeyword("Params"), vec5)
// 		vec6 := EmptyVector
// 		for _, elem6 := range (*elem2.Func).Locals {
// 			vec6 = vec6.Conjoin()
// 		}
// 		map4.Add(MakeKeyword("Locals"), vec6)
// 		map4.Add(MakeKeyword("FrameSize"), MakeInt(int((*elem2.Func).FrameSize)))
// 		map7 := EmptyArrayMap()
// 		vec8 := EmptyVector
// 		for _, elem8 := range (*(*elem2.Func).LineTable).Data {
// 			vec8 = vec8.Conjoin(MakeInt(int(elem8)))
// 		}
// 		map7.Add(MakeKeyword("Data"), vec8)
// 		map7.Add(MakeKeyword("PC"), )
// 		map7.Add(MakeKeyword("Line"), MakeInt(int((*(*elem2.Func).LineTable).Line)))
// 		map4.Add(MakeKeyword("LineTable"), map7)
// 		map9 := EmptyArrayMap()
// 		vec10 := EmptyVector
// 		for _, elem10 := range (*(*elem2.Func).Obj).Funcs {
// 			vec10 = vec10.Conjoin()
// 		}
// 		map9.Add(MakeKeyword("Funcs"), vec10)
// 		vec11 := EmptyVector
// 		for _, elem11 := range (*(*elem2.Func).Obj).Paths {
// 			vec11 = vec11.Conjoin()
// 		}
// 		map9.Add(MakeKeyword("Paths"), vec11)
// 		map4.Add(MakeKeyword("Obj"), map9)
// 		map3.Add(MakeKeyword("Func"), map4)
// 		vec2 = vec2.Conjoin(map3)
// 	}
// 	map1.Add(MakeKeyword("Syms"), vec2)
// 	vec12 := EmptyVector
// 	for _, elem12 := range (*res1).Funcs {
// 		map13 := EmptyArrayMap()
// 		map13.Add(MakeKeyword("Entry"), )
// 		map13.Add(MakeKeyword("End"), )
// 		vec14 := EmptyVector
// 		for _, elem14 := range elem12.Params {
// 			map15 := EmptyArrayMap()
// 			map15.Add(MakeKeyword("Value"), )
// 			map15.Add(MakeKeyword("Type"), MakeInt(int((*elem14).Type)))
// 			map15.Add(MakeKeyword("Name"), MakeString((*elem14).Name))
// 			map15.Add(MakeKeyword("GoType"), )
// 			map15.Add(MakeKeyword("Func"), )
// 			vec14 = vec14.Conjoin(map15)
// 		}
// 		map13.Add(MakeKeyword("Params"), vec14)
// 		vec16 := EmptyVector
// 		for _, elem16 := range elem12.Locals {
// 			map17 := EmptyArrayMap()
// 			map17.Add(MakeKeyword("Value"), )
// 			map17.Add(MakeKeyword("Type"), MakeInt(int((*elem16).Type)))
// 			map17.Add(MakeKeyword("Name"), MakeString((*elem16).Name))
// 			map17.Add(MakeKeyword("GoType"), )
// 			map17.Add(MakeKeyword("Func"), )
// 			vec16 = vec16.Conjoin(map17)
// 		}
// 		map13.Add(MakeKeyword("Locals"), vec16)
// 		map13.Add(MakeKeyword("FrameSize"), MakeInt(int(elem12.FrameSize)))
// 		map18 := EmptyArrayMap()
// 		vec19 := EmptyVector
// 		for _, elem19 := range (*elem12.LineTable).Data {
// 			vec19 = vec19.Conjoin(MakeInt(int(elem19)))
// 		}
// 		map18.Add(MakeKeyword("Data"), vec19)
// 		map18.Add(MakeKeyword("PC"), )
// 		map18.Add(MakeKeyword("Line"), MakeInt(int((*elem12.LineTable).Line)))
// 		map13.Add(MakeKeyword("LineTable"), map18)
// 		map20 := EmptyArrayMap()
// 		vec21 := EmptyVector
// 		for _, elem21 := range (*elem12.Obj).Funcs {
// 			vec21 = vec21.Conjoin()
// 		}
// 		map20.Add(MakeKeyword("Funcs"), vec21)
// 		vec22 := EmptyVector
// 		for _, elem22 := range (*elem12.Obj).Paths {
// 			map23 := EmptyArrayMap()
// 			map23.Add(MakeKeyword("Value"), )
// 			map23.Add(MakeKeyword("Type"), MakeInt(int(elem22.Type)))
// 			map23.Add(MakeKeyword("Name"), MakeString(elem22.Name))
// 			map23.Add(MakeKeyword("GoType"), )
// 			map23.Add(MakeKeyword("Func"), )
// 			vec22 = vec22.Conjoin(map23)
// 		}
// 		map20.Add(MakeKeyword("Paths"), vec22)
// 		map13.Add(MakeKeyword("Obj"), map20)
// 		vec12 = vec12.Conjoin(map13)
// 	}
// 	map1.Add(MakeKeyword("Funcs"), vec12)
// 	map1.Add(MakeKeyword("Files"), (*res1).Files)
// 	vec24 := EmptyVector
// 	for _, elem24 := range (*res1).Objs {
// 		map25 := EmptyArrayMap()
// 		vec26 := EmptyVector
// 		for _, elem26 := range elem24.Funcs {
// 			map27 := EmptyArrayMap()
// 			map27.Add(MakeKeyword("Entry"), )
// 			map27.Add(MakeKeyword("End"), )
// 			vec28 := EmptyVector
// 			for _, elem28 := range elem26.Params {
// 				map29 := EmptyArrayMap()
// 				map29.Add(MakeKeyword("Value"), )
// 				map29.Add(MakeKeyword("Type"), MakeInt(int((*elem28).Type)))
// 				map29.Add(MakeKeyword("Name"), MakeString((*elem28).Name))
// 				map29.Add(MakeKeyword("GoType"), )
// 				map29.Add(MakeKeyword("Func"), )
// 				vec28 = vec28.Conjoin(map29)
// 			}
// 			map27.Add(MakeKeyword("Params"), vec28)
// 			vec30 := EmptyVector
// 			for _, elem30 := range elem26.Locals {
// 				map31 := EmptyArrayMap()
// 				map31.Add(MakeKeyword("Value"), )
// 				map31.Add(MakeKeyword("Type"), MakeInt(int((*elem30).Type)))
// 				map31.Add(MakeKeyword("Name"), MakeString((*elem30).Name))
// 				map31.Add(MakeKeyword("GoType"), )
// 				map31.Add(MakeKeyword("Func"), )
// 				vec30 = vec30.Conjoin(map31)
// 			}
// 			map27.Add(MakeKeyword("Locals"), vec30)
// 			map27.Add(MakeKeyword("FrameSize"), MakeInt(int(elem26.FrameSize)))
// 			map32 := EmptyArrayMap()
// 			vec33 := EmptyVector
// 			for _, elem33 := range (*elem26.LineTable).Data {
// 				vec33 = vec33.Conjoin(MakeInt(int(elem33)))
// 			}
// 			map32.Add(MakeKeyword("Data"), vec33)
// 			map32.Add(MakeKeyword("PC"), )
// 			map32.Add(MakeKeyword("Line"), MakeInt(int((*elem26.LineTable).Line)))
// 			map27.Add(MakeKeyword("LineTable"), map32)
// 			map27.Add(MakeKeyword("Obj"), )
// 			vec26 = vec26.Conjoin(map27)
// 		}
// 		map25.Add(MakeKeyword("Funcs"), vec26)
// 		vec34 := EmptyVector
// 		for _, elem34 := range elem24.Paths {
// 			map35 := EmptyArrayMap()
// 			map35.Add(MakeKeyword("Value"), )
// 			map35.Add(MakeKeyword("Type"), MakeInt(int(elem34.Type)))
// 			map35.Add(MakeKeyword("Name"), MakeString(elem34.Name))
// 			map35.Add(MakeKeyword("GoType"), )
// 			map36 := EmptyArrayMap()
// 			map36.Add(MakeKeyword("Entry"), )
// 			map36.Add(MakeKeyword("End"), )
// 			vec37 := EmptyVector
// 			for _, elem37 := range (*elem34.Func).Params {
// 				vec37 = vec37.Conjoin()
// 			}
// 			map36.Add(MakeKeyword("Params"), vec37)
// 			vec38 := EmptyVector
// 			for _, elem38 := range (*elem34.Func).Locals {
// 				vec38 = vec38.Conjoin()
// 			}
// 			map36.Add(MakeKeyword("Locals"), vec38)
// 			map36.Add(MakeKeyword("FrameSize"), MakeInt(int((*elem34.Func).FrameSize)))
// 			map39 := EmptyArrayMap()
// 			vec40 := EmptyVector
// 			for _, elem40 := range (*(*elem34.Func).LineTable).Data {
// 				vec40 = vec40.Conjoin(MakeInt(int(elem40)))
// 			}
// 			map39.Add(MakeKeyword("Data"), vec40)
// 			map39.Add(MakeKeyword("PC"), )
// 			map39.Add(MakeKeyword("Line"), MakeInt(int((*(*elem34.Func).LineTable).Line)))
// 			map36.Add(MakeKeyword("LineTable"), map39)
// 			map36.Add(MakeKeyword("Obj"), )
// 			map35.Add(MakeKeyword("Func"), map36)
// 			vec34 = vec34.Conjoin(map35)
// 		}
// 		map25.Add(MakeKeyword("Paths"), vec34)
// 		vec24 = vec24.Conjoin(map25)
// 	}
// 	map1.Add(MakeKeyword("Objs"), vec24)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC gzip.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/gzip/gunzip.go:92:18)) Object {
// 	_, res2 := _gzip.NewReader(r)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC gzip.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/gzip/gzip.go:49:18)) Object {
// 	return _gzip.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC gzip.NewWriterLevel has:
// func newWriterLevel(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/gzip/gzip.go:60:23), level int) Object {
// 	_, res2 := _gzip.NewWriterLevel(w, level)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC heap.Fix has:
// func fix(h ABEND884(unrecognized type Interface at: GO.link/src/container/heap/heap.go:87:12), i int) Object {
// 	_heap.Fix(h, i)
// 	...ABEND675: TODO...
// }

GO FUNC heap.Init has:
// func init(h ABEND884(unrecognized type Interface at: GO.link/src/container/heap/heap.go:42:13)) Object {
// 	_heap.Init(h)
// 	...ABEND675: TODO...
// }

GO FUNC heap.Pop has:
// func pop(h ABEND884(unrecognized type Interface at: GO.link/src/container/heap/heap.go:62:12)) Object {
// 	return _heap.Pop(h)
// }

GO FUNC heap.Push has:
// func push(h ABEND884(unrecognized type Interface at: GO.link/src/container/heap/heap.go:53:13), x ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/container/heap/heap.go:53:26)) Object {
// 	_heap.Push(h, x)
// 	...ABEND675: TODO...
// }

GO FUNC heap.Remove has:
// func remove(h ABEND884(unrecognized type Interface at: GO.link/src/container/heap/heap.go:72:15), i int) Object {
// 	return _heap.Remove(h, i)
// }

GO FUNC hex.Decode has:
// func decode(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/hex/hex.go:57:22), src ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/hex/hex.go:57:22)) Object {
// 	res1, res2 := _hex.Decode(dst, src)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(res1)))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC hex.DecodeString has:
func decodeString(s string) Object {
	res1, res2 := _hex.DecodeString(s)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC hex.Dumper has:
// func dumper(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/hex/hex.go:204:15)) Object {
// 	return _hex.Dumper(w)
// }

GO FUNC hex.NewDecoder has:
// func newDecoder(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/hex/hex.go:165:19)) Object {
// 	return _hex.NewDecoder(r)
// }

GO FUNC hex.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/hex/hex.go:136:19)) Object {
// 	return _hex.NewEncoder(w)
// }

GO FUNC hmac.New has:
// func new(h ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/hmac/hmac.go:70:12), key ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/hmac/hmac.go:70:34)) Object {
// 	return _hmac.New(h, key)
// }

GO FUNC http.Error has:
// func error(w ABEND884(unrecognized type ResponseWriter at: GO.link/src/net/http/server.go:1973:14), error string, code int) Object {
// 	_http.Error(w, error, code)
// 	...ABEND675: TODO...
// }

GO FUNC http.FileServer has:
// func fileServer(root ABEND884(unrecognized type FileSystem at: GO.link/src/net/http/fs.go:713:22)) Object {
// 	return _http.FileServer(root)
// }

GO FUNC http.Get has:
// func get(url string) Object {
// 	resp, err := _http.Get(url)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 	map1.Add(MakeKeyword("StatusCode"), MakeInt(int((*resp).StatusCode)))
// 	map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 	map1.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*resp).ProtoMajor)))
// 	map1.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*resp).ProtoMinor)))
// 	map1.Add(MakeKeyword("Header"), (*resp).Header)
// 	map1.Add(MakeKeyword("Body"), (*resp).Body)
// 	map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*resp).TransferEncoding {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("TransferEncoding"), vec2)
// 	map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 	map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 	map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 	map3 := EmptyArrayMap()
// 	map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 	map3.Add(MakeKeyword("URL"), (*(*(*resp).Request).URL))
// 	map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 	map3.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*(*resp).Request).ProtoMajor)))
// 	map3.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*(*resp).Request).ProtoMinor)))
// 	map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 	map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 	map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 	map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*(*resp).Request).TransferEncoding {
// 		vec4 = vec4.Conjoin(MakeString(elem4))
// 	}
// 	map3.Add(MakeKeyword("TransferEncoding"), vec4)
// 	map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 	map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 	map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 	map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 	map3.Add(MakeKeyword("MultipartForm"), (*(*(*resp).Request).MultipartForm))
// 	map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 	map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 	map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 	map3.Add(MakeKeyword("TLS"), (*(*(*resp).Request).TLS))
// 	map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 	map3.Add(MakeKeyword("Response"), )
// 	map1.Add(MakeKeyword("Request"), map3)
// 	map1.Add(MakeKeyword("TLS"), (*(*resp).TLS))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC http.Handle has:
// func handle(pattern string, handler ABEND884(unrecognized type Handler at: GO.link/src/net/http/server.go:2401:37)) Object {
// 	_http.Handle(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC http.HandleFunc has:
// func handleFunc(pattern string, handler ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/server.go:2406:41)) Object {
// 	_http.HandleFunc(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC http.Head has:
// func head(url string) Object {
// 	resp, err := _http.Head(url)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 	map1.Add(MakeKeyword("StatusCode"), MakeInt(int((*resp).StatusCode)))
// 	map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 	map1.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*resp).ProtoMajor)))
// 	map1.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*resp).ProtoMinor)))
// 	map1.Add(MakeKeyword("Header"), (*resp).Header)
// 	map1.Add(MakeKeyword("Body"), (*resp).Body)
// 	map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*resp).TransferEncoding {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("TransferEncoding"), vec2)
// 	map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 	map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 	map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 	map3 := EmptyArrayMap()
// 	map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 	map3.Add(MakeKeyword("URL"), (*(*(*resp).Request).URL))
// 	map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 	map3.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*(*resp).Request).ProtoMajor)))
// 	map3.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*(*resp).Request).ProtoMinor)))
// 	map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 	map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 	map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 	map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*(*resp).Request).TransferEncoding {
// 		vec4 = vec4.Conjoin(MakeString(elem4))
// 	}
// 	map3.Add(MakeKeyword("TransferEncoding"), vec4)
// 	map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 	map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 	map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 	map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 	map3.Add(MakeKeyword("MultipartForm"), (*(*(*resp).Request).MultipartForm))
// 	map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 	map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 	map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 	map3.Add(MakeKeyword("TLS"), (*(*(*resp).Request).TLS))
// 	map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 	map3.Add(MakeKeyword("Response"), )
// 	map1.Add(MakeKeyword("Request"), map3)
// 	map1.Add(MakeKeyword("TLS"), (*(*resp).TLS))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC http.MaxBytesReader has:
// func maxBytesReader(w ABEND884(unrecognized type ResponseWriter at: GO.link/src/net/http/request.go:1056:23), r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:1056:41), n int64) Object {
// 	return _http.MaxBytesReader(w, r, n)
// }

GO FUNC http.NewFileTransport has:
// func newFileTransport(fs ABEND884(unrecognized type FileSystem at: GO.link/src/net/http/filetransport.go:30:26)) Object {
// 	return _http.NewFileTransport(fs)
// }

GO FUNC http.NewRequest has:
// func newRequest(method string, url string, body ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/request.go:792:42)) Object {
// 	res1, res2 := _http.NewRequest(method, url, body)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Method"), MakeString((*res1).Method))
// 	map1.Add(MakeKeyword("URL"), (*(*res1).URL))
// 	map1.Add(MakeKeyword("Proto"), MakeString((*res1).Proto))
// 	map1.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*res1).ProtoMajor)))
// 	map1.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*res1).ProtoMinor)))
// 	map1.Add(MakeKeyword("Header"), (*res1).Header)
// 	map1.Add(MakeKeyword("Body"), (*res1).Body)
// 	map1.Add(MakeKeyword("GetBody"), (*res1).GetBody)
// 	map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*res1).ContentLength)))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).TransferEncoding {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("TransferEncoding"), vec2)
// 	map1.Add(MakeKeyword("Close"), MakeBool((*res1).Close))
// 	map1.Add(MakeKeyword("Host"), MakeString((*res1).Host))
// 	map1.Add(MakeKeyword("Form"), (*res1).Form)
// 	map1.Add(MakeKeyword("PostForm"), (*res1).PostForm)
// 	map1.Add(MakeKeyword("MultipartForm"), (*(*res1).MultipartForm))
// 	map1.Add(MakeKeyword("Trailer"), (*res1).Trailer)
// 	map1.Add(MakeKeyword("RemoteAddr"), MakeString((*res1).RemoteAddr))
// 	map1.Add(MakeKeyword("RequestURI"), MakeString((*res1).RequestURI))
// 	map1.Add(MakeKeyword("TLS"), (*(*res1).TLS))
// 	map1.Add(MakeKeyword("Cancel"), (*res1).Cancel)
// 	map3 := EmptyArrayMap()
// 	map3.Add(MakeKeyword("Status"), MakeString((*(*res1).Response).Status))
// 	map3.Add(MakeKeyword("StatusCode"), MakeInt(int((*(*res1).Response).StatusCode)))
// 	map3.Add(MakeKeyword("Proto"), MakeString((*(*res1).Response).Proto))
// 	map3.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*(*res1).Response).ProtoMajor)))
// 	map3.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*(*res1).Response).ProtoMinor)))
// 	map3.Add(MakeKeyword("Header"), (*(*res1).Response).Header)
// 	map3.Add(MakeKeyword("Body"), (*(*res1).Response).Body)
// 	map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*res1).Response).ContentLength)))
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*(*res1).Response).TransferEncoding {
// 		vec4 = vec4.Conjoin(MakeString(elem4))
// 	}
// 	map3.Add(MakeKeyword("TransferEncoding"), vec4)
// 	map3.Add(MakeKeyword("Close"), MakeBool((*(*res1).Response).Close))
// 	map3.Add(MakeKeyword("Uncompressed"), MakeBool((*(*res1).Response).Uncompressed))
// 	map3.Add(MakeKeyword("Trailer"), (*(*res1).Response).Trailer)
// 	map3.Add(MakeKeyword("Request"), )
// 	map3.Add(MakeKeyword("TLS"), (*(*(*res1).Response).TLS))
// 	map1.Add(MakeKeyword("Response"), map3)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC http.NewServeMux has:
// func newServeMux() Object {
// 	return _http.NewServeMux()
// 	ABEND124(no public information returned)
// }

GO FUNC http.NotFound has:
// func notFound(w ABEND884(unrecognized type ResponseWriter at: GO.link/src/net/http/server.go:1981:17), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/server.go:1981:35)) Object {
// 	_http.NotFound(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC http.NotFoundHandler has:
// func notFoundHandler() Object {
// 	return _http.NotFoundHandler()
// }

GO FUNC http.ParseHTTPVersion has:
func parseHTTPVersion(vers string) Object {
	major, minor, ok := _http.ParseHTTPVersion(vers)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(major)))
	res = res.Conjoin(MakeInt(int(minor)))
	res = res.Conjoin(MakeBool(ok))
	return res
}

GO FUNC http.ParseTime has:
// func parseTime(text string) Object {
// 	t, err := _http.ParseTime(text)
// 	res := EmptyVector
// 	res = res.Conjoin(t)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC http.Post has:
// func post(url string, contentType string, body ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/client.go:748:41)) Object {
// 	resp, err := _http.Post(url, contentType, body)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 	map1.Add(MakeKeyword("StatusCode"), MakeInt(int((*resp).StatusCode)))
// 	map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 	map1.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*resp).ProtoMajor)))
// 	map1.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*resp).ProtoMinor)))
// 	map1.Add(MakeKeyword("Header"), (*resp).Header)
// 	map1.Add(MakeKeyword("Body"), (*resp).Body)
// 	map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*resp).TransferEncoding {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("TransferEncoding"), vec2)
// 	map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 	map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 	map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 	map3 := EmptyArrayMap()
// 	map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 	map3.Add(MakeKeyword("URL"), (*(*(*resp).Request).URL))
// 	map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 	map3.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*(*resp).Request).ProtoMajor)))
// 	map3.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*(*resp).Request).ProtoMinor)))
// 	map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 	map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 	map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 	map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*(*resp).Request).TransferEncoding {
// 		vec4 = vec4.Conjoin(MakeString(elem4))
// 	}
// 	map3.Add(MakeKeyword("TransferEncoding"), vec4)
// 	map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 	map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 	map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 	map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 	map3.Add(MakeKeyword("MultipartForm"), (*(*(*resp).Request).MultipartForm))
// 	map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 	map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 	map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 	map3.Add(MakeKeyword("TLS"), (*(*(*resp).Request).TLS))
// 	map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 	map3.Add(MakeKeyword("Response"), )
// 	map1.Add(MakeKeyword("Request"), map3)
// 	map1.Add(MakeKeyword("TLS"), (*(*resp).TLS))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC http.PostForm has:
// func postForm(url string, data ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/client.go:785:32)) Object {
// 	resp, err := _http.PostForm(url, data)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 	map1.Add(MakeKeyword("StatusCode"), MakeInt(int((*resp).StatusCode)))
// 	map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 	map1.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*resp).ProtoMajor)))
// 	map1.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*resp).ProtoMinor)))
// 	map1.Add(MakeKeyword("Header"), (*resp).Header)
// 	map1.Add(MakeKeyword("Body"), (*resp).Body)
// 	map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*resp).TransferEncoding {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("TransferEncoding"), vec2)
// 	map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 	map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 	map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 	map3 := EmptyArrayMap()
// 	map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 	map3.Add(MakeKeyword("URL"), (*(*(*resp).Request).URL))
// 	map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 	map3.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*(*resp).Request).ProtoMajor)))
// 	map3.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*(*resp).Request).ProtoMinor)))
// 	map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 	map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 	map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 	map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*(*resp).Request).TransferEncoding {
// 		vec4 = vec4.Conjoin(MakeString(elem4))
// 	}
// 	map3.Add(MakeKeyword("TransferEncoding"), vec4)
// 	map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 	map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 	map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 	map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 	map3.Add(MakeKeyword("MultipartForm"), (*(*(*resp).Request).MultipartForm))
// 	map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 	map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 	map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 	map3.Add(MakeKeyword("TLS"), (*(*(*resp).Request).TLS))
// 	map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 	map3.Add(MakeKeyword("Response"), )
// 	map1.Add(MakeKeyword("Request"), map3)
// 	map1.Add(MakeKeyword("TLS"), (*(*resp).TLS))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC http.ProxyFromEnvironment has:
// func proxyFromEnvironment(req ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/transport.go:345:31)) Object {
// 	res1, res2 := _http.ProxyFromEnvironment(req)
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC http.ProxyURL has:
// func proxyURL(fixedURL ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/transport.go:351:24)) Object {
// 	return _http.ProxyURL(fixedURL)
// }

GO FUNC http.ReadRequest has:
// func readRequest(b ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/request.go:942:20)) Object {
// 	res1, res2 := _http.ReadRequest(b)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Method"), MakeString((*res1).Method))
// 	map1.Add(MakeKeyword("URL"), (*(*res1).URL))
// 	map1.Add(MakeKeyword("Proto"), MakeString((*res1).Proto))
// 	map1.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*res1).ProtoMajor)))
// 	map1.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*res1).ProtoMinor)))
// 	map1.Add(MakeKeyword("Header"), (*res1).Header)
// 	map1.Add(MakeKeyword("Body"), (*res1).Body)
// 	map1.Add(MakeKeyword("GetBody"), (*res1).GetBody)
// 	map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*res1).ContentLength)))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).TransferEncoding {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("TransferEncoding"), vec2)
// 	map1.Add(MakeKeyword("Close"), MakeBool((*res1).Close))
// 	map1.Add(MakeKeyword("Host"), MakeString((*res1).Host))
// 	map1.Add(MakeKeyword("Form"), (*res1).Form)
// 	map1.Add(MakeKeyword("PostForm"), (*res1).PostForm)
// 	map1.Add(MakeKeyword("MultipartForm"), (*(*res1).MultipartForm))
// 	map1.Add(MakeKeyword("Trailer"), (*res1).Trailer)
// 	map1.Add(MakeKeyword("RemoteAddr"), MakeString((*res1).RemoteAddr))
// 	map1.Add(MakeKeyword("RequestURI"), MakeString((*res1).RequestURI))
// 	map1.Add(MakeKeyword("TLS"), (*(*res1).TLS))
// 	map1.Add(MakeKeyword("Cancel"), (*res1).Cancel)
// 	map3 := EmptyArrayMap()
// 	map3.Add(MakeKeyword("Status"), MakeString((*(*res1).Response).Status))
// 	map3.Add(MakeKeyword("StatusCode"), MakeInt(int((*(*res1).Response).StatusCode)))
// 	map3.Add(MakeKeyword("Proto"), MakeString((*(*res1).Response).Proto))
// 	map3.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*(*res1).Response).ProtoMajor)))
// 	map3.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*(*res1).Response).ProtoMinor)))
// 	map3.Add(MakeKeyword("Header"), (*(*res1).Response).Header)
// 	map3.Add(MakeKeyword("Body"), (*(*res1).Response).Body)
// 	map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*res1).Response).ContentLength)))
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*(*res1).Response).TransferEncoding {
// 		vec4 = vec4.Conjoin(MakeString(elem4))
// 	}
// 	map3.Add(MakeKeyword("TransferEncoding"), vec4)
// 	map3.Add(MakeKeyword("Close"), MakeBool((*(*res1).Response).Close))
// 	map3.Add(MakeKeyword("Uncompressed"), MakeBool((*(*res1).Response).Uncompressed))
// 	map3.Add(MakeKeyword("Trailer"), (*(*res1).Response).Trailer)
// 	map3.Add(MakeKeyword("Request"), )
// 	map3.Add(MakeKeyword("TLS"), (*(*(*res1).Response).TLS))
// 	map1.Add(MakeKeyword("Response"), map3)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC http.ReadResponse has:
// func readResponse(r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/response.go:148:21), req ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/response.go:148:40)) Object {
// 	res1, res2 := _http.ReadResponse(r, req)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Status"), MakeString((*res1).Status))
// 	map1.Add(MakeKeyword("StatusCode"), MakeInt(int((*res1).StatusCode)))
// 	map1.Add(MakeKeyword("Proto"), MakeString((*res1).Proto))
// 	map1.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*res1).ProtoMajor)))
// 	map1.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*res1).ProtoMinor)))
// 	map1.Add(MakeKeyword("Header"), (*res1).Header)
// 	map1.Add(MakeKeyword("Body"), (*res1).Body)
// 	map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*res1).ContentLength)))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).TransferEncoding {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("TransferEncoding"), vec2)
// 	map1.Add(MakeKeyword("Close"), MakeBool((*res1).Close))
// 	map1.Add(MakeKeyword("Uncompressed"), MakeBool((*res1).Uncompressed))
// 	map1.Add(MakeKeyword("Trailer"), (*res1).Trailer)
// 	map3 := EmptyArrayMap()
// 	map3.Add(MakeKeyword("Method"), MakeString((*(*res1).Request).Method))
// 	map3.Add(MakeKeyword("URL"), (*(*(*res1).Request).URL))
// 	map3.Add(MakeKeyword("Proto"), MakeString((*(*res1).Request).Proto))
// 	map3.Add(MakeKeyword("ProtoMajor"), MakeInt(int((*(*res1).Request).ProtoMajor)))
// 	map3.Add(MakeKeyword("ProtoMinor"), MakeInt(int((*(*res1).Request).ProtoMinor)))
// 	map3.Add(MakeKeyword("Header"), (*(*res1).Request).Header)
// 	map3.Add(MakeKeyword("Body"), (*(*res1).Request).Body)
// 	map3.Add(MakeKeyword("GetBody"), (*(*res1).Request).GetBody)
// 	map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*res1).Request).ContentLength)))
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*(*res1).Request).TransferEncoding {
// 		vec4 = vec4.Conjoin(MakeString(elem4))
// 	}
// 	map3.Add(MakeKeyword("TransferEncoding"), vec4)
// 	map3.Add(MakeKeyword("Close"), MakeBool((*(*res1).Request).Close))
// 	map3.Add(MakeKeyword("Host"), MakeString((*(*res1).Request).Host))
// 	map3.Add(MakeKeyword("Form"), (*(*res1).Request).Form)
// 	map3.Add(MakeKeyword("PostForm"), (*(*res1).Request).PostForm)
// 	map3.Add(MakeKeyword("MultipartForm"), (*(*(*res1).Request).MultipartForm))
// 	map3.Add(MakeKeyword("Trailer"), (*(*res1).Request).Trailer)
// 	map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*res1).Request).RemoteAddr))
// 	map3.Add(MakeKeyword("RequestURI"), MakeString((*(*res1).Request).RequestURI))
// 	map3.Add(MakeKeyword("TLS"), (*(*(*res1).Request).TLS))
// 	map3.Add(MakeKeyword("Cancel"), (*(*res1).Request).Cancel)
// 	map3.Add(MakeKeyword("Response"), )
// 	map1.Add(MakeKeyword("Request"), map3)
// 	map1.Add(MakeKeyword("TLS"), (*(*res1).TLS))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC http.Redirect has:
// func redirect(w ABEND884(unrecognized type ResponseWriter at: GO.link/src/net/http/server.go:2020:17), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/server.go:2020:35), url string, code int) Object {
// 	_http.Redirect(w, r, url, code)
// 	...ABEND675: TODO...
// }

GO FUNC http.RedirectHandler has:
// func redirectHandler(url string, code int) Object {
// 	return _http.RedirectHandler(url, code)
// }

GO FUNC http.ServeContent has:
// func serveContent(w ABEND884(unrecognized type ResponseWriter at: GO.link/src/net/http/fs.go:151:21), req ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/fs.go:151:41), name string, modtime ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/fs.go:151:72), content ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/fs.go:151:91)) Object {
// 	_http.ServeContent(w, req, name, modtime, content)
// 	...ABEND675: TODO...
// }

GO FUNC http.ServeFile has:
// func serveFile(w ABEND884(unrecognized type ResponseWriter at: GO.link/src/net/http/fs.go:670:18), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/fs.go:670:36), name string) Object {
// 	_http.ServeFile(w, r, name)
// 	...ABEND675: TODO...
// }

GO FUNC http.SetCookie has:
// func setCookie(w ABEND884(unrecognized type ResponseWriter at: GO.link/src/net/http/cookie.go:157:18), cookie ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/cookie.go:157:41)) Object {
// 	_http.SetCookie(w, cookie)
// 	...ABEND675: TODO...
// }

GO FUNC http.StripPrefix has:
// func stripPrefix(prefix string, h ABEND884(unrecognized type Handler at: GO.link/src/net/http/server.go:1992:35)) Object {
// 	return _http.StripPrefix(prefix, h)
// }

GO FUNC http.TimeoutHandler has:
// func timeoutHandler(h ABEND884(unrecognized type Handler at: GO.link/src/net/http/server.go:3106:23), dt ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/server.go:3106:35), msg string) Object {
// 	return _http.TimeoutHandler(h, dt, msg)
// }

GO FUNC httptest.NewRecorder has:
// func newRecorder() Object {
// 	res := _httptest.NewRecorder()
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Code"), MakeInt(int((*res).Code)))
// 	map1.Add(MakeKeyword("HeaderMap"), (*res).HeaderMap)
// 	map1.Add(MakeKeyword("Body"), (*(*res).Body))
// 	map1.Add(MakeKeyword("Flushed"), MakeBool((*res).Flushed))
// 	return map1
// }

GO FUNC httptest.NewRequest has:
// func newRequest(method string, target string, body ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/httptest.go:41:45)) Object {
// 	return _httptest.NewRequest(method, target, body)
// }

GO FUNC httptest.NewServer has:
// func newServer(handler ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:80:24)) Object {
// 	res := _httptest.NewServer(handler)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("URL"), MakeString((*res).URL))
// 	map1.Add(MakeKeyword("Listener"), (*res).Listener)
// 	map1.Add(MakeKeyword("TLS"), (*(*res).TLS))
// 	map1.Add(MakeKeyword("Config"), (*(*res).Config))
// 	return map1
// }

GO FUNC httptest.NewTLSServer has:
// func newTLSServer(handler ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:160:27)) Object {
// 	res := _httptest.NewTLSServer(handler)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("URL"), MakeString((*res).URL))
// 	map1.Add(MakeKeyword("Listener"), (*res).Listener)
// 	map1.Add(MakeKeyword("TLS"), (*(*res).TLS))
// 	map1.Add(MakeKeyword("Config"), (*(*res).Config))
// 	return map1
// }

GO FUNC httptest.NewUnstartedServer has:
// func newUnstartedServer(handler ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptest/server.go:92:33)) Object {
// 	res := _httptest.NewUnstartedServer(handler)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("URL"), MakeString((*res).URL))
// 	map1.Add(MakeKeyword("Listener"), (*res).Listener)
// 	map1.Add(MakeKeyword("TLS"), (*(*res).TLS))
// 	map1.Add(MakeKeyword("Config"), (*(*res).Config))
// 	return map1
// }

GO FUNC httptrace.ContextClientTrace has:
// func contextClientTrace(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptrace/trace.go:24:29)) Object {
// 	res := _httptrace.ContextClientTrace(ctx)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("GetConn"), (*res).GetConn)
// 	map1.Add(MakeKeyword("GotConn"), (*res).GotConn)
// 	map1.Add(MakeKeyword("PutIdleConn"), (*res).PutIdleConn)
// 	map1.Add(MakeKeyword("GotFirstResponseByte"), (*res).GotFirstResponseByte)
// 	map1.Add(MakeKeyword("Got100Continue"), (*res).Got100Continue)
// 	map1.Add(MakeKeyword("Got1xxResponse"), (*res).Got1xxResponse)
// 	map1.Add(MakeKeyword("DNSStart"), (*res).DNSStart)
// 	map1.Add(MakeKeyword("DNSDone"), (*res).DNSDone)
// 	map1.Add(MakeKeyword("ConnectStart"), (*res).ConnectStart)
// 	map1.Add(MakeKeyword("ConnectDone"), (*res).ConnectDone)
// 	map1.Add(MakeKeyword("TLSHandshakeStart"), (*res).TLSHandshakeStart)
// 	map1.Add(MakeKeyword("TLSHandshakeDone"), (*res).TLSHandshakeDone)
// 	map1.Add(MakeKeyword("WroteHeaderField"), (*res).WroteHeaderField)
// 	map1.Add(MakeKeyword("WroteHeaders"), (*res).WroteHeaders)
// 	map1.Add(MakeKeyword("Wait100Continue"), (*res).Wait100Continue)
// 	map1.Add(MakeKeyword("WroteRequest"), (*res).WroteRequest)
// 	return map1
// }

GO FUNC httptrace.WithClientTrace has:
// func withClientTrace(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httptrace/trace.go:34:26), trace ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httptrace/trace.go:34:49)) Object {
// 	return _httptrace.WithClientTrace(ctx, trace)
// }

GO FUNC httputil.DumpRequest has:
// func dumpRequest(req ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/dump.go:191:22), body bool) Object {
// 	res1, res2 := _httputil.DumpRequest(req, body)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC httputil.DumpRequestOut has:
// func dumpRequestOut(req ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/dump.go:66:25), body bool) Object {
// 	res1, res2 := _httputil.DumpRequestOut(req, body)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC httputil.DumpResponse has:
// func dumpResponse(resp ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/dump.go:281:24), body bool) Object {
// 	res1, res2 := _httputil.DumpResponse(resp, body)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC httputil.NewChunkedReader has:
// func newChunkedReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/httputil.go:20:25)) Object {
// 	return _httputil.NewChunkedReader(r)
// }

GO FUNC httputil.NewChunkedWriter has:
// func newChunkedWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/httputil.go:35:25)) Object {
// 	return _httputil.NewChunkedWriter(w)
// }

GO FUNC httputil.NewClientConn has:
// func newClientConn(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/persist.go:248:22), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/persist.go:248:34)) Object {
// 	return _httputil.NewClientConn(c, r)
// 	ABEND124(no public information returned)
// }

GO FUNC httputil.NewProxyClientConn has:
// func newProxyClientConn(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/persist.go:265:27), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/persist.go:265:39)) Object {
// 	return _httputil.NewProxyClientConn(c, r)
// 	ABEND124(no public information returned)
// }

GO FUNC httputil.NewServerConn has:
// func newServerConn(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/httputil/persist.go:54:22), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/persist.go:54:34)) Object {
// 	return _httputil.NewServerConn(c, r)
// 	ABEND124(no public information returned)
// }

GO FUNC httputil.NewSingleHostReverseProxy has:
// func newSingleHostReverseProxy(target ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/httputil/reverseproxy.go:103:39)) Object {
// 	res := _httputil.NewSingleHostReverseProxy(target)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Director"), (*res).Director)
// 	map1.Add(MakeKeyword("Transport"), (*res).Transport)
// 	map1.Add(MakeKeyword("FlushInterval"), (*res).FlushInterval)
// 	map1.Add(MakeKeyword("ErrorLog"), (*(*res).ErrorLog))
// 	map1.Add(MakeKeyword("BufferPool"), (*res).BufferPool)
// 	map1.Add(MakeKeyword("ModifyResponse"), (*res).ModifyResponse)
// 	map1.Add(MakeKeyword("ErrorHandler"), (*res).ErrorHandler)
// 	return map1
// }

GO FUNC image.Decode has:
// func decode(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/format.go:78:15)) Object {
// 	res1, res2, res3 := _image.Decode(r)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(MakeString(res2))
// 	res = res.Conjoin(func () Object { if (res3) == nil { return NIL } else { return MakeError(res3) } }())
// 	return res
// }

GO FUNC image.DecodeConfig has:
// func decodeConfig(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/format.go:92:21)) Object {
// 	res1, res2, res3 := _image.DecodeConfig(r)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("ColorModel"), res1.ColorModel)
// 	map1.Add(MakeKeyword("Width"), MakeInt(int(res1.Width)))
// 	map1.Add(MakeKeyword("Height"), MakeInt(int(res1.Height)))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(MakeString(res2))
// 	res = res.Conjoin(func () Object { if (res3) == nil { return NIL } else { return MakeError(res3) } }())
// 	return res
// }

GO FUNC image.NewAlpha has:
// func newAlpha(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/image.go:567:17)) Object {
// 	res := _image.NewAlpha(r)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Pix {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Pix"), vec2)
// 	map1.Add(MakeKeyword("Stride"), MakeInt(int((*res).Stride)))
// 	map3 := EmptyArrayMap()
// 	map4 := EmptyArrayMap()
// 	map4.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map4.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map3.Add(MakeKeyword("Min"), map4)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map5.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map3.Add(MakeKeyword("Max"), map5)
// 	map1.Add(MakeKeyword("Rect"), map3)
// 	return map1
// }

GO FUNC image.NewAlpha16 has:
// func newAlpha16(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/image.go:662:19)) Object {
// 	res := _image.NewAlpha16(r)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Pix {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Pix"), vec2)
// 	map1.Add(MakeKeyword("Stride"), MakeInt(int((*res).Stride)))
// 	map3 := EmptyArrayMap()
// 	map4 := EmptyArrayMap()
// 	map4.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map4.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map3.Add(MakeKeyword("Min"), map4)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map5.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map3.Add(MakeKeyword("Max"), map5)
// 	map1.Add(MakeKeyword("Rect"), map3)
// 	return map1
// }

GO FUNC image.NewCMYK has:
// func newCMYK(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/image.go:909:16)) Object {
// 	res := _image.NewCMYK(r)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Pix {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Pix"), vec2)
// 	map1.Add(MakeKeyword("Stride"), MakeInt(int((*res).Stride)))
// 	map3 := EmptyArrayMap()
// 	map4 := EmptyArrayMap()
// 	map4.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map4.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map3.Add(MakeKeyword("Min"), map4)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map5.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map3.Add(MakeKeyword("Max"), map5)
// 	map1.Add(MakeKeyword("Rect"), map3)
// 	return map1
// }

GO FUNC image.NewGray has:
// func newGray(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/image.go:741:16)) Object {
// 	res := _image.NewGray(r)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Pix {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Pix"), vec2)
// 	map1.Add(MakeKeyword("Stride"), MakeInt(int((*res).Stride)))
// 	map3 := EmptyArrayMap()
// 	map4 := EmptyArrayMap()
// 	map4.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map4.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map3.Add(MakeKeyword("Min"), map4)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map5.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map3.Add(MakeKeyword("Max"), map5)
// 	map1.Add(MakeKeyword("Rect"), map3)
// 	return map1
// }

GO FUNC image.NewGray16 has:
// func newGray16(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/image.go:823:18)) Object {
// 	res := _image.NewGray16(r)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Pix {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Pix"), vec2)
// 	map1.Add(MakeKeyword("Stride"), MakeInt(int((*res).Stride)))
// 	map3 := EmptyArrayMap()
// 	map4 := EmptyArrayMap()
// 	map4.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map4.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map3.Add(MakeKeyword("Min"), map4)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map5.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map3.Add(MakeKeyword("Max"), map5)
// 	map1.Add(MakeKeyword("Rect"), map3)
// 	return map1
// }

GO FUNC image.NewNRGBA has:
// func newNRGBA(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/image.go:363:17)) Object {
// 	res := _image.NewNRGBA(r)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Pix {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Pix"), vec2)
// 	map1.Add(MakeKeyword("Stride"), MakeInt(int((*res).Stride)))
// 	map3 := EmptyArrayMap()
// 	map4 := EmptyArrayMap()
// 	map4.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map4.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map3.Add(MakeKeyword("Min"), map4)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map5.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map3.Add(MakeKeyword("Max"), map5)
// 	map1.Add(MakeKeyword("Rect"), map3)
// 	return map1
// }

GO FUNC image.NewNRGBA64 has:
// func newNRGBA64(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/image.go:475:19)) Object {
// 	res := _image.NewNRGBA64(r)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Pix {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Pix"), vec2)
// 	map1.Add(MakeKeyword("Stride"), MakeInt(int((*res).Stride)))
// 	map3 := EmptyArrayMap()
// 	map4 := EmptyArrayMap()
// 	map4.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map4.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map3.Add(MakeKeyword("Min"), map4)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map5.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map3.Add(MakeKeyword("Max"), map5)
// 	map1.Add(MakeKeyword("Rect"), map3)
// 	return map1
// }

GO FUNC image.NewNYCbCrA has:
// func newNYCbCrA(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/ycbcr.go:278:19), subsampleRatio ABEND884(unrecognized type YCbCrSubsampleRatio at: GO.link/src/image/ycbcr.go:278:45)) Object {
// 	res := _image.NewNYCbCrA(r, subsampleRatio)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).A {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("A"), vec2)
// 	map1.Add(MakeKeyword("AStride"), MakeInt(int((*res).AStride)))
// 	return map1
// }

GO FUNC image.NewPaletted has:
// func newPaletted(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/image.go:1019:20), p ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/image.go:1019:33)) Object {
// 	res := _image.NewPaletted(r, p)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Pix {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Pix"), vec2)
// 	map1.Add(MakeKeyword("Stride"), MakeInt(int((*res).Stride)))
// 	map3 := EmptyArrayMap()
// 	map4 := EmptyArrayMap()
// 	map4.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map4.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map3.Add(MakeKeyword("Min"), map4)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map5.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map3.Add(MakeKeyword("Max"), map5)
// 	map1.Add(MakeKeyword("Rect"), map3)
// 	map1.Add(MakeKeyword("Palette"), (*res).Palette)
// 	return map1
// }

GO FUNC image.NewRGBA has:
// func newRGBA(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/image.go:152:16)) Object {
// 	res := _image.NewRGBA(r)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Pix {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Pix"), vec2)
// 	map1.Add(MakeKeyword("Stride"), MakeInt(int((*res).Stride)))
// 	map3 := EmptyArrayMap()
// 	map4 := EmptyArrayMap()
// 	map4.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map4.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map3.Add(MakeKeyword("Min"), map4)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map5.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map3.Add(MakeKeyword("Max"), map5)
// 	map1.Add(MakeKeyword("Rect"), map3)
// 	return map1
// }

GO FUNC image.NewRGBA64 has:
// func newRGBA64(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/image.go:264:18)) Object {
// 	res := _image.NewRGBA64(r)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Pix {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Pix"), vec2)
// 	map1.Add(MakeKeyword("Stride"), MakeInt(int((*res).Stride)))
// 	map3 := EmptyArrayMap()
// 	map4 := EmptyArrayMap()
// 	map4.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map4.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map3.Add(MakeKeyword("Min"), map4)
// 	map5 := EmptyArrayMap()
// 	map5.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map5.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map3.Add(MakeKeyword("Max"), map5)
// 	map1.Add(MakeKeyword("Rect"), map3)
// 	return map1
// }

GO FUNC image.NewUniform has:
// func newUniform(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/names.go:50:19)) Object {
// 	res := _image.NewUniform(c)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("C"), (*res).C)
// 	return map1
// }

GO FUNC image.NewYCbCr has:
// func newYCbCr(r ABEND884(unrecognized type Rectangle at: GO.link/src/image/ycbcr.go:169:17), subsampleRatio ABEND884(unrecognized type YCbCrSubsampleRatio at: GO.link/src/image/ycbcr.go:169:43)) Object {
// 	res := _image.NewYCbCr(r, subsampleRatio)
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).Y {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Y"), vec2)
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res).Cb {
// 		vec3 = vec3.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Cb"), vec3)
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res).Cr {
// 		vec4 = vec4.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Cr"), vec4)
// 	map1.Add(MakeKeyword("YStride"), MakeInt(int((*res).YStride)))
// 	map1.Add(MakeKeyword("CStride"), MakeInt(int((*res).CStride)))
// 	map1.Add(MakeKeyword("SubsampleRatio"), MakeInt(int((*res).SubsampleRatio)))
// 	map5 := EmptyArrayMap()
// 	map6 := EmptyArrayMap()
// 	map6.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Min.X)))
// 	map6.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Min.Y)))
// 	map5.Add(MakeKeyword("Min"), map6)
// 	map7 := EmptyArrayMap()
// 	map7.Add(MakeKeyword("X"), MakeInt(int((*res).Rect.Max.X)))
// 	map7.Add(MakeKeyword("Y"), MakeInt(int((*res).Rect.Max.Y)))
// 	map5.Add(MakeKeyword("Max"), map7)
// 	map1.Add(MakeKeyword("Rect"), map5)
// 	return map1
// }

GO FUNC image.Pt has:
func pt(X int, Y int) Object {
	res := _image.Pt(X, Y)
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("X"), MakeInt(int(res.X)))
	map1.Add(MakeKeyword("Y"), MakeInt(int(res.Y)))
	return map1
}

GO FUNC image.Rect has:
func rect(x0 int, y0 int, x1 int, y1 int) Object {
	res := _image.Rect(x0, y0, x1, y1)
	map1 := EmptyArrayMap()
	map2 := EmptyArrayMap()
	map2.Add(MakeKeyword("X"), MakeInt(int(res.Min.X)))
	map2.Add(MakeKeyword("Y"), MakeInt(int(res.Min.Y)))
	map1.Add(MakeKeyword("Min"), map2)
	map3 := EmptyArrayMap()
	map3.Add(MakeKeyword("X"), MakeInt(int(res.Max.X)))
	map3.Add(MakeKeyword("Y"), MakeInt(int(res.Max.Y)))
	map1.Add(MakeKeyword("Max"), map3)
	return map1
}

GO FUNC image.RegisterFormat has:
// func registerFormat(name string, magic string, decode ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/image/format.go:32:48), decodeConfig ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/image/format.go:32:93)) Object {
// 	_image.RegisterFormat(name, magic, decode, decodeConfig)
// 	...ABEND675: TODO...
// }

GO FUNC importer.Default has:
// func default() Object {
// 	return _importer.Default()
// }

GO FUNC importer.For has:
// func for(compiler string, lookup ABEND884(unrecognized type Lookup at: GO.link/src/go/importer/importer.go:42:34)) Object {
// 	return _importer.For(compiler, lookup)
// }

GO FUNC io.Copy has:
// func copy(dst ABEND884(unrecognized type Writer at: GO.link/src/io/io.go:363:15), src ABEND884(unrecognized type Reader at: GO.link/src/io/io.go:363:27)) Object {
// 	written, err := _io.Copy(dst, src)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(written)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC io.CopyBuffer has:
// func copyBuffer(dst ABEND884(unrecognized type Writer at: GO.link/src/io/io.go:371:21), src ABEND884(unrecognized type Reader at: GO.link/src/io/io.go:371:33), buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/io/io.go:371:45)) Object {
// 	written, err := _io.CopyBuffer(dst, src, buf)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(written)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC io.CopyN has:
// func copyN(dst ABEND884(unrecognized type Writer at: GO.link/src/io/io.go:339:16), src ABEND884(unrecognized type Reader at: GO.link/src/io/io.go:339:28), n int64) Object {
// 	written, err := _io.CopyN(dst, src, n)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(written)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC io.LimitReader has:
// func limitReader(r ABEND884(unrecognized type Reader at: GO.link/src/io/io.go:430:20), n int64) Object {
// 	return _io.LimitReader(r, n)
// }

GO FUNC io.MultiReader has:
// func multiReader(readers ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/io/multi.go:48:26)) Object {
// 	return _io.MultiReader(readers)
// }

GO FUNC io.MultiWriter has:
// func multiWriter(writers ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/io/multi.go:102:26)) Object {
// 	return _io.MultiWriter(writers)
// }

GO FUNC io.NewSectionReader has:
// func newSectionReader(r ABEND884(unrecognized type ReaderAt at: GO.link/src/io/io.go:455:25), off int64, n int64) Object {
// 	return _io.NewSectionReader(r, off, n)
// 	ABEND124(no public information returned)
// }

GO FUNC io.Pipe has:
// func pipe() Object {
// 	_, _ := _io.Pipe()
// 	ABEND123(no public information returned)
// }

GO FUNC io.ReadAtLeast has:
// func readAtLeast(r ABEND884(unrecognized type Reader at: GO.link/src/io/io.go:304:20), buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/io/io.go:304:32), min int) Object {
// 	n, err := _io.ReadAtLeast(r, buf, min)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC io.ReadFull has:
// func readFull(r ABEND884(unrecognized type Reader at: GO.link/src/io/io.go:328:17), buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/io/io.go:328:29)) Object {
// 	n, err := _io.ReadFull(r, buf)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC io.TeeReader has:
// func teeReader(r ABEND884(unrecognized type Reader at: GO.link/src/io/io.go:525:18), w ABEND884(unrecognized type Writer at: GO.link/src/io/io.go:525:28)) Object {
// 	return _io.TeeReader(r, w)
// }

GO FUNC io.WriteString has:
// func writeString(w ABEND884(unrecognized type Writer at: GO.link/src/io/io.go:289:20), s string) Object {
// 	n, err := _io.WriteString(w, s)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC iotest.DataErrReader has:
// func dataErrReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:45:22)) Object {
// 	return _iotest.DataErrReader(r)
// }

GO FUNC iotest.HalfReader has:
// func halfReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:30:19)) Object {
// 	return _iotest.HalfReader(r)
// }

GO FUNC iotest.NewReadLogger has:
// func newReadLogger(prefix string, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/logger.go:52:37)) Object {
// 	return _iotest.NewReadLogger(prefix, r)
// }

GO FUNC iotest.NewWriteLogger has:
// func newWriteLogger(prefix string, w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/logger.go:30:38)) Object {
// 	return _iotest.NewWriteLogger(prefix, w)
// }

GO FUNC iotest.OneByteReader has:
// func oneByteReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:15:22)) Object {
// 	return _iotest.OneByteReader(r)
// }

GO FUNC iotest.TimeoutReader has:
// func timeoutReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/reader.go:75:22)) Object {
// 	return _iotest.TimeoutReader(r)
// }

GO FUNC iotest.TruncateWriter has:
// func truncateWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/iotest/writer.go:11:23), n int64) Object {
// 	return _iotest.TruncateWriter(w, n)
// }

GO FUNC ioutil.NopCloser has:
// func nopCloser(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/io/ioutil/ioutil.go:118:18)) Object {
// 	return _ioutil.NopCloser(r)
// }

GO FUNC ioutil.ReadAll has:
// func readAll(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/io/ioutil/ioutil.go:44:16)) Object {
// 	res1, res2 := _ioutil.ReadAll(r)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC ioutil.ReadDir has:
// func readDir(dirname string) Object {
// 	res1, res2 := _ioutil.ReadDir(dirname)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(elem1)
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC ioutil.ReadFile has:
func readFile(filename string) Object {
	res1, res2 := _ioutil.ReadFile(filename)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC ioutil.TempDir has:
func tempDir(dir string, prefix string) Object {
	name, err := _ioutil.TempDir(dir, prefix)
	res := EmptyVector
	res = res.Conjoin(MakeString(name))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC ioutil.TempFile has:
// func tempFile(dir string, pattern string) Object {
// 	f, err := _ioutil.TempFile(dir, pattern)
// 	res := EmptyVector
// 	res = res.Conjoin((*f))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC jpeg.Decode has:
// func decode(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/jpeg/reader.go:777:15)) Object {
// 	res1, res2 := _jpeg.Decode(r)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC jpeg.DecodeConfig has:
// func decodeConfig(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/jpeg/reader.go:784:21)) Object {
// 	res1, res2 := _jpeg.DecodeConfig(r)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC json.HTMLEscape has:
// func hTMLEscape(dst ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/json/encode.go:194:21), src ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/json/encode.go:194:40)) Object {
// 	_json.HTMLEscape(dst, src)
// 	...ABEND675: TODO...
// }

GO FUNC json.Marshal has:
// func marshal(v ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/json/encode.go:157:16)) Object {
// 	res1, res2 := _json.Marshal(v)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC json.MarshalIndent has:
// func marshalIndent(v ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/json/encode.go:175:22), prefix string, indent string) Object {
// 	res1, res2 := _json.MarshalIndent(v, prefix, indent)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC json.NewDecoder has:
// func newDecoder(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/json/stream.go:31:19)) Object {
// 	return _json.NewDecoder(r)
// 	ABEND124(no public information returned)
// }

GO FUNC json.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/json/stream.go:186:19)) Object {
// 	return _json.NewEncoder(w)
// 	ABEND124(no public information returned)
// }

GO FUNC jsonrpc.Dial has:
// func dial(network string, address string) Object {
// 	res1, res2 := _jsonrpc.Dial(network, address)
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC jsonrpc.NewClient has:
// func newClient(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/client.go:113:21)) Object {
// 	return _jsonrpc.NewClient(conn)
// }

GO FUNC jsonrpc.NewClientCodec has:
// func newClientCodec(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/client.go:37:26)) Object {
// 	return _jsonrpc.NewClientCodec(conn)
// }

GO FUNC jsonrpc.NewServerCodec has:
// func newServerCodec(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/server.go:37:26)) Object {
// 	return _jsonrpc.NewServerCodec(conn)
// }

GO FUNC jsonrpc.ServeConn has:
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/jsonrpc/server.go:132:21)) Object {
// 	_jsonrpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO FUNC list.New has:
// func new() Object {
// 	return _list.New()
// 	ABEND124(no public information returned)
// }

GO FUNC log.Fatal has:
// func fatal(v ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:305:14)) Object {
// 	_log.Fatal(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Fatalf has:
// func fatalf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:311:30)) Object {
// 	_log.Fatalf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Fatalln has:
// func fatalln(v ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:317:16)) Object {
// 	_log.Fatalln(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.New has:
// func new(out ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/log/log.go:62:14), prefix string, flag int) Object {
// 	return _log.New(out, prefix, flag)
// 	ABEND124(no public information returned)
// }

GO FUNC log.Panic has:
// func panic(v ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:323:14)) Object {
// 	_log.Panic(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Panicf has:
// func panicf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:330:30)) Object {
// 	_log.Panicf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Panicln has:
// func panicln(v ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:337:16)) Object {
// 	_log.Panicln(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Print has:
// func print(v ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:288:14)) Object {
// 	_log.Print(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Printf has:
// func printf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:294:30)) Object {
// 	_log.Printf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Println has:
// func println(v ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/log/log.go:300:16)) Object {
// 	_log.Println(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetFlags has:
// func setFlags(flag int) Object {
// 	_log.SetFlags(flag)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetOutput has:
// func setOutput(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/log/log.go:258:18)) Object {
// 	_log.SetOutput(w)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetPrefix has:
// func setPrefix(prefix string) Object {
// 	_log.SetPrefix(prefix)
// 	...ABEND675: TODO...
// }

GO FUNC lzw.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/lzw/reader.go:239:18), order ABEND884(unrecognized type Order at: GO.link/src/compress/lzw/reader.go:239:35), litWidth int) Object {
// 	return _lzw.NewReader(r, order, litWidth)
// }

GO FUNC lzw.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/lzw/writer.go:241:18), order ABEND884(unrecognized type Order at: GO.link/src/compress/lzw/writer.go:241:35), litWidth int) Object {
// 	return _lzw.NewWriter(w, order, litWidth)
// }

GO FUNC macho.NewFatFile has:
// func newFatFile(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/macho/fat.go:45:19)) Object {
// 	res1, res2 := _macho.NewFatFile(r)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Magic"), MakeInt(int((*res1).Magic)))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Arches {
// 		vec2 = vec2.Conjoin(NIL)
// 	}
// 	map1.Add(MakeKeyword("Arches"), vec2)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC macho.NewFile has:
// func newFile(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/macho/file.go:228:16)) Object {
// 	res1, res2 := _macho.NewFile(r)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("ByteOrder"), (*res1).ByteOrder)
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Loads {
// 		vec2 = vec2.Conjoin(elem2)
// 	}
// 	map1.Add(MakeKeyword("Loads"), vec2)
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res1).Sections {
// 		map4 := EmptyArrayMap()
// 		vec5 := EmptyVector
// 		for _, elem5 := range (*elem3).Relocs {
// 			map6 := EmptyArrayMap()
// 			map6.Add(MakeKeyword("Addr"), MakeInt(int(elem5.Addr)))
// 			map6.Add(MakeKeyword("Value"), MakeInt(int(elem5.Value)))
// 			map6.Add(MakeKeyword("Type"), )
// 			map6.Add(MakeKeyword("Len"), )
// 			map6.Add(MakeKeyword("Pcrel"), MakeBool(elem5.Pcrel))
// 			map6.Add(MakeKeyword("Extern"), MakeBool(elem5.Extern))
// 			map6.Add(MakeKeyword("Scattered"), MakeBool(elem5.Scattered))
// 			vec5 = vec5.Conjoin(map6)
// 		}
// 		map4.Add(MakeKeyword("Relocs"), vec5)
// 		vec3 = vec3.Conjoin(map4)
// 	}
// 	map1.Add(MakeKeyword("Sections"), vec3)
// 	map7 := EmptyArrayMap()
// 	vec8 := EmptyVector
// 	for _, elem8 := range (*(*res1).Symtab).Syms {
// 		map9 := EmptyArrayMap()
// 		map9.Add(MakeKeyword("Name"), MakeString(elem8.Name))
// 		map9.Add(MakeKeyword("Type"), )
// 		map9.Add(MakeKeyword("Sect"), )
// 		map9.Add(MakeKeyword("Desc"), MakeInt(int(elem8.Desc)))
// 		map9.Add(MakeKeyword("Value"), )
// 		vec8 = vec8.Conjoin(map9)
// 	}
// 	map7.Add(MakeKeyword("Syms"), vec8)
// 	map1.Add(MakeKeyword("Symtab"), map7)
// 	map10 := EmptyArrayMap()
// 	vec11 := EmptyVector
// 	for _, elem11 := range (*(*res1).Dysymtab).IndirectSyms {
// 		vec11 = vec11.Conjoin(MakeInt(int(elem11)))
// 	}
// 	map10.Add(MakeKeyword("IndirectSyms"), vec11)
// 	map1.Add(MakeKeyword("Dysymtab"), map10)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC macho.Open has:
// func open(name string) Object {
// 	res1, res2 := _macho.Open(name)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("ByteOrder"), (*res1).ByteOrder)
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Loads {
// 		vec2 = vec2.Conjoin(elem2)
// 	}
// 	map1.Add(MakeKeyword("Loads"), vec2)
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res1).Sections {
// 		map4 := EmptyArrayMap()
// 		vec5 := EmptyVector
// 		for _, elem5 := range (*elem3).Relocs {
// 			map6 := EmptyArrayMap()
// 			map6.Add(MakeKeyword("Addr"), MakeInt(int(elem5.Addr)))
// 			map6.Add(MakeKeyword("Value"), MakeInt(int(elem5.Value)))
// 			map6.Add(MakeKeyword("Type"), )
// 			map6.Add(MakeKeyword("Len"), )
// 			map6.Add(MakeKeyword("Pcrel"), MakeBool(elem5.Pcrel))
// 			map6.Add(MakeKeyword("Extern"), MakeBool(elem5.Extern))
// 			map6.Add(MakeKeyword("Scattered"), MakeBool(elem5.Scattered))
// 			vec5 = vec5.Conjoin(map6)
// 		}
// 		map4.Add(MakeKeyword("Relocs"), vec5)
// 		vec3 = vec3.Conjoin(map4)
// 	}
// 	map1.Add(MakeKeyword("Sections"), vec3)
// 	map7 := EmptyArrayMap()
// 	vec8 := EmptyVector
// 	for _, elem8 := range (*(*res1).Symtab).Syms {
// 		map9 := EmptyArrayMap()
// 		map9.Add(MakeKeyword("Name"), MakeString(elem8.Name))
// 		map9.Add(MakeKeyword("Type"), )
// 		map9.Add(MakeKeyword("Sect"), )
// 		map9.Add(MakeKeyword("Desc"), MakeInt(int(elem8.Desc)))
// 		map9.Add(MakeKeyword("Value"), )
// 		vec8 = vec8.Conjoin(map9)
// 	}
// 	map7.Add(MakeKeyword("Syms"), vec8)
// 	map1.Add(MakeKeyword("Symtab"), map7)
// 	map10 := EmptyArrayMap()
// 	vec11 := EmptyVector
// 	for _, elem11 := range (*(*res1).Dysymtab).IndirectSyms {
// 		vec11 = vec11.Conjoin(MakeInt(int(elem11)))
// 	}
// 	map10.Add(MakeKeyword("IndirectSyms"), vec11)
// 	map1.Add(MakeKeyword("Dysymtab"), map10)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC macho.OpenFat has:
func openFat(name string) Object {
	res1, res2 := _macho.OpenFat(name)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Magic"), MakeInt(int((*res1).Magic)))
	vec2 := EmptyVector
	for _, elem2 := range (*res1).Arches {
		vec2 = vec2.Conjoin(NIL)
	}
	map1.Add(MakeKeyword("Arches"), vec2)
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC mail.ParseAddress has:
func parseAddress(address string) Object {
	res1, res2 := _mail.ParseAddress(address)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
	map1.Add(MakeKeyword("Address"), MakeString((*res1).Address))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC mail.ParseAddressList has:
func parseAddressList(list string) Object {
	res1, res2 := _mail.ParseAddressList(list)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		map2 := EmptyArrayMap()
		map2.Add(MakeKeyword("Name"), MakeString((*elem1).Name))
		map2.Add(MakeKeyword("Address"), MakeString((*elem1).Address))
		vec1 = vec1.Conjoin(map2)
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC mail.ParseDate has:
// func parseDate(date string) Object {
// 	res1, res2 := _mail.ParseDate(date)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC mail.ReadMessage has:
// func readMessage(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/mail/message.go:52:20)) Object {
// 	msg, err := _mail.ReadMessage(r)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Header"), (*msg).Header)
// 	map1.Add(MakeKeyword("Body"), (*msg).Body)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC math.Abs has:
// func abs(x ABEND884(unrecognized type float64 at: GO.link/src/math/abs.go:12:12)) Object {
// 	return _math.Abs(x)
// }

GO FUNC math.Acos has:
// func acos(x ABEND884(unrecognized type float64 at: GO.link/src/math/asin.go:51:13)) Object {
// 	return _math.Acos(x)
// }

GO FUNC math.Acosh has:
// func acosh(x ABEND884(unrecognized type float64 at: GO.link/src/math/acosh.go:42:14)) Object {
// 	return _math.Acosh(x)
// }

GO FUNC math.Asin has:
// func asin(x ABEND884(unrecognized type float64 at: GO.link/src/math/asin.go:19:13)) Object {
// 	return _math.Asin(x)
// }

GO FUNC math.Asinh has:
// func asinh(x ABEND884(unrecognized type float64 at: GO.link/src/math/asinh.go:39:14)) Object {
// 	return _math.Asinh(x)
// }

GO FUNC math.Atan has:
// func atan(x ABEND884(unrecognized type float64 at: GO.link/src/math/atan.go:95:13)) Object {
// 	return _math.Atan(x)
// }

GO FUNC math.Atan2 has:
// func atan2(y ABEND884(unrecognized type float64 at: GO.link/src/math/atan2.go:29:17), x ABEND884(unrecognized type float64 at: GO.link/src/math/atan2.go:29:17)) Object {
// 	return _math.Atan2(y, x)
// }

GO FUNC math.Atanh has:
// func atanh(x ABEND884(unrecognized type float64 at: GO.link/src/math/atanh.go:47:14)) Object {
// 	return _math.Atanh(x)
// }

GO FUNC math.Cbrt has:
// func cbrt(x ABEND884(unrecognized type float64 at: GO.link/src/math/cbrt.go:25:13)) Object {
// 	return _math.Cbrt(x)
// }

GO FUNC math.Ceil has:
// func ceil(x ABEND884(unrecognized type float64 at: GO.link/src/math/floor.go:36:13)) Object {
// 	return _math.Ceil(x)
// }

GO FUNC math.Copysign has:
// func copysign(x ABEND884(unrecognized type float64 at: GO.link/src/math/copysign.go:9:20), y ABEND884(unrecognized type float64 at: GO.link/src/math/copysign.go:9:20)) Object {
// 	return _math.Copysign(x, y)
// }

GO FUNC math.Cos has:
// func cos(x ABEND884(unrecognized type float64 at: GO.link/src/math/sin.go:117:12)) Object {
// 	return _math.Cos(x)
// }

GO FUNC math.Cosh has:
// func cosh(x ABEND884(unrecognized type float64 at: GO.link/src/math/sinh.go:72:13)) Object {
// 	return _math.Cosh(x)
// }

GO FUNC math.Dim has:
// func dim(x ABEND884(unrecognized type float64 at: GO.link/src/math/dim.go:13:15), y ABEND884(unrecognized type float64 at: GO.link/src/math/dim.go:13:15)) Object {
// 	return _math.Dim(x, y)
// }

GO FUNC math.Erf has:
// func erf(x ABEND884(unrecognized type float64 at: GO.link/src/math/erf.go:188:12)) Object {
// 	return _math.Erf(x)
// }

GO FUNC math.Erfc has:
// func erfc(x ABEND884(unrecognized type float64 at: GO.link/src/math/erf.go:267:13)) Object {
// 	return _math.Erfc(x)
// }

GO FUNC math.Erfcinv has:
// func erfcinv(x ABEND884(unrecognized type float64 at: GO.link/src/math/erfinv.go:125:16)) Object {
// 	return _math.Erfcinv(x)
// }

GO FUNC math.Erfinv has:
// func erfinv(x ABEND884(unrecognized type float64 at: GO.link/src/math/erfinv.go:76:15)) Object {
// 	return _math.Erfinv(x)
// }

GO FUNC math.Exp has:
// func exp(x ABEND884(unrecognized type float64 at: GO.link/src/math/exp.go:14:12)) Object {
// 	return _math.Exp(x)
// }

GO FUNC math.Exp2 has:
// func exp2(x ABEND884(unrecognized type float64 at: GO.link/src/math/exp.go:135:13)) Object {
// 	return _math.Exp2(x)
// }

GO FUNC math.Expm1 has:
// func expm1(x ABEND884(unrecognized type float64 at: GO.link/src/math/expm1.go:124:14)) Object {
// 	return _math.Expm1(x)
// }

GO FUNC math.Float32frombits has:
// func float32frombits(b uint32) Object {
// 	return _math.Float32frombits(b)
// }

GO FUNC math.Float64bits has:
// func float64bits(f ABEND884(unrecognized type float64 at: GO.link/src/math/unsafe.go:17:20)) Object {
// 	return _math.Float64bits(f)
// }

GO FUNC math.Float64frombits has:
// func float64frombits(b ABEND884(unrecognized type uint64 at: GO.link/src/math/unsafe.go:21:24)) Object {
// 	return _math.Float64frombits(b)
// }

GO FUNC math.Floor has:
// func floor(x ABEND884(unrecognized type float64 at: GO.link/src/math/floor.go:13:14)) Object {
// 	return _math.Floor(x)
// }

GO FUNC math.Frexp has:
// func frexp(f ABEND884(unrecognized type float64 at: GO.link/src/math/frexp.go:16:14)) Object {
// 	frac, exp := _math.Frexp(f)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeInt(int(exp)))
// 	return res
// }

GO FUNC math.Gamma has:
// func gamma(x ABEND884(unrecognized type float64 at: GO.link/src/math/gamma.go:130:14)) Object {
// 	return _math.Gamma(x)
// }

GO FUNC math.Hypot has:
// func hypot(p ABEND884(unrecognized type float64 at: GO.link/src/math/hypot.go:19:17), q ABEND884(unrecognized type float64 at: GO.link/src/math/hypot.go:19:17)) Object {
// 	return _math.Hypot(p, q)
// }

GO FUNC math.Inf has:
// func inf(sign int) Object {
// 	return _math.Inf(sign)
// }

GO FUNC math.J0 has:
// func j0(x ABEND884(unrecognized type float64 at: GO.link/src/math/j0.go:76:11)) Object {
// 	return _math.J0(x)
// }

GO FUNC math.J1 has:
// func j1(x ABEND884(unrecognized type float64 at: GO.link/src/math/j1.go:74:11)) Object {
// 	return _math.J1(x)
// }

GO FUNC math.Jn has:
// func jn(n int, x ABEND884(unrecognized type float64 at: GO.link/src/math/jn.go:53:18)) Object {
// 	return _math.Jn(n, x)
// }

GO FUNC math.Ldexp has:
// func ldexp(frac ABEND884(unrecognized type float64 at: GO.link/src/math/ldexp.go:14:17), exp int) Object {
// 	return _math.Ldexp(frac, exp)
// }

GO FUNC math.Lgamma has:
// func lgamma(x ABEND884(unrecognized type float64 at: GO.link/src/math/lgamma.go:174:15)) Object {
// 	lgamma, sign := _math.Lgamma(x)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeInt(int(sign)))
// 	return res
// }

GO FUNC math.Log has:
// func log(x ABEND884(unrecognized type float64 at: GO.link/src/math/log.go:80:12)) Object {
// 	return _math.Log(x)
// }

GO FUNC math.Log10 has:
// func log10(x ABEND884(unrecognized type float64 at: GO.link/src/math/log10.go:9:14)) Object {
// 	return _math.Log10(x)
// }

GO FUNC math.Log1p has:
// func log1p(x ABEND884(unrecognized type float64 at: GO.link/src/math/log1p.go:95:14)) Object {
// 	return _math.Log1p(x)
// }

GO FUNC math.Log2 has:
// func log2(x ABEND884(unrecognized type float64 at: GO.link/src/math/log10.go:17:13)) Object {
// 	return _math.Log2(x)
// }

GO FUNC math.Logb has:
// func logb(x ABEND884(unrecognized type float64 at: GO.link/src/math/logb.go:13:13)) Object {
// 	return _math.Logb(x)
// }

GO FUNC math.Max has:
// func max(x ABEND884(unrecognized type float64 at: GO.link/src/math/dim.go:35:15), y ABEND884(unrecognized type float64 at: GO.link/src/math/dim.go:35:15)) Object {
// 	return _math.Max(x, y)
// }

GO FUNC math.Min has:
// func min(x ABEND884(unrecognized type float64 at: GO.link/src/math/dim.go:62:15), y ABEND884(unrecognized type float64 at: GO.link/src/math/dim.go:62:15)) Object {
// 	return _math.Min(x, y)
// }

GO FUNC math.Mod has:
// func mod(x ABEND884(unrecognized type float64 at: GO.link/src/math/mod.go:21:15), y ABEND884(unrecognized type float64 at: GO.link/src/math/mod.go:21:15)) Object {
// 	return _math.Mod(x, y)
// }

GO FUNC math.Modf has:
// func modf(f ABEND884(unrecognized type float64 at: GO.link/src/math/modf.go:13:13)) Object {
// 	int, frac := _math.Modf(f)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC math.NaN has:
// func naN() Object {
// 	return _math.NaN()
// }

GO FUNC math.Nextafter has:
// func nextafter(x ABEND884(unrecognized type float64 at: GO.link/src/math/nextafter.go:35:21), y ABEND884(unrecognized type float64 at: GO.link/src/math/nextafter.go:35:21)) Object {
// 	return _math.Nextafter(x, y)
// }

GO FUNC math.Nextafter32 has:
// func nextafter32(x ABEND884(unrecognized type float32 at: GO.link/src/math/nextafter.go:13:23), y ABEND884(unrecognized type float32 at: GO.link/src/math/nextafter.go:13:23)) Object {
// 	return _math.Nextafter32(x, y)
// }

GO FUNC math.Pow has:
// func pow(x ABEND884(unrecognized type float64 at: GO.link/src/math/pow.go:38:15), y ABEND884(unrecognized type float64 at: GO.link/src/math/pow.go:38:15)) Object {
// 	return _math.Pow(x, y)
// }

GO FUNC math.Pow10 has:
// func pow10(n int) Object {
// 	return _math.Pow10(n)
// }

GO FUNC math.Remainder has:
// func remainder(x ABEND884(unrecognized type float64 at: GO.link/src/math/remainder.go:37:21), y ABEND884(unrecognized type float64 at: GO.link/src/math/remainder.go:37:21)) Object {
// 	return _math.Remainder(x, y)
// }

GO FUNC math.Round has:
// func round(x ABEND884(unrecognized type float64 at: GO.link/src/math/floor.go:64:14)) Object {
// 	return _math.Round(x)
// }

GO FUNC math.RoundToEven has:
// func roundToEven(x ABEND884(unrecognized type float64 at: GO.link/src/math/floor.go:101:20)) Object {
// 	return _math.RoundToEven(x)
// }

GO FUNC math.Sin has:
// func sin(x ABEND884(unrecognized type float64 at: GO.link/src/math/sin.go:172:12)) Object {
// 	return _math.Sin(x)
// }

GO FUNC math.Sincos has:
// func sincos(x ABEND884(unrecognized type float64 at: GO.link/src/math/sincos.go:17:15)) Object {
// 	sin, cos := _math.Sincos(x)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC math.Sinh has:
// func sinh(x ABEND884(unrecognized type float64 at: GO.link/src/math/sinh.go:25:13)) Object {
// 	return _math.Sinh(x)
// }

GO FUNC math.Sqrt has:
// func sqrt(x ABEND884(unrecognized type float64 at: GO.link/src/math/sqrt.go:92:13)) Object {
// 	return _math.Sqrt(x)
// }

GO FUNC math.Tan has:
// func tan(x ABEND884(unrecognized type float64 at: GO.link/src/math/tan.go:82:12)) Object {
// 	return _math.Tan(x)
// }

GO FUNC math.Tanh has:
// func tanh(x ABEND884(unrecognized type float64 at: GO.link/src/math/tanh.go:74:13)) Object {
// 	return _math.Tanh(x)
// }

GO FUNC math.Trunc has:
// func trunc(x ABEND884(unrecognized type float64 at: GO.link/src/math/floor.go:48:14)) Object {
// 	return _math.Trunc(x)
// }

GO FUNC math.Y0 has:
// func y0(x ABEND884(unrecognized type float64 at: GO.link/src/math/j0.go:154:11)) Object {
// 	return _math.Y0(x)
// }

GO FUNC math.Y1 has:
// func y1(x ABEND884(unrecognized type float64 at: GO.link/src/math/j1.go:154:11)) Object {
// 	return _math.Y1(x)
// }

GO FUNC math.Yn has:
// func yn(n int, x ABEND884(unrecognized type float64 at: GO.link/src/math/jn.go:233:18)) Object {
// 	return _math.Yn(n, x)
// }

GO FUNC md5.New has:
// func new() Object {
// 	return _md5.New()
// }

GO FUNC md5.Sum has:
// func sum(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/md5/md5.go:204:15)) Object {
// 	res := _md5.Sum(data)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC mime.ExtensionsByType has:
func extensionsByType(typ string) Object {
	res1, res2 := _mime.ExtensionsByType(typ)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC mime.ParseMediaType has:
// func parseMediaType(v string) Object {
// 	mediatype, params, err := _mime.ParseMediaType(v)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeString(mediatype))
// 	res = res.Conjoin(params)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC multipart.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/mime/multipart/multipart.go:99:18), boundary string) Object {
// 	return _multipart.NewReader(r, boundary)
// 	ABEND124(no public information returned)
// }

GO FUNC multipart.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/mime/multipart/writer.go:27:18)) Object {
// 	return _multipart.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC net.CIDRMask has:
func cIDRMask(ones int, bits int) Object {
	res := _net.CIDRMask(ones, bits)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	return vec1
}

GO FUNC net.Dial has:
// func dial(network string, address string) Object {
// 	res1, res2 := _net.Dial(network, address)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.DialIP has:
// func dialIP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/iprawsock.go:211:42), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/iprawsock.go:211:42)) Object {
// 	_, res2 := _net.DialIP(network, laddr, raddr)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.DialTCP has:
// func dialTCP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/tcpsock.go:206:43), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/tcpsock.go:206:43)) Object {
// 	_, res2 := _net.DialTCP(network, laddr, raddr)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.DialTimeout has:
// func dialTimeout(network string, address string, timeout ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/dial.go:313:51)) Object {
// 	res1, res2 := _net.DialTimeout(network, address, timeout)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.DialUDP has:
// func dialUDP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/udpsock.go:205:43), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/udpsock.go:205:43)) Object {
// 	_, res2 := _net.DialUDP(network, laddr, raddr)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.DialUnix has:
// func dialUnix(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/unixsock.go:200:44), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/unixsock.go:200:44)) Object {
// 	_, res2 := _net.DialUnix(network, laddr, raddr)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.FileConn has:
// func fileConn(f ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/file.go:21:17)) Object {
// 	c, err := _net.FileConn(f)
// 	res := EmptyVector
// 	res = res.Conjoin(c)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC net.FileListener has:
// func fileListener(f ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/file.go:33:21)) Object {
// 	ln, err := _net.FileListener(f)
// 	res := EmptyVector
// 	res = res.Conjoin(ln)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC net.FilePacketConn has:
// func filePacketConn(f ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/file.go:45:23)) Object {
// 	c, err := _net.FilePacketConn(f)
// 	res := EmptyVector
// 	res = res.Conjoin(c)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC net.IPv4 has:
func iPv4(a byte, b byte, c byte, d byte) Object {
	res := _net.IPv4(a, b, c, d)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	return vec1
}

GO FUNC net.IPv4Mask has:
func iPv4Mask(a byte, b byte, c byte, d byte) Object {
	res := _net.IPv4Mask(a, b, c, d)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	return vec1
}

GO FUNC net.InterfaceAddrs has:
// func interfaceAddrs() Object {
// 	res1, res2 := _net.InterfaceAddrs()
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(elem1)
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.InterfaceByIndex has:
func interfaceByIndex(index int) Object {
	res1, res2 := _net.InterfaceByIndex(index)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Index"), MakeInt(int((*res1).Index)))
	map1.Add(MakeKeyword("MTU"), MakeInt(int((*res1).MTU)))
	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
	vec2 := EmptyVector
	for _, elem2 := range (*res1).HardwareAddr {
		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
	}
	map1.Add(MakeKeyword("HardwareAddr"), vec2)
	map1.Add(MakeKeyword("Flags"), MakeInt(int((*res1).Flags)))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.InterfaceByName has:
func interfaceByName(name string) Object {
	res1, res2 := _net.InterfaceByName(name)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Index"), MakeInt(int((*res1).Index)))
	map1.Add(MakeKeyword("MTU"), MakeInt(int((*res1).MTU)))
	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
	vec2 := EmptyVector
	for _, elem2 := range (*res1).HardwareAddr {
		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
	}
	map1.Add(MakeKeyword("HardwareAddr"), vec2)
	map1.Add(MakeKeyword("Flags"), MakeInt(int((*res1).Flags)))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.Interfaces has:
func interfaces() Object {
	res1, res2 := _net.Interfaces()
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		map2 := EmptyArrayMap()
		map2.Add(MakeKeyword("Index"), MakeInt(int(elem1.Index)))
		map2.Add(MakeKeyword("MTU"), MakeInt(int(elem1.MTU)))
		map2.Add(MakeKeyword("Name"), MakeString(elem1.Name))
		vec3 := EmptyVector
		for _, elem3 := range elem1.HardwareAddr {
			vec3 = vec3.Conjoin(MakeInt(int(elem3)))
		}
		map2.Add(MakeKeyword("HardwareAddr"), vec3)
		map2.Add(MakeKeyword("Flags"), MakeInt(int(elem1.Flags)))
		vec1 = vec1.Conjoin(map2)
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.Listen has:
// func listen(network string, address string) Object {
// 	res1, res2 := _net.Listen(network, address)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.ListenIP has:
// func listenIP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/iprawsock.go:230:37)) Object {
// 	_, res2 := _net.ListenIP(network, laddr)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.ListenMulticastUDP has:
// func listenMulticastUDP(network string, ifi ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/udpsock.go:265:45), gaddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/udpsock.go:265:63)) Object {
// 	_, res2 := _net.ListenMulticastUDP(network, ifi, gaddr)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.ListenPacket has:
// func listenPacket(network string, address string) Object {
// 	res1, res2 := _net.ListenPacket(network, address)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.ListenTCP has:
// func listenTCP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/tcpsock.go:323:38)) Object {
// 	_, res2 := _net.ListenTCP(network, laddr)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.ListenUDP has:
// func listenUDP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/udpsock.go:231:38)) Object {
// 	_, res2 := _net.ListenUDP(network, laddr)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.ListenUnix has:
// func listenUnix(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/unixsock.go:314:39)) Object {
// 	_, res2 := _net.ListenUnix(network, laddr)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.ListenUnixgram has:
// func listenUnixgram(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/unixsock.go:334:43)) Object {
// 	_, res2 := _net.ListenUnixgram(network, laddr)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC net.LookupAddr has:
func lookupAddr(addr string) Object {
	names, err := _net.LookupAddr(addr)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range names {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC net.LookupCNAME has:
func lookupCNAME(host string) Object {
	cname, err := _net.LookupCNAME(host)
	res := EmptyVector
	res = res.Conjoin(MakeString(cname))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC net.LookupHost has:
func lookupHost(host string) Object {
	addrs, err := _net.LookupHost(host)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range addrs {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC net.LookupIP has:
func lookupIP(host string) Object {
	res1, res2 := _net.LookupIP(host)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		vec2 := EmptyVector
		for _, elem2 := range elem1 {
			vec2 = vec2.Conjoin(MakeInt(int(elem2)))
		}
		vec1 = vec1.Conjoin(vec2)
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.LookupMX has:
func lookupMX(name string) Object {
	res1, res2 := _net.LookupMX(name)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		map2 := EmptyArrayMap()
		map2.Add(MakeKeyword("Host"), MakeString((*elem1).Host))
		map2.Add(MakeKeyword("Pref"), MakeInt(int((*elem1).Pref)))
		vec1 = vec1.Conjoin(map2)
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.LookupNS has:
func lookupNS(name string) Object {
	res1, res2 := _net.LookupNS(name)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		map2 := EmptyArrayMap()
		map2.Add(MakeKeyword("Host"), MakeString((*elem1).Host))
		vec1 = vec1.Conjoin(map2)
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.LookupPort has:
func lookupPort(network string, service string) Object {
	port, err := _net.LookupPort(network, service)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(port)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC net.LookupSRV has:
func lookupSRV(service string, proto string, name string) Object {
	cname, addrs, err := _net.LookupSRV(service, proto, name)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range addrs {
		map2 := EmptyArrayMap()
		map2.Add(MakeKeyword("Target"), MakeString((*elem1).Target))
		map2.Add(MakeKeyword("Port"), MakeInt(int((*elem1).Port)))
		map2.Add(MakeKeyword("Priority"), MakeInt(int((*elem1).Priority)))
		map2.Add(MakeKeyword("Weight"), MakeInt(int((*elem1).Weight)))
		vec1 = vec1.Conjoin(map2)
	}
	res = res.Conjoin(MakeString(cname))
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC net.LookupTXT has:
func lookupTXT(name string) Object {
	res1, res2 := _net.LookupTXT(name)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.ParseCIDR has:
func parseCIDR(s string) Object {
	res1, res2, res3 := _net.ParseCIDR(s)
	res := EmptyVector
	map2 := EmptyArrayMap()
	vec3 := EmptyVector
	for _, elem3 := range (*res2).IP {
		vec3 = vec3.Conjoin(MakeInt(int(elem3)))
	}
	map2.Add(MakeKeyword("IP"), vec3)
	vec4 := EmptyVector
	for _, elem4 := range (*res2).Mask {
		vec4 = vec4.Conjoin(MakeInt(int(elem4)))
	}
	map2.Add(MakeKeyword("Mask"), vec4)
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(map2)
	res = res.Conjoin(func () Object { if (res3) == nil { return NIL } else { return MakeError(res3) } }())
	return res
}

GO FUNC net.ParseIP has:
func parseIP(s string) Object {
	res := _net.ParseIP(s)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	return vec1
}

GO FUNC net.ParseMAC has:
func parseMAC(s string) Object {
	hw, err := _net.ParseMAC(s)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range hw {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC net.Pipe has:
// func pipe() Object {
// 	res1, res2 := _net.Pipe()
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(res2)
// 	return res
// }

GO FUNC net.ResolveIPAddr has:
func resolveIPAddr(network string, address string) Object {
	res1, res2 := _net.ResolveIPAddr(network, address)
	res := EmptyVector
	map1 := EmptyArrayMap()
	vec2 := EmptyVector
	for _, elem2 := range (*res1).IP {
		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
	}
	map1.Add(MakeKeyword("IP"), vec2)
	map1.Add(MakeKeyword("Zone"), MakeString((*res1).Zone))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.ResolveTCPAddr has:
func resolveTCPAddr(network string, address string) Object {
	res1, res2 := _net.ResolveTCPAddr(network, address)
	res := EmptyVector
	map1 := EmptyArrayMap()
	vec2 := EmptyVector
	for _, elem2 := range (*res1).IP {
		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
	}
	map1.Add(MakeKeyword("IP"), vec2)
	map1.Add(MakeKeyword("Port"), MakeInt(int((*res1).Port)))
	map1.Add(MakeKeyword("Zone"), MakeString((*res1).Zone))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.ResolveUDPAddr has:
func resolveUDPAddr(network string, address string) Object {
	res1, res2 := _net.ResolveUDPAddr(network, address)
	res := EmptyVector
	map1 := EmptyArrayMap()
	vec2 := EmptyVector
	for _, elem2 := range (*res1).IP {
		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
	}
	map1.Add(MakeKeyword("IP"), vec2)
	map1.Add(MakeKeyword("Port"), MakeInt(int((*res1).Port)))
	map1.Add(MakeKeyword("Zone"), MakeString((*res1).Zone))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.ResolveUnixAddr has:
func resolveUnixAddr(network string, address string) Object {
	res1, res2 := _net.ResolveUnixAddr(network, address)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
	map1.Add(MakeKeyword("Net"), MakeString((*res1).Net))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC net.SplitHostPort has:
func splitHostPort(hostport string) Object {
	host, port, err := _net.SplitHostPort(hostport)
	res := EmptyVector
	res = res.Conjoin(MakeString(host))
	res = res.Conjoin(MakeString(port))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC os.Clearenv has:
// func clearenv() Object {
// 	_os.Clearenv()
// 	...ABEND675: TODO...
// }

GO FUNC os.Create has:
func create(name string) Object {
	_, res2 := _os.Create(name)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC os.Environ has:
func environ() Object {
	res := _os.Environ()
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	return vec1
}

GO FUNC os.Executable has:
func executable() Object {
	res1, res2 := _os.Executable()
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC os.Exit has:
// func exit(code int) Object {
// 	_os.Exit(code)
// 	...ABEND675: TODO...
// }

GO FUNC os.FindProcess has:
func findProcess(pid int) Object {
	res1, res2 := _os.FindProcess(pid)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Pid"), MakeInt(int((*res1).Pid)))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC os.Getgroups has:
func getgroups() Object {
	res1, res2 := _os.Getgroups()
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC os.Getwd has:
func getwd() Object {
	dir, err := _os.Getwd()
	res := EmptyVector
	res = res.Conjoin(MakeString(dir))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC os.Hostname has:
func hostname() Object {
	name, err := _os.Hostname()
	res := EmptyVector
	res = res.Conjoin(MakeString(name))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC os.LookupEnv has:
func lookupEnv(key string) Object {
	res1, res2 := _os.LookupEnv(key)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(MakeBool(res2))
	return res
}

GO FUNC os.Lstat has:
// func lstat(name string) Object {
// 	res1, res2 := _os.Lstat(name)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC os.NewFile has:
// func newFile(fd ABEND884(unrecognized type uintptr at: GO.link/src/os/file_unix.go:81:17), name string) Object {
// 	return _os.NewFile(fd, name)
// 	ABEND124(no public information returned)
// }

GO FUNC os.Open has:
func open(name string) Object {
	_, res2 := _os.Open(name)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC os.OpenFile has:
// func openFile(name string, flag int, perm ABEND884(unrecognized type FileMode at: GO.link/src/os/file.go:282:43)) Object {
// 	_, res2 := _os.OpenFile(name, flag, perm)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC os.Pipe has:
func pipe() Object {
	_, _, err := _os.Pipe()
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC os.Readlink has:
func readlink(name string) Object {
	res1, res2 := _os.Readlink(name)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC os.StartProcess has:
// func startProcess(name string, argv ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/os/exec.go:100:37), attr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/os/exec.go:100:52)) Object {
// 	res1, res2 := _os.StartProcess(name, argv, attr)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Pid"), MakeInt(int((*res1).Pid)))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC os.Stat has:
// func stat(name string) Object {
// 	res1, res2 := _os.Stat(name)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC os.UserCacheDir has:
func userCacheDir() Object {
	res1, res2 := _os.UserCacheDir()
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC parse.New has:
// func new(name string, funcs ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/text/template/parse/parse.go:125:29)) Object {
// 	res := _parse.New(name, funcs)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Name"), MakeString((*res).Name))
// 	map1.Add(MakeKeyword("ParseName"), MakeString((*res).ParseName))
// 	map2 := EmptyArrayMap()
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*(*res).Root).Nodes {
// 		vec3 = vec3.Conjoin(elem3)
// 	}
// 	map2.Add(MakeKeyword("Nodes"), vec3)
// 	map1.Add(MakeKeyword("Root"), map2)
// 	return map1
// }

GO FUNC parse.NewIdentifier has:
func newIdentifier(ident string) Object {
	res := _parse.NewIdentifier(ident)
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Ident"), MakeString((*res).Ident))
	return map1
}

GO FUNC parse.Parse has:
// func parse(name string, text string, leftDelim string, rightDelim string, funcs ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/text/template/parse/parse.go:51:60)) Object {
// 	res1, res2 := _parse.Parse(name, text, leftDelim, rightDelim, funcs)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC parser.ParseDir has:
// func parseDir(fset ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/parser/interface.go:135:20), path string, filter ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/go/parser/interface.go:135:56), mode ABEND884(unrecognized type Mode at: GO.link/src/go/parser/interface.go:135:85)) Object {
// 	pkgs, first := _parser.ParseDir(fset, path, filter, mode)
// 	res := EmptyVector
// 	res = res.Conjoin(pkgs)
// 	res = res.Conjoin(func () Object { if (first) == nil { return NIL } else { return MakeError(first) } }())
// 	return res
// }

GO FUNC parser.ParseExpr has:
// func parseExpr(x string) Object {
// 	res1, res2 := _parser.ParseExpr(x)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC parser.ParseExprFrom has:
// func parseExprFrom(fset ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/parser/interface.go:176:25), filename string, src ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/parser/interface.go:176:62), mode ABEND884(unrecognized type Mode at: GO.link/src/go/parser/interface.go:176:80)) Object {
// 	res1, res2 := _parser.ParseExprFrom(fset, filename, src, mode)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC parser.ParseFile has:
// func parseFile(fset ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/parser/interface.go:80:21), filename string, src ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/parser/interface.go:80:58), mode ABEND884(unrecognized type Mode at: GO.link/src/go/parser/interface.go:80:76)) Object {
// 	f, err := _parser.ParseFile(fset, filename, src, mode)
// 	res := EmptyVector
// 	res = res.Conjoin((*f))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC path.Match has:
func match(pattern string, name string) Object {
	matched, err := _path.Match(pattern, name)
	res := EmptyVector
	res = res.Conjoin(MakeBool(matched))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC path.Split has:
func split(path string) Object {
	dir, file := _path.Split(path)
	res := EmptyVector
	res = res.Conjoin(MakeString(dir))
	res = res.Conjoin(MakeString(file))
	return res
}

GO FUNC pe.NewFile has:
// func newFile(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/pe/file.go:69:16)) Object {
// 	res1, res2 := _pe.NewFile(r)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("OptionalHeader"), (*res1).OptionalHeader)
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Sections {
// 		map3 := EmptyArrayMap()
// 		vec4 := EmptyVector
// 		for _, elem4 := range (*elem2).Relocs {
// 			map5 := EmptyArrayMap()
// 			map5.Add(MakeKeyword("VirtualAddress"), MakeInt(int(elem4.VirtualAddress)))
// 			map5.Add(MakeKeyword("SymbolTableIndex"), MakeInt(int(elem4.SymbolTableIndex)))
// 			map5.Add(MakeKeyword("Type"), MakeInt(int(elem4.Type)))
// 			vec4 = vec4.Conjoin(map5)
// 		}
// 		map3.Add(MakeKeyword("Relocs"), vec4)
// 		vec2 = vec2.Conjoin(map3)
// 	}
// 	map1.Add(MakeKeyword("Sections"), vec2)
// 	vec6 := EmptyVector
// 	for _, elem6 := range (*res1).Symbols {
// 		map7 := EmptyArrayMap()
// 		map7.Add(MakeKeyword("Name"), MakeString((*elem6).Name))
// 		map7.Add(MakeKeyword("Value"), MakeInt(int((*elem6).Value)))
// 		map7.Add(MakeKeyword("SectionNumber"), MakeInt(int((*elem6).SectionNumber)))
// 		map7.Add(MakeKeyword("Type"), MakeInt(int((*elem6).Type)))
// 		map7.Add(MakeKeyword("StorageClass"), )
// 		vec6 = vec6.Conjoin(map7)
// 	}
// 	map1.Add(MakeKeyword("Symbols"), vec6)
// 	vec8 := EmptyVector
// 	for _, elem8 := range (*res1).COFFSymbols {
// 		map9 := EmptyArrayMap()
// 		vec10 := EmptyVector
// 		for _, elem10 := range elem8.Name {
// 			vec10 = vec10.Conjoin()
// 		}
// 		map9.Add(MakeKeyword("Name"), vec10)
// 		map9.Add(MakeKeyword("Value"), MakeInt(int(elem8.Value)))
// 		map9.Add(MakeKeyword("SectionNumber"), MakeInt(int(elem8.SectionNumber)))
// 		map9.Add(MakeKeyword("Type"), MakeInt(int(elem8.Type)))
// 		map9.Add(MakeKeyword("StorageClass"), )
// 		map9.Add(MakeKeyword("NumberOfAuxSymbols"), )
// 		vec8 = vec8.Conjoin(map9)
// 	}
// 	map1.Add(MakeKeyword("COFFSymbols"), vec8)
// 	vec11 := EmptyVector
// 	for _, elem11 := range (*res1).StringTable {
// 		vec11 = vec11.Conjoin(MakeInt(int(elem11)))
// 	}
// 	map1.Add(MakeKeyword("StringTable"), vec11)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC pe.Open has:
// func open(name string) Object {
// 	res1, res2 := _pe.Open(name)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("OptionalHeader"), (*res1).OptionalHeader)
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Sections {
// 		map3 := EmptyArrayMap()
// 		vec4 := EmptyVector
// 		for _, elem4 := range (*elem2).Relocs {
// 			map5 := EmptyArrayMap()
// 			map5.Add(MakeKeyword("VirtualAddress"), MakeInt(int(elem4.VirtualAddress)))
// 			map5.Add(MakeKeyword("SymbolTableIndex"), MakeInt(int(elem4.SymbolTableIndex)))
// 			map5.Add(MakeKeyword("Type"), MakeInt(int(elem4.Type)))
// 			vec4 = vec4.Conjoin(map5)
// 		}
// 		map3.Add(MakeKeyword("Relocs"), vec4)
// 		vec2 = vec2.Conjoin(map3)
// 	}
// 	map1.Add(MakeKeyword("Sections"), vec2)
// 	vec6 := EmptyVector
// 	for _, elem6 := range (*res1).Symbols {
// 		map7 := EmptyArrayMap()
// 		map7.Add(MakeKeyword("Name"), MakeString((*elem6).Name))
// 		map7.Add(MakeKeyword("Value"), MakeInt(int((*elem6).Value)))
// 		map7.Add(MakeKeyword("SectionNumber"), MakeInt(int((*elem6).SectionNumber)))
// 		map7.Add(MakeKeyword("Type"), MakeInt(int((*elem6).Type)))
// 		map7.Add(MakeKeyword("StorageClass"), )
// 		vec6 = vec6.Conjoin(map7)
// 	}
// 	map1.Add(MakeKeyword("Symbols"), vec6)
// 	vec8 := EmptyVector
// 	for _, elem8 := range (*res1).COFFSymbols {
// 		map9 := EmptyArrayMap()
// 		vec10 := EmptyVector
// 		for _, elem10 := range elem8.Name {
// 			vec10 = vec10.Conjoin()
// 		}
// 		map9.Add(MakeKeyword("Name"), vec10)
// 		map9.Add(MakeKeyword("Value"), MakeInt(int(elem8.Value)))
// 		map9.Add(MakeKeyword("SectionNumber"), MakeInt(int(elem8.SectionNumber)))
// 		map9.Add(MakeKeyword("Type"), MakeInt(int(elem8.Type)))
// 		map9.Add(MakeKeyword("StorageClass"), )
// 		map9.Add(MakeKeyword("NumberOfAuxSymbols"), )
// 		vec8 = vec8.Conjoin(map9)
// 	}
// 	map1.Add(MakeKeyword("COFFSymbols"), vec8)
// 	vec11 := EmptyVector
// 	for _, elem11 := range (*res1).StringTable {
// 		vec11 = vec11.Conjoin(MakeInt(int(elem11)))
// 	}
// 	map1.Add(MakeKeyword("StringTable"), vec11)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC pem.Decode has:
// func decode(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/pem/pem.go:78:18)) Object {
// 	p, rest := _pem.Decode(data)
// 	res := EmptyVector
// 	vec3 := EmptyVector
// 	for _, elem3 := range rest {
// 		vec3 = vec3.Conjoin(MakeInt(int(elem3)))
// 	}
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Type"), MakeString((*p).Type))
// 	map1.Add(MakeKeyword("Headers"), (*p).Headers)
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*p).Bytes {
// 		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 	}
// 	map1.Add(MakeKeyword("Bytes"), vec2)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(vec3)
// 	return res
// }

GO FUNC pem.EncodeToMemory has:
// func encodeToMemory(b ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/encoding/pem/pem.go:326:23)) Object {
// 	res := _pem.EncodeToMemory(b)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC plan9obj.NewFile has:
// func newFile(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/debug/plan9obj/file.go:135:16)) Object {
// 	res1, res2 := _plan9obj.NewFile(r)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Sections {
// 		vec2 = vec2.Conjoin(NIL)
// 	}
// 	map1.Add(MakeKeyword("Sections"), vec2)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC plan9obj.Open has:
func open(name string) Object {
	res1, res2 := _plan9obj.Open(name)
	res := EmptyVector
	map1 := EmptyArrayMap()
	vec2 := EmptyVector
	for _, elem2 := range (*res1).Sections {
		vec2 = vec2.Conjoin(NIL)
	}
	map1.Add(MakeKeyword("Sections"), vec2)
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC plugin.Open has:
func open(path string) Object {
	_, res2 := _plugin.Open(path)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC png.Decode has:
// func decode(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/png/reader.go:952:15)) Object {
// 	res1, res2 := _png.Decode(r)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC png.DecodeConfig has:
// func decodeConfig(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/image/png/reader.go:976:21)) Object {
// 	res1, res2 := _png.DecodeConfig(r)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC pprof.Cmdline has:
// func cmdline(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:83:16), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/pprof/pprof.go:83:39)) Object {
// 	_pprof.Cmdline(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC pprof.Handler has:
// func handler(name string) Object {
// 	return _pprof.Handler(name)
// }

GO FUNC pprof.Index has:
// func index(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:264:14), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/pprof/pprof.go:264:37)) Object {
// 	_pprof.Index(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC pprof.Profile has:
// func profile(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:116:16), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/pprof/pprof.go:116:39)) Object {
// 	_pprof.Profile(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC pprof.Symbol has:
// func symbol(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:174:15), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/pprof/pprof.go:174:38)) Object {
// 	_pprof.Symbol(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC pprof.Trace has:
// func trace(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/http/pprof/pprof.go:145:14), r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/http/pprof/pprof.go:145:37)) Object {
// 	_pprof.Trace(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC pprof.Do has:
// func do(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/runtime.go:31:13), labels ABEND884(unrecognized type LabelSet at: GO.link/src/runtime/pprof/runtime.go:31:37), f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/runtime/pprof/runtime.go:31:49)) Object {
// 	_pprof.Do(ctx, labels, f)
// 	...ABEND675: TODO...
// }

GO FUNC pprof.ForLabels has:
// func forLabels(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/label.go:78:20), f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/runtime/pprof/label.go:78:39)) Object {
// 	_pprof.ForLabels(ctx, f)
// 	...ABEND675: TODO...
// }

GO FUNC pprof.Label has:
// func label(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/label.go:70:16), key string) Object {
// 	res1, res2 := _pprof.Label(ctx, key)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeString(res1))
// 	res = res.Conjoin(MakeBool(res2))
// 	return res
// }

GO FUNC pprof.Labels has:
// func labels(args ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/runtime/pprof/label.go:57:18)) Object {
// 	return _pprof.Labels(args)
// 	ABEND124(no public information returned)
// }

GO FUNC pprof.Lookup has:
// func lookup(name string) Object {
// 	return _pprof.Lookup(name)
// 	ABEND124(no public information returned)
// }

GO FUNC pprof.NewProfile has:
// func newProfile(name string) Object {
// 	return _pprof.NewProfile(name)
// 	ABEND124(no public information returned)
// }

GO FUNC pprof.Profiles has:
func profiles() Object {
	res := _pprof.Profiles()
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(NIL)
	}
	return vec1
}

GO FUNC pprof.SetGoroutineLabels has:
// func setGoroutineLabels(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/runtime.go:20:29)) Object {
// 	_pprof.SetGoroutineLabels(ctx)
// 	...ABEND675: TODO...
// }

GO FUNC pprof.StopCPUProfile has:
// func stopCPUProfile() Object {
// 	_pprof.StopCPUProfile()
// 	...ABEND675: TODO...
// }

GO FUNC pprof.WithLabels has:
// func withLabels(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/pprof/label.go:39:21), labels ABEND884(unrecognized type LabelSet at: GO.link/src/runtime/pprof/label.go:39:45)) Object {
// 	return _pprof.WithLabels(ctx, labels)
// }

GO FUNC quick.Value has:
// func value(t ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/testing/quick/quick.go:59:14), rand ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/testing/quick/quick.go:59:33)) Object {
// 	value, ok := _quick.Value(t, rand)
// 	res := EmptyVector
// 	res = res.Conjoin(value)
// 	res = res.Conjoin(MakeBool(ok))
// 	return res
// }

GO FUNC quotedprintable.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/mime/quotedprintable/reader.go:24:18)) Object {
// 	return _quotedprintable.NewReader(r)
// 	ABEND124(no public information returned)
// }

GO FUNC quotedprintable.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/mime/quotedprintable/writer.go:24:18)) Object {
// 	res := _quotedprintable.NewWriter(w)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Binary"), MakeBool((*res).Binary))
// 	return map1
// }

GO FUNC rand.Int has:
// func int(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rand/util.go:106:15), max ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rand/util.go:106:30)) Object {
// 	n, err := _rand.Int(rand, max)
// 	res := EmptyVector
// 	res = res.Conjoin((*n))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC rand.Prime has:
// func prime(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rand/util.go:31:17), bits int) Object {
// 	p, err := _rand.Prime(rand, bits)
// 	res := EmptyVector
// 	res = res.Conjoin((*p))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC rand.Read has:
// func read(b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rand/rand.go:23:13)) Object {
// 	n, err := _rand.Read(b)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC rand.ExpFloat64 has:
// func expFloat64() Object {
// 	return _rand.ExpFloat64()
// }

GO FUNC rand.Float32 has:
// func float32() Object {
// 	return _rand.Float32()
// }

GO FUNC rand.Float64 has:
// func float64() Object {
// 	return _rand.Float64()
// }

GO FUNC rand.New has:
// func new(src ABEND884(unrecognized type Source at: GO.link/src/math/rand/rand.go:67:14)) Object {
// 	return _rand.New(src)
// 	ABEND124(no public information returned)
// }

GO FUNC rand.NewSource has:
// func newSource(seed int64) Object {
// 	return _rand.NewSource(seed)
// }

GO FUNC rand.NewZipf has:
// func newZipf(r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/math/rand/zipf.go:39:16), s ABEND884(unrecognized type float64 at: GO.link/src/math/rand/zipf.go:39:25), v ABEND884(unrecognized type float64 at: GO.link/src/math/rand/zipf.go:39:36), imax ABEND884(unrecognized type uint64 at: GO.link/src/math/rand/zipf.go:39:50)) Object {
// 	return _rand.NewZipf(r, s, v, imax)
// 	ABEND124(no public information returned)
// }

GO FUNC rand.NormFloat64 has:
// func normFloat64() Object {
// 	return _rand.NormFloat64()
// }

GO FUNC rand.Perm has:
func perm(n int) Object {
	res := _rand.Perm(n)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	return vec1
}

GO FUNC rand.Read has:
// func read(p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/math/rand/rand.go:351:13)) Object {
// 	n, err := _rand.Read(p)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC rand.Seed has:
// func seed(seed int64) Object {
// 	_rand.Seed(seed)
// 	...ABEND675: TODO...
// }

GO FUNC rand.Shuffle has:
// func shuffle(n int, swap ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/math/rand/rand.go:346:26)) Object {
// 	_rand.Shuffle(n, swap)
// 	...ABEND675: TODO...
// }

GO FUNC rand.Uint64 has:
// func uint64() Object {
// 	return _rand.Uint64()
// }

GO FUNC rc4.NewCipher has:
// func newCipher(key ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rc4/rc4.go:31:20)) Object {
// 	_, res2 := _rc4.NewCipher(key)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC reflect.Append has:
// func append(s ABEND884(unrecognized type Value at: GO.link/src/reflect/value.go:1890:15), x ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/reflect/value.go:1890:24)) Object {
// 	return _reflect.Append(s, x)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.AppendSlice has:
// func appendSlice(s ABEND884(unrecognized type Value at: GO.link/src/reflect/value.go:1901:23), t ABEND884(unrecognized type Value at: GO.link/src/reflect/value.go:1901:23)) Object {
// 	return _reflect.AppendSlice(s, t)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.ArrayOf has:
// func arrayOf(count int, elem ABEND884(unrecognized type Type at: GO.link/src/reflect/type.go:2836:30)) Object {
// 	return _reflect.ArrayOf(count, elem)
// }

GO FUNC reflect.ChanOf has:
// func chanOf(dir ABEND884(unrecognized type ChanDir at: GO.link/src/reflect/type.go:1779:17), t ABEND884(unrecognized type Type at: GO.link/src/reflect/type.go:1779:28)) Object {
// 	return _reflect.ChanOf(dir, t)
// }

GO FUNC reflect.FuncOf has:
// func funcOf(in ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/reflect/type.go:1924:21), out ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/reflect/type.go:1924:21), variadic bool) Object {
// 	return _reflect.FuncOf(in, out, variadic)
// }

GO FUNC reflect.Indirect has:
// func indirect(v ABEND884(unrecognized type Value at: GO.link/src/reflect/value.go:2173:17)) Object {
// 	return _reflect.Indirect(v)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MakeChan has:
// func makeChan(typ ABEND884(unrecognized type Type at: GO.link/src/reflect/value.go:2139:19), buffer int) Object {
// 	return _reflect.MakeChan(typ, buffer)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MakeFunc has:
// func makeFunc(typ ABEND884(unrecognized type Type at: GO.link/src/reflect/makefunc.go:48:19), fn ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/reflect/makefunc.go:48:28)) Object {
// 	return _reflect.MakeFunc(typ, fn)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MakeMap has:
// func makeMap(typ ABEND884(unrecognized type Type at: GO.link/src/reflect/value.go:2155:18)) Object {
// 	return _reflect.MakeMap(typ)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MakeMapWithSize has:
// func makeMapWithSize(typ ABEND884(unrecognized type Type at: GO.link/src/reflect/value.go:2161:26), n int) Object {
// 	return _reflect.MakeMapWithSize(typ, n)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MakeSlice has:
// func makeSlice(typ ABEND884(unrecognized type Type at: GO.link/src/reflect/value.go:2120:20), len int, cap int) Object {
// 	return _reflect.MakeSlice(typ, len, cap)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MapOf has:
// func mapOf(key ABEND884(unrecognized type Type at: GO.link/src/reflect/type.go:1836:22), elem ABEND884(unrecognized type Type at: GO.link/src/reflect/type.go:1836:22)) Object {
// 	return _reflect.MapOf(key, elem)
// }

GO FUNC reflect.New has:
// func new(typ ABEND884(unrecognized type Type at: GO.link/src/reflect/value.go:2215:14)) Object {
// 	return _reflect.New(typ)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.NewAt has:
// func newAt(typ ABEND884(unrecognized type Type at: GO.link/src/reflect/value.go:2227:16), p ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/reflect/value.go:2227:24)) Object {
// 	return _reflect.NewAt(typ, p)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.PtrTo has:
// func ptrTo(t ABEND884(unrecognized type Type at: GO.link/src/reflect/type.go:1386:14)) Object {
// 	return _reflect.PtrTo(t)
// }

GO FUNC reflect.Select has:
// func select(cases ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/reflect/value.go:2025:19)) Object {
// 	chosen, _, recvOK := _reflect.Select(cases)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(chosen)))
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(MakeBool(recvOK))
// 	return res
// }

GO FUNC reflect.SliceOf has:
// func sliceOf(t ABEND884(unrecognized type Type at: GO.link/src/reflect/type.go:2232:16)) Object {
// 	return _reflect.SliceOf(t)
// }

GO FUNC reflect.StructOf has:
// func structOf(fields ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/reflect/type.go:2349:22)) Object {
// 	return _reflect.StructOf(fields)
// }

GO FUNC reflect.Swapper has:
// func swapper(slice ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/swapper.go:13:20)) Object {
// 	return _reflect.Swapper(slice)
// }

GO FUNC reflect.TypeOf has:
// func typeOf(i ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:1376:15)) Object {
// 	return _reflect.TypeOf(i)
// }

GO FUNC reflect.ValueOf has:
// func valueOf(i ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/value.go:2182:16)) Object {
// 	return _reflect.ValueOf(i)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.Zero has:
// func zero(typ ABEND884(unrecognized type Type at: GO.link/src/reflect/value.go:2201:15)) Object {
// 	return _reflect.Zero(typ)
// 	ABEND124(no public information returned)
// }

GO FUNC regexp.Compile has:
func compile(expr string) Object {
	_, res2 := _regexp.Compile(expr)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC regexp.CompilePOSIX has:
func compilePOSIX(expr string) Object {
	_, res2 := _regexp.CompilePOSIX(expr)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC regexp.Match has:
// func match(pattern string, b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/regexp/regexp.go:475:30)) Object {
// 	matched, err := _regexp.Match(pattern, b)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeBool(matched))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC regexp.MatchReader has:
// func matchReader(pattern string, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/regexp/regexp.go:453:36)) Object {
// 	matched, err := _regexp.MatchReader(pattern, r)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeBool(matched))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC regexp.MatchString has:
func matchString(pattern string, s string) Object {
	matched, err := _regexp.MatchString(pattern, s)
	res := EmptyVector
	res = res.Conjoin(MakeBool(matched))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC regexp.MustCompile has:
// func mustCompile(str string) Object {
// 	return _regexp.MustCompile(str)
// 	ABEND124(no public information returned)
// }

GO FUNC regexp.MustCompilePOSIX has:
// func mustCompilePOSIX(str string) Object {
// 	return _regexp.MustCompilePOSIX(str)
// 	ABEND124(no public information returned)
// }

GO FUNC ring.New has:
// func new(n int) Object {
// 	res := _ring.New(n)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Value"), (*res).Value)
// 	return map1
// }

GO FUNC rpc.Accept has:
// func accept(lis ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/server.go:692:17)) Object {
// 	_rpc.Accept(lis)
// 	...ABEND675: TODO...
// }

GO FUNC rpc.Dial has:
func dial(network string, address string) Object {
	_, res2 := _rpc.Dial(network, address)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC rpc.DialHTTP has:
func dialHTTP(network string, address string) Object {
	_, res2 := _rpc.DialHTTP(network, address)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC rpc.DialHTTPPath has:
func dialHTTPPath(network string, address string, path string) Object {
	_, res2 := _rpc.DialHTTPPath(network, address, path)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC rpc.HandleHTTP has:
// func handleHTTP() Object {
// 	_rpc.HandleHTTP()
// 	...ABEND675: TODO...
// }

GO FUNC rpc.NewClient has:
// func newClient(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/client.go:193:21)) Object {
// 	return _rpc.NewClient(conn)
// 	ABEND124(no public information returned)
// }

GO FUNC rpc.NewClientWithCodec has:
// func newClientWithCodec(codec ABEND884(unrecognized type ClientCodec at: GO.link/src/net/rpc/client.go:201:31)) Object {
// 	return _rpc.NewClientWithCodec(codec)
// 	ABEND124(no public information returned)
// }

GO FUNC rpc.NewServer has:
// func newServer() Object {
// 	return _rpc.NewServer()
// 	ABEND124(no public information returned)
// }

GO FUNC rpc.ServeCodec has:
// func serveCodec(codec ABEND884(unrecognized type ServerCodec at: GO.link/src/net/rpc/server.go:679:23)) Object {
// 	_rpc.ServeCodec(codec)
// 	...ABEND675: TODO...
// }

GO FUNC rpc.ServeConn has:
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/rpc/server.go:673:21)) Object {
// 	_rpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO FUNC rsa.DecryptOAEP has:
// func decryptOAEP(hash ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:569:23), random ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:569:41), priv ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/rsa.go:569:57), ciphertext ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/rsa.go:569:81), label ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/rsa.go:569:95)) Object {
// 	res1, res2 := _rsa.DecryptOAEP(hash, random, priv, ciphertext, label)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC rsa.DecryptPKCS1v15 has:
// func decryptPKCS1v15(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:76:27), priv ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:76:43), ciphertext ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pkcs1v15.go:76:67)) Object {
// 	res1, res2 := _rsa.DecryptPKCS1v15(rand, priv, ciphertext)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC rsa.EncryptOAEP has:
// func encryptOAEP(hash ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:376:23), random ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:376:41), pub ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/rsa.go:376:56), msg ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/rsa.go:376:72), label ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/rsa.go:376:86)) Object {
// 	res1, res2 := _rsa.EncryptOAEP(hash, random, pub, msg, label)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC rsa.EncryptPKCS1v15 has:
// func encryptPKCS1v15(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:39:27), pub ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:39:42), msg ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pkcs1v15.go:39:58)) Object {
// 	res1, res2 := _rsa.EncryptPKCS1v15(rand, pub, msg)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC rsa.GenerateKey has:
// func generateKey(random ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:207:25), bits int) Object {
// 	res1, res2 := _rsa.GenerateKey(random, bits)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("D"), (*(*res1).D))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Primes {
// 		vec2 = vec2.Conjoin((*elem2))
// 	}
// 	map1.Add(MakeKeyword("Primes"), vec2)
// 	map3 := EmptyArrayMap()
// 	map3.Add(MakeKeyword("Dp"), (*(*res1).Precomputed.Dp))
// 	map3.Add(MakeKeyword("Dq"), (*(*res1).Precomputed.Dq))
// 	map3.Add(MakeKeyword("Qinv"), (*(*res1).Precomputed.Qinv))
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res1).Precomputed.CRTValues {
// 		map5 := EmptyArrayMap()
// 		map5.Add(MakeKeyword("Exp"), (*elem4.Exp))
// 		map5.Add(MakeKeyword("Coeff"), (*elem4.Coeff))
// 		map5.Add(MakeKeyword("R"), (*elem4.R))
// 		vec4 = vec4.Conjoin(map5)
// 	}
// 	map3.Add(MakeKeyword("CRTValues"), vec4)
// 	map1.Add(MakeKeyword("Precomputed"), map3)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC rsa.GenerateMultiPrimeKey has:
// func generateMultiPrimeKey(random ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/rsa.go:222:35), nprimes int, bits int) Object {
// 	res1, res2 := _rsa.GenerateMultiPrimeKey(random, nprimes, bits)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("D"), (*(*res1).D))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Primes {
// 		vec2 = vec2.Conjoin((*elem2))
// 	}
// 	map1.Add(MakeKeyword("Primes"), vec2)
// 	map3 := EmptyArrayMap()
// 	map3.Add(MakeKeyword("Dp"), (*(*res1).Precomputed.Dp))
// 	map3.Add(MakeKeyword("Dq"), (*(*res1).Precomputed.Dq))
// 	map3.Add(MakeKeyword("Qinv"), (*(*res1).Precomputed.Qinv))
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res1).Precomputed.CRTValues {
// 		map5 := EmptyArrayMap()
// 		map5.Add(MakeKeyword("Exp"), (*elem4.Exp))
// 		map5.Add(MakeKeyword("Coeff"), (*elem4.Coeff))
// 		map5.Add(MakeKeyword("R"), (*elem4.R))
// 		vec4 = vec4.Conjoin(map5)
// 	}
// 	map3.Add(MakeKeyword("CRTValues"), vec4)
// 	map1.Add(MakeKeyword("Precomputed"), map3)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC rsa.SignPKCS1v15 has:
// func signPKCS1v15(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:232:24), priv ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:232:40), hash ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pkcs1v15.go:232:58), hashed ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pkcs1v15.go:232:78)) Object {
// 	res1, res2 := _rsa.SignPKCS1v15(rand, priv, hash, hashed)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC rsa.SignPSS has:
// func signPSS(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pss.go:249:19), priv ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pss.go:249:35), hash ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/rsa/pss.go:249:53), hashed ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/rsa/pss.go:249:73), opts ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/rsa/pss.go:249:86)) Object {
// 	res1, res2 := _rsa.SignPSS(rand, priv, hash, hashed, opts)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC runtime.BlockProfile has:
// func blockProfile(p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:634:21)) Object {
// 	n, ok := _runtime.BlockProfile(p)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(MakeBool(ok))
// 	return res
// }

GO FUNC runtime.Breakpoint has:
// func breakpoint() Object {
// 	_runtime.Breakpoint()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.CPUProfile has:
func cPUProfile() Object {
	res := _runtime.CPUProfile()
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	return vec1
}

GO FUNC runtime.Caller has:
// func caller(skip int) Object {
// 	pc, file, line, ok := _runtime.Caller(skip)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeString(file))
// 	res = res.Conjoin(MakeInt(int(line)))
// 	res = res.Conjoin(MakeBool(ok))
// 	return res
// }

GO FUNC runtime.CallersFrames has:
// func callersFrames(callers ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/symtab.go:91:28)) Object {
// 	return _runtime.CallersFrames(callers)
// 	ABEND124(no public information returned)
// }

GO FUNC runtime.FuncForPC has:
// func funcForPC(pc ABEND884(unrecognized type uintptr at: GO.link/src/runtime/symtab.go:609:19)) Object {
// 	return _runtime.FuncForPC(pc)
// 	ABEND124(no public information returned)
// }

GO FUNC runtime.GC has:
// func gC() Object {
// 	_runtime.GC()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.Goexit has:
// func goexit() Object {
// 	_runtime.Goexit()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.GoroutineProfile has:
// func goroutineProfile(p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:720:25)) Object {
// 	n, ok := _runtime.GoroutineProfile(p)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(MakeBool(ok))
// 	return res
// }

GO FUNC runtime.Gosched has:
// func gosched() Object {
// 	_runtime.Gosched()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.KeepAlive has:
// func keepAlive(x ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/runtime/mfinal.go:446:18)) Object {
// 	_runtime.KeepAlive(x)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.LockOSThread has:
// func lockOSThread() Object {
// 	_runtime.LockOSThread()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.MemProfile has:
// func memProfile(p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:543:19), inuseZero bool) Object {
// 	n, ok := _runtime.MemProfile(p, inuseZero)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(MakeBool(ok))
// 	return res
// }

GO FUNC runtime.MutexProfile has:
// func mutexProfile(p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:669:21)) Object {
// 	n, ok := _runtime.MutexProfile(p)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(MakeBool(ok))
// 	return res
// }

GO FUNC runtime.ReadMemStats has:
// func readMemStats(m ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/runtime/mstats.go:457:21)) Object {
// 	_runtime.ReadMemStats(m)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.ReadTrace has:
func readTrace() Object {
	res := _runtime.ReadTrace()
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	return vec1
}

GO FUNC runtime.SetBlockProfileRate has:
// func setBlockProfileRate(rate int) Object {
// 	_runtime.SetBlockProfileRate(rate)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetCPUProfileRate has:
// func setCPUProfileRate(hz int) Object {
// 	_runtime.SetCPUProfileRate(hz)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetCgoTraceback has:
// func setCgoTraceback(version int, traceback ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/traceback.go:1198:66), context ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/traceback.go:1198:66), symbolizer ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/traceback.go:1198:66)) Object {
// 	_runtime.SetCgoTraceback(version, traceback, context, symbolizer)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetFinalizer has:
// func setFinalizer(obj ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/runtime/mfinal.go:309:23), finalizer ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/runtime/mfinal.go:309:46)) Object {
// 	_runtime.SetFinalizer(obj, finalizer)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.StopTrace has:
// func stopTrace() Object {
// 	_runtime.StopTrace()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.ThreadCreateProfile has:
// func threadCreateProfile(p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/runtime/mprof.go:698:28)) Object {
// 	n, ok := _runtime.ThreadCreateProfile(p)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(MakeBool(ok))
// 	return res
// }

GO FUNC runtime.UnlockOSThread has:
// func unlockOSThread() Object {
// 	_runtime.UnlockOSThread()
// 	...ABEND675: TODO...
// }

GO FUNC runtime._ExternalCode has:
// func _ExternalCode() Object {
// 	_runtime._ExternalCode()
// 	...ABEND675: TODO...
// }

GO FUNC runtime._GC has:
// func _GC() Object {
// 	_runtime._GC()
// 	...ABEND675: TODO...
// }

GO FUNC runtime._LostExternalCode has:
// func _LostExternalCode() Object {
// 	_runtime._LostExternalCode()
// 	...ABEND675: TODO...
// }

GO FUNC runtime._LostSIGPROFDuringAtomic64 has:
// func _LostSIGPROFDuringAtomic64() Object {
// 	_runtime._LostSIGPROFDuringAtomic64()
// 	...ABEND675: TODO...
// }

GO FUNC runtime._System has:
// func _System() Object {
// 	_runtime._System()
// 	...ABEND675: TODO...
// }

GO FUNC runtime._VDSO has:
// func _VDSO() Object {
// 	_runtime._VDSO()
// 	...ABEND675: TODO...
// }

GO FUNC runtime._cgo_panic_internal has:
// func _cgo_panic_internal(p ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/runtime/cgocallback.go:11:28)) Object {
// 	_runtime._cgo_panic_internal(p)
// 	...ABEND675: TODO...
// }

GO FUNC scanner.PrintError has:
// func printError(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/scanner/errors.go:116:19), err error) Object {
// 	_scanner.PrintError(w, err)
// 	...ABEND675: TODO...
// }

GO FUNC sha1.New has:
// func new() Object {
// 	return _sha1.New()
// }

GO FUNC sha1.Sum has:
// func sum(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha1/sha1.go:260:15)) Object {
// 	res := _sha1.Sum(data)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC sha256.New has:
// func new() Object {
// 	return _sha256.New()
// }

GO FUNC sha256.New224 has:
// func new224() Object {
// 	return _sha256.New224()
// }

GO FUNC sha256.Sum224 has:
// func sum224(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha256/sha256.go:281:18)) Object {
// 	res := _sha256.Sum224(data)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC sha256.Sum256 has:
// func sum256(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha256/sha256.go:273:18)) Object {
// 	res := _sha256.Sum256(data)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC sha512.New has:
// func new() Object {
// 	return _sha512.New()
// }

GO FUNC sha512.New384 has:
// func new384() Object {
// 	return _sha512.New384()
// }

GO FUNC sha512.New512_224 has:
// func new512_224() Object {
// 	return _sha512.New512_224()
// }

GO FUNC sha512.New512_256 has:
// func new512_256() Object {
// 	return _sha512.New512_256()
// }

GO FUNC sha512.Sum384 has:
// func sum384(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha512/sha512.go:351:18)) Object {
// 	res := _sha512.Sum384(data)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC sha512.Sum512 has:
// func sum512(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha512/sha512.go:343:18)) Object {
// 	res := _sha512.Sum512(data)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC sha512.Sum512_224 has:
// func sum512_224(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha512/sha512.go:361:22)) Object {
// 	res := _sha512.Sum512_224(data)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC sha512.Sum512_256 has:
// func sum512_256(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/sha512/sha512.go:371:22)) Object {
// 	res := _sha512.Sum512_256(data)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC signal.Ignore has:
// func ignore(sig ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/os/signal/signal.go:85:17)) Object {
// 	_signal.Ignore(sig)
// 	...ABEND675: TODO...
// }

GO FUNC signal.Notify has:
// func notify(c ABEND882(unrecognized Expr type *ast.ChanType at: GO.link/src/os/signal/signal.go:111:15), sig ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/os/signal/signal.go:111:37)) Object {
// 	_signal.Notify(c, sig)
// 	...ABEND675: TODO...
// }

GO FUNC signal.Reset has:
// func reset(sig ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/os/signal/signal.go:155:16)) Object {
// 	_signal.Reset(sig)
// 	...ABEND675: TODO...
// }

GO FUNC signal.Stop has:
// func stop(c ABEND882(unrecognized Expr type *ast.ChanType at: GO.link/src/os/signal/signal.go:162:13)) Object {
// 	_signal.Stop(c)
// 	...ABEND675: TODO...
// }

GO FUNC smtp.CRAMMD5Auth has:
// func cRAMMD5Auth(username string, secret string) Object {
// 	return _smtp.CRAMMD5Auth(username, secret)
// }

GO FUNC smtp.Dial has:
// func dial(addr string) Object {
// 	res1, res2 := _smtp.Dial(addr)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Text"), (*(*res1).Text))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC smtp.NewClient has:
// func newClient(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/smtp/smtp.go:62:21), host string) Object {
// 	res1, res2 := _smtp.NewClient(conn, host)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Text"), (*(*res1).Text))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC smtp.PlainAuth has:
// func plainAuth(identity string, username string, password string, host string) Object {
// 	return _smtp.PlainAuth(identity, username, password, host)
// }

GO FUNC sort.Float64s has:
// func float64s(a ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/sort.go:311:17)) Object {
// 	_sort.Float64s(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Ints has:
// func ints(a ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/sort.go:307:13)) Object {
// 	_sort.Ints(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Reverse has:
// func reverse(data ABEND884(unrecognized type Interface at: GO.link/src/sort/sort.go:251:19)) Object {
// 	return _sort.Reverse(data)
// }

GO FUNC sort.Slice has:
// func slice(slice ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/sort/slice.go:17:18), less ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/sort/slice.go:17:36)) Object {
// 	_sort.Slice(slice, less)
// 	...ABEND675: TODO...
// }

GO FUNC sort.SliceStable has:
// func sliceStable(slice ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/sort/slice.go:28:24), less ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/sort/slice.go:28:42)) Object {
// 	_sort.SliceStable(slice, less)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Sort has:
// func sort(data ABEND884(unrecognized type Interface at: GO.link/src/sort/sort.go:216:16)) Object {
// 	_sort.Sort(data)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Stable has:
// func stable(data ABEND884(unrecognized type Interface at: GO.link/src/sort/sort.go:356:18)) Object {
// 	_sort.Stable(data)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Strings has:
// func strings(a ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/sort/sort.go:314:16)) Object {
// 	_sort.Strings(a)
// 	...ABEND675: TODO...
// }

GO FUNC sql.Drivers has:
func drivers() Object {
	res := _sql.Drivers()
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	return vec1
}

GO FUNC sql.Named has:
// func named(name string, value ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/database/sql/sql.go:110:31)) Object {
// 	res := _sql.Named(name, value)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("_Named_Fields_Required"), NIL)
// 	map1.Add(MakeKeyword("Name"), MakeString(res.Name))
// 	map1.Add(MakeKeyword("Value"), res.Value)
// 	return map1
// }

GO FUNC sql.Open has:
func open(driverName string, dataSourceName string) Object {
	_, res2 := _sql.Open(driverName, dataSourceName)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC sql.OpenDB has:
// func openDB(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/database/sql/sql.go:660:15)) Object {
// 	return _sql.OpenDB(c)
// 	ABEND124(no public information returned)
// }

GO FUNC sql.Register has:
// func register(name string, driver ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/database/sql/sql.go:44:35)) Object {
// 	_sql.Register(name, driver)
// 	...ABEND675: TODO...
// }

GO FUNC strconv.AppendBool has:
// func appendBool(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/atob.go:30:21), b bool) Object {
// 	res := _strconv.AppendBool(dst, b)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC strconv.AppendFloat has:
// func appendFloat(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/ftoa.go:51:22), f ABEND884(unrecognized type float64 at: GO.link/src/strconv/ftoa.go:51:32), fmt byte, prec int, bitSize int) Object {
// 	res := _strconv.AppendFloat(dst, f, fmt, prec, bitSize)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC strconv.AppendInt has:
// func appendInt(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/itoa.go:40:20), i int64, base int) Object {
// 	res := _strconv.AppendInt(dst, i, base)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC strconv.AppendQuote has:
// func appendQuote(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:117:22), s string) Object {
// 	res := _strconv.AppendQuote(dst, s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC strconv.AppendQuoteRune has:
// func appendQuoteRune(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:156:26), r ABEND884(unrecognized type rune at: GO.link/src/strconv/quote.go:156:36)) Object {
// 	res := _strconv.AppendQuoteRune(dst, r)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC strconv.AppendQuoteRuneToASCII has:
// func appendQuoteRuneToASCII(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:170:33), r ABEND884(unrecognized type rune at: GO.link/src/strconv/quote.go:170:43)) Object {
// 	res := _strconv.AppendQuoteRuneToASCII(dst, r)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC strconv.AppendQuoteRuneToGraphic has:
// func appendQuoteRuneToGraphic(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:184:35), r ABEND884(unrecognized type rune at: GO.link/src/strconv/quote.go:184:45)) Object {
// 	res := _strconv.AppendQuoteRuneToGraphic(dst, r)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC strconv.AppendQuoteToASCII has:
// func appendQuoteToASCII(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:130:29), s string) Object {
// 	res := _strconv.AppendQuoteToASCII(dst, s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC strconv.AppendQuoteToGraphic has:
// func appendQuoteToGraphic(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/quote.go:143:31), s string) Object {
// 	res := _strconv.AppendQuoteToGraphic(dst, s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC strconv.AppendUint has:
// func appendUint(dst ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/strconv/itoa.go:50:21), i ABEND884(unrecognized type uint64 at: GO.link/src/strconv/itoa.go:50:31), base int) Object {
// 	res := _strconv.AppendUint(dst, i, base)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC strconv.Atoi has:
func atoi(s string) Object {
	res1, res2 := _strconv.Atoi(s)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(res1)))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC strconv.ParseBool has:
func parseBool(str string) Object {
	res1, res2 := _strconv.ParseBool(str)
	res := EmptyVector
	res = res.Conjoin(MakeBool(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC strconv.ParseFloat has:
// func parseFloat(s string, bitSize int) Object {
// 	res1, res2 := _strconv.ParseFloat(s, bitSize)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC strconv.ParseInt has:
func parseInt(s string, base int, bitSize int) Object {
	i, err := _strconv.ParseInt(s, base, bitSize)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(i)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC strconv.ParseUint has:
// func parseUint(s string, base int, bitSize int) Object {
// 	res1, res2 := _strconv.ParseUint(s, base, bitSize)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC strconv.Unquote has:
func unquote(s string) Object {
	res1, res2 := _strconv.Unquote(s)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC strconv.UnquoteChar has:
// func unquoteChar(s string, quote byte) Object {
// 	value, multibyte, tail, err := _strconv.UnquoteChar(s, quote)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeBool(multibyte))
// 	res = res.Conjoin(MakeString(tail))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC strings.Fields has:
func fields(s string) Object {
	res := _strings.Fields(s)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	return vec1
}

GO FUNC strings.FieldsFunc has:
// func fieldsFunc(s string, f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/strings/strings.go:378:29)) Object {
// 	res := _strings.FieldsFunc(s, f)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeString(elem1))
// 	}
// 	return vec1
// }

GO FUNC strings.NewReader has:
// func newReader(s string) Object {
// 	return _strings.NewReader(s)
// 	ABEND124(no public information returned)
// }

GO FUNC strings.NewReplacer has:
// func newReplacer(oldnew ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/strings/replace.go:24:25)) Object {
// 	return _strings.NewReplacer(oldnew)
// 	ABEND124(no public information returned)
// }

GO FUNC strings.Split has:
func split(s string, sep string) Object {
	res := _strings.Split(s, sep)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	return vec1
}

GO FUNC strings.SplitAfter has:
func splitAfter(s string, sep string) Object {
	res := _strings.SplitAfter(s, sep)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	return vec1
}

GO FUNC strings.SplitAfterN has:
func splitAfterN(s string, sep string, n int) Object {
	res := _strings.SplitAfterN(s, sep, n)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	return vec1
}

GO FUNC strings.SplitN has:
func splitN(s string, sep string, n int) Object {
	res := _strings.SplitN(s, sep, n)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	return vec1
}

GO FUNC subtle.ConstantTimeCopy has:
// func constantTimeCopy(v int, x ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/subtle/constant_time.go:43:35), y ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/subtle/constant_time.go:43:35)) Object {
// 	_subtle.ConstantTimeCopy(v, x, y)
// 	...ABEND675: TODO...
// }

GO FUNC suffixarray.New has:
// func new(data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/index/suffixarray/suffixarray.go:35:15)) Object {
// 	return _suffixarray.New(data)
// 	ABEND124(no public information returned)
// }

GO FUNC sync.NewCond has:
// func newCond(l ABEND884(unrecognized type Locker at: GO.link/src/sync/cond.go:32:16)) Object {
// 	res := _sync.NewCond(l)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("L"), (*res).L)
// 	return map1
// }

GO FUNC syntax.Compile has:
// func compile(re ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/regexp/syntax/compile.go:80:17)) Object {
// 	res1, res2 := _syntax.Compile(re)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Inst {
// 		map3 := EmptyArrayMap()
// 		map3.Add(MakeKeyword("Op"), )
// 		map3.Add(MakeKeyword("Out"), MakeInt(int(elem2.Out)))
// 		map3.Add(MakeKeyword("Arg"), MakeInt(int(elem2.Arg)))
// 		vec4 := EmptyVector
// 		for _, elem4 := range elem2.Rune {
// 			vec4 = vec4.Conjoin()
// 		}
// 		map3.Add(MakeKeyword("Rune"), vec4)
// 		vec2 = vec2.Conjoin(map3)
// 	}
// 	map1.Add(MakeKeyword("Inst"), vec2)
// 	map1.Add(MakeKeyword("Start"), MakeInt(int((*res1).Start)))
// 	map1.Add(MakeKeyword("NumCap"), MakeInt(int((*res1).NumCap)))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC syntax.EmptyOpContext has:
// func emptyOpContext(r1 ABEND884(unrecognized type rune at: GO.link/src/regexp/syntax/prog.go:79:28), r2 ABEND884(unrecognized type rune at: GO.link/src/regexp/syntax/prog.go:79:28)) Object {
// 	return _syntax.EmptyOpContext(r1, r2)
// }

GO FUNC syntax.Parse has:
// func parse(s string, flags ABEND884(unrecognized type Flags at: GO.link/src/regexp/syntax/parse.go:701:28)) Object {
// 	res1, res2 := _syntax.Parse(s, flags)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Op"), )
// 	map1.Add(MakeKeyword("Flags"), MakeInt(int((*res1).Flags)))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Sub {
// 		vec2 = vec2.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Sub"), vec2)
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res1).Sub0 {
// 		vec3 = vec3.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Sub0"), vec3)
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res1).Rune {
// 		vec4 = vec4.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Rune"), vec4)
// 	vec5 := EmptyVector
// 	for _, elem5 := range (*res1).Rune0 {
// 		vec5 = vec5.Conjoin()
// 	}
// 	map1.Add(MakeKeyword("Rune0"), vec5)
// 	map1.Add(MakeKeyword("Min"), MakeInt(int((*res1).Min)))
// 	map1.Add(MakeKeyword("Max"), MakeInt(int((*res1).Max)))
// 	map1.Add(MakeKeyword("Cap"), MakeInt(int((*res1).Cap)))
// 	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC syscall.Accept has:
// func accept(fd int) Object {
// 	nfd, sa, err := _syscall.Accept(fd)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(nfd)))
// 	res = res.Conjoin(sa)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.BpfBuflen has:
func bpfBuflen(fd int) Object {
	res1, res2 := _syscall.BpfBuflen(fd)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(res1)))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.BpfDatalink has:
func bpfDatalink(fd int) Object {
	res1, res2 := _syscall.BpfDatalink(fd)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(res1)))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.BpfHeadercmpl has:
func bpfHeadercmpl(fd int) Object {
	res1, res2 := _syscall.BpfHeadercmpl(fd)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(res1)))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.BpfInterface has:
func bpfInterface(fd int, name string) Object {
	res1, res2 := _syscall.BpfInterface(fd, name)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.BpfJump has:
// func bpfJump(code int, k int, jt int, jf int) Object {
// 	res := _syscall.BpfJump(code, k, jt, jf)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Code"), MakeInt(int((*res).Code)))
// 	map1.Add(MakeKeyword("Jt"), )
// 	map1.Add(MakeKeyword("Jf"), )
// 	map1.Add(MakeKeyword("K"), MakeInt(int((*res).K)))
// 	return map1
// }

GO FUNC syscall.BpfStats has:
func bpfStats(fd int) Object {
	res1, res2 := _syscall.BpfStats(fd)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Recv"), MakeInt(int((*res1).Recv)))
	map1.Add(MakeKeyword("Drop"), MakeInt(int((*res1).Drop)))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.BpfStmt has:
// func bpfStmt(code int, k int) Object {
// 	res := _syscall.BpfStmt(code, k)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Code"), MakeInt(int((*res).Code)))
// 	map1.Add(MakeKeyword("Jt"), )
// 	map1.Add(MakeKeyword("Jf"), )
// 	map1.Add(MakeKeyword("K"), MakeInt(int((*res).K)))
// 	return map1
// }

GO FUNC syscall.BpfTimeout has:
func bpfTimeout(fd int) Object {
	res1, res2 := _syscall.BpfTimeout(fd)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Sec"), MakeInt(int((*res1).Sec)))
	map1.Add(MakeKeyword("Usec"), MakeInt(int((*res1).Usec)))
	vec2 := EmptyVector
	for _, elem2 := range (*res1).Pad_cgo_0 {
		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
	}
	map1.Add(MakeKeyword("Pad_cgo_0"), vec2)
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.BytePtrFromString has:
func bytePtrFromString(s string) Object {
	res1, res2 := _syscall.BytePtrFromString(s)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int((*res1))))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.ByteSliceFromString has:
func byteSliceFromString(s string) Object {
	res1, res2 := _syscall.ByteSliceFromString(s)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.Clearenv has:
// func clearenv() Object {
// 	_syscall.Clearenv()
// 	...ABEND675: TODO...
// }

GO FUNC syscall.CloseOnExec has:
// func closeOnExec(fd int) Object {
// 	_syscall.CloseOnExec(fd)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.Dup has:
func dup(fd int) Object {
	nfd, err := _syscall.Dup(fd)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(nfd)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Environ has:
func environ() Object {
	res := _syscall.Environ()
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeString(elem1))
	}
	return vec1
}

GO FUNC syscall.Exit has:
// func exit(code int) Object {
// 	_syscall.Exit(code)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.ForkExec has:
// func forkExec(argv0 string, argv ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/exec_unix.go:235:34), attr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/exec_unix.go:235:49)) Object {
// 	pid, err := _syscall.ForkExec(argv0, argv, attr)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(pid)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.Fpathconf has:
func fpathconf(fd int, name int) Object {
	val, err := _syscall.Fpathconf(fd, name)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(val)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Getdirentries has:
// func getdirentries(fd int, buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:548:32), basep ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/zsyscall_darwin_amd64.go:548:46)) Object {
// 	n, err := _syscall.Getdirentries(fd, buf, basep)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.Getenv has:
func getenv(key string) Object {
	value, found := _syscall.Getenv(key)
	res := EmptyVector
	res = res.Conjoin(MakeString(value))
	res = res.Conjoin(MakeBool(found))
	return res
}

GO FUNC syscall.Getfsstat has:
// func getfsstat(buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_darwin.go:176:20), flags int) Object {
// 	n, err := _syscall.Getfsstat(buf, flags)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.Getgroups has:
func getgroups() Object {
	gids, err := _syscall.Getgroups()
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range gids {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Getpeername has:
// func getpeername(fd int) Object {
// 	sa, err := _syscall.Getpeername(fd)
// 	res := EmptyVector
// 	res = res.Conjoin(sa)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.Getpgid has:
func getpgid(pid int) Object {
	pgid, err := _syscall.Getpgid(pid)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(pgid)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Getpriority has:
func getpriority(which int, who int) Object {
	prio, err := _syscall.Getpriority(which, who)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(prio)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Getsid has:
func getsid(pid int) Object {
	sid, err := _syscall.Getsid(pid)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(sid)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Getsockname has:
// func getsockname(fd int) Object {
// 	sa, err := _syscall.Getsockname(fd)
// 	res := EmptyVector
// 	res = res.Conjoin(sa)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.GetsockoptByte has:
func getsockoptByte(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptByte(fd, level, opt)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(value)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.GetsockoptICMPv6Filter has:
func getsockoptICMPv6Filter(fd int, level int, opt int) Object {
	res1, res2 := _syscall.GetsockoptICMPv6Filter(fd, level, opt)
	res := EmptyVector
	map1 := EmptyArrayMap()
	vec2 := EmptyVector
	for _, elem2 := range (*res1).Filt {
		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
	}
	map1.Add(MakeKeyword("Filt"), vec2)
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.GetsockoptIPMreq has:
func getsockoptIPMreq(fd int, level int, opt int) Object {
	res1, res2 := _syscall.GetsockoptIPMreq(fd, level, opt)
	res := EmptyVector
	map1 := EmptyArrayMap()
	vec2 := EmptyVector
	for _, elem2 := range (*res1).Multiaddr {
		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
	}
	map1.Add(MakeKeyword("Multiaddr"), vec2)
	vec3 := EmptyVector
	for _, elem3 := range (*res1).Interface {
		vec3 = vec3.Conjoin(MakeInt(int(elem3)))
	}
	map1.Add(MakeKeyword("Interface"), vec3)
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.GetsockoptIPv6MTUInfo has:
// func getsockoptIPv6MTUInfo(fd int, level int, opt int) Object {
// 	res1, res2 := _syscall.GetsockoptIPv6MTUInfo(fd, level, opt)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map2 := EmptyArrayMap()
// 	map2.Add(MakeKeyword("Len"), )
// 	map2.Add(MakeKeyword("Family"), )
// 	map2.Add(MakeKeyword("Port"), MakeInt(int((*res1).Addr.Port)))
// 	map2.Add(MakeKeyword("Flowinfo"), MakeInt(int((*res1).Addr.Flowinfo)))
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res1).Addr.Addr {
// 		vec3 = vec3.Conjoin(MakeInt(int(elem3)))
// 	}
// 	map2.Add(MakeKeyword("Addr"), vec3)
// 	map2.Add(MakeKeyword("Scope_id"), MakeInt(int((*res1).Addr.Scope_id)))
// 	map1.Add(MakeKeyword("Addr"), map2)
// 	map1.Add(MakeKeyword("Mtu"), MakeInt(int((*res1).Mtu)))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC syscall.GetsockoptIPv6Mreq has:
func getsockoptIPv6Mreq(fd int, level int, opt int) Object {
	res1, res2 := _syscall.GetsockoptIPv6Mreq(fd, level, opt)
	res := EmptyVector
	map1 := EmptyArrayMap()
	vec2 := EmptyVector
	for _, elem2 := range (*res1).Multiaddr {
		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
	}
	map1.Add(MakeKeyword("Multiaddr"), vec2)
	map1.Add(MakeKeyword("Interface"), MakeInt(int((*res1).Interface)))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.GetsockoptInet4Addr has:
func getsockoptInet4Addr(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptInet4Addr(fd, level, opt)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range value {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.GetsockoptInt has:
func getsockoptInt(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptInt(fd, level, opt)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(value)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Getwd has:
func getwd() Object {
	res1, res2 := _syscall.Getwd()
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.Kevent has:
// func kevent(kq int, changes ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:439:37), events ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:439:37), timeout ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_bsd.go:439:57)) Object {
// 	n, err := _syscall.Kevent(kq, changes, events, timeout)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.Kqueue has:
func kqueue() Object {
	fd, err := _syscall.Kqueue()
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(fd)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Mmap has:
func mmap(fd int, offset int64, length int, prot int, flags int) Object {
	data, err := _syscall.Mmap(fd, offset, length, prot, flags)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range data {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.NsecToTimespec has:
func nsecToTimespec(nsec int64) Object {
	res := _syscall.NsecToTimespec(nsec)
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Sec"), MakeInt(int(res.Sec)))
	map1.Add(MakeKeyword("Nsec"), MakeInt(int(res.Nsec)))
	return map1
}

GO FUNC syscall.NsecToTimeval has:
func nsecToTimeval(nsec int64) Object {
	res := _syscall.NsecToTimeval(nsec)
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Sec"), MakeInt(int(res.Sec)))
	map1.Add(MakeKeyword("Usec"), MakeInt(int(res.Usec)))
	vec2 := EmptyVector
	for _, elem2 := range res.Pad_cgo_0 {
		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
	}
	map1.Add(MakeKeyword("Pad_cgo_0"), vec2)
	return map1
}

GO FUNC syscall.Open has:
func open(path string, mode int, perm uint32) Object {
	fd, err := _syscall.Open(path, mode, perm)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(fd)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.ParseDirent has:
// func parseDirent(buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/dirent.go:64:22), max int, names ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/dirent.go:64:45)) Object {
// 	consumed, count, newnames := _syscall.ParseDirent(buf, max, names)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range newnames {
// 		vec1 = vec1.Conjoin(MakeString(elem1))
// 	}
// 	res = res.Conjoin(MakeInt(int(consumed)))
// 	res = res.Conjoin(MakeInt(int(count)))
// 	res = res.Conjoin(vec1)
// 	return res
// }

GO FUNC syscall.ParseRoutingMessage has:
// func parseRoutingMessage(b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/route_bsd.go:331:28)) Object {
// 	msgs, err := _syscall.ParseRoutingMessage(b)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range msgs {
// 		vec1 = vec1.Conjoin(elem1)
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.ParseRoutingSockaddr has:
// func parseRoutingSockaddr(msg ABEND884(unrecognized type RoutingMessage at: GO.link/src/syscall/route_bsd.go:358:31)) Object {
// 	res1, res2 := _syscall.ParseRoutingSockaddr(msg)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(elem1)
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC syscall.ParseSocketControlMessage has:
// func parseSocketControlMessage(b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/sockcmsg_unix.go:49:34)) Object {
// 	res1, res2 := _syscall.ParseSocketControlMessage(b)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		map2 := EmptyArrayMap()
// 		map3 := EmptyArrayMap()
// 		map3.Add(MakeKeyword("Len"), MakeInt(int(elem1.Header.Len)))
// 		map3.Add(MakeKeyword("Level"), MakeInt(int(elem1.Header.Level)))
// 		map3.Add(MakeKeyword("Type"), MakeInt(int(elem1.Header.Type)))
// 		map2.Add(MakeKeyword("Header"), map3)
// 		vec4 := EmptyVector
// 		for _, elem4 := range elem1.Data {
// 			vec4 = vec4.Conjoin(MakeInt(int(elem4)))
// 		}
// 		map2.Add(MakeKeyword("Data"), vec4)
// 		vec1 = vec1.Conjoin(map2)
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC syscall.ParseUnixRights has:
// func parseUnixRights(m ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/sockcmsg_unix.go:91:24)) Object {
// 	res1, res2 := _syscall.ParseUnixRights(m)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC syscall.Pathconf has:
func pathconf(path string, name int) Object {
	val, err := _syscall.Pathconf(path, name)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(val)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Pread has:
// func pread(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:906:22), offset int64) Object {
// 	n, err := _syscall.Pread(fd, p, offset)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.Pwrite has:
// func pwrite(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:923:23), offset int64) Object {
// 	n, err := _syscall.Pwrite(fd, p, offset)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.RawSyscall has:
// func rawSyscall(trap ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:31:34), a1 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:31:34), a2 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:31:34), a3 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:31:34)) Object {
// 	r1, r2, err := _syscall.RawSyscall(trap, a1, a2, a3)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC syscall.RawSyscall6 has:
// func rawSyscall6(trap ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47), a1 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47), a2 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47), a3 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47), a4 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47), a5 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47), a6 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:32:47)) Object {
// 	r1, r2, err := _syscall.RawSyscall6(trap, a1, a2, a3, a4, a5, a6)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC syscall.Read has:
// func read(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_unix.go:171:21)) Object {
// 	n, err := _syscall.Read(fd, p)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.ReadDirent has:
// func readDirent(fd int, buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:65:29)) Object {
// 	n, err := _syscall.ReadDirent(fd, buf)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.Readlink has:
// func readlink(path string, buf ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/zsyscall_darwin_amd64.go:957:32)) Object {
// 	n, err := _syscall.Readlink(path, buf)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.Recvfrom has:
// func recvfrom(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_unix.go:259:25), flags int) Object {
// 	n, from, err := _syscall.Recvfrom(fd, p, flags)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(from)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.Recvmsg has:
// func recvmsg(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:358:29), oob ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:358:29), flags int) Object {
// 	n, oobn, recvflags, from, err := _syscall.Recvmsg(fd, p, oob, flags)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(MakeInt(int(oobn)))
// 	res = res.Conjoin(MakeInt(int(recvflags)))
// 	res = res.Conjoin(from)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.RouteRIB has:
func routeRIB(facility int, param int) Object {
	res1, res2 := _syscall.RouteRIB(facility, param)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range res1 {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.Seek has:
func seek(fd int, offset int64, whence int) Object {
	newoffset, err := _syscall.Seek(fd, offset, whence)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(newoffset)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Sendfile has:
// func sendfile(outfd int, infd int, offset ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_unix.go:334:43), count int) Object {
// 	written, err := _syscall.Sendfile(outfd, infd, offset, count)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(written)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.SendmsgN has:
// func sendmsgN(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:399:30), oob ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_bsd.go:399:30), to ABEND884(unrecognized type Sockaddr at: GO.link/src/syscall/syscall_bsd.go:399:41), flags int) Object {
// 	n, err := _syscall.SendmsgN(fd, p, oob, to, flags)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.SetBpfBuflen has:
func setBpfBuflen(fd int, l int) Object {
	res1, res2 := _syscall.SetBpfBuflen(fd, l)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(res1)))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.SetBpfDatalink has:
func setBpfDatalink(fd int, t int) Object {
	res1, res2 := _syscall.SetBpfDatalink(fd, t)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(res1)))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC syscall.SetKevent has:
// func setKevent(k ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_darwin_amd64.go:35:18), fd int, mode int, flags int) Object {
// 	_syscall.SetKevent(k, fd, mode, flags)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.Setsid has:
func setsid() Object {
	pid, err := _syscall.Setsid()
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(pid)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.SlicePtrFromStrings has:
// func slicePtrFromStrings(ss ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/exec_unix.go:83:29)) Object {
// 	res1, res2 := _syscall.SlicePtrFromStrings(ss)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int((*elem1))))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC syscall.Socket has:
func socket(domain int, typ int, proto int) Object {
	fd, err := _syscall.Socket(domain, typ, proto)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(fd)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.Socketpair has:
func socketpair(domain int, typ int, proto int) Object {
	fd, err := _syscall.Socketpair(domain, typ, proto)
	res := EmptyVector
	vec1 := EmptyVector
	for _, elem1 := range fd {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	res = res.Conjoin(vec1)
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.StartProcess has:
// func startProcess(argv0 string, argv ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/exec_unix.go:240:38), attr ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/exec_unix.go:240:53)) Object {
// 	pid, handle, err := _syscall.StartProcess(argv0, argv, attr)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(pid)))
// 	res = res.Conjoin()
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.StringByteSlice has:
func stringByteSlice(s string) Object {
	res := _syscall.StringByteSlice(s)
	vec1 := EmptyVector
	for _, elem1 := range res {
		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
	}
	return vec1
}

GO FUNC syscall.StringSlicePtr has:
// func stringSlicePtr(ss ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/exec_unix.go:71:24)) Object {
// 	res := _syscall.StringSlicePtr(ss)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int((*elem1))))
// 	}
// 	return vec1
// }

GO FUNC syscall.Syscall has:
// func syscall(trap ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:29:31), a1 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:29:31), a2 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:29:31), a3 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:29:31)) Object {
// 	r1, r2, err := _syscall.Syscall(trap, a1, a2, a3)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC syscall.Syscall6 has:
// func syscall6(trap ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44), a1 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44), a2 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44), a3 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44), a4 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44), a5 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44), a6 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_unix.go:30:44)) Object {
// 	r1, r2, err := _syscall.Syscall6(trap, a1, a2, a3, a4, a5, a6)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC syscall.Syscall9 has:
// func syscall9(trap ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56), a1 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56), a2 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56), a3 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56), a4 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56), a5 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56), a6 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56), a7 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56), a8 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56), a9 ABEND884(unrecognized type uintptr at: GO.link/src/syscall/syscall_darwin_amd64.go:66:56)) Object {
// 	r1, r2, err := _syscall.Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC syscall.Sysctl has:
func sysctl(name string) Object {
	value, err := _syscall.Sysctl(name)
	res := EmptyVector
	res = res.Conjoin(MakeString(value))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.SysctlUint32 has:
func sysctlUint32(name string) Object {
	value, err := _syscall.SysctlUint32(name)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(value)))
	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return res
}

GO FUNC syscall.UnixRights has:
// func unixRights(fds ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/syscall/sockcmsg_unix.go:74:21)) Object {
// 	res := _syscall.UnixRights(fds)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC syscall.Wait4 has:
// func wait4(pid int, wstatus ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_bsd.go:127:29), options int, rusage ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/syscall/syscall_bsd.go:127:62)) Object {
// 	wpid, err := _syscall.Wait4(pid, wstatus, options, rusage)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(wpid)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syscall.Write has:
// func write(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/syscall/syscall_unix.go:187:22)) Object {
// 	n, err := _syscall.Write(fd, p)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeInt(int(n)))
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC syslog.Dial has:
// func dial(network string, raddr string, priority ABEND884(unrecognized type Priority at: GO.link/src/log/syslog/syslog.go:118:43), tag string) Object {
// 	_, res2 := _syslog.Dial(network, raddr, priority, tag)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC syslog.New has:
// func new(priority ABEND884(unrecognized type Priority at: GO.link/src/log/syslog/syslog.go:107:19), tag string) Object {
// 	_, res2 := _syslog.New(priority, tag)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC syslog.NewLogger has:
// func newLogger(p ABEND884(unrecognized type Priority at: GO.link/src/log/syslog/syslog.go:309:18), logFlag int) Object {
// 	res1, res2 := _syslog.NewLogger(p, logFlag)
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC tabwriter.NewWriter has:
// func newWriter(output ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/text/tabwriter/tabwriter.go:597:23), minwidth int, tabwidth int, padding int, padchar byte, flags uint) Object {
// 	return _tabwriter.NewWriter(output, minwidth, tabwidth, padding, padchar, flags)
// 	ABEND124(no public information returned)
// }

GO FUNC tar.FileInfoHeader has:
// func fileInfoHeader(fi ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/tar/common.go:629:24), link string) Object {
// 	res1, res2 := _tar.FileInfoHeader(fi, link)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Typeflag"), MakeInt(int((*res1).Typeflag)))
// 	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
// 	map1.Add(MakeKeyword("Linkname"), MakeString((*res1).Linkname))
// 	map1.Add(MakeKeyword("Size"), MakeInt(int((*res1).Size)))
// 	map1.Add(MakeKeyword("Mode"), MakeInt(int((*res1).Mode)))
// 	map1.Add(MakeKeyword("Uid"), MakeInt(int((*res1).Uid)))
// 	map1.Add(MakeKeyword("Gid"), MakeInt(int((*res1).Gid)))
// 	map1.Add(MakeKeyword("Uname"), MakeString((*res1).Uname))
// 	map1.Add(MakeKeyword("Gname"), MakeString((*res1).Gname))
// 	map1.Add(MakeKeyword("ModTime"), (*res1).ModTime)
// 	map1.Add(MakeKeyword("AccessTime"), (*res1).AccessTime)
// 	map1.Add(MakeKeyword("ChangeTime"), (*res1).ChangeTime)
// 	map1.Add(MakeKeyword("Devmajor"), MakeInt(int((*res1).Devmajor)))
// 	map1.Add(MakeKeyword("Devminor"), MakeInt(int((*res1).Devminor)))
// 	map1.Add(MakeKeyword("Xattrs"), (*res1).Xattrs)
// 	map1.Add(MakeKeyword("PAXRecords"), (*res1).PAXRecords)
// 	map1.Add(MakeKeyword("Format"), MakeInt(int((*res1).Format)))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC tar.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/tar/reader.go:39:18)) Object {
// 	return _tar.NewReader(r)
// 	ABEND124(no public information returned)
// }

GO FUNC tar.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/tar/writer.go:33:18)) Object {
// 	return _tar.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC template.HTMLEscape has:
// func hTMLEscape(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/text/template/funcs.go:510:19), b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/text/template/funcs.go:510:32)) Object {
// 	_template.HTMLEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC template.IsTrue has:
// func isTrue(val ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/text/template/exec.go:302:17)) Object {
// 	truth, ok := _template.IsTrue(val)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeBool(truth))
// 	res = res.Conjoin(MakeBool(ok))
// 	return res
// }

GO FUNC template.JSEscape has:
// func jSEscape(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/text/template/funcs.go:568:17), b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/text/template/funcs.go:568:30)) Object {
// 	_template.JSEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC template.Must has:
// func must(t ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/text/template/helper.go:21:13), err error) Object {
// 	return _template.Must(t, err)
// 	ABEND124(no public information returned)
// }

GO FUNC template.New has:
// func new(name string) Object {
// 	return _template.New(name)
// 	ABEND124(no public information returned)
// }

GO FUNC template.ParseFiles has:
// func parseFiles(filenames ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/text/template/helper.go:37:27)) Object {
// 	_, res2 := _template.ParseFiles(filenames)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC template.ParseGlob has:
func parseGlob(pattern string) Object {
	_, res2 := _template.ParseGlob(pattern)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC template.HTMLEscape has:
// func hTMLEscape(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/html/template/escape.go:855:19), b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/html/template/escape.go:855:32)) Object {
// 	_template.HTMLEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC template.IsTrue has:
// func isTrue(val ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/html/template/template.go:487:17)) Object {
// 	truth, ok := _template.IsTrue(val)
// 	res := EmptyVector
// 	res = res.Conjoin(MakeBool(truth))
// 	res = res.Conjoin(MakeBool(ok))
// 	return res
// }

GO FUNC template.JSEscape has:
// func jSEscape(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/html/template/escape.go:871:17), b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/html/template/escape.go:871:30)) Object {
// 	_template.JSEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC template.Must has:
// func must(t ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/html/template/template.go:370:13), err error) Object {
// 	res := _template.Must(t, err)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Tree"), (*(*res).Tree))
// 	return map1
// }

GO FUNC template.New has:
// func new(name string) Object {
// 	res := _template.New(name)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Tree"), (*(*res).Tree))
// 	return map1
// }

GO FUNC template.ParseFiles has:
// func parseFiles(filenames ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/html/template/template.go:386:27)) Object {
// 	res1, res2 := _template.ParseFiles(filenames)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Tree"), (*(*res1).Tree))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC template.ParseGlob has:
// func parseGlob(pattern string) Object {
// 	res1, res2 := _template.ParseGlob(pattern)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Tree"), (*(*res1).Tree))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC testing.AllocsPerRun has:
// func allocsPerRun(runs int, f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/testing/allocs.go:20:31)) Object {
// 	return _testing.AllocsPerRun(runs, f)
// }

GO FUNC testing.Benchmark has:
// func benchmark(f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/testing/benchmark.go:649:18)) Object {
// 	res := _testing.Benchmark(f)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("N"), MakeInt(int(res.N)))
// 	map1.Add(MakeKeyword("T"), res.T)
// 	map1.Add(MakeKeyword("Bytes"), MakeInt(int(res.Bytes)))
// 	map1.Add(MakeKeyword("MemAllocs"), )
// 	map1.Add(MakeKeyword("MemBytes"), )
// 	return map1
// }

GO FUNC testing.Coverage has:
// func coverage() Object {
// 	return _testing.Coverage()
// }

GO FUNC testing.Main has:
// func main(matchString ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/testing/testing.go:961:23), tests ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:961:66), benchmarks ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:961:93), examples ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:961:123)) Object {
// 	_testing.Main(matchString, tests, benchmarks, examples)
// 	...ABEND675: TODO...
// }

GO FUNC testing.MainStart has:
// func mainStart(deps ABEND884(unrecognized type testDeps at: GO.link/src/testing/testing.go:995:21), tests ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:995:37), benchmarks ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:995:64), examples ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/testing.go:995:94)) Object {
// 	return _testing.MainStart(deps, tests, benchmarks, examples)
// 	ABEND124(no public information returned)
// }

GO FUNC testing.RegisterCover has:
// func registerCover(c ABEND884(unrecognized type Cover at: GO.link/src/testing/cover.go:67:22)) Object {
// 	_testing.RegisterCover(c)
// 	...ABEND675: TODO...
// }

GO FUNC testing.RunBenchmarks has:
// func runBenchmarks(matchString ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/testing/benchmark.go:377:32), benchmarks ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/testing/benchmark.go:377:80)) Object {
// 	_testing.RunBenchmarks(matchString, benchmarks)
// 	...ABEND675: TODO...
// }

GO FUNC textproto.Dial has:
func dial(network string, addr string) Object {
	_, res2 := _textproto.Dial(network, addr)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC textproto.NewConn has:
// func newConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/net/textproto/textproto.go:66:19)) Object {
// 	return _textproto.NewConn(conn)
// 	ABEND124(no public information returned)
// }

GO FUNC textproto.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/textproto/reader.go:29:18)) Object {
// 	res := _textproto.NewReader(r)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("R"), (*(*res).R))
// 	return map1
// }

GO FUNC textproto.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/net/textproto/writer.go:21:18)) Object {
// 	res := _textproto.NewWriter(w)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("W"), (*(*res).W))
// 	return map1
// }

GO FUNC textproto.TrimBytes has:
// func trimBytes(b ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/net/textproto/textproto.go:137:18)) Object {
// 	res := _textproto.TrimBytes(b)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC time.After has:
// func after(d ABEND884(unrecognized type Duration at: GO.link/src/time/sleep.go:152:14)) Object {
// 	return _time.After(d)
// }

GO FUNC time.AfterFunc has:
// func afterFunc(d ABEND884(unrecognized type Duration at: GO.link/src/time/sleep.go:159:18), f ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/time/sleep.go:159:30)) Object {
// 	res := _time.AfterFunc(d, f)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("C"), (*res).C)
// 	return map1
// }

GO FUNC time.Date has:
// func date(year int, month ABEND884(unrecognized type Month at: GO.link/src/time/time.go:1326:27), day int, hour int, min int, sec int, nsec int, loc ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/time/time.go:1326:69)) Object {
// 	return _time.Date(year, month, day, hour, min, sec, nsec, loc)
// 	ABEND124(no public information returned)
// }

GO FUNC time.FixedZone has:
// func fixedZone(name string, offset int) Object {
// 	return _time.FixedZone(name, offset)
// 	ABEND124(no public information returned)
// }

GO FUNC time.LoadLocation has:
func loadLocation(name string) Object {
	_, res2 := _time.LoadLocation(name)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC time.LoadLocationFromTZData has:
// func loadLocationFromTZData(name string, data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/time/zoneinfo_read.go:86:47)) Object {
// 	_, res2 := _time.LoadLocationFromTZData(name, data)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC time.NewTicker has:
// func newTicker(d ABEND884(unrecognized type Duration at: GO.link/src/time/tick.go:21:18)) Object {
// 	res := _time.NewTicker(d)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("C"), (*res).C)
// 	return map1
// }

GO FUNC time.NewTimer has:
// func newTimer(d ABEND884(unrecognized type Duration at: GO.link/src/time/sleep.go:85:17)) Object {
// 	res := _time.NewTimer(d)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("C"), (*res).C)
// 	return map1
// }

GO FUNC time.Now has:
// func now() Object {
// 	return _time.Now()
// 	ABEND124(no public information returned)
// }

GO FUNC time.Parse has:
func parse(layout string, value string) Object {
	_, res2 := _time.Parse(layout, value)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC time.ParseDuration has:
func parseDuration(s string) Object {
	res1, res2 := _time.ParseDuration(s)
	res := EmptyVector
	res = res.Conjoin(MakeInt(int(res1)))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC time.ParseInLocation has:
// func parseInLocation(layout string, value string, loc ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/time/format.go:782:48)) Object {
// 	_, res2 := _time.ParseInLocation(layout, value, loc)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC time.Sleep has:
// func sleep(d ABEND884(unrecognized type Duration at: GO.link/src/time/sleep.go:9:14)) Object {
// 	_time.Sleep(d)
// 	...ABEND675: TODO...
// }

GO FUNC time.Tick has:
// func tick(d ABEND884(unrecognized type Duration at: GO.link/src/time/tick.go:54:13)) Object {
// 	return _time.Tick(d)
// }

GO FUNC time.Unix has:
// func unix(sec int64, nsec int64) Object {
// 	return _time.Unix(sec, nsec)
// 	ABEND124(no public information returned)
// }

GO FUNC tls.Client has:
// func client(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/tls.go:39:18), config ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:39:35)) Object {
// 	return _tls.Client(conn, config)
// 	ABEND124(no public information returned)
// }

GO FUNC tls.Dial has:
// func dial(network string, addr string, config ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:169:40)) Object {
// 	_, res2 := _tls.Dial(network, addr, config)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC tls.DialWithDialer has:
// func dialWithDialer(dialer ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:98:28), network string, addr string, config ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:98:70)) Object {
// 	_, res2 := _tls.DialWithDialer(dialer, network, addr, config)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC tls.Listen has:
// func listen(network string, laddr string, config ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:74:43)) Object {
// 	res1, res2 := _tls.Listen(network, laddr, config)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC tls.LoadX509KeyPair has:
// func loadX509KeyPair(certFile string, keyFile string) Object {
// 	res1, res2 := _tls.LoadX509KeyPair(certFile, keyFile)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range res1.Certificate {
// 		vec3 := EmptyVector
// 		for _, elem3 := range elem2 {
// 			vec3 = vec3.Conjoin(MakeInt(int(elem3)))
// 		}
// 		vec2 = vec2.Conjoin(vec3)
// 	}
// 	map1.Add(MakeKeyword("Certificate"), vec2)
// 	map1.Add(MakeKeyword("PrivateKey"), res1.PrivateKey)
// 	vec4 := EmptyVector
// 	for _, elem4 := range res1.OCSPStaple {
// 		vec4 = vec4.Conjoin(MakeInt(int(elem4)))
// 	}
// 	map1.Add(MakeKeyword("OCSPStaple"), vec4)
// 	vec5 := EmptyVector
// 	for _, elem5 := range res1.SignedCertificateTimestamps {
// 		vec6 := EmptyVector
// 		for _, elem6 := range elem5 {
// 			vec6 = vec6.Conjoin(MakeInt(int(elem6)))
// 		}
// 		vec5 = vec5.Conjoin(vec6)
// 	}
// 	map1.Add(MakeKeyword("SignedCertificateTimestamps"), vec5)
// 	map1.Add(MakeKeyword("Leaf"), (*res1.Leaf))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC tls.NewLRUClientSessionCache has:
// func newLRUClientSessionCache(capacity int) Object {
// 	return _tls.NewLRUClientSessionCache(capacity)
// }

GO FUNC tls.NewListener has:
// func newListener(inner ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/tls.go:63:24), config ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:63:45)) Object {
// 	return _tls.NewListener(inner, config)
// }

GO FUNC tls.Server has:
// func server(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/tls/tls.go:31:18), config ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/tls/tls.go:31:35)) Object {
// 	return _tls.Server(conn, config)
// 	ABEND124(no public information returned)
// }

GO FUNC tls.X509KeyPair has:
// func x509KeyPair(certPEMBlock ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/tls/tls.go:193:44), keyPEMBlock ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/tls/tls.go:193:44)) Object {
// 	res1, res2 := _tls.X509KeyPair(certPEMBlock, keyPEMBlock)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range res1.Certificate {
// 		vec3 := EmptyVector
// 		for _, elem3 := range elem2 {
// 			vec3 = vec3.Conjoin(MakeInt(int(elem3)))
// 		}
// 		vec2 = vec2.Conjoin(vec3)
// 	}
// 	map1.Add(MakeKeyword("Certificate"), vec2)
// 	map1.Add(MakeKeyword("PrivateKey"), res1.PrivateKey)
// 	vec4 := EmptyVector
// 	for _, elem4 := range res1.OCSPStaple {
// 		vec4 = vec4.Conjoin(MakeInt(int(elem4)))
// 	}
// 	map1.Add(MakeKeyword("OCSPStaple"), vec4)
// 	vec5 := EmptyVector
// 	for _, elem5 := range res1.SignedCertificateTimestamps {
// 		vec6 := EmptyVector
// 		for _, elem6 := range elem5 {
// 			vec6 = vec6.Conjoin(MakeInt(int(elem6)))
// 		}
// 		vec5 = vec5.Conjoin(vec6)
// 	}
// 	map1.Add(MakeKeyword("SignedCertificateTimestamps"), vec5)
// 	map1.Add(MakeKeyword("Leaf"), (*res1.Leaf))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC token.NewFileSet has:
// func newFileSet() Object {
// 	return _token.NewFileSet()
// 	ABEND124(no public information returned)
// }

GO FUNC trace.Log has:
// func log(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:91:14), category string, message string) Object {
// 	_trace.Log(ctx, category, message)
// 	...ABEND675: TODO...
// }

GO FUNC trace.Logf has:
// func logf(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:97:15), category string, format string, args ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/runtime/trace/annotation.go:97:62)) Object {
// 	_trace.Logf(ctx, category, format, args)
// 	...ABEND675: TODO...
// }

GO FUNC trace.NewTask has:
// func newTask(pctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:34:19), taskType string) Object {
// 	ctx, _ := _trace.NewTask(pctx, taskType)
// 	res := EmptyVector
// 	res = res.Conjoin(ctx)
// 	res = res.Conjoin(NIL)
// 	return res
// }

GO FUNC trace.StartRegion has:
// func startRegion(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:149:22), regionType string) Object {
// 	return _trace.StartRegion(ctx, regionType)
// 	ABEND124(no public information returned)
// }

GO FUNC trace.Stop has:
// func stop() Object {
// 	_trace.Stop()
// 	...ABEND675: TODO...
// }

GO FUNC trace.WithRegion has:
// func withRegion(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/runtime/trace/annotation.go:118:21), regionType string, fn ABEND882(unrecognized Expr type *ast.FuncType at: GO.link/src/runtime/trace/annotation.go:118:60)) Object {
// 	_trace.WithRegion(ctx, regionType, fn)
// 	...ABEND675: TODO...
// }

GO FUNC types.DefPredeclaredTestFuncs has:
// func defPredeclaredTestFuncs() Object {
// 	_types.DefPredeclaredTestFuncs()
// 	...ABEND675: TODO...
// }

GO FUNC types.Default has:
// func default(typ ABEND884(unrecognized type Type at: GO.link/src/go/types/predicates.go:302:18)) Object {
// 	return _types.Default(typ)
// }

GO FUNC types.Eval has:
// func eval(fset ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/eval.go:34:16), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/eval.go:34:36), pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/eval.go:34:50), expr string) Object {
// 	_, err := _types.Eval(fset, pkg, pos, expr)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Type"), _.Type)
// 	map1.Add(MakeKeyword("Value"), _.Value)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC types.LookupFieldOrMethod has:
// func lookupFieldOrMethod(T ABEND884(unrecognized type Type at: GO.link/src/go/types/lookup.go:35:28), addressable bool, pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/lookup.go:35:56), name string) Object {
// 	obj, index, indirect := _types.LookupFieldOrMethod(T, addressable, pkg, name)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range index {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(obj)
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(MakeBool(indirect))
// 	return res
// }

GO FUNC types.MissingMethod has:
// func missingMethod(V ABEND884(unrecognized type Type at: GO.link/src/go/types/lookup.go:250:22), T ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/lookup.go:250:30), static bool) Object {
// 	_, wrongType := _types.MissingMethod(V, T, static)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(MakeBool(wrongType))
// 	return res
// }

GO FUNC types.NewArray has:
// func newArray(elem ABEND884(unrecognized type Type at: GO.link/src/go/types/type.go:101:20), len int64) Object {
// 	return _types.NewArray(elem, len)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewChan has:
// func newChan(dir ABEND884(unrecognized type ChanDir at: GO.link/src/go/types/type.go:413:18), elem ABEND884(unrecognized type Type at: GO.link/src/go/types/type.go:413:32)) Object {
// 	return _types.NewChan(dir, elem)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewChecker has:
// func newChecker(conf ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/check.go:170:22), fset ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/check.go:170:36), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/check.go:170:56), info ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/check.go:170:71)) Object {
// 	return _types.NewChecker(conf, fset, pkg, info)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewConst has:
// func newConst(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:205:19), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:205:34), name string, typ ABEND884(unrecognized type Type at: GO.link/src/go/types/object.go:205:61), val ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:205:71)) Object {
// 	return _types.NewConst(pos, pkg, name, typ, val)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewField has:
// func newField(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:276:19), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:276:34), name string, typ ABEND884(unrecognized type Type at: GO.link/src/go/types/object.go:276:61), embedded bool) Object {
// 	return _types.NewField(pos, pkg, name, typ, embedded)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewFunc has:
// func newFunc(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:301:18), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:301:33), name string, sig ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:301:60)) Object {
// 	return _types.NewFunc(pos, pkg, name, sig)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewInterface has:
// func newInterface(methods ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:266:27), embeddeds ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:266:46)) Object {
// 	return _types.NewInterface(methods, embeddeds)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewInterfaceType has:
// func newInterfaceType(methods ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:280:31), embeddeds ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:280:50)) Object {
// 	return _types.NewInterfaceType(methods, embeddeds)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewLabel has:
// func newLabel(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:331:19), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:331:34), name string) Object {
// 	return _types.NewLabel(pos, pkg, name)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewMap has:
// func newMap(key ABEND884(unrecognized type Type at: GO.link/src/go/types/type.go:386:23), elem ABEND884(unrecognized type Type at: GO.link/src/go/types/type.go:386:23)) Object {
// 	return _types.NewMap(key, elem)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewMethodSet has:
// func newMethodSet(T ABEND884(unrecognized type Type at: GO.link/src/go/types/methodset.go:67:21)) Object {
// 	return _types.NewMethodSet(T)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewNamed has:
// func newNamed(obj ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/type.go:433:19), underlying ABEND884(unrecognized type Type at: GO.link/src/go/types/type.go:433:41), methods ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:433:55)) Object {
// 	return _types.NewNamed(obj, underlying, methods)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewPackage has:
// func newPackage(path string, name string) Object {
// 	return _types.NewPackage(path, name)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewParam has:
// func newParam(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:269:19), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:269:34), name string, typ ABEND884(unrecognized type Type at: GO.link/src/go/types/object.go:269:61)) Object {
// 	return _types.NewParam(pos, pkg, name, typ)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewPkgName has:
// func newPkgName(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:189:21), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:189:36), name string, imported ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:189:68)) Object {
// 	return _types.NewPkgName(pos, pkg, name, imported)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewPointer has:
// func newPointer(elem ABEND884(unrecognized type Type at: GO.link/src/go/types/type.go:164:22)) Object {
// 	return _types.NewPointer(elem)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewScope has:
// func newScope(parent ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/scope.go:36:22), pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/scope.go:36:39), end ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/scope.go:36:39), comment string) Object {
// 	return _types.NewScope(parent, pos, end, comment)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewSignature has:
// func newSignature(recv ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/type.go:213:24), params ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/type.go:213:46), results ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/type.go:213:46), variadic bool) Object {
// 	return _types.NewSignature(recv, params, results, variadic)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewSlice has:
// func newSlice(elem ABEND884(unrecognized type Type at: GO.link/src/go/types/type.go:116:20)) Object {
// 	return _types.NewSlice(elem)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewStruct has:
// func newStruct(fields ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:131:23), tags ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/go/types/type.go:131:36)) Object {
// 	return _types.NewStruct(fields, tags)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewTuple has:
// func newTuple(x ABEND882(unrecognized Expr type *ast.Ellipsis at: GO.link/src/go/types/type.go:177:17)) Object {
// 	return _types.NewTuple(x)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewTypeName has:
// func newTypeName(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:226:22), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:226:37), name string, typ ABEND884(unrecognized type Type at: GO.link/src/go/types/object.go:226:64)) Object {
// 	return _types.NewTypeName(pos, pkg, name, typ)
// 	ABEND124(no public information returned)
// }

GO FUNC types.NewVar has:
// func newVar(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/object.go:264:17), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/object.go:264:32), name string, typ ABEND884(unrecognized type Type at: GO.link/src/go/types/object.go:264:59)) Object {
// 	return _types.NewVar(pos, pkg, name, typ)
// 	ABEND124(no public information returned)
// }

GO FUNC types.RelativeTo has:
// func relativeTo(pkg ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/typestring.go:29:21)) Object {
// 	return _types.RelativeTo(pkg)
// }

GO FUNC types.SizesFor has:
// func sizesFor(compiler string, arch string) Object {
// 	return _types.SizesFor(compiler, arch)
// }

GO FUNC types.WriteExpr has:
// func writeExpr(buf ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/exprstring.go:26:20), x ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/go/types/exprstring.go:26:37)) Object {
// 	_types.WriteExpr(buf, x)
// 	...ABEND675: TODO...
// }

GO FUNC types.WriteSignature has:
// func writeSignature(buf ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/typestring.go:285:25), sig ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/typestring.go:285:44), qf ABEND884(unrecognized type Qualifier at: GO.link/src/go/types/typestring.go:285:59)) Object {
// 	_types.WriteSignature(buf, sig, qf)
// 	...ABEND675: TODO...
// }

GO FUNC types.WriteType has:
// func writeType(buf ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/go/types/typestring.go:74:20), typ ABEND884(unrecognized type Type at: GO.link/src/go/types/typestring.go:74:39), qf ABEND884(unrecognized type Qualifier at: GO.link/src/go/types/typestring.go:74:48)) Object {
// 	_types.WriteType(buf, typ, qf)
// 	...ABEND675: TODO...
// }

GO FUNC unicode.SimpleFold has:
// func simpleFold(r ABEND884(unrecognized type rune at: GO.link/src/unicode/letter.go:339:19)) Object {
// 	return _unicode.SimpleFold(r)
// }

GO FUNC unicode.To has:
// func to(_case int, r ABEND884(unrecognized type rune at: GO.link/src/unicode/letter.go:247:22)) Object {
// 	return _unicode.To(_case, r)
// }

GO FUNC unicode.ToLower has:
// func toLower(r ABEND884(unrecognized type rune at: GO.link/src/unicode/letter.go:264:16)) Object {
// 	return _unicode.ToLower(r)
// }

GO FUNC unicode.ToTitle has:
// func toTitle(r ABEND884(unrecognized type rune at: GO.link/src/unicode/letter.go:275:16)) Object {
// 	return _unicode.ToTitle(r)
// }

GO FUNC unicode.ToUpper has:
// func toUpper(r ABEND884(unrecognized type rune at: GO.link/src/unicode/letter.go:253:16)) Object {
// 	return _unicode.ToUpper(r)
// }

GO FUNC unsafe.Alignof has:
// func alignof(x ABEND884(unrecognized type ArbitraryType at: GO.link/src/unsafe/unsafe.go:196:16)) Object {
// 	return _unsafe.Alignof(x)
// }

GO FUNC unsafe.Offsetof has:
// func offsetof(x ABEND884(unrecognized type ArbitraryType at: GO.link/src/unsafe/unsafe.go:186:17)) Object {
// 	return _unsafe.Offsetof(x)
// }

GO FUNC unsafe.Sizeof has:
// func sizeof(x ABEND884(unrecognized type ArbitraryType at: GO.link/src/unsafe/unsafe.go:181:15)) Object {
// 	return _unsafe.Sizeof(x)
// }

GO FUNC url.Parse has:
func parse(rawurl string) Object {
	res1, res2 := _url.Parse(rawurl)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Scheme"), MakeString((*res1).Scheme))
	map1.Add(MakeKeyword("Opaque"), MakeString((*res1).Opaque))
	map1.Add(MakeKeyword("User"), NIL)
	map1.Add(MakeKeyword("Host"), MakeString((*res1).Host))
	map1.Add(MakeKeyword("Path"), MakeString((*res1).Path))
	map1.Add(MakeKeyword("RawPath"), MakeString((*res1).RawPath))
	map1.Add(MakeKeyword("ForceQuery"), MakeBool((*res1).ForceQuery))
	map1.Add(MakeKeyword("RawQuery"), MakeString((*res1).RawQuery))
	map1.Add(MakeKeyword("Fragment"), MakeString((*res1).Fragment))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC url.ParseQuery has:
// func parseQuery(query string) Object {
// 	res1, res2 := _url.ParseQuery(query)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC url.ParseRequestURI has:
func parseRequestURI(rawurl string) Object {
	res1, res2 := _url.ParseRequestURI(rawurl)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Scheme"), MakeString((*res1).Scheme))
	map1.Add(MakeKeyword("Opaque"), MakeString((*res1).Opaque))
	map1.Add(MakeKeyword("User"), NIL)
	map1.Add(MakeKeyword("Host"), MakeString((*res1).Host))
	map1.Add(MakeKeyword("Path"), MakeString((*res1).Path))
	map1.Add(MakeKeyword("RawPath"), MakeString((*res1).RawPath))
	map1.Add(MakeKeyword("ForceQuery"), MakeBool((*res1).ForceQuery))
	map1.Add(MakeKeyword("RawQuery"), MakeString((*res1).RawQuery))
	map1.Add(MakeKeyword("Fragment"), MakeString((*res1).Fragment))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC url.PathUnescape has:
func pathUnescape(s string) Object {
	res1, res2 := _url.PathUnescape(s)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC url.QueryUnescape has:
func queryUnescape(s string) Object {
	res1, res2 := _url.QueryUnescape(s)
	res := EmptyVector
	res = res.Conjoin(MakeString(res1))
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC url.User has:
// func user(username string) Object {
// 	return _url.User(username)
// 	ABEND124(no public information returned)
// }

GO FUNC url.UserPassword has:
// func userPassword(username string, password string) Object {
// 	return _url.UserPassword(username, password)
// 	ABEND124(no public information returned)
// }

GO FUNC user.Current has:
func current() Object {
	res1, res2 := _user.Current()
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Uid"), MakeString((*res1).Uid))
	map1.Add(MakeKeyword("Gid"), MakeString((*res1).Gid))
	map1.Add(MakeKeyword("Username"), MakeString((*res1).Username))
	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
	map1.Add(MakeKeyword("HomeDir"), MakeString((*res1).HomeDir))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC user.Lookup has:
func lookup(username string) Object {
	res1, res2 := _user.Lookup(username)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Uid"), MakeString((*res1).Uid))
	map1.Add(MakeKeyword("Gid"), MakeString((*res1).Gid))
	map1.Add(MakeKeyword("Username"), MakeString((*res1).Username))
	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
	map1.Add(MakeKeyword("HomeDir"), MakeString((*res1).HomeDir))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC user.LookupGroup has:
func lookupGroup(name string) Object {
	res1, res2 := _user.LookupGroup(name)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Gid"), MakeString((*res1).Gid))
	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC user.LookupGroupId has:
func lookupGroupId(gid string) Object {
	res1, res2 := _user.LookupGroupId(gid)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Gid"), MakeString((*res1).Gid))
	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC user.LookupId has:
func lookupId(uid string) Object {
	res1, res2 := _user.LookupId(uid)
	res := EmptyVector
	map1 := EmptyArrayMap()
	map1.Add(MakeKeyword("Uid"), MakeString((*res1).Uid))
	map1.Add(MakeKeyword("Gid"), MakeString((*res1).Gid))
	map1.Add(MakeKeyword("Username"), MakeString((*res1).Username))
	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
	map1.Add(MakeKeyword("HomeDir"), MakeString((*res1).HomeDir))
	res = res.Conjoin(map1)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC utf16.Decode has:
// func decode(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf16/utf16.go:88:15)) Object {
// 	res := _utf16.Decode(s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin()
// 	}
// 	return vec1
// }

GO FUNC utf16.DecodeRune has:
// func decodeRune(r1 ABEND884(unrecognized type rune at: GO.link/src/unicode/utf16/utf16.go:37:24), r2 ABEND884(unrecognized type rune at: GO.link/src/unicode/utf16/utf16.go:37:24)) Object {
// 	return _utf16.DecodeRune(r1, r2)
// }

GO FUNC utf16.Encode has:
// func encode(s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf16/utf16.go:56:15)) Object {
// 	res := _utf16.Encode(s)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC utf16.EncodeRune has:
// func encodeRune(r ABEND884(unrecognized type rune at: GO.link/src/unicode/utf16/utf16.go:47:19)) Object {
// 	r1, r2 := _utf16.EncodeRune(r)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin()
// 	return res
// }

GO FUNC utf8.DecodeLastRune has:
// func decodeLastRune(p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf8/utf8.go:245:23)) Object {
// 	r, size := _utf8.DecodeLastRune(p)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeInt(int(size)))
// 	return res
// }

GO FUNC utf8.DecodeLastRuneInString has:
// func decodeLastRuneInString(s string) Object {
// 	r, size := _utf8.DecodeLastRuneInString(s)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeInt(int(size)))
// 	return res
// }

GO FUNC utf8.DecodeRune has:
// func decodeRune(p ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/unicode/utf8/utf8.go:149:19)) Object {
// 	r, size := _utf8.DecodeRune(p)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeInt(int(size)))
// 	return res
// }

GO FUNC utf8.DecodeRuneInString has:
// func decodeRuneInString(s string) Object {
// 	r, size := _utf8.DecodeRuneInString(s)
// 	res := EmptyVector
// 	res = res.Conjoin()
// 	res = res.Conjoin(MakeInt(int(size)))
// 	return res
// }

GO FUNC x509.CreateCertificate has:
// func createCertificate(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2082:29), template ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/x509.go:2082:57), parent ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/x509.go:2082:57), pub ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:2082:81), priv ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:2082:81)) Object {
// 	cert, err := _x509.CreateCertificate(rand, template, parent, pub, priv)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range cert {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC x509.CreateCertificateRequest has:
// func createCertificateRequest(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/x509.go:2407:36), template ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/x509.go:2407:56), priv ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:2407:82)) Object {
// 	csr, err := _x509.CreateCertificateRequest(rand, template, priv)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range csr {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC x509.DecryptPEMBlock has:
// func decryptPEMBlock(b ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/pem_decrypt.go:115:24), password ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pem_decrypt.go:115:45)) Object {
// 	res1, res2 := _x509.DecryptPEMBlock(b, password)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.EncryptPEMBlock has:
// func encryptPEMBlock(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/crypto/x509/pem_decrypt.go:183:27), blockType string, data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pem_decrypt.go:183:71), password ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pem_decrypt.go:183:71), alg ABEND884(unrecognized type PEMCipher at: GO.link/src/crypto/x509/pem_decrypt.go:183:83)) Object {
// 	res1, res2 := _x509.EncryptPEMBlock(rand, blockType, data, password, alg)
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.MarshalECPrivateKey has:
// func marshalECPrivateKey(key ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/sec1.go:37:30)) Object {
// 	res1, res2 := _x509.MarshalECPrivateKey(key)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.MarshalPKCS1PrivateKey has:
// func marshalPKCS1PrivateKey(key ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/pkcs1.go:92:33)) Object {
// 	res := _x509.MarshalPKCS1PrivateKey(key)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC x509.MarshalPKCS1PublicKey has:
// func marshalPKCS1PublicKey(key ABEND882(unrecognized Expr type *ast.StarExpr at: GO.link/src/crypto/x509/pkcs1.go:148:32)) Object {
// 	res := _x509.MarshalPKCS1PublicKey(key)
// 	vec1 := EmptyVector
// 	for _, elem1 := range res {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	return vec1
// }

GO FUNC x509.MarshalPKCS8PrivateKey has:
// func marshalPKCS8PrivateKey(key ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/pkcs8.go:63:33)) Object {
// 	res1, res2 := _x509.MarshalPKCS8PrivateKey(key)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.MarshalPKIXPublicKey has:
// func marshalPKIXPublicKey(pub ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:104:31)) Object {
// 	res1, res2 := _x509.MarshalPKIXPublicKey(pub)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.NewCertPool has:
// func newCertPool() Object {
// 	return _x509.NewCertPool()
// 	ABEND124(no public information returned)
// }

GO FUNC x509.ParseCRL has:
// func parseCRL(crlBytes ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:2179:24)) Object {
// 	res1, res2 := _x509.ParseCRL(crlBytes)
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.ParseCertificate has:
// func parseCertificate(asn1Data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:1562:32)) Object {
// 	res1, res2 := _x509.ParseCertificate(asn1Data)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Raw {
// 		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 	}
// 	map1.Add(MakeKeyword("Raw"), vec2)
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res1).RawTBSCertificate {
// 		vec3 = vec3.Conjoin(MakeInt(int(elem3)))
// 	}
// 	map1.Add(MakeKeyword("RawTBSCertificate"), vec3)
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res1).RawSubjectPublicKeyInfo {
// 		vec4 = vec4.Conjoin(MakeInt(int(elem4)))
// 	}
// 	map1.Add(MakeKeyword("RawSubjectPublicKeyInfo"), vec4)
// 	vec5 := EmptyVector
// 	for _, elem5 := range (*res1).RawSubject {
// 		vec5 = vec5.Conjoin(MakeInt(int(elem5)))
// 	}
// 	map1.Add(MakeKeyword("RawSubject"), vec5)
// 	vec6 := EmptyVector
// 	for _, elem6 := range (*res1).RawIssuer {
// 		vec6 = vec6.Conjoin(MakeInt(int(elem6)))
// 	}
// 	map1.Add(MakeKeyword("RawIssuer"), vec6)
// 	vec7 := EmptyVector
// 	for _, elem7 := range (*res1).Signature {
// 		vec7 = vec7.Conjoin(MakeInt(int(elem7)))
// 	}
// 	map1.Add(MakeKeyword("Signature"), vec7)
// 	map1.Add(MakeKeyword("SignatureAlgorithm"), MakeInt(int((*res1).SignatureAlgorithm)))
// 	map1.Add(MakeKeyword("PublicKeyAlgorithm"), MakeInt(int((*res1).PublicKeyAlgorithm)))
// 	map1.Add(MakeKeyword("PublicKey"), (*res1).PublicKey)
// 	map1.Add(MakeKeyword("Version"), MakeInt(int((*res1).Version)))
// 	map1.Add(MakeKeyword("SerialNumber"), (*(*res1).SerialNumber))
// 	map1.Add(MakeKeyword("Issuer"), (*res1).Issuer)
// 	map1.Add(MakeKeyword("Subject"), (*res1).Subject)
// 	map1.Add(MakeKeyword("NotBefore"), (*res1).NotBefore)
// 	map1.Add(MakeKeyword("NotAfter"), (*res1).NotAfter)
// 	map1.Add(MakeKeyword("KeyUsage"), MakeInt(int((*res1).KeyUsage)))
// 	vec8 := EmptyVector
// 	for _, elem8 := range (*res1).Extensions {
// 		vec8 = vec8.Conjoin(elem8)
// 	}
// 	map1.Add(MakeKeyword("Extensions"), vec8)
// 	vec9 := EmptyVector
// 	for _, elem9 := range (*res1).ExtraExtensions {
// 		vec9 = vec9.Conjoin(elem9)
// 	}
// 	map1.Add(MakeKeyword("ExtraExtensions"), vec9)
// 	vec10 := EmptyVector
// 	for _, elem10 := range (*res1).UnhandledCriticalExtensions {
// 		vec10 = vec10.Conjoin(elem10)
// 	}
// 	map1.Add(MakeKeyword("UnhandledCriticalExtensions"), vec10)
// 	vec11 := EmptyVector
// 	for _, elem11 := range (*res1).ExtKeyUsage {
// 		vec11 = vec11.Conjoin(MakeInt(int(elem11)))
// 	}
// 	map1.Add(MakeKeyword("ExtKeyUsage"), vec11)
// 	vec12 := EmptyVector
// 	for _, elem12 := range (*res1).UnknownExtKeyUsage {
// 		vec12 = vec12.Conjoin(elem12)
// 	}
// 	map1.Add(MakeKeyword("UnknownExtKeyUsage"), vec12)
// 	map1.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*res1).BasicConstraintsValid))
// 	map1.Add(MakeKeyword("IsCA"), MakeBool((*res1).IsCA))
// 	map1.Add(MakeKeyword("MaxPathLen"), MakeInt(int((*res1).MaxPathLen)))
// 	map1.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*res1).MaxPathLenZero))
// 	vec13 := EmptyVector
// 	for _, elem13 := range (*res1).SubjectKeyId {
// 		vec13 = vec13.Conjoin(MakeInt(int(elem13)))
// 	}
// 	map1.Add(MakeKeyword("SubjectKeyId"), vec13)
// 	vec14 := EmptyVector
// 	for _, elem14 := range (*res1).AuthorityKeyId {
// 		vec14 = vec14.Conjoin(MakeInt(int(elem14)))
// 	}
// 	map1.Add(MakeKeyword("AuthorityKeyId"), vec14)
// 	vec15 := EmptyVector
// 	for _, elem15 := range (*res1).OCSPServer {
// 		vec15 = vec15.Conjoin(MakeString(elem15))
// 	}
// 	map1.Add(MakeKeyword("OCSPServer"), vec15)
// 	vec16 := EmptyVector
// 	for _, elem16 := range (*res1).IssuingCertificateURL {
// 		vec16 = vec16.Conjoin(MakeString(elem16))
// 	}
// 	map1.Add(MakeKeyword("IssuingCertificateURL"), vec16)
// 	vec17 := EmptyVector
// 	for _, elem17 := range (*res1).DNSNames {
// 		vec17 = vec17.Conjoin(MakeString(elem17))
// 	}
// 	map1.Add(MakeKeyword("DNSNames"), vec17)
// 	vec18 := EmptyVector
// 	for _, elem18 := range (*res1).EmailAddresses {
// 		vec18 = vec18.Conjoin(MakeString(elem18))
// 	}
// 	map1.Add(MakeKeyword("EmailAddresses"), vec18)
// 	vec19 := EmptyVector
// 	for _, elem19 := range (*res1).IPAddresses {
// 		vec19 = vec19.Conjoin(elem19)
// 	}
// 	map1.Add(MakeKeyword("IPAddresses"), vec19)
// 	vec20 := EmptyVector
// 	for _, elem20 := range (*res1).URIs {
// 		vec20 = vec20.Conjoin((*elem20))
// 	}
// 	map1.Add(MakeKeyword("URIs"), vec20)
// 	map1.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*res1).PermittedDNSDomainsCritical))
// 	vec21 := EmptyVector
// 	for _, elem21 := range (*res1).PermittedDNSDomains {
// 		vec21 = vec21.Conjoin(MakeString(elem21))
// 	}
// 	map1.Add(MakeKeyword("PermittedDNSDomains"), vec21)
// 	vec22 := EmptyVector
// 	for _, elem22 := range (*res1).ExcludedDNSDomains {
// 		vec22 = vec22.Conjoin(MakeString(elem22))
// 	}
// 	map1.Add(MakeKeyword("ExcludedDNSDomains"), vec22)
// 	vec23 := EmptyVector
// 	for _, elem23 := range (*res1).PermittedIPRanges {
// 		vec23 = vec23.Conjoin((*elem23))
// 	}
// 	map1.Add(MakeKeyword("PermittedIPRanges"), vec23)
// 	vec24 := EmptyVector
// 	for _, elem24 := range (*res1).ExcludedIPRanges {
// 		vec24 = vec24.Conjoin((*elem24))
// 	}
// 	map1.Add(MakeKeyword("ExcludedIPRanges"), vec24)
// 	vec25 := EmptyVector
// 	for _, elem25 := range (*res1).PermittedEmailAddresses {
// 		vec25 = vec25.Conjoin(MakeString(elem25))
// 	}
// 	map1.Add(MakeKeyword("PermittedEmailAddresses"), vec25)
// 	vec26 := EmptyVector
// 	for _, elem26 := range (*res1).ExcludedEmailAddresses {
// 		vec26 = vec26.Conjoin(MakeString(elem26))
// 	}
// 	map1.Add(MakeKeyword("ExcludedEmailAddresses"), vec26)
// 	vec27 := EmptyVector
// 	for _, elem27 := range (*res1).PermittedURIDomains {
// 		vec27 = vec27.Conjoin(MakeString(elem27))
// 	}
// 	map1.Add(MakeKeyword("PermittedURIDomains"), vec27)
// 	vec28 := EmptyVector
// 	for _, elem28 := range (*res1).ExcludedURIDomains {
// 		vec28 = vec28.Conjoin(MakeString(elem28))
// 	}
// 	map1.Add(MakeKeyword("ExcludedURIDomains"), vec28)
// 	vec29 := EmptyVector
// 	for _, elem29 := range (*res1).CRLDistributionPoints {
// 		vec29 = vec29.Conjoin(MakeString(elem29))
// 	}
// 	map1.Add(MakeKeyword("CRLDistributionPoints"), vec29)
// 	vec30 := EmptyVector
// 	for _, elem30 := range (*res1).PolicyIdentifiers {
// 		vec30 = vec30.Conjoin(elem30)
// 	}
// 	map1.Add(MakeKeyword("PolicyIdentifiers"), vec30)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.ParseCertificateRequest has:
// func parseCertificateRequest(asn1Data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:2575:39)) Object {
// 	res1, res2 := _x509.ParseCertificateRequest(asn1Data)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Raw {
// 		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 	}
// 	map1.Add(MakeKeyword("Raw"), vec2)
// 	vec3 := EmptyVector
// 	for _, elem3 := range (*res1).RawTBSCertificateRequest {
// 		vec3 = vec3.Conjoin(MakeInt(int(elem3)))
// 	}
// 	map1.Add(MakeKeyword("RawTBSCertificateRequest"), vec3)
// 	vec4 := EmptyVector
// 	for _, elem4 := range (*res1).RawSubjectPublicKeyInfo {
// 		vec4 = vec4.Conjoin(MakeInt(int(elem4)))
// 	}
// 	map1.Add(MakeKeyword("RawSubjectPublicKeyInfo"), vec4)
// 	vec5 := EmptyVector
// 	for _, elem5 := range (*res1).RawSubject {
// 		vec5 = vec5.Conjoin(MakeInt(int(elem5)))
// 	}
// 	map1.Add(MakeKeyword("RawSubject"), vec5)
// 	map1.Add(MakeKeyword("Version"), MakeInt(int((*res1).Version)))
// 	vec6 := EmptyVector
// 	for _, elem6 := range (*res1).Signature {
// 		vec6 = vec6.Conjoin(MakeInt(int(elem6)))
// 	}
// 	map1.Add(MakeKeyword("Signature"), vec6)
// 	map1.Add(MakeKeyword("SignatureAlgorithm"), MakeInt(int((*res1).SignatureAlgorithm)))
// 	map1.Add(MakeKeyword("PublicKeyAlgorithm"), MakeInt(int((*res1).PublicKeyAlgorithm)))
// 	map1.Add(MakeKeyword("PublicKey"), (*res1).PublicKey)
// 	map1.Add(MakeKeyword("Subject"), (*res1).Subject)
// 	vec7 := EmptyVector
// 	for _, elem7 := range (*res1).Attributes {
// 		vec7 = vec7.Conjoin(elem7)
// 	}
// 	map1.Add(MakeKeyword("Attributes"), vec7)
// 	vec8 := EmptyVector
// 	for _, elem8 := range (*res1).Extensions {
// 		vec8 = vec8.Conjoin(elem8)
// 	}
// 	map1.Add(MakeKeyword("Extensions"), vec8)
// 	vec9 := EmptyVector
// 	for _, elem9 := range (*res1).ExtraExtensions {
// 		vec9 = vec9.Conjoin(elem9)
// 	}
// 	map1.Add(MakeKeyword("ExtraExtensions"), vec9)
// 	vec10 := EmptyVector
// 	for _, elem10 := range (*res1).DNSNames {
// 		vec10 = vec10.Conjoin(MakeString(elem10))
// 	}
// 	map1.Add(MakeKeyword("DNSNames"), vec10)
// 	vec11 := EmptyVector
// 	for _, elem11 := range (*res1).EmailAddresses {
// 		vec11 = vec11.Conjoin(MakeString(elem11))
// 	}
// 	map1.Add(MakeKeyword("EmailAddresses"), vec11)
// 	vec12 := EmptyVector
// 	for _, elem12 := range (*res1).IPAddresses {
// 		vec12 = vec12.Conjoin(elem12)
// 	}
// 	map1.Add(MakeKeyword("IPAddresses"), vec12)
// 	vec13 := EmptyVector
// 	for _, elem13 := range (*res1).URIs {
// 		vec13 = vec13.Conjoin((*elem13))
// 	}
// 	map1.Add(MakeKeyword("URIs"), vec13)
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.ParseCertificates has:
// func parseCertificates(asn1Data ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:1577:33)) Object {
// 	res1, res2 := _x509.ParseCertificates(asn1Data)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		map2 := EmptyArrayMap()
// 		vec3 := EmptyVector
// 		for _, elem3 := range (*elem1).Raw {
// 			vec3 = vec3.Conjoin(MakeInt(int(elem3)))
// 		}
// 		map2.Add(MakeKeyword("Raw"), vec3)
// 		vec4 := EmptyVector
// 		for _, elem4 := range (*elem1).RawTBSCertificate {
// 			vec4 = vec4.Conjoin(MakeInt(int(elem4)))
// 		}
// 		map2.Add(MakeKeyword("RawTBSCertificate"), vec4)
// 		vec5 := EmptyVector
// 		for _, elem5 := range (*elem1).RawSubjectPublicKeyInfo {
// 			vec5 = vec5.Conjoin(MakeInt(int(elem5)))
// 		}
// 		map2.Add(MakeKeyword("RawSubjectPublicKeyInfo"), vec5)
// 		vec6 := EmptyVector
// 		for _, elem6 := range (*elem1).RawSubject {
// 			vec6 = vec6.Conjoin(MakeInt(int(elem6)))
// 		}
// 		map2.Add(MakeKeyword("RawSubject"), vec6)
// 		vec7 := EmptyVector
// 		for _, elem7 := range (*elem1).RawIssuer {
// 			vec7 = vec7.Conjoin(MakeInt(int(elem7)))
// 		}
// 		map2.Add(MakeKeyword("RawIssuer"), vec7)
// 		vec8 := EmptyVector
// 		for _, elem8 := range (*elem1).Signature {
// 			vec8 = vec8.Conjoin(MakeInt(int(elem8)))
// 		}
// 		map2.Add(MakeKeyword("Signature"), vec8)
// 		map2.Add(MakeKeyword("SignatureAlgorithm"), MakeInt(int((*elem1).SignatureAlgorithm)))
// 		map2.Add(MakeKeyword("PublicKeyAlgorithm"), MakeInt(int((*elem1).PublicKeyAlgorithm)))
// 		map2.Add(MakeKeyword("PublicKey"), (*elem1).PublicKey)
// 		map2.Add(MakeKeyword("Version"), MakeInt(int((*elem1).Version)))
// 		map2.Add(MakeKeyword("SerialNumber"), (*(*elem1).SerialNumber))
// 		map2.Add(MakeKeyword("Issuer"), (*elem1).Issuer)
// 		map2.Add(MakeKeyword("Subject"), (*elem1).Subject)
// 		map2.Add(MakeKeyword("NotBefore"), (*elem1).NotBefore)
// 		map2.Add(MakeKeyword("NotAfter"), (*elem1).NotAfter)
// 		map2.Add(MakeKeyword("KeyUsage"), MakeInt(int((*elem1).KeyUsage)))
// 		vec9 := EmptyVector
// 		for _, elem9 := range (*elem1).Extensions {
// 			vec9 = vec9.Conjoin(elem9)
// 		}
// 		map2.Add(MakeKeyword("Extensions"), vec9)
// 		vec10 := EmptyVector
// 		for _, elem10 := range (*elem1).ExtraExtensions {
// 			vec10 = vec10.Conjoin(elem10)
// 		}
// 		map2.Add(MakeKeyword("ExtraExtensions"), vec10)
// 		vec11 := EmptyVector
// 		for _, elem11 := range (*elem1).UnhandledCriticalExtensions {
// 			vec11 = vec11.Conjoin(elem11)
// 		}
// 		map2.Add(MakeKeyword("UnhandledCriticalExtensions"), vec11)
// 		vec12 := EmptyVector
// 		for _, elem12 := range (*elem1).ExtKeyUsage {
// 			vec12 = vec12.Conjoin(MakeInt(int(elem12)))
// 		}
// 		map2.Add(MakeKeyword("ExtKeyUsage"), vec12)
// 		vec13 := EmptyVector
// 		for _, elem13 := range (*elem1).UnknownExtKeyUsage {
// 			vec13 = vec13.Conjoin(elem13)
// 		}
// 		map2.Add(MakeKeyword("UnknownExtKeyUsage"), vec13)
// 		map2.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*elem1).BasicConstraintsValid))
// 		map2.Add(MakeKeyword("IsCA"), MakeBool((*elem1).IsCA))
// 		map2.Add(MakeKeyword("MaxPathLen"), MakeInt(int((*elem1).MaxPathLen)))
// 		map2.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*elem1).MaxPathLenZero))
// 		vec14 := EmptyVector
// 		for _, elem14 := range (*elem1).SubjectKeyId {
// 			vec14 = vec14.Conjoin(MakeInt(int(elem14)))
// 		}
// 		map2.Add(MakeKeyword("SubjectKeyId"), vec14)
// 		vec15 := EmptyVector
// 		for _, elem15 := range (*elem1).AuthorityKeyId {
// 			vec15 = vec15.Conjoin(MakeInt(int(elem15)))
// 		}
// 		map2.Add(MakeKeyword("AuthorityKeyId"), vec15)
// 		vec16 := EmptyVector
// 		for _, elem16 := range (*elem1).OCSPServer {
// 			vec16 = vec16.Conjoin(MakeString(elem16))
// 		}
// 		map2.Add(MakeKeyword("OCSPServer"), vec16)
// 		vec17 := EmptyVector
// 		for _, elem17 := range (*elem1).IssuingCertificateURL {
// 			vec17 = vec17.Conjoin(MakeString(elem17))
// 		}
// 		map2.Add(MakeKeyword("IssuingCertificateURL"), vec17)
// 		vec18 := EmptyVector
// 		for _, elem18 := range (*elem1).DNSNames {
// 			vec18 = vec18.Conjoin(MakeString(elem18))
// 		}
// 		map2.Add(MakeKeyword("DNSNames"), vec18)
// 		vec19 := EmptyVector
// 		for _, elem19 := range (*elem1).EmailAddresses {
// 			vec19 = vec19.Conjoin(MakeString(elem19))
// 		}
// 		map2.Add(MakeKeyword("EmailAddresses"), vec19)
// 		vec20 := EmptyVector
// 		for _, elem20 := range (*elem1).IPAddresses {
// 			vec20 = vec20.Conjoin(elem20)
// 		}
// 		map2.Add(MakeKeyword("IPAddresses"), vec20)
// 		vec21 := EmptyVector
// 		for _, elem21 := range (*elem1).URIs {
// 			vec21 = vec21.Conjoin((*elem21))
// 		}
// 		map2.Add(MakeKeyword("URIs"), vec21)
// 		map2.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*elem1).PermittedDNSDomainsCritical))
// 		vec22 := EmptyVector
// 		for _, elem22 := range (*elem1).PermittedDNSDomains {
// 			vec22 = vec22.Conjoin(MakeString(elem22))
// 		}
// 		map2.Add(MakeKeyword("PermittedDNSDomains"), vec22)
// 		vec23 := EmptyVector
// 		for _, elem23 := range (*elem1).ExcludedDNSDomains {
// 			vec23 = vec23.Conjoin(MakeString(elem23))
// 		}
// 		map2.Add(MakeKeyword("ExcludedDNSDomains"), vec23)
// 		vec24 := EmptyVector
// 		for _, elem24 := range (*elem1).PermittedIPRanges {
// 			vec24 = vec24.Conjoin((*elem24))
// 		}
// 		map2.Add(MakeKeyword("PermittedIPRanges"), vec24)
// 		vec25 := EmptyVector
// 		for _, elem25 := range (*elem1).ExcludedIPRanges {
// 			vec25 = vec25.Conjoin((*elem25))
// 		}
// 		map2.Add(MakeKeyword("ExcludedIPRanges"), vec25)
// 		vec26 := EmptyVector
// 		for _, elem26 := range (*elem1).PermittedEmailAddresses {
// 			vec26 = vec26.Conjoin(MakeString(elem26))
// 		}
// 		map2.Add(MakeKeyword("PermittedEmailAddresses"), vec26)
// 		vec27 := EmptyVector
// 		for _, elem27 := range (*elem1).ExcludedEmailAddresses {
// 			vec27 = vec27.Conjoin(MakeString(elem27))
// 		}
// 		map2.Add(MakeKeyword("ExcludedEmailAddresses"), vec27)
// 		vec28 := EmptyVector
// 		for _, elem28 := range (*elem1).PermittedURIDomains {
// 			vec28 = vec28.Conjoin(MakeString(elem28))
// 		}
// 		map2.Add(MakeKeyword("PermittedURIDomains"), vec28)
// 		vec29 := EmptyVector
// 		for _, elem29 := range (*elem1).ExcludedURIDomains {
// 			vec29 = vec29.Conjoin(MakeString(elem29))
// 		}
// 		map2.Add(MakeKeyword("ExcludedURIDomains"), vec29)
// 		vec30 := EmptyVector
// 		for _, elem30 := range (*elem1).CRLDistributionPoints {
// 			vec30 = vec30.Conjoin(MakeString(elem30))
// 		}
// 		map2.Add(MakeKeyword("CRLDistributionPoints"), vec30)
// 		vec31 := EmptyVector
// 		for _, elem31 := range (*elem1).PolicyIdentifiers {
// 			vec31 = vec31.Conjoin(elem31)
// 		}
// 		map2.Add(MakeKeyword("PolicyIdentifiers"), vec31)
// 		vec1 = vec1.Conjoin(map2)
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.ParseDERCRL has:
// func parseDERCRL(derBytes ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:2190:27)) Object {
// 	res1, res2 := _x509.ParseDERCRL(derBytes)
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.ParseECPrivateKey has:
// func parseECPrivateKey(der ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/sec1.go:32:28)) Object {
// 	res1, res2 := _x509.ParseECPrivateKey(der)
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.ParsePKCS1PrivateKey has:
// func parsePKCS1PrivateKey(der ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pkcs1.go:45:31)) Object {
// 	res1, res2 := _x509.ParsePKCS1PrivateKey(der)
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.ParsePKCS1PublicKey has:
// func parsePKCS1PublicKey(der ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pkcs1.go:124:30)) Object {
// 	res1, res2 := _x509.ParsePKCS1PublicKey(der)
// 	res := EmptyVector
// 	res = res.Conjoin((*res1))
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC x509.ParsePKCS8PrivateKey has:
// func parsePKCS8PrivateKey(der ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/pkcs8.go:28:31)) Object {
// 	key, err := _x509.ParsePKCS8PrivateKey(der)
// 	res := EmptyVector
// 	res = res.Conjoin(key)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC x509.ParsePKIXPublicKey has:
// func parsePKIXPublicKey(derBytes ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/crypto/x509/x509.go:55:34)) Object {
// 	pub, err := _x509.ParsePKIXPublicKey(derBytes)
// 	res := EmptyVector
// 	res = res.Conjoin(pub)
// 	res = res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return res
// }

GO FUNC x509.SystemCertPool has:
func systemCertPool() Object {
	_, res2 := _x509.SystemCertPool()
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC xml.CopyToken has:
// func copyToken(t ABEND884(unrecognized type Token at: GO.link/src/encoding/xml/xml.go:122:18)) Object {
// 	return _xml.CopyToken(t)
// }

GO FUNC xml.Escape has:
// func escape(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/xml/xml.go:1985:15), s ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/encoding/xml/xml.go:1985:28)) Object {
// 	_xml.Escape(w, s)
// 	...ABEND675: TODO...
// }

GO FUNC xml.Marshal has:
// func marshal(v ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/xml/marshal.go:75:16)) Object {
// 	res1, res2 := _xml.Marshal(v)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC xml.MarshalIndent has:
// func marshalIndent(v ABEND882(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/xml/marshal.go:121:22), prefix string, indent string) Object {
// 	res1, res2 := _xml.MarshalIndent(v, prefix, indent)
// 	res := EmptyVector
// 	vec1 := EmptyVector
// 	for _, elem1 := range res1 {
// 		vec1 = vec1.Conjoin(MakeInt(int(elem1)))
// 	}
// 	res = res.Conjoin(vec1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC xml.NewDecoder has:
// func newDecoder(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/xml/xml.go:229:19)) Object {
// 	res := _xml.NewDecoder(r)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Strict"), MakeBool((*res).Strict))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).AutoClose {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("AutoClose"), vec2)
// 	map1.Add(MakeKeyword("Entity"), (*res).Entity)
// 	map1.Add(MakeKeyword("CharsetReader"), (*res).CharsetReader)
// 	map1.Add(MakeKeyword("DefaultSpace"), MakeString((*res).DefaultSpace))
// 	return map1
// }

GO FUNC xml.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/encoding/xml/marshal.go:137:19)) Object {
// 	return _xml.NewEncoder(w)
// 	ABEND124(no public information returned)
// }

GO FUNC xml.NewTokenDecoder has:
// func newTokenDecoder(t ABEND884(unrecognized type TokenReader at: GO.link/src/encoding/xml/xml.go:241:24)) Object {
// 	res := _xml.NewTokenDecoder(t)
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Strict"), MakeBool((*res).Strict))
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res).AutoClose {
// 		vec2 = vec2.Conjoin(MakeString(elem2))
// 	}
// 	map1.Add(MakeKeyword("AutoClose"), vec2)
// 	map1.Add(MakeKeyword("Entity"), (*res).Entity)
// 	map1.Add(MakeKeyword("CharsetReader"), (*res).CharsetReader)
// 	map1.Add(MakeKeyword("DefaultSpace"), MakeString((*res).DefaultSpace))
// 	return map1
// }

GO FUNC zip.FileInfoHeader has:
// func fileInfoHeader(fi ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/zip/struct.go:169:24)) Object {
// 	res1, res2 := _zip.FileInfoHeader(fi)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	map1.Add(MakeKeyword("Name"), MakeString((*res1).Name))
// 	map1.Add(MakeKeyword("Comment"), MakeString((*res1).Comment))
// 	map1.Add(MakeKeyword("NonUTF8"), MakeBool((*res1).NonUTF8))
// 	map1.Add(MakeKeyword("CreatorVersion"), MakeInt(int((*res1).CreatorVersion)))
// 	map1.Add(MakeKeyword("ReaderVersion"), MakeInt(int((*res1).ReaderVersion)))
// 	map1.Add(MakeKeyword("Flags"), MakeInt(int((*res1).Flags)))
// 	map1.Add(MakeKeyword("Method"), MakeInt(int((*res1).Method)))
// 	map1.Add(MakeKeyword("Modified"), (*res1).Modified)
// 	map1.Add(MakeKeyword("ModifiedTime"), MakeInt(int((*res1).ModifiedTime)))
// 	map1.Add(MakeKeyword("ModifiedDate"), MakeInt(int((*res1).ModifiedDate)))
// 	map1.Add(MakeKeyword("CRC32"), MakeInt(int((*res1).CRC32)))
// 	map1.Add(MakeKeyword("CompressedSize"), MakeInt(int((*res1).CompressedSize)))
// 	map1.Add(MakeKeyword("UncompressedSize"), MakeInt(int((*res1).UncompressedSize)))
// 	map1.Add(MakeKeyword("CompressedSize64"), )
// 	map1.Add(MakeKeyword("UncompressedSize64"), )
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).Extra {
// 		vec2 = vec2.Conjoin(MakeInt(int(elem2)))
// 	}
// 	map1.Add(MakeKeyword("Extra"), vec2)
// 	map1.Add(MakeKeyword("ExternalAttrs"), MakeInt(int((*res1).ExternalAttrs)))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC zip.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/zip/reader.go:71:18), size int64) Object {
// 	res1, res2 := _zip.NewReader(r, size)
// 	res := EmptyVector
// 	map1 := EmptyArrayMap()
// 	vec2 := EmptyVector
// 	for _, elem2 := range (*res1).File {
// 		vec2 = vec2.Conjoin(NIL)
// 	}
// 	map1.Add(MakeKeyword("File"), vec2)
// 	map1.Add(MakeKeyword("Comment"), MakeString((*res1).Comment))
// 	res = res.Conjoin(map1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC zip.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/archive/zip/writer.go:43:18)) Object {
// 	return _zip.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC zip.OpenReader has:
func openReader(name string) Object {
	_, res2 := _zip.OpenReader(name)
	res := EmptyVector
	res = res.Conjoin(NIL)
	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
	return res
}

GO FUNC zip.RegisterCompressor has:
// func registerCompressor(method uint16, comp ABEND884(unrecognized type Compressor at: GO.link/src/archive/zip/register.go:128:45)) Object {
// 	_zip.RegisterCompressor(method, comp)
// 	...ABEND675: TODO...
// }

GO FUNC zip.RegisterDecompressor has:
// func registerDecompressor(method uint16, dcomp ABEND884(unrecognized type Decompressor at: GO.link/src/archive/zip/register.go:120:48)) Object {
// 	_zip.RegisterDecompressor(method, dcomp)
// 	...ABEND675: TODO...
// }

GO FUNC zlib.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/reader.go:70:18)) Object {
// 	res1, res2 := _zlib.NewReader(r)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC zlib.NewReaderDict has:
// func newReaderDict(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/reader.go:79:22), dict ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/compress/zlib/reader.go:79:38)) Object {
// 	res1, res2 := _zlib.NewReaderDict(r, dict)
// 	res := EmptyVector
// 	res = res.Conjoin(res1)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC zlib.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/writer.go:43:18)) Object {
// 	return _zlib.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC zlib.NewWriterLevel has:
// func newWriterLevel(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/writer.go:54:23), level int) Object {
// 	_, res2 := _zlib.NewWriterLevel(w, level)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

GO FUNC zlib.NewWriterLevelDict has:
// func newWriterLevelDict(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: GO.link/src/compress/zlib/writer.go:63:27), level int, dict ABEND882(unrecognized Expr type *ast.ArrayType at: GO.link/src/compress/zlib/writer.go:63:54)) Object {
// 	_, res2 := _zlib.NewWriterLevelDict(w, level, dict)
// 	res := EmptyVector
// 	res = res.Conjoin(NIL)
// 	res = res.Conjoin(func () Object { if (res2) == nil { return NIL } else { return MakeError(res2) } }())
// 	return res
// }

Totals: types=968 functions=1482 receivers=5623
