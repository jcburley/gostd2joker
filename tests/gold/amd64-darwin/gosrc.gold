Walking from ../GOSRC to ../GOSRC/archive
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/archive/tar
Processing sourceDir=../GOSRC dump=false:
Package tar:
Processing package=tar:
Excluding ../GOSRC/archive/tar/testdata
Walking from ../GOSRC to ../GOSRC/archive/zip
Processing sourceDir=../GOSRC dump=false:
Package zip:
Processing package=zip:
Excluding ../GOSRC/archive/zip/testdata
Walking from ../GOSRC to ../GOSRC/bufio
Processing sourceDir=../GOSRC dump=false:
Package bufio:
Processing package=bufio:
Excluding ../GOSRC/builtin
Walking from ../GOSRC to ../GOSRC/bytes
Processing sourceDir=../GOSRC dump=false:
Package bytes:
Processing package=bytes:
Excluding ../GOSRC/cmd
Walking from ../GOSRC to ../GOSRC/compress
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/compress/bzip2
Processing sourceDir=../GOSRC dump=false:
Package bzip2:
Processing package=bzip2:
Excluding ../GOSRC/compress/bzip2/testdata
Walking from ../GOSRC to ../GOSRC/compress/flate
Processing sourceDir=../GOSRC dump=false:
Package flate:
Processing package=flate:
Excluding ../GOSRC/compress/flate/testdata
Walking from ../GOSRC to ../GOSRC/compress/gzip
Processing sourceDir=../GOSRC dump=false:
Package gzip:
Processing package=gzip:
Excluding ../GOSRC/compress/gzip/testdata
Walking from ../GOSRC to ../GOSRC/compress/lzw
Processing sourceDir=../GOSRC dump=false:
Package lzw:
Processing package=lzw:
Excluding ../GOSRC/compress/testdata
Walking from ../GOSRC to ../GOSRC/compress/zlib
Processing sourceDir=../GOSRC dump=false:
Package zlib:
Processing package=zlib:
Walking from ../GOSRC to ../GOSRC/container
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/container/heap
Processing sourceDir=../GOSRC dump=false:
Package heap:
Processing package=heap:
Walking from ../GOSRC to ../GOSRC/container/list
Processing sourceDir=../GOSRC dump=false:
Package list:
Processing package=list:
Walking from ../GOSRC to ../GOSRC/container/ring
Processing sourceDir=../GOSRC dump=false:
Package ring:
Processing package=ring:
Walking from ../GOSRC to ../GOSRC/context
Processing sourceDir=../GOSRC dump=false:
Package context:
Processing package=context:
Walking from ../GOSRC to ../GOSRC/crypto
Processing sourceDir=../GOSRC dump=false:
Package crypto:
Processing package=crypto:
Walking from ../GOSRC to ../GOSRC/crypto/aes
Processing sourceDir=../GOSRC dump=false:
Package aes:
Processing package=aes:
Walking from ../GOSRC to ../GOSRC/crypto/cipher
Processing sourceDir=../GOSRC dump=false:
Package cipher:
Processing package=cipher:
Walking from ../GOSRC to ../GOSRC/crypto/des
Processing sourceDir=../GOSRC dump=false:
Package des:
Processing package=des:
Walking from ../GOSRC to ../GOSRC/crypto/dsa
Processing sourceDir=../GOSRC dump=false:
Package dsa:
Processing package=dsa:
Walking from ../GOSRC to ../GOSRC/crypto/ecdsa
Processing sourceDir=../GOSRC dump=false:
Package ecdsa:
Processing package=ecdsa:
Excluding ../GOSRC/crypto/ecdsa/testdata
Walking from ../GOSRC to ../GOSRC/crypto/elliptic
Processing sourceDir=../GOSRC dump=false:
Package elliptic:
Processing package=elliptic:
Walking from ../GOSRC to ../GOSRC/crypto/hmac
Processing sourceDir=../GOSRC dump=false:
Package hmac:
Processing package=hmac:
Excluding ../GOSRC/crypto/internal
Walking from ../GOSRC to ../GOSRC/crypto/md5
Processing sourceDir=../GOSRC dump=false:
Package md5:
Processing package=md5:
Walking from ../GOSRC to ../GOSRC/crypto/rand
Processing sourceDir=../GOSRC dump=false:
Package rand:
Processing package=rand:
Walking from ../GOSRC to ../GOSRC/crypto/rc4
Processing sourceDir=../GOSRC dump=false:
Package rc4:
Processing package=rc4:
Walking from ../GOSRC to ../GOSRC/crypto/rsa
Processing sourceDir=../GOSRC dump=false:
Package rsa:
Processing package=rsa:
Excluding ../GOSRC/crypto/rsa/testdata
Walking from ../GOSRC to ../GOSRC/crypto/sha1
Processing sourceDir=../GOSRC dump=false:
Package sha1:
Processing package=sha1:
Walking from ../GOSRC to ../GOSRC/crypto/sha256
Processing sourceDir=../GOSRC dump=false:
Package sha256:
Processing package=sha256:
Walking from ../GOSRC to ../GOSRC/crypto/sha512
Processing sourceDir=../GOSRC dump=false:
Package sha512:
Processing package=sha512:
Walking from ../GOSRC to ../GOSRC/crypto/subtle
Processing sourceDir=../GOSRC dump=false:
Package subtle:
Processing package=subtle:
Walking from ../GOSRC to ../GOSRC/crypto/tls
Processing sourceDir=../GOSRC dump=false:
Package tls:
Processing package=tls:
Excluding ../GOSRC/crypto/tls/testdata
Walking from ../GOSRC to ../GOSRC/crypto/x509
Processing sourceDir=../GOSRC dump=false:
Package x509:
Processing package=x509:
Walking from ../GOSRC to ../GOSRC/crypto/x509/pkix
Processing sourceDir=../GOSRC dump=false:
Package pkix:
Processing package=pkix:
Excluding ../GOSRC/crypto/x509/testdata
Walking from ../GOSRC to ../GOSRC/database
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/database/sql
Processing sourceDir=../GOSRC dump=false:
Package sql:
Processing package=sql:
Walking from ../GOSRC to ../GOSRC/database/sql/driver
Processing sourceDir=../GOSRC dump=false:
Package driver:
Processing package=driver:
Walking from ../GOSRC to ../GOSRC/debug
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/debug/dwarf
Processing sourceDir=../GOSRC dump=false:
Package dwarf:
Processing package=dwarf:
Excluding ../GOSRC/debug/dwarf/testdata
Walking from ../GOSRC to ../GOSRC/debug/elf
Processing sourceDir=../GOSRC dump=false:
Package elf:
Processing package=elf:
Excluding ../GOSRC/debug/elf/testdata
Walking from ../GOSRC to ../GOSRC/debug/gosym
Processing sourceDir=../GOSRC dump=false:
Package gosym:
Processing package=gosym:
Walking from ../GOSRC to ../GOSRC/debug/macho
Processing sourceDir=../GOSRC dump=false:
Package macho:
Processing package=macho:
Excluding ../GOSRC/debug/macho/testdata
Walking from ../GOSRC to ../GOSRC/debug/pe
Processing sourceDir=../GOSRC dump=false:
Package pe:
Processing package=pe:
Excluding ../GOSRC/debug/pe/testdata
Walking from ../GOSRC to ../GOSRC/debug/plan9obj
Processing sourceDir=../GOSRC dump=false:
Package plan9obj:
Processing package=plan9obj:
Excluding ../GOSRC/debug/plan9obj/testdata
Walking from ../GOSRC to ../GOSRC/encoding
Processing sourceDir=../GOSRC dump=false:
Package encoding:
Processing package=encoding:
Walking from ../GOSRC to ../GOSRC/encoding/ascii85
Processing sourceDir=../GOSRC dump=false:
Package ascii85:
Processing package=ascii85:
Walking from ../GOSRC to ../GOSRC/encoding/asn1
Processing sourceDir=../GOSRC dump=false:
Package asn1:
Processing package=asn1:
Walking from ../GOSRC to ../GOSRC/encoding/base32
Processing sourceDir=../GOSRC dump=false:
Package base32:
Processing package=base32:
Walking from ../GOSRC to ../GOSRC/encoding/base64
Processing sourceDir=../GOSRC dump=false:
Package base64:
Processing package=base64:
Walking from ../GOSRC to ../GOSRC/encoding/binary
Processing sourceDir=../GOSRC dump=false:
Package binary:
Processing package=binary:
Walking from ../GOSRC to ../GOSRC/encoding/csv
Processing sourceDir=../GOSRC dump=false:
Package csv:
Processing package=csv:
Walking from ../GOSRC to ../GOSRC/encoding/gob
Processing sourceDir=../GOSRC dump=false:
Package gob:
Processing package=gob:
Walking from ../GOSRC to ../GOSRC/encoding/hex
Processing sourceDir=../GOSRC dump=false:
Package hex:
Processing package=hex:
Walking from ../GOSRC to ../GOSRC/encoding/json
Processing sourceDir=../GOSRC dump=false:
Package json:
Processing package=json:
Excluding ../GOSRC/encoding/json/testdata
Walking from ../GOSRC to ../GOSRC/encoding/pem
Processing sourceDir=../GOSRC dump=false:
Package pem:
Processing package=pem:
Walking from ../GOSRC to ../GOSRC/encoding/xml
Processing sourceDir=../GOSRC dump=false:
Package xml:
Processing package=xml:
Walking from ../GOSRC to ../GOSRC/errors
Processing sourceDir=../GOSRC dump=false:
Package errors:
Processing package=errors:
Walking from ../GOSRC to ../GOSRC/expvar
Processing sourceDir=../GOSRC dump=false:
Package expvar:
Processing package=expvar:
Walking from ../GOSRC to ../GOSRC/flag
Processing sourceDir=../GOSRC dump=false:
Package flag:
Processing package=flag:
Walking from ../GOSRC to ../GOSRC/fmt
Processing sourceDir=../GOSRC dump=false:
Package fmt:
Processing package=fmt:
Walking from ../GOSRC to ../GOSRC/go
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/go/ast
Processing sourceDir=../GOSRC dump=false:
Package ast:
Processing package=ast:
Walking from ../GOSRC to ../GOSRC/go/build
Processing sourceDir=../GOSRC dump=false:
Package build:
Processing package=build:
Excluding ../GOSRC/go/build/testdata
Walking from ../GOSRC to ../GOSRC/go/constant
Processing sourceDir=../GOSRC dump=false:
Package constant:
Processing package=constant:
Walking from ../GOSRC to ../GOSRC/go/doc
Processing sourceDir=../GOSRC dump=false:
Package doc:
Processing package=doc:
Excluding ../GOSRC/go/doc/testdata
Walking from ../GOSRC to ../GOSRC/go/format
Processing sourceDir=../GOSRC dump=false:
Package format:
Processing package=format:
Walking from ../GOSRC to ../GOSRC/go/importer
Processing sourceDir=../GOSRC dump=false:
Package importer:
Processing package=importer:
Excluding ../GOSRC/go/internal
Walking from ../GOSRC to ../GOSRC/go/parser
Processing sourceDir=../GOSRC dump=false:
Package parser:
Processing package=parser:
Excluding ../GOSRC/go/parser/testdata
Walking from ../GOSRC to ../GOSRC/go/printer
Processing sourceDir=../GOSRC dump=false:
Package printer:
Processing package=printer:
Excluding ../GOSRC/go/printer/testdata
Walking from ../GOSRC to ../GOSRC/go/scanner
Processing sourceDir=../GOSRC dump=false:
Package scanner:
Processing package=scanner:
Walking from ../GOSRC to ../GOSRC/go/token
Processing sourceDir=../GOSRC dump=false:
Package token:
Processing package=token:
Walking from ../GOSRC to ../GOSRC/go/types
Processing sourceDir=../GOSRC dump=false:
Package types:
Processing package=types:
Excluding ../GOSRC/go/types/testdata
Walking from ../GOSRC to ../GOSRC/hash
Processing sourceDir=../GOSRC dump=false:
Package hash:
Processing package=hash:
Walking from ../GOSRC to ../GOSRC/hash/adler32
Processing sourceDir=../GOSRC dump=false:
Package adler32:
Processing package=adler32:
Walking from ../GOSRC to ../GOSRC/hash/crc32
Processing sourceDir=../GOSRC dump=false:
Package crc32:
Processing package=crc32:
Walking from ../GOSRC to ../GOSRC/hash/crc64
Processing sourceDir=../GOSRC dump=false:
Package crc64:
Processing package=crc64:
Walking from ../GOSRC to ../GOSRC/hash/fnv
Processing sourceDir=../GOSRC dump=false:
Package fnv:
Processing package=fnv:
Walking from ../GOSRC to ../GOSRC/html
Processing sourceDir=../GOSRC dump=false:
Package html:
Processing package=html:
Walking from ../GOSRC to ../GOSRC/html/template
Processing sourceDir=../GOSRC dump=false:
Package template:
Processing package=template:
Walking from ../GOSRC to ../GOSRC/image
Processing sourceDir=../GOSRC dump=false:
Package image:
Processing package=image:
Walking from ../GOSRC to ../GOSRC/image/color
Processing sourceDir=../GOSRC dump=false:
Package color:
Processing package=color:
Walking from ../GOSRC to ../GOSRC/image/color/palette
Processing sourceDir=../GOSRC dump=false:
Package palette:
Processing package=palette:
Walking from ../GOSRC to ../GOSRC/image/draw
Processing sourceDir=../GOSRC dump=false:
Package draw:
Processing package=draw:
Walking from ../GOSRC to ../GOSRC/image/gif
Processing sourceDir=../GOSRC dump=false:
Package gif:
Processing package=gif:
Excluding ../GOSRC/image/internal
Walking from ../GOSRC to ../GOSRC/image/jpeg
Processing sourceDir=../GOSRC dump=false:
Package jpeg:
Processing package=jpeg:
Walking from ../GOSRC to ../GOSRC/image/png
Processing sourceDir=../GOSRC dump=false:
Package png:
Processing package=png:
Excluding ../GOSRC/image/png/testdata
Excluding ../GOSRC/image/testdata
Walking from ../GOSRC to ../GOSRC/index
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/index/suffixarray
Processing sourceDir=../GOSRC dump=false:
Package suffixarray:
Processing package=suffixarray:
Excluding ../GOSRC/internal
Walking from ../GOSRC to ../GOSRC/io
Processing sourceDir=../GOSRC dump=false:
Package io:
Processing package=io:
Walking from ../GOSRC to ../GOSRC/io/ioutil
Processing sourceDir=../GOSRC dump=false:
Package ioutil:
Processing package=ioutil:
Excluding ../GOSRC/io/ioutil/testdata
Walking from ../GOSRC to ../GOSRC/log
Processing sourceDir=../GOSRC dump=false:
Package log:
Processing package=log:
Walking from ../GOSRC to ../GOSRC/log/syslog
Processing sourceDir=../GOSRC dump=false:
Package syslog:
Processing package=syslog:
Walking from ../GOSRC to ../GOSRC/math
Processing sourceDir=../GOSRC dump=false:
Package math:
Processing package=math:
Walking from ../GOSRC to ../GOSRC/math/big
Processing sourceDir=../GOSRC dump=false:
Package big:
Processing package=big:
Walking from ../GOSRC to ../GOSRC/math/bits
Processing sourceDir=../GOSRC dump=false:
Package bits:
Processing package=bits:
Walking from ../GOSRC to ../GOSRC/math/cmplx
Processing sourceDir=../GOSRC dump=false:
Package cmplx:
Processing package=cmplx:
Walking from ../GOSRC to ../GOSRC/math/rand
Processing sourceDir=../GOSRC dump=false:
Package rand:
Processing package=rand:
Walking from ../GOSRC to ../GOSRC/mime
Processing sourceDir=../GOSRC dump=false:
Package mime:
Processing package=mime:
Walking from ../GOSRC to ../GOSRC/mime/multipart
Processing sourceDir=../GOSRC dump=false:
Package multipart:
Processing package=multipart:
Excluding ../GOSRC/mime/multipart/testdata
Walking from ../GOSRC to ../GOSRC/mime/quotedprintable
Processing sourceDir=../GOSRC dump=false:
Package quotedprintable:
Processing package=quotedprintable:
Excluding ../GOSRC/mime/testdata
Walking from ../GOSRC to ../GOSRC/net
Processing sourceDir=../GOSRC dump=false:
Package net:
Processing package=net:
Walking from ../GOSRC to ../GOSRC/net/http
Processing sourceDir=../GOSRC dump=false:
Package http:
Processing package=http:
Walking from ../GOSRC to ../GOSRC/net/http/cgi
Processing sourceDir=../GOSRC dump=false:
Package cgi:
Processing package=cgi:
Excluding ../GOSRC/net/http/cgi/testdata
Walking from ../GOSRC to ../GOSRC/net/http/cookiejar
Processing sourceDir=../GOSRC dump=false:
Package cookiejar:
Processing package=cookiejar:
Walking from ../GOSRC to ../GOSRC/net/http/fcgi
Processing sourceDir=../GOSRC dump=false:
Package fcgi:
Processing package=fcgi:
Walking from ../GOSRC to ../GOSRC/net/http/httptest
Processing sourceDir=../GOSRC dump=false:
Package httptest:
Processing package=httptest:
Walking from ../GOSRC to ../GOSRC/net/http/httptrace
Processing sourceDir=../GOSRC dump=false:
Package httptrace:
Processing package=httptrace:
Walking from ../GOSRC to ../GOSRC/net/http/httputil
Processing sourceDir=../GOSRC dump=false:
Package httputil:
Processing package=httputil:
Excluding ../GOSRC/net/http/internal
Walking from ../GOSRC to ../GOSRC/net/http/pprof
Processing sourceDir=../GOSRC dump=false:
Package pprof:
Processing package=pprof:
Excluding ../GOSRC/net/http/testdata
Excluding ../GOSRC/net/internal
Walking from ../GOSRC to ../GOSRC/net/mail
Processing sourceDir=../GOSRC dump=false:
Package mail:
Processing package=mail:
Walking from ../GOSRC to ../GOSRC/net/rpc
Processing sourceDir=../GOSRC dump=false:
Package rpc:
Processing package=rpc:
Walking from ../GOSRC to ../GOSRC/net/rpc/jsonrpc
Processing sourceDir=../GOSRC dump=false:
Package jsonrpc:
Processing package=jsonrpc:
Walking from ../GOSRC to ../GOSRC/net/smtp
Processing sourceDir=../GOSRC dump=false:
Package smtp:
Processing package=smtp:
Excluding ../GOSRC/net/testdata
Walking from ../GOSRC to ../GOSRC/net/textproto
Processing sourceDir=../GOSRC dump=false:
Package textproto:
Processing package=textproto:
Walking from ../GOSRC to ../GOSRC/net/url
Processing sourceDir=../GOSRC dump=false:
Package url:
Processing package=url:
Walking from ../GOSRC to ../GOSRC/os
Processing sourceDir=../GOSRC dump=false:
Package os:
Processing package=os:
Walking from ../GOSRC to ../GOSRC/os/exec
Processing sourceDir=../GOSRC dump=false:
Package exec:
Processing package=exec:
Walking from ../GOSRC to ../GOSRC/os/signal
Processing sourceDir=../GOSRC dump=false:
Package signal:
Processing package=signal:
Excluding ../GOSRC/os/signal/internal
Walking from ../GOSRC to ../GOSRC/os/user
Processing sourceDir=../GOSRC dump=false:
Package user:
Processing package=user:
Walking from ../GOSRC to ../GOSRC/path
Processing sourceDir=../GOSRC dump=false:
Package path:
Processing package=path:
Walking from ../GOSRC to ../GOSRC/path/filepath
Processing sourceDir=../GOSRC dump=false:
Package filepath:
Processing package=filepath:
Walking from ../GOSRC to ../GOSRC/plugin
Processing sourceDir=../GOSRC dump=false:
Package plugin:
Processing package=plugin:
Walking from ../GOSRC to ../GOSRC/reflect
Processing sourceDir=../GOSRC dump=false:
Package reflect:
Processing package=reflect:
Walking from ../GOSRC to ../GOSRC/regexp
Processing sourceDir=../GOSRC dump=false:
Package regexp:
Processing package=regexp:
Walking from ../GOSRC to ../GOSRC/regexp/syntax
Processing sourceDir=../GOSRC dump=false:
Package syntax:
Processing package=syntax:
Excluding ../GOSRC/regexp/testdata
Walking from ../GOSRC to ../GOSRC/runtime
Processing sourceDir=../GOSRC dump=false:
Package runtime:
Processing package=runtime:
Walking from ../GOSRC to ../GOSRC/runtime/cgo
Processing sourceDir=../GOSRC dump=false:
Package cgo:
Processing package=cgo:
Walking from ../GOSRC to ../GOSRC/runtime/debug
Processing sourceDir=../GOSRC dump=false:
Package debug:
Processing package=debug:
Excluding ../GOSRC/runtime/internal
Walking from ../GOSRC to ../GOSRC/runtime/msan
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/runtime/pprof
Processing sourceDir=../GOSRC dump=false:
Package pprof:
Processing package=pprof:
Excluding ../GOSRC/runtime/pprof/internal
Excluding ../GOSRC/runtime/pprof/testdata
Walking from ../GOSRC to ../GOSRC/runtime/race
Processing sourceDir=../GOSRC dump=false:
Package race:
Processing package=race:
Excluding ../GOSRC/runtime/race/testdata
Excluding ../GOSRC/runtime/testdata
Walking from ../GOSRC to ../GOSRC/runtime/trace
Processing sourceDir=../GOSRC dump=false:
Package trace:
Processing package=trace:
Walking from ../GOSRC to ../GOSRC/sort
Processing sourceDir=../GOSRC dump=false:
Package sort:
Processing package=sort:
Walking from ../GOSRC to ../GOSRC/strconv
Processing sourceDir=../GOSRC dump=false:
Package strconv:
Processing package=strconv:
Excluding ../GOSRC/strconv/testdata
Walking from ../GOSRC to ../GOSRC/strings
Processing sourceDir=../GOSRC dump=false:
Package strings:
Processing package=strings:
Walking from ../GOSRC to ../GOSRC/sync
Processing sourceDir=../GOSRC dump=false:
Package sync:
Processing package=sync:
Walking from ../GOSRC to ../GOSRC/sync/atomic
Processing sourceDir=../GOSRC dump=false:
Package atomic:
Processing package=atomic:
Walking from ../GOSRC to ../GOSRC/syscall
Processing sourceDir=../GOSRC dump=false:
Package syscall:
Processing package=syscall:
Walking from ../GOSRC to ../GOSRC/syscall/js
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/testing
Processing sourceDir=../GOSRC dump=false:
Package testing:
Processing package=testing:
Excluding ../GOSRC/testing/internal
Walking from ../GOSRC to ../GOSRC/testing/iotest
Processing sourceDir=../GOSRC dump=false:
Package iotest:
Processing package=iotest:
Walking from ../GOSRC to ../GOSRC/testing/quick
Processing sourceDir=../GOSRC dump=false:
Package quick:
Processing package=quick:
Walking from ../GOSRC to ../GOSRC/text
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/text/scanner
Processing sourceDir=../GOSRC dump=false:
Package scanner:
Processing package=scanner:
Walking from ../GOSRC to ../GOSRC/text/tabwriter
Processing sourceDir=../GOSRC dump=false:
Package tabwriter:
Processing package=tabwriter:
Walking from ../GOSRC to ../GOSRC/text/template
Processing sourceDir=../GOSRC dump=false:
Package template:
Processing package=template:
Walking from ../GOSRC to ../GOSRC/text/template/parse
Processing sourceDir=../GOSRC dump=false:
Package parse:
Processing package=parse:
Excluding ../GOSRC/text/template/testdata
Walking from ../GOSRC to ../GOSRC/time
Processing sourceDir=../GOSRC dump=false:
Package time:
Processing package=time:
Walking from ../GOSRC to ../GOSRC/unicode
Processing sourceDir=../GOSRC dump=false:
Package unicode:
Processing package=unicode:
Walking from ../GOSRC to ../GOSRC/unicode/utf16
Processing sourceDir=../GOSRC dump=false:
Package utf16:
Processing package=utf16:
Walking from ../GOSRC to ../GOSRC/unicode/utf8
Processing sourceDir=../GOSRC dump=false:
Package utf8:
Processing package=utf8:
Walking from ../GOSRC to ../GOSRC/unsafe
Processing sourceDir=../GOSRC dump=false:
Package unsafe:
Processing package=unsafe:
Walking from ../GOSRC to ../GOSRC/vendor
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto/chacha20poly1305
Processing sourceDir=../GOSRC dump=false:
Package chacha20poly1305:
Processing package=chacha20poly1305:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto/cryptobyte
Processing sourceDir=../GOSRC dump=false:
Package cryptobyte:
Processing package=cryptobyte:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/asn1
Processing sourceDir=../GOSRC dump=false:
Package asn1:
Processing package=asn1:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto/curve25519
Processing sourceDir=../GOSRC dump=false:
Package curve25519:
Processing package=curve25519:
Excluding ../GOSRC/vendor/golang_org/x/crypto/internal
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto/poly1305
Processing sourceDir=../GOSRC dump=false:
Package poly1305:
Processing package=poly1305:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/dns
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage
Processing sourceDir=../GOSRC dump=false:
Package dnsmessage:
Processing package=dnsmessage:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/http
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/http/httpguts
Processing sourceDir=../GOSRC dump=false:
Package httpguts:
Processing package=httpguts:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/http/httpproxy
Processing sourceDir=../GOSRC dump=false:
Package httpproxy:
Processing package=httpproxy:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/http2
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/http2/hpack
Processing sourceDir=../GOSRC dump=false:
Package hpack:
Processing package=hpack:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/idna
Processing sourceDir=../GOSRC dump=false:
Package idna:
Processing package=idna:
Excluding ../GOSRC/vendor/golang_org/x/net/internal
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/lif
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/nettest
Processing sourceDir=../GOSRC dump=false:
Package nettest:
Processing package=nettest:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/route
Processing sourceDir=../GOSRC dump=false:
Package route:
Processing package=route:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/secure
Processing sourceDir=../GOSRC dump=false:
Package secure:
Processing package=secure:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/secure/bidirule
Processing sourceDir=../GOSRC dump=false:
Package bidirule:
Processing package=bidirule:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/transform
Processing sourceDir=../GOSRC dump=false:
Package transform:
Processing package=transform:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/unicode
Processing sourceDir=../GOSRC dump=false:
Package unicode:
Processing package=unicode:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/unicode/bidi
Processing sourceDir=../GOSRC dump=false:
Package bidi:
Processing package=bidi:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/unicode/norm
Processing sourceDir=../GOSRC dump=false:
Package norm:
Processing package=norm:
NOTE: Already seen function rand.Int in ../GOSRC/crypto/rand/util.go, yet again in ../GOSRC/math/rand/rand.go
NOTE: Already seen function rand.Read in ../GOSRC/crypto/rand/rand.go, yet again in ../GOSRC/math/rand/rand.go
NOTE: Already seen function template.HTMLEscape in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.HTMLEscapeString in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.HTMLEscaper in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.IsTrue in ../GOSRC/html/template/template.go, yet again in ../GOSRC/text/template/exec.go
NOTE: Already seen function template.JSEscape in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.JSEscapeString in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.JSEscaper in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.Must in ../GOSRC/html/template/template.go, yet again in ../GOSRC/text/template/helper.go
NOTE: Already seen function template.New in ../GOSRC/html/template/template.go, yet again in ../GOSRC/text/template/template.go
NOTE: Already seen function template.ParseFiles in ../GOSRC/html/template/template.go, yet again in ../GOSRC/text/template/helper.go
NOTE: Already seen function template.ParseGlob in ../GOSRC/html/template/template.go, yet again in ../GOSRC/text/template/helper.go
NOTE: Already seen function template.URLQueryEscaper in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
TYPE aes.KeySizeError:
  ../GOSRC/crypto/aes/cipher.go
TYPE ascii85.CorruptInputError:
  ../GOSRC/encoding/ascii85/ascii85.go
TYPE asn1.BitString:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.Enumerated:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.Flag:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.ObjectIdentifier:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.RawContent:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.RawValue:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.StructuralError:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.SyntaxError:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.Tag:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/asn1/asn1.go
TYPE ast.ArrayType:
  ../GOSRC/go/ast/ast.go
TYPE ast.AssignStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.BadDecl:
  ../GOSRC/go/ast/ast.go
TYPE ast.BadExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.BadStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.BasicLit:
  ../GOSRC/go/ast/ast.go
TYPE ast.BinaryExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.BlockStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.BranchStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.CallExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.CaseClause:
  ../GOSRC/go/ast/ast.go
TYPE ast.ChanDir:
  ../GOSRC/go/ast/ast.go
TYPE ast.ChanType:
  ../GOSRC/go/ast/ast.go
TYPE ast.CommClause:
  ../GOSRC/go/ast/ast.go
TYPE ast.Comment:
  ../GOSRC/go/ast/ast.go
TYPE ast.CommentGroup:
  ../GOSRC/go/ast/ast.go
TYPE ast.CommentMap:
  ../GOSRC/go/ast/commentmap.go
TYPE ast.CompositeLit:
  ../GOSRC/go/ast/ast.go
TYPE ast.Decl:
  ../GOSRC/go/ast/ast.go
TYPE ast.DeclStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.DeferStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.Ellipsis:
  ../GOSRC/go/ast/ast.go
TYPE ast.EmptyStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.Expr:
  ../GOSRC/go/ast/ast.go
TYPE ast.ExprStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.Field:
  ../GOSRC/go/ast/ast.go
TYPE ast.FieldFilter:
  ../GOSRC/go/ast/print.go
TYPE ast.FieldList:
  ../GOSRC/go/ast/ast.go
TYPE ast.File:
  ../GOSRC/go/ast/ast.go
TYPE ast.Filter:
  ../GOSRC/go/ast/filter.go
TYPE ast.ForStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.FuncDecl:
  ../GOSRC/go/ast/ast.go
TYPE ast.FuncLit:
  ../GOSRC/go/ast/ast.go
TYPE ast.FuncType:
  ../GOSRC/go/ast/ast.go
TYPE ast.GenDecl:
  ../GOSRC/go/ast/ast.go
TYPE ast.GoStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.Ident:
  ../GOSRC/go/ast/ast.go
TYPE ast.IfStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.ImportSpec:
  ../GOSRC/go/ast/ast.go
TYPE ast.Importer:
  ../GOSRC/go/ast/resolve.go
TYPE ast.IncDecStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.IndexExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.InterfaceType:
  ../GOSRC/go/ast/ast.go
TYPE ast.KeyValueExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.LabeledStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.MapType:
  ../GOSRC/go/ast/ast.go
TYPE ast.MergeMode:
  ../GOSRC/go/ast/filter.go
TYPE ast.Node:
  ../GOSRC/go/ast/ast.go
TYPE ast.ObjKind:
  ../GOSRC/go/ast/scope.go
TYPE ast.Object:
  ../GOSRC/go/ast/scope.go
TYPE ast.Package:
  ../GOSRC/go/ast/ast.go
TYPE ast.ParenExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.RangeStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.ReturnStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.Scope:
  ../GOSRC/go/ast/scope.go
TYPE ast.SelectStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.SelectorExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.SendStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.SliceExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.Spec:
  ../GOSRC/go/ast/ast.go
TYPE ast.StarExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.Stmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.StructType:
  ../GOSRC/go/ast/ast.go
TYPE ast.SwitchStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.TypeAssertExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.TypeSpec:
  ../GOSRC/go/ast/ast.go
TYPE ast.TypeSwitchStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.UnaryExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.ValueSpec:
  ../GOSRC/go/ast/ast.go
TYPE ast.Visitor:
  ../GOSRC/go/ast/walk.go
TYPE atomic.Value:
  ../GOSRC/sync/atomic/value.go
TYPE base32.CorruptInputError:
  ../GOSRC/encoding/base32/base32.go
TYPE base32.Encoding:
  ../GOSRC/encoding/base32/base32.go
TYPE base64.CorruptInputError:
  ../GOSRC/encoding/base64/base64.go
TYPE base64.Encoding:
  ../GOSRC/encoding/base64/base64.go
TYPE bidi.Class:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/trieval.go
TYPE bidi.Direction:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Option:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Ordering:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Paragraph:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Properties:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/prop.go
TYPE bidi.Run:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidirule.Transformer:
  ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go
TYPE big.Accuracy:
  ../GOSRC/math/big/float.go
TYPE big.ErrNaN:
  ../GOSRC/math/big/float.go
TYPE big.Float:
  ../GOSRC/math/big/float.go
TYPE big.Int:
  ../GOSRC/math/big/int.go
TYPE big.Rat:
  ../GOSRC/math/big/rat.go
TYPE big.RoundingMode:
  ../GOSRC/math/big/float.go
TYPE big.Word:
  ../GOSRC/math/big/arith.go
TYPE binary.ByteOrder:
  ../GOSRC/encoding/binary/binary.go
TYPE bufio.ReadWriter:
  ../GOSRC/bufio/bufio.go
TYPE bufio.Reader:
  ../GOSRC/bufio/bufio.go
TYPE bufio.Scanner:
  ../GOSRC/bufio/scan.go
TYPE bufio.SplitFunc:
  ../GOSRC/bufio/scan.go
TYPE bufio.Writer:
  ../GOSRC/bufio/bufio.go
TYPE build.Context:
  ../GOSRC/go/build/build.go
TYPE build.ImportMode:
  ../GOSRC/go/build/build.go
TYPE build.MultiplePackageError:
  ../GOSRC/go/build/build.go
TYPE build.NoGoError:
  ../GOSRC/go/build/build.go
TYPE build.Package:
  ../GOSRC/go/build/build.go
TYPE bytes.Buffer:
  ../GOSRC/bytes/buffer.go
TYPE bytes.Reader:
  ../GOSRC/bytes/reader.go
TYPE bzip2.StructuralError:
  ../GOSRC/compress/bzip2/bzip2.go
TYPE cgi.Handler:
  ../GOSRC/net/http/cgi/host.go
TYPE cipher.AEAD:
  ../GOSRC/crypto/cipher/gcm.go
TYPE cipher.Block:
  ../GOSRC/crypto/cipher/cipher.go
TYPE cipher.BlockMode:
  ../GOSRC/crypto/cipher/cipher.go
TYPE cipher.Stream:
  ../GOSRC/crypto/cipher/cipher.go
TYPE cipher.StreamReader:
  ../GOSRC/crypto/cipher/io.go
TYPE cipher.StreamWriter:
  ../GOSRC/crypto/cipher/io.go
TYPE color.Alpha:
  ../GOSRC/image/color/color.go
TYPE color.Alpha16:
  ../GOSRC/image/color/color.go
TYPE color.CMYK:
  ../GOSRC/image/color/ycbcr.go
TYPE color.Color:
  ../GOSRC/image/color/color.go
TYPE color.Gray:
  ../GOSRC/image/color/color.go
TYPE color.Gray16:
  ../GOSRC/image/color/color.go
TYPE color.Model:
  ../GOSRC/image/color/color.go
TYPE color.NRGBA:
  ../GOSRC/image/color/color.go
TYPE color.NRGBA64:
  ../GOSRC/image/color/color.go
TYPE color.NYCbCrA:
  ../GOSRC/image/color/ycbcr.go
TYPE color.Palette:
  ../GOSRC/image/color/color.go
TYPE color.RGBA:
  ../GOSRC/image/color/color.go
TYPE color.RGBA64:
  ../GOSRC/image/color/color.go
TYPE color.YCbCr:
  ../GOSRC/image/color/ycbcr.go
TYPE constant.Kind:
  ../GOSRC/go/constant/value.go
TYPE constant.Value:
  ../GOSRC/go/constant/value.go
TYPE context.CancelFunc:
  ../GOSRC/context/context.go
TYPE context.Context:
  ../GOSRC/context/context.go
TYPE cookiejar.Jar:
  ../GOSRC/net/http/cookiejar/jar.go
TYPE cookiejar.Options:
  ../GOSRC/net/http/cookiejar/jar.go
TYPE cookiejar.PublicSuffixList:
  ../GOSRC/net/http/cookiejar/jar.go
TYPE crc32.Table:
  ../GOSRC/hash/crc32/crc32.go
TYPE crc64.Table:
  ../GOSRC/hash/crc64/crc64.go
TYPE crypto.Decrypter:
  ../GOSRC/crypto/crypto.go
TYPE crypto.DecrypterOpts:
  ../GOSRC/crypto/crypto.go
TYPE crypto.Hash:
  ../GOSRC/crypto/crypto.go
TYPE crypto.PrivateKey:
  ../GOSRC/crypto/crypto.go
TYPE crypto.PublicKey:
  ../GOSRC/crypto/crypto.go
TYPE crypto.Signer:
  ../GOSRC/crypto/crypto.go
TYPE crypto.SignerOpts:
  ../GOSRC/crypto/crypto.go
TYPE cryptobyte.BuildError:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.Builder:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.BuilderContinuation:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.MarshalingValue:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.String:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/string.go
TYPE csv.ParseError:
  ../GOSRC/encoding/csv/reader.go
TYPE csv.Reader:
  ../GOSRC/encoding/csv/reader.go
TYPE csv.Writer:
  ../GOSRC/encoding/csv/writer.go
TYPE debug.GCStats:
  ../GOSRC/runtime/debug/garbage.go
TYPE des.KeySizeError:
  ../GOSRC/crypto/des/cipher.go
TYPE dnsmessage.AAAAResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.AResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Builder:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.CNAMEResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Class:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Header:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.MXResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Message:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.NSResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Name:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.OpCode:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.PTRResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Parser:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Question:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.RCode:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Resource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.ResourceBody:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.ResourceHeader:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.SOAResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.SRVResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.TXTResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Type:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE doc.Example:
  ../GOSRC/go/doc/example.go
TYPE doc.Filter:
  ../GOSRC/go/doc/filter.go
TYPE doc.Func:
  ../GOSRC/go/doc/doc.go
TYPE doc.Mode:
  ../GOSRC/go/doc/doc.go
TYPE doc.Note:
  ../GOSRC/go/doc/doc.go
TYPE doc.Package:
  ../GOSRC/go/doc/doc.go
TYPE doc.Type:
  ../GOSRC/go/doc/doc.go
TYPE doc.Value:
  ../GOSRC/go/doc/doc.go
TYPE draw.Drawer:
  ../GOSRC/image/draw/draw.go
TYPE draw.Image:
  ../GOSRC/image/draw/draw.go
TYPE draw.Op:
  ../GOSRC/image/draw/draw.go
TYPE draw.Quantizer:
  ../GOSRC/image/draw/draw.go
TYPE driver.ColumnConverter:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Conn:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.ConnBeginTx:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.ConnPrepareContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Connector:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Driver:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.DriverContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Execer:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.ExecerContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.IsolationLevel:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.NamedValue:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.NamedValueChecker:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.NotNull:
  ../GOSRC/database/sql/driver/types.go
TYPE driver.Null:
  ../GOSRC/database/sql/driver/types.go
TYPE driver.Pinger:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Queryer:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.QueryerContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Result:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Rows:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsAffected:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeDatabaseTypeName:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeLength:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeNullable:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsColumnTypePrecisionScale:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeScanType:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsNextResultSet:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.SessionResetter:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Stmt:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.StmtExecContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.StmtQueryContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Tx:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.TxOptions:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Value:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.ValueConverter:
  ../GOSRC/database/sql/driver/types.go
TYPE driver.Valuer:
  ../GOSRC/database/sql/driver/types.go
TYPE dsa.ParameterSizes:
  ../GOSRC/crypto/dsa/dsa.go
TYPE dsa.Parameters:
  ../GOSRC/crypto/dsa/dsa.go
TYPE dsa.PrivateKey:
  ../GOSRC/crypto/dsa/dsa.go
TYPE dsa.PublicKey:
  ../GOSRC/crypto/dsa/dsa.go
TYPE dwarf.AddrType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.ArrayType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Attr:
  ../GOSRC/debug/dwarf/const.go
TYPE dwarf.BasicType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.BoolType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.CharType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Class:
  ../GOSRC/debug/dwarf/entry.go
TYPE dwarf.CommonType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.ComplexType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Data:
  ../GOSRC/debug/dwarf/open.go
TYPE dwarf.DecodeError:
  ../GOSRC/debug/dwarf/buf.go
TYPE dwarf.DotDotDotType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Entry:
  ../GOSRC/debug/dwarf/entry.go
TYPE dwarf.EnumType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.EnumValue:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Field:
  ../GOSRC/debug/dwarf/entry.go
TYPE dwarf.FloatType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.FuncType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.IntType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.LineEntry:
  ../GOSRC/debug/dwarf/line.go
TYPE dwarf.LineFile:
  ../GOSRC/debug/dwarf/line.go
TYPE dwarf.LineReader:
  ../GOSRC/debug/dwarf/line.go
TYPE dwarf.LineReaderPos:
  ../GOSRC/debug/dwarf/line.go
TYPE dwarf.Offset:
  ../GOSRC/debug/dwarf/entry.go
TYPE dwarf.PtrType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.QualType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Reader:
  ../GOSRC/debug/dwarf/entry.go
TYPE dwarf.StructField:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.StructType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Tag:
  ../GOSRC/debug/dwarf/const.go
TYPE dwarf.Type:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.TypedefType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.UcharType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.UintType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.UnspecifiedType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.VoidType:
  ../GOSRC/debug/dwarf/type.go
TYPE ecdsa.PrivateKey:
  ../GOSRC/crypto/ecdsa/ecdsa.go
TYPE ecdsa.PublicKey:
  ../GOSRC/crypto/ecdsa/ecdsa.go
TYPE elf.Chdr32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Chdr64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Class:
  ../GOSRC/debug/elf/elf.go
TYPE elf.CompressionType:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Data:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Dyn32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Dyn64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.DynFlag:
  ../GOSRC/debug/elf/elf.go
TYPE elf.DynTag:
  ../GOSRC/debug/elf/elf.go
TYPE elf.File:
  ../GOSRC/debug/elf/file.go
TYPE elf.FileHeader:
  ../GOSRC/debug/elf/file.go
TYPE elf.FormatError:
  ../GOSRC/debug/elf/file.go
TYPE elf.Header32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Header64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.ImportedSymbol:
  ../GOSRC/debug/elf/file.go
TYPE elf.Machine:
  ../GOSRC/debug/elf/elf.go
TYPE elf.NType:
  ../GOSRC/debug/elf/elf.go
TYPE elf.OSABI:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Prog:
  ../GOSRC/debug/elf/file.go
TYPE elf.Prog32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Prog64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.ProgFlag:
  ../GOSRC/debug/elf/elf.go
TYPE elf.ProgHeader:
  ../GOSRC/debug/elf/file.go
TYPE elf.ProgType:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_386:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_390:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_AARCH64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_ALPHA:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_ARM:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_MIPS:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_PPC:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_PPC64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_RISCV:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_SPARC:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_X86_64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Rel32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Rel64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Rela32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Rela64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Section:
  ../GOSRC/debug/elf/file.go
TYPE elf.Section32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Section64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SectionFlag:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SectionHeader:
  ../GOSRC/debug/elf/file.go
TYPE elf.SectionIndex:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SectionType:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Sym32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Sym64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SymBind:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SymType:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SymVis:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Symbol:
  ../GOSRC/debug/elf/file.go
TYPE elf.Type:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Version:
  ../GOSRC/debug/elf/elf.go
TYPE elliptic.Curve:
  ../GOSRC/crypto/elliptic/elliptic.go
TYPE elliptic.CurveParams:
  ../GOSRC/crypto/elliptic/elliptic.go
TYPE encoding.BinaryMarshaler:
  ../GOSRC/encoding/encoding.go
TYPE encoding.BinaryUnmarshaler:
  ../GOSRC/encoding/encoding.go
TYPE encoding.TextMarshaler:
  ../GOSRC/encoding/encoding.go
TYPE encoding.TextUnmarshaler:
  ../GOSRC/encoding/encoding.go
TYPE exec.Cmd:
  ../GOSRC/os/exec/exec.go
TYPE exec.Error:
  ../GOSRC/os/exec/exec.go
TYPE exec.ExitError:
  ../GOSRC/os/exec/exec.go
TYPE expvar.Float:
  ../GOSRC/expvar/expvar.go
TYPE expvar.Func:
  ../GOSRC/expvar/expvar.go
TYPE expvar.Int:
  ../GOSRC/expvar/expvar.go
TYPE expvar.KeyValue:
  ../GOSRC/expvar/expvar.go
TYPE expvar.Map:
  ../GOSRC/expvar/expvar.go
TYPE expvar.String:
  ../GOSRC/expvar/expvar.go
TYPE expvar.Var:
  ../GOSRC/expvar/expvar.go
TYPE filepath.WalkFunc:
  ../GOSRC/path/filepath/path.go
TYPE flag.ErrorHandling:
  ../GOSRC/flag/flag.go
TYPE flag.Flag:
  ../GOSRC/flag/flag.go
TYPE flag.FlagSet:
  ../GOSRC/flag/flag.go
TYPE flag.Getter:
  ../GOSRC/flag/flag.go
TYPE flag.Value:
  ../GOSRC/flag/flag.go
TYPE flate.CorruptInputError:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.InternalError:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.ReadError:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.Reader:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.Resetter:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.WriteError:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.Writer:
  ../GOSRC/compress/flate/deflate.go
TYPE fmt.Formatter:
  ../GOSRC/fmt/print.go
TYPE fmt.GoStringer:
  ../GOSRC/fmt/print.go
TYPE fmt.ScanState:
  ../GOSRC/fmt/scan.go
TYPE fmt.Scanner:
  ../GOSRC/fmt/scan.go
TYPE fmt.State:
  ../GOSRC/fmt/print.go
TYPE fmt.Stringer:
  ../GOSRC/fmt/print.go
TYPE gif.GIF:
  ../GOSRC/image/gif/reader.go
TYPE gif.Options:
  ../GOSRC/image/gif/writer.go
TYPE gob.CommonType:
  ../GOSRC/encoding/gob/type.go
TYPE gob.Decoder:
  ../GOSRC/encoding/gob/decoder.go
TYPE gob.Encoder:
  ../GOSRC/encoding/gob/encoder.go
TYPE gob.GobDecoder:
  ../GOSRC/encoding/gob/type.go
TYPE gob.GobEncoder:
  ../GOSRC/encoding/gob/type.go
TYPE gosym.DecodingError:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.Func:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.LineTable:
  ../GOSRC/debug/gosym/pclntab.go
TYPE gosym.Obj:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.Sym:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.Table:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.UnknownFileError:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.UnknownLineError:
  ../GOSRC/debug/gosym/symtab.go
TYPE gzip.Header:
  ../GOSRC/compress/gzip/gunzip.go
TYPE gzip.Reader:
  ../GOSRC/compress/gzip/gunzip.go
TYPE gzip.Writer:
  ../GOSRC/compress/gzip/gzip.go
TYPE hash.Hash:
  ../GOSRC/hash/hash.go
TYPE hash.Hash32:
  ../GOSRC/hash/hash.go
TYPE hash.Hash64:
  ../GOSRC/hash/hash.go
TYPE heap.Interface:
  ../GOSRC/container/heap/heap.go
TYPE hex.InvalidByteError:
  ../GOSRC/encoding/hex/hex.go
TYPE hpack.Decoder:
  ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE hpack.DecodingError:
  ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE hpack.Encoder:
  ../GOSRC/vendor/golang_org/x/net/http2/hpack/encode.go
TYPE hpack.HeaderField:
  ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE hpack.InvalidIndexError:
  ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE http.Client:
  ../GOSRC/net/http/client.go
TYPE http.CloseNotifier:
  ../GOSRC/net/http/server.go
TYPE http.ConnState:
  ../GOSRC/net/http/server.go
TYPE http.Cookie:
  ../GOSRC/net/http/cookie.go
TYPE http.CookieJar:
  ../GOSRC/net/http/jar.go
TYPE http.Dir:
  ../GOSRC/net/http/fs.go
TYPE http.File:
  ../GOSRC/net/http/fs.go
TYPE http.FileSystem:
  ../GOSRC/net/http/fs.go
TYPE http.Flusher:
  ../GOSRC/net/http/server.go
TYPE http.Handler:
  ../GOSRC/net/http/server.go
TYPE http.HandlerFunc:
  ../GOSRC/net/http/server.go
TYPE http.Header:
  ../GOSRC/net/http/header.go
TYPE http.Hijacker:
  ../GOSRC/net/http/server.go
TYPE http.ProtocolError:
  ../GOSRC/net/http/request.go
TYPE http.PushOptions:
  ../GOSRC/net/http/http.go
TYPE http.Pusher:
  ../GOSRC/net/http/http.go
TYPE http.Request:
  ../GOSRC/net/http/request.go
TYPE http.Response:
  ../GOSRC/net/http/response.go
TYPE http.ResponseWriter:
  ../GOSRC/net/http/server.go
TYPE http.RoundTripper:
  ../GOSRC/net/http/client.go
TYPE http.SameSite:
  ../GOSRC/net/http/cookie.go
TYPE http.ServeMux:
  ../GOSRC/net/http/server.go
TYPE http.Server:
  ../GOSRC/net/http/server.go
TYPE http.Transport:
  ../GOSRC/net/http/transport.go
TYPE httpproxy.Config:
  ../GOSRC/vendor/golang_org/x/net/http/httpproxy/proxy.go
TYPE httptest.ResponseRecorder:
  ../GOSRC/net/http/httptest/recorder.go
TYPE httptest.Server:
  ../GOSRC/net/http/httptest/server.go
TYPE httptrace.ClientTrace:
  ../GOSRC/net/http/httptrace/trace.go
TYPE httptrace.DNSDoneInfo:
  ../GOSRC/net/http/httptrace/trace.go
TYPE httptrace.DNSStartInfo:
  ../GOSRC/net/http/httptrace/trace.go
TYPE httptrace.GotConnInfo:
  ../GOSRC/net/http/httptrace/trace.go
TYPE httptrace.WroteRequestInfo:
  ../GOSRC/net/http/httptrace/trace.go
TYPE httputil.BufferPool:
  ../GOSRC/net/http/httputil/reverseproxy.go
TYPE httputil.ClientConn:
  ../GOSRC/net/http/httputil/persist.go
TYPE httputil.ReverseProxy:
  ../GOSRC/net/http/httputil/reverseproxy.go
TYPE httputil.ServerConn:
  ../GOSRC/net/http/httputil/persist.go
TYPE idna.Option:
  ../GOSRC/vendor/golang_org/x/net/idna/idna.go
TYPE idna.Profile:
  ../GOSRC/vendor/golang_org/x/net/idna/idna.go
TYPE image.Alpha:
  ../GOSRC/image/image.go
TYPE image.Alpha16:
  ../GOSRC/image/image.go
TYPE image.CMYK:
  ../GOSRC/image/image.go
TYPE image.Config:
  ../GOSRC/image/image.go
TYPE image.Gray:
  ../GOSRC/image/image.go
TYPE image.Gray16:
  ../GOSRC/image/image.go
TYPE image.Image:
  ../GOSRC/image/image.go
TYPE image.NRGBA:
  ../GOSRC/image/image.go
TYPE image.NRGBA64:
  ../GOSRC/image/image.go
TYPE image.NYCbCrA:
  ../GOSRC/image/ycbcr.go
TYPE image.Paletted:
  ../GOSRC/image/image.go
TYPE image.PalettedImage:
  ../GOSRC/image/image.go
TYPE image.Point:
  ../GOSRC/image/geom.go
TYPE image.RGBA:
  ../GOSRC/image/image.go
TYPE image.RGBA64:
  ../GOSRC/image/image.go
TYPE image.Rectangle:
  ../GOSRC/image/geom.go
TYPE image.Uniform:
  ../GOSRC/image/names.go
TYPE image.YCbCr:
  ../GOSRC/image/ycbcr.go
TYPE image.YCbCrSubsampleRatio:
  ../GOSRC/image/ycbcr.go
TYPE importer.Lookup:
  ../GOSRC/go/importer/importer.go
TYPE io.ByteReader:
  ../GOSRC/io/io.go
TYPE io.ByteScanner:
  ../GOSRC/io/io.go
TYPE io.ByteWriter:
  ../GOSRC/io/io.go
TYPE io.Closer:
  ../GOSRC/io/io.go
TYPE io.LimitedReader:
  ../GOSRC/io/io.go
TYPE io.PipeReader:
  ../GOSRC/io/pipe.go
TYPE io.PipeWriter:
  ../GOSRC/io/pipe.go
TYPE io.ReadCloser:
  ../GOSRC/io/io.go
TYPE io.ReadSeeker:
  ../GOSRC/io/io.go
TYPE io.ReadWriteCloser:
  ../GOSRC/io/io.go
TYPE io.ReadWriteSeeker:
  ../GOSRC/io/io.go
TYPE io.ReadWriter:
  ../GOSRC/io/io.go
TYPE io.Reader:
  ../GOSRC/io/io.go
TYPE io.ReaderAt:
  ../GOSRC/io/io.go
TYPE io.ReaderFrom:
  ../GOSRC/io/io.go
TYPE io.RuneReader:
  ../GOSRC/io/io.go
TYPE io.RuneScanner:
  ../GOSRC/io/io.go
TYPE io.SectionReader:
  ../GOSRC/io/io.go
TYPE io.Seeker:
  ../GOSRC/io/io.go
TYPE io.WriteCloser:
  ../GOSRC/io/io.go
TYPE io.WriteSeeker:
  ../GOSRC/io/io.go
TYPE io.Writer:
  ../GOSRC/io/io.go
TYPE io.WriterAt:
  ../GOSRC/io/io.go
TYPE io.WriterTo:
  ../GOSRC/io/io.go
TYPE jpeg.FormatError:
  ../GOSRC/image/jpeg/reader.go
TYPE jpeg.Options:
  ../GOSRC/image/jpeg/writer.go
TYPE jpeg.Reader:
  ../GOSRC/image/jpeg/reader.go
TYPE jpeg.UnsupportedError:
  ../GOSRC/image/jpeg/reader.go
TYPE json.Decoder:
  ../GOSRC/encoding/json/stream.go
TYPE json.Delim:
  ../GOSRC/encoding/json/stream.go
TYPE json.Encoder:
  ../GOSRC/encoding/json/stream.go
TYPE json.InvalidUTF8Error:
  ../GOSRC/encoding/json/encode.go
TYPE json.InvalidUnmarshalError:
  ../GOSRC/encoding/json/decode.go
TYPE json.Marshaler:
  ../GOSRC/encoding/json/encode.go
TYPE json.MarshalerError:
  ../GOSRC/encoding/json/encode.go
TYPE json.Number:
  ../GOSRC/encoding/json/decode.go
TYPE json.RawMessage:
  ../GOSRC/encoding/json/stream.go
TYPE json.SyntaxError:
  ../GOSRC/encoding/json/scanner.go
TYPE json.Token:
  ../GOSRC/encoding/json/stream.go
TYPE json.UnmarshalFieldError:
  ../GOSRC/encoding/json/decode.go
TYPE json.UnmarshalTypeError:
  ../GOSRC/encoding/json/decode.go
TYPE json.Unmarshaler:
  ../GOSRC/encoding/json/decode.go
TYPE json.UnsupportedTypeError:
  ../GOSRC/encoding/json/encode.go
TYPE json.UnsupportedValueError:
  ../GOSRC/encoding/json/encode.go
TYPE list.Element:
  ../GOSRC/container/list/list.go
TYPE list.List:
  ../GOSRC/container/list/list.go
TYPE log.Logger:
  ../GOSRC/log/log.go
TYPE lzw.Order:
  ../GOSRC/compress/lzw/reader.go
TYPE macho.Cpu:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Dylib:
  ../GOSRC/debug/macho/file.go
TYPE macho.DylibCmd:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Dysymtab:
  ../GOSRC/debug/macho/file.go
TYPE macho.DysymtabCmd:
  ../GOSRC/debug/macho/macho.go
TYPE macho.FatArch:
  ../GOSRC/debug/macho/fat.go
TYPE macho.FatArchHeader:
  ../GOSRC/debug/macho/fat.go
TYPE macho.FatFile:
  ../GOSRC/debug/macho/fat.go
TYPE macho.File:
  ../GOSRC/debug/macho/file.go
TYPE macho.FileHeader:
  ../GOSRC/debug/macho/macho.go
TYPE macho.FormatError:
  ../GOSRC/debug/macho/file.go
TYPE macho.Load:
  ../GOSRC/debug/macho/file.go
TYPE macho.LoadBytes:
  ../GOSRC/debug/macho/file.go
TYPE macho.LoadCmd:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Nlist32:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Nlist64:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Regs386:
  ../GOSRC/debug/macho/macho.go
TYPE macho.RegsAMD64:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Reloc:
  ../GOSRC/debug/macho/file.go
TYPE macho.RelocTypeARM:
  ../GOSRC/debug/macho/reloctype.go
TYPE macho.RelocTypeARM64:
  ../GOSRC/debug/macho/reloctype.go
TYPE macho.RelocTypeGeneric:
  ../GOSRC/debug/macho/reloctype.go
TYPE macho.RelocTypeX86_64:
  ../GOSRC/debug/macho/reloctype.go
TYPE macho.Rpath:
  ../GOSRC/debug/macho/file.go
TYPE macho.RpathCmd:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Section:
  ../GOSRC/debug/macho/file.go
TYPE macho.Section32:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Section64:
  ../GOSRC/debug/macho/macho.go
TYPE macho.SectionHeader:
  ../GOSRC/debug/macho/file.go
TYPE macho.Segment:
  ../GOSRC/debug/macho/file.go
TYPE macho.Segment32:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Segment64:
  ../GOSRC/debug/macho/macho.go
TYPE macho.SegmentHeader:
  ../GOSRC/debug/macho/file.go
TYPE macho.Symbol:
  ../GOSRC/debug/macho/file.go
TYPE macho.Symtab:
  ../GOSRC/debug/macho/file.go
TYPE macho.SymtabCmd:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Thread:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Type:
  ../GOSRC/debug/macho/macho.go
TYPE mail.Address:
  ../GOSRC/net/mail/message.go
TYPE mail.AddressParser:
  ../GOSRC/net/mail/message.go
TYPE mail.Header:
  ../GOSRC/net/mail/message.go
TYPE mail.Message:
  ../GOSRC/net/mail/message.go
TYPE mime.WordDecoder:
  ../GOSRC/mime/encodedword.go
TYPE mime.WordEncoder:
  ../GOSRC/mime/encodedword.go
TYPE multipart.File:
  ../GOSRC/mime/multipart/formdata.go
TYPE multipart.FileHeader:
  ../GOSRC/mime/multipart/formdata.go
TYPE multipart.Form:
  ../GOSRC/mime/multipart/formdata.go
TYPE multipart.Part:
  ../GOSRC/mime/multipart/multipart.go
TYPE multipart.Reader:
  ../GOSRC/mime/multipart/multipart.go
TYPE multipart.Writer:
  ../GOSRC/mime/multipart/writer.go
TYPE net.Addr:
  ../GOSRC/net/net.go
TYPE net.AddrError:
  ../GOSRC/net/net.go
TYPE net.Buffers:
  ../GOSRC/net/net.go
TYPE net.Conn:
  ../GOSRC/net/net.go
TYPE net.DNSConfigError:
  ../GOSRC/net/net.go
TYPE net.DNSError:
  ../GOSRC/net/net.go
TYPE net.Dialer:
  ../GOSRC/net/dial.go
TYPE net.Error:
  ../GOSRC/net/net.go
TYPE net.Flags:
  ../GOSRC/net/interface.go
TYPE net.HardwareAddr:
  ../GOSRC/net/mac.go
TYPE net.IP:
  ../GOSRC/net/ip.go
TYPE net.IPAddr:
  ../GOSRC/net/iprawsock.go
TYPE net.IPConn:
  ../GOSRC/net/iprawsock.go
TYPE net.IPMask:
  ../GOSRC/net/ip.go
TYPE net.IPNet:
  ../GOSRC/net/ip.go
TYPE net.Interface:
  ../GOSRC/net/interface.go
TYPE net.InvalidAddrError:
  ../GOSRC/net/net.go
TYPE net.ListenConfig:
  ../GOSRC/net/dial.go
TYPE net.Listener:
  ../GOSRC/net/net.go
TYPE net.MX:
  ../GOSRC/net/dnsclient.go
TYPE net.NS:
  ../GOSRC/net/dnsclient.go
TYPE net.OpError:
  ../GOSRC/net/net.go
TYPE net.PacketConn:
  ../GOSRC/net/net.go
TYPE net.ParseError:
  ../GOSRC/net/net.go
TYPE net.Resolver:
  ../GOSRC/net/lookup.go
TYPE net.SRV:
  ../GOSRC/net/dnsclient.go
TYPE net.TCPAddr:
  ../GOSRC/net/tcpsock.go
TYPE net.TCPConn:
  ../GOSRC/net/tcpsock.go
TYPE net.TCPListener:
  ../GOSRC/net/tcpsock.go
TYPE net.UDPAddr:
  ../GOSRC/net/udpsock.go
TYPE net.UDPConn:
  ../GOSRC/net/udpsock.go
TYPE net.UnixAddr:
  ../GOSRC/net/unixsock.go
TYPE net.UnixConn:
  ../GOSRC/net/unixsock.go
TYPE net.UnixListener:
  ../GOSRC/net/unixsock.go
TYPE net.UnknownNetworkError:
  ../GOSRC/net/net.go
TYPE nettest.MakePipe:
  ../GOSRC/vendor/golang_org/x/net/nettest/conntest.go
TYPE norm.Form:
  ../GOSRC/vendor/golang_org/x/text/unicode/norm/normalize.go
TYPE norm.Iter:
  ../GOSRC/vendor/golang_org/x/text/unicode/norm/iter.go
TYPE norm.Properties:
  ../GOSRC/vendor/golang_org/x/text/unicode/norm/forminfo.go
TYPE os.File:
  ../GOSRC/os/types.go
TYPE os.FileInfo:
  ../GOSRC/os/types.go
TYPE os.FileMode:
  ../GOSRC/os/types.go
TYPE os.LinkError:
  ../GOSRC/os/file.go
TYPE os.PathError:
  ../GOSRC/os/error.go
TYPE os.ProcAttr:
  ../GOSRC/os/exec.go
TYPE os.Process:
  ../GOSRC/os/exec.go
TYPE os.ProcessState:
  ../GOSRC/os/exec_posix.go
TYPE os.Signal:
  ../GOSRC/os/exec.go
TYPE os.SyscallError:
  ../GOSRC/os/error.go
TYPE parse.ActionNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.BoolNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.BranchNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.ChainNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.CommandNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.DotNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.FieldNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.IdentifierNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.IfNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.ListNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.NilNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.Node:
  ../GOSRC/text/template/parse/node.go
TYPE parse.NodeType:
  ../GOSRC/text/template/parse/node.go
TYPE parse.NumberNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.PipeNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.Pos:
  ../GOSRC/text/template/parse/node.go
TYPE parse.RangeNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.StringNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.TemplateNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.TextNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.Tree:
  ../GOSRC/text/template/parse/parse.go
TYPE parse.VariableNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.WithNode:
  ../GOSRC/text/template/parse/node.go
TYPE parser.Mode:
  ../GOSRC/go/parser/interface.go
TYPE pe.COFFSymbol:
  ../GOSRC/debug/pe/symbol.go
TYPE pe.DataDirectory:
  ../GOSRC/debug/pe/pe.go
TYPE pe.File:
  ../GOSRC/debug/pe/file.go
TYPE pe.FileHeader:
  ../GOSRC/debug/pe/pe.go
TYPE pe.FormatError:
  ../GOSRC/debug/pe/file.go
TYPE pe.ImportDirectory:
  ../GOSRC/debug/pe/file.go
TYPE pe.OptionalHeader32:
  ../GOSRC/debug/pe/pe.go
TYPE pe.OptionalHeader64:
  ../GOSRC/debug/pe/pe.go
TYPE pe.Reloc:
  ../GOSRC/debug/pe/section.go
TYPE pe.Section:
  ../GOSRC/debug/pe/section.go
TYPE pe.SectionHeader:
  ../GOSRC/debug/pe/section.go
TYPE pe.SectionHeader32:
  ../GOSRC/debug/pe/section.go
TYPE pe.StringTable:
  ../GOSRC/debug/pe/string.go
TYPE pe.Symbol:
  ../GOSRC/debug/pe/symbol.go
TYPE pem.Block:
  ../GOSRC/encoding/pem/pem.go
TYPE pkix.AlgorithmIdentifier:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.AttributeTypeAndValue:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.AttributeTypeAndValueSET:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.CertificateList:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.Extension:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.Name:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.RDNSequence:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.RelativeDistinguishedNameSET:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.RevokedCertificate:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.TBSCertificateList:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE plan9obj.File:
  ../GOSRC/debug/plan9obj/file.go
TYPE plan9obj.FileHeader:
  ../GOSRC/debug/plan9obj/file.go
TYPE plan9obj.Section:
  ../GOSRC/debug/plan9obj/file.go
TYPE plan9obj.SectionHeader:
  ../GOSRC/debug/plan9obj/file.go
TYPE plan9obj.Sym:
  ../GOSRC/debug/plan9obj/file.go
TYPE plugin.Plugin:
  ../GOSRC/plugin/plugin.go
TYPE plugin.Symbol:
  ../GOSRC/plugin/plugin.go
TYPE png.CompressionLevel:
  ../GOSRC/image/png/writer.go
TYPE png.Encoder:
  ../GOSRC/image/png/writer.go
TYPE png.EncoderBuffer:
  ../GOSRC/image/png/writer.go
TYPE png.EncoderBufferPool:
  ../GOSRC/image/png/writer.go
TYPE png.FormatError:
  ../GOSRC/image/png/reader.go
TYPE png.UnsupportedError:
  ../GOSRC/image/png/reader.go
TYPE pprof.LabelSet:
  ../GOSRC/runtime/pprof/label.go
TYPE pprof.Profile:
  ../GOSRC/runtime/pprof/pprof.go
TYPE printer.CommentedNode:
  ../GOSRC/go/printer/printer.go
TYPE printer.Config:
  ../GOSRC/go/printer/printer.go
TYPE printer.Mode:
  ../GOSRC/go/printer/printer.go
TYPE quick.CheckEqualError:
  ../GOSRC/testing/quick/quick.go
TYPE quick.CheckError:
  ../GOSRC/testing/quick/quick.go
TYPE quick.Config:
  ../GOSRC/testing/quick/quick.go
TYPE quick.Generator:
  ../GOSRC/testing/quick/quick.go
TYPE quick.SetupError:
  ../GOSRC/testing/quick/quick.go
TYPE quotedprintable.Reader:
  ../GOSRC/mime/quotedprintable/reader.go
TYPE quotedprintable.Writer:
  ../GOSRC/mime/quotedprintable/writer.go
TYPE rand.Rand:
  ../GOSRC/math/rand/rand.go
TYPE rand.Source:
  ../GOSRC/math/rand/rand.go
TYPE rand.Source64:
  ../GOSRC/math/rand/rand.go
TYPE rand.Zipf:
  ../GOSRC/math/rand/zipf.go
TYPE rc4.Cipher:
  ../GOSRC/crypto/rc4/rc4.go
TYPE rc4.KeySizeError:
  ../GOSRC/crypto/rc4/rc4.go
TYPE reflect.ChanDir:
  ../GOSRC/reflect/type.go
TYPE reflect.Kind:
  ../GOSRC/reflect/type.go
TYPE reflect.Method:
  ../GOSRC/reflect/type.go
TYPE reflect.SelectCase:
  ../GOSRC/reflect/value.go
TYPE reflect.SelectDir:
  ../GOSRC/reflect/value.go
TYPE reflect.SliceHeader:
  ../GOSRC/reflect/value.go
TYPE reflect.StringHeader:
  ../GOSRC/reflect/value.go
TYPE reflect.StructField:
  ../GOSRC/reflect/type.go
TYPE reflect.StructTag:
  ../GOSRC/reflect/type.go
TYPE reflect.Type:
  ../GOSRC/reflect/type.go
TYPE reflect.Value:
  ../GOSRC/reflect/value.go
TYPE reflect.ValueError:
  ../GOSRC/reflect/value.go
TYPE regexp.Regexp:
  ../GOSRC/regexp/regexp.go
TYPE ring.Ring:
  ../GOSRC/container/ring/ring.go
TYPE route.Addr:
  ../GOSRC/vendor/golang_org/x/net/route/address.go
TYPE route.DefaultAddr:
  ../GOSRC/vendor/golang_org/x/net/route/address.go
TYPE route.Inet4Addr:
  ../GOSRC/vendor/golang_org/x/net/route/address.go
TYPE route.Inet6Addr:
  ../GOSRC/vendor/golang_org/x/net/route/address.go
TYPE route.InterfaceAddrMessage:
  ../GOSRC/vendor/golang_org/x/net/route/interface.go
TYPE route.InterfaceAnnounceMessage:
  ../GOSRC/vendor/golang_org/x/net/route/interface.go
TYPE route.InterfaceMessage:
  ../GOSRC/vendor/golang_org/x/net/route/interface.go
TYPE route.InterfaceMetrics:
  ../GOSRC/vendor/golang_org/x/net/route/sys_darwin.go
TYPE route.InterfaceMulticastAddrMessage:
  ../GOSRC/vendor/golang_org/x/net/route/interface.go
TYPE route.LinkAddr:
  ../GOSRC/vendor/golang_org/x/net/route/address.go
TYPE route.Message:
  ../GOSRC/vendor/golang_org/x/net/route/message.go
TYPE route.RIBType:
  ../GOSRC/vendor/golang_org/x/net/route/route.go
TYPE route.RouteMessage:
  ../GOSRC/vendor/golang_org/x/net/route/route.go
TYPE route.RouteMetrics:
  ../GOSRC/vendor/golang_org/x/net/route/sys_darwin.go
TYPE route.Sys:
  ../GOSRC/vendor/golang_org/x/net/route/message.go
TYPE route.SysType:
  ../GOSRC/vendor/golang_org/x/net/route/message.go
TYPE rpc.Call:
  ../GOSRC/net/rpc/client.go
TYPE rpc.Client:
  ../GOSRC/net/rpc/client.go
TYPE rpc.ClientCodec:
  ../GOSRC/net/rpc/client.go
TYPE rpc.Request:
  ../GOSRC/net/rpc/server.go
TYPE rpc.Response:
  ../GOSRC/net/rpc/server.go
TYPE rpc.Server:
  ../GOSRC/net/rpc/server.go
TYPE rpc.ServerCodec:
  ../GOSRC/net/rpc/server.go
TYPE rpc.ServerError:
  ../GOSRC/net/rpc/client.go
TYPE rsa.CRTValue:
  ../GOSRC/crypto/rsa/rsa.go
TYPE rsa.OAEPOptions:
  ../GOSRC/crypto/rsa/rsa.go
TYPE rsa.PKCS1v15DecryptOptions:
  ../GOSRC/crypto/rsa/pkcs1v15.go
TYPE rsa.PSSOptions:
  ../GOSRC/crypto/rsa/pss.go
TYPE rsa.PrecomputedValues:
  ../GOSRC/crypto/rsa/rsa.go
TYPE rsa.PrivateKey:
  ../GOSRC/crypto/rsa/rsa.go
TYPE rsa.PublicKey:
  ../GOSRC/crypto/rsa/rsa.go
TYPE runtime.BlockProfileRecord:
  ../GOSRC/runtime/mprof.go
TYPE runtime.Error:
  ../GOSRC/runtime/error.go
TYPE runtime.Frame:
  ../GOSRC/runtime/symtab.go
TYPE runtime.Frames:
  ../GOSRC/runtime/symtab.go
TYPE runtime.Func:
  ../GOSRC/runtime/symtab.go
TYPE runtime.MemProfileRecord:
  ../GOSRC/runtime/mprof.go
TYPE runtime.MemStats:
  ../GOSRC/runtime/mstats.go
TYPE runtime.StackRecord:
  ../GOSRC/runtime/mprof.go
TYPE runtime.TypeAssertionError:
  ../GOSRC/runtime/error.go
TYPE runtime._defer:
  ../GOSRC/runtime/runtime2.go
TYPE runtime._func:
  ../GOSRC/runtime/runtime2.go
TYPE runtime._panic:
  ../GOSRC/runtime/runtime2.go
TYPE runtime._type:
  ../GOSRC/runtime/type.go
TYPE runtime._typePair:
  ../GOSRC/runtime/type.go
TYPE scanner.Error:
  ../GOSRC/go/scanner/errors.go
TYPE scanner.ErrorHandler:
  ../GOSRC/go/scanner/scanner.go
TYPE scanner.ErrorList:
  ../GOSRC/go/scanner/errors.go
TYPE scanner.Mode:
  ../GOSRC/go/scanner/scanner.go
TYPE scanner.Position:
  ../GOSRC/text/scanner/scanner.go
TYPE scanner.Scanner:
  ../GOSRC/text/scanner/scanner.go
TYPE smtp.Auth:
  ../GOSRC/net/smtp/auth.go
TYPE smtp.Client:
  ../GOSRC/net/smtp/smtp.go
TYPE smtp.ServerInfo:
  ../GOSRC/net/smtp/auth.go
TYPE sort.Float64Slice:
  ../GOSRC/sort/sort.go
TYPE sort.IntSlice:
  ../GOSRC/sort/sort.go
TYPE sort.Interface:
  ../GOSRC/sort/sort.go
TYPE sort.StringSlice:
  ../GOSRC/sort/sort.go
TYPE sql.ColumnType:
  ../GOSRC/database/sql/sql.go
TYPE sql.Conn:
  ../GOSRC/database/sql/sql.go
TYPE sql.DB:
  ../GOSRC/database/sql/sql.go
TYPE sql.DBStats:
  ../GOSRC/database/sql/sql.go
TYPE sql.IsolationLevel:
  ../GOSRC/database/sql/sql.go
TYPE sql.NamedArg:
  ../GOSRC/database/sql/sql.go
TYPE sql.NullBool:
  ../GOSRC/database/sql/sql.go
TYPE sql.NullFloat64:
  ../GOSRC/database/sql/sql.go
TYPE sql.NullInt64:
  ../GOSRC/database/sql/sql.go
TYPE sql.NullString:
  ../GOSRC/database/sql/sql.go
TYPE sql.Out:
  ../GOSRC/database/sql/sql.go
TYPE sql.RawBytes:
  ../GOSRC/database/sql/sql.go
TYPE sql.Result:
  ../GOSRC/database/sql/sql.go
TYPE sql.Row:
  ../GOSRC/database/sql/sql.go
TYPE sql.Rows:
  ../GOSRC/database/sql/sql.go
TYPE sql.Scanner:
  ../GOSRC/database/sql/sql.go
TYPE sql.Stmt:
  ../GOSRC/database/sql/sql.go
TYPE sql.Tx:
  ../GOSRC/database/sql/sql.go
TYPE sql.TxOptions:
  ../GOSRC/database/sql/sql.go
TYPE strconv.NumError:
  ../GOSRC/strconv/atoi.go
TYPE strings.Builder:
  ../GOSRC/strings/builder.go
TYPE strings.Reader:
  ../GOSRC/strings/reader.go
TYPE strings.Replacer:
  ../GOSRC/strings/replace.go
TYPE suffixarray.Index:
  ../GOSRC/index/suffixarray/suffixarray.go
TYPE sync.Cond:
  ../GOSRC/sync/cond.go
TYPE sync.Locker:
  ../GOSRC/sync/mutex.go
TYPE sync.Map:
  ../GOSRC/sync/map.go
TYPE sync.Mutex:
  ../GOSRC/sync/mutex.go
TYPE sync.Once:
  ../GOSRC/sync/once.go
TYPE sync.Pool:
  ../GOSRC/sync/pool.go
TYPE sync.RWMutex:
  ../GOSRC/sync/rwmutex.go
TYPE sync.WaitGroup:
  ../GOSRC/sync/waitgroup.go
TYPE syntax.EmptyOp:
  ../GOSRC/regexp/syntax/prog.go
TYPE syntax.Error:
  ../GOSRC/regexp/syntax/parse.go
TYPE syntax.ErrorCode:
  ../GOSRC/regexp/syntax/parse.go
TYPE syntax.Flags:
  ../GOSRC/regexp/syntax/parse.go
TYPE syntax.Inst:
  ../GOSRC/regexp/syntax/prog.go
TYPE syntax.InstOp:
  ../GOSRC/regexp/syntax/prog.go
TYPE syntax.Op:
  ../GOSRC/regexp/syntax/regexp.go
TYPE syntax.Prog:
  ../GOSRC/regexp/syntax/prog.go
TYPE syntax.Regexp:
  ../GOSRC/regexp/syntax/regexp.go
TYPE syscall.BpfHdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfInsn:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfProgram:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfStat:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfVersion:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Cmsghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Conn:
  ../GOSRC/syscall/net.go
TYPE syscall.Credential:
  ../GOSRC/syscall/exec_unix.go
TYPE syscall.Dirent:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Errno:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.Fbootstraptransfer_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.FdSet:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Flock_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Fsid:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Fstore_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.ICMPv6Filter:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPMreq:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPv6MTUInfo:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPv6Mreq:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfData:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfMsghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfaMsghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfmaMsghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfmaMsghdr2:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Inet4Pktinfo:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Inet6Pktinfo:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.InterfaceAddrMessage:
  ../GOSRC/syscall/route_bsd.go
TYPE syscall.InterfaceMessage:
  ../GOSRC/syscall/route_bsd.go
TYPE syscall.InterfaceMulticastAddrMessage:
  ../GOSRC/syscall/route_darwin.go
TYPE syscall.Iovec:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Kevent_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Linger:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Log2phys_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Msghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.ProcAttr:
  ../GOSRC/syscall/exec_unix.go
TYPE syscall.Radvisory_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawConn:
  ../GOSRC/syscall/net.go
TYPE syscall.RawSockaddr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrAny:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrDatalink:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrInet4:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrInet6:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrUnix:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Rlimit:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RouteMessage:
  ../GOSRC/syscall/route_bsd.go
TYPE syscall.RoutingMessage:
  ../GOSRC/syscall/route_bsd.go
TYPE syscall.RtMetrics:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RtMsghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Rusage:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Signal:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.Sockaddr:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.SockaddrDatalink:
  ../GOSRC/syscall/syscall_darwin.go
TYPE syscall.SockaddrInet4:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.SockaddrInet6:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.SockaddrUnix:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.SocketControlMessage:
  ../GOSRC/syscall/sockcmsg_unix.go
TYPE syscall.Stat_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Statfs_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.SysProcAttr:
  ../GOSRC/syscall/exec_bsd.go
TYPE syscall.Termios:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timespec:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timeval:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timeval32:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.WaitStatus:
  ../GOSRC/syscall/syscall_bsd.go
TYPE syscall._C_int:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall._C_long:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall._C_long_long:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall._C_short:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall._Gid_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall._Socklen:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syslog.Priority:
  ../GOSRC/log/syslog/syslog.go
TYPE syslog.Writer:
  ../GOSRC/log/syslog/syslog.go
TYPE tabwriter.Writer:
  ../GOSRC/text/tabwriter/tabwriter.go
TYPE tar.Format:
  ../GOSRC/archive/tar/format.go
TYPE tar.Header:
  ../GOSRC/archive/tar/common.go
TYPE tar.Reader:
  ../GOSRC/archive/tar/reader.go
TYPE tar.Writer:
  ../GOSRC/archive/tar/writer.go
TYPE template.CSS:
  ../GOSRC/html/template/content.go
TYPE template.Error:
  ../GOSRC/html/template/error.go
TYPE template.ErrorCode:
  ../GOSRC/html/template/error.go
TYPE template.ExecError:
  ../GOSRC/text/template/exec.go
TYPE template.FuncMap:
  ../GOSRC/text/template/funcs.go
TYPE template.HTML:
  ../GOSRC/html/template/content.go
TYPE template.HTMLAttr:
  ../GOSRC/html/template/content.go
TYPE template.JS:
  ../GOSRC/html/template/content.go
TYPE template.JSStr:
  ../GOSRC/html/template/content.go
TYPE template.Srcset:
  ../GOSRC/html/template/content.go
TYPE template.Template:
  ../GOSRC/text/template/template.go
TYPE template.URL:
  ../GOSRC/html/template/content.go
TYPE testing.B:
  ../GOSRC/testing/benchmark.go
TYPE testing.BenchmarkResult:
  ../GOSRC/testing/benchmark.go
TYPE testing.Cover:
  ../GOSRC/testing/cover.go
TYPE testing.CoverBlock:
  ../GOSRC/testing/cover.go
TYPE testing.InternalBenchmark:
  ../GOSRC/testing/benchmark.go
TYPE testing.InternalExample:
  ../GOSRC/testing/example.go
TYPE testing.InternalTest:
  ../GOSRC/testing/testing.go
TYPE testing.M:
  ../GOSRC/testing/testing.go
TYPE testing.PB:
  ../GOSRC/testing/benchmark.go
TYPE testing.T:
  ../GOSRC/testing/testing.go
TYPE testing.TB:
  ../GOSRC/testing/testing.go
TYPE textproto.Conn:
  ../GOSRC/net/textproto/textproto.go
TYPE textproto.Error:
  ../GOSRC/net/textproto/textproto.go
TYPE textproto.MIMEHeader:
  ../GOSRC/net/textproto/header.go
TYPE textproto.Pipeline:
  ../GOSRC/net/textproto/pipeline.go
TYPE textproto.ProtocolError:
  ../GOSRC/net/textproto/textproto.go
TYPE textproto.Reader:
  ../GOSRC/net/textproto/reader.go
TYPE textproto.Writer:
  ../GOSRC/net/textproto/writer.go
TYPE time.Duration:
  ../GOSRC/time/time.go
TYPE time.Location:
  ../GOSRC/time/zoneinfo.go
TYPE time.Month:
  ../GOSRC/time/time.go
TYPE time.ParseError:
  ../GOSRC/time/format.go
TYPE time.Ticker:
  ../GOSRC/time/tick.go
TYPE time.Time:
  ../GOSRC/time/time.go
TYPE time.Timer:
  ../GOSRC/time/sleep.go
TYPE time.Weekday:
  ../GOSRC/time/time.go
TYPE tls.Certificate:
  ../GOSRC/crypto/tls/common.go
TYPE tls.CertificateRequestInfo:
  ../GOSRC/crypto/tls/common.go
TYPE tls.ClientAuthType:
  ../GOSRC/crypto/tls/common.go
TYPE tls.ClientHelloInfo:
  ../GOSRC/crypto/tls/common.go
TYPE tls.ClientSessionCache:
  ../GOSRC/crypto/tls/common.go
TYPE tls.ClientSessionState:
  ../GOSRC/crypto/tls/common.go
TYPE tls.Config:
  ../GOSRC/crypto/tls/common.go
TYPE tls.Conn:
  ../GOSRC/crypto/tls/conn.go
TYPE tls.ConnectionState:
  ../GOSRC/crypto/tls/common.go
TYPE tls.CurveID:
  ../GOSRC/crypto/tls/common.go
TYPE tls.RecordHeaderError:
  ../GOSRC/crypto/tls/conn.go
TYPE tls.RenegotiationSupport:
  ../GOSRC/crypto/tls/common.go
TYPE tls.SignatureScheme:
  ../GOSRC/crypto/tls/common.go
TYPE token.File:
  ../GOSRC/go/token/position.go
TYPE token.FileSet:
  ../GOSRC/go/token/position.go
TYPE token.Pos:
  ../GOSRC/go/token/position.go
TYPE token.Position:
  ../GOSRC/go/token/position.go
TYPE token.Token:
  ../GOSRC/go/token/token.go
TYPE trace.Region:
  ../GOSRC/runtime/trace/annotation.go
TYPE trace.Task:
  ../GOSRC/runtime/trace/annotation.go
TYPE transform.NopResetter:
  ../GOSRC/vendor/golang_org/x/text/transform/transform.go
TYPE transform.Reader:
  ../GOSRC/vendor/golang_org/x/text/transform/transform.go
TYPE transform.SpanningTransformer:
  ../GOSRC/vendor/golang_org/x/text/transform/transform.go
TYPE transform.Transformer:
  ../GOSRC/vendor/golang_org/x/text/transform/transform.go
TYPE transform.Writer:
  ../GOSRC/vendor/golang_org/x/text/transform/transform.go
TYPE types.Array:
  ../GOSRC/go/types/type.go
TYPE types.Basic:
  ../GOSRC/go/types/type.go
TYPE types.BasicInfo:
  ../GOSRC/go/types/type.go
TYPE types.BasicKind:
  ../GOSRC/go/types/type.go
TYPE types.Builtin:
  ../GOSRC/go/types/object.go
TYPE types.Chan:
  ../GOSRC/go/types/type.go
TYPE types.ChanDir:
  ../GOSRC/go/types/type.go
TYPE types.Checker:
  ../GOSRC/go/types/check.go
TYPE types.Config:
  ../GOSRC/go/types/api.go
TYPE types.Const:
  ../GOSRC/go/types/object.go
TYPE types.Error:
  ../GOSRC/go/types/api.go
TYPE types.Func:
  ../GOSRC/go/types/object.go
TYPE types.ImportMode:
  ../GOSRC/go/types/api.go
TYPE types.Importer:
  ../GOSRC/go/types/api.go
TYPE types.ImporterFrom:
  ../GOSRC/go/types/api.go
TYPE types.Info:
  ../GOSRC/go/types/api.go
TYPE types.Initializer:
  ../GOSRC/go/types/api.go
TYPE types.Interface:
  ../GOSRC/go/types/type.go
TYPE types.Label:
  ../GOSRC/go/types/object.go
TYPE types.Map:
  ../GOSRC/go/types/type.go
TYPE types.MethodSet:
  ../GOSRC/go/types/methodset.go
TYPE types.Named:
  ../GOSRC/go/types/type.go
TYPE types.Nil:
  ../GOSRC/go/types/object.go
TYPE types.Object:
  ../GOSRC/go/types/object.go
TYPE types.Package:
  ../GOSRC/go/types/package.go
TYPE types.PkgName:
  ../GOSRC/go/types/object.go
TYPE types.Pointer:
  ../GOSRC/go/types/type.go
TYPE types.Qualifier:
  ../GOSRC/go/types/typestring.go
TYPE types.Scope:
  ../GOSRC/go/types/scope.go
TYPE types.Selection:
  ../GOSRC/go/types/selection.go
TYPE types.SelectionKind:
  ../GOSRC/go/types/selection.go
TYPE types.Signature:
  ../GOSRC/go/types/type.go
TYPE types.Sizes:
  ../GOSRC/go/types/sizes.go
TYPE types.Slice:
  ../GOSRC/go/types/type.go
TYPE types.StdSizes:
  ../GOSRC/go/types/sizes.go
TYPE types.Struct:
  ../GOSRC/go/types/type.go
TYPE types.Tuple:
  ../GOSRC/go/types/type.go
TYPE types.Type:
  ../GOSRC/go/types/type.go
TYPE types.TypeAndValue:
  ../GOSRC/go/types/api.go
TYPE types.TypeName:
  ../GOSRC/go/types/object.go
TYPE types.Var:
  ../GOSRC/go/types/object.go
TYPE unicode.CaseRange:
  ../GOSRC/unicode/letter.go
TYPE unicode.Range16:
  ../GOSRC/unicode/letter.go
TYPE unicode.Range32:
  ../GOSRC/unicode/letter.go
TYPE unicode.RangeTable:
  ../GOSRC/unicode/letter.go
TYPE unicode.SpecialCase:
  ../GOSRC/unicode/letter.go
TYPE unsafe.ArbitraryType:
  ../GOSRC/unsafe/unsafe.go
TYPE unsafe.Pointer:
  ../GOSRC/unsafe/unsafe.go
TYPE url.Error:
  ../GOSRC/net/url/url.go
TYPE url.EscapeError:
  ../GOSRC/net/url/url.go
TYPE url.InvalidHostError:
  ../GOSRC/net/url/url.go
TYPE url.URL:
  ../GOSRC/net/url/url.go
TYPE url.Userinfo:
  ../GOSRC/net/url/url.go
TYPE url.Values:
  ../GOSRC/net/url/url.go
TYPE user.Group:
  ../GOSRC/os/user/user.go
TYPE user.UnknownGroupError:
  ../GOSRC/os/user/user.go
TYPE user.UnknownGroupIdError:
  ../GOSRC/os/user/user.go
TYPE user.UnknownUserError:
  ../GOSRC/os/user/user.go
TYPE user.UnknownUserIdError:
  ../GOSRC/os/user/user.go
TYPE user.User:
  ../GOSRC/os/user/user.go
TYPE x509.CertPool:
  ../GOSRC/crypto/x509/cert_pool.go
TYPE x509.Certificate:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.CertificateInvalidError:
  ../GOSRC/crypto/x509/verify.go
TYPE x509.CertificateRequest:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.ConstraintViolationError:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.ExtKeyUsage:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.HostnameError:
  ../GOSRC/crypto/x509/verify.go
TYPE x509.InsecureAlgorithmError:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.InvalidReason:
  ../GOSRC/crypto/x509/verify.go
TYPE x509.KeyUsage:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.PEMCipher:
  ../GOSRC/crypto/x509/pem_decrypt.go
TYPE x509.PublicKeyAlgorithm:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.SignatureAlgorithm:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.SystemRootsError:
  ../GOSRC/crypto/x509/verify.go
TYPE x509.UnhandledCriticalExtension:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.UnknownAuthorityError:
  ../GOSRC/crypto/x509/verify.go
TYPE x509.VerifyOptions:
  ../GOSRC/crypto/x509/verify.go
TYPE xml.Attr:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.CharData:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.Comment:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.Decoder:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.Directive:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.Encoder:
  ../GOSRC/encoding/xml/marshal.go
TYPE xml.EndElement:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.Marshaler:
  ../GOSRC/encoding/xml/marshal.go
TYPE xml.MarshalerAttr:
  ../GOSRC/encoding/xml/marshal.go
TYPE xml.Name:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.ProcInst:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.StartElement:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.SyntaxError:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.TagPathError:
  ../GOSRC/encoding/xml/typeinfo.go
TYPE xml.Token:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.TokenReader:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.UnmarshalError:
  ../GOSRC/encoding/xml/read.go
TYPE xml.Unmarshaler:
  ../GOSRC/encoding/xml/read.go
TYPE xml.UnmarshalerAttr:
  ../GOSRC/encoding/xml/read.go
TYPE xml.UnsupportedTypeError:
  ../GOSRC/encoding/xml/marshal.go
TYPE zip.Compressor:
  ../GOSRC/archive/zip/register.go
TYPE zip.Decompressor:
  ../GOSRC/archive/zip/register.go
TYPE zip.File:
  ../GOSRC/archive/zip/reader.go
TYPE zip.FileHeader:
  ../GOSRC/archive/zip/struct.go
TYPE zip.ReadCloser:
  ../GOSRC/archive/zip/reader.go
TYPE zip.Reader:
  ../GOSRC/archive/zip/reader.go
TYPE zip.Writer:
  ../GOSRC/archive/zip/writer.go
TYPE zlib.Resetter:
  ../GOSRC/compress/zlib/reader.go
TYPE zlib.Writer:
  ../GOSRC/compress/zlib/writer.go
JOKER FUNC adler32.Checksum has:
;; (defn ^Int Checksum
;;   "Checksum returns the Adler-32 checksum of data.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "checksum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/adler32/adler32.go:134:20) data])

JOKER FUNC adler32.New has:
;; (defn New
;;   "New returns a new hash.Hash32 computing the Adler-32 checksum. Its\nSum method will lay the value out in big-endian byte order. The\nreturned Hash32 also implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/adler32/adler32.go:43:12)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC aes.NewCipher has:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\nThe key argument should be the AES key,\neither 16, 24, or 32 bytes to select\nAES-128, AES-192, or AES-256.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/aes/cipher.go:32:29) Error]"
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/aes/cipher.go:32:20) key])

JOKER FUNC ascii85.Decode has:
;; (defn Decode
;;   "Decode decodes src into dst, returning both the number\nof bytes written to dst and the number consumed from src.\nIf src contains invalid ascii85 data, Decode will return the\nnumber of bytes successfully written and a CorruptInputError.\nDecode ignores space and control characters in src.\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nDecode expects these to have been stripped by the caller.\n\nIf flush is true, Decode assumes that src represents the\nend of the input stream and processes it completely rather\nthan wait for the completion of another 32-bit block.\n\nNewDecoder wraps an io.Reader interface around Decode.\nGo return type: (ndst int, nsrc int, err error)\nJoker return type: [^Int ndst ^Int nsrc ^Error err]"
;;   {:added "1.0"
;;    :go "decode(dst, src, flush)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/ascii85/ascii85.go:189:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/ascii85/ascii85.go:189:22) src, flush])

JOKER FUNC ascii85.Encode has:
;; (defn ^Int Encode
;;   "Encode encodes src into at most MaxEncodedLen(len(src))\nbytes of dst, returning the actual number of bytes written.\n\nThe encoding handles 4-byte chunks, using a special encoding\nfor the last fragment, so Encode is not appropriate for use on\nindividual blocks of a large data stream. Use NewEncoder() instead.\n\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nEncode does not add these.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "encode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/ascii85/ascii85.go:27:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/ascii85/ascii85.go:27:22) src])

JOKER FUNC ascii85.MaxEncodedLen has:
(defn ^Int MaxEncodedLen
  "MaxEncodedLen returns the maximum length of an encoding of n source bytes.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "maxEncodedLen(n)"}
  [^Int n])

JOKER FUNC ascii85.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder constructs a new ascii85 stream decoder.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/ascii85/ascii85.go:246:30)"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/ascii85/ascii85.go:246:19) r])

JOKER FUNC ascii85.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new ascii85 stream encoder. Data written to\nthe returned writer will be encoded and then written to w.\nAscii85 encodings operate in 32-bit blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\ntrailing partial block.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/ascii85/ascii85.go:93:30)"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/ascii85/ascii85.go:93:19) w])

JOKER FUNC asn1.Marshal has:
;; (defn Marshal
;;   "Marshal returns the ASN.1 encoding of val.\n\nIn addition to the struct tags recognised by Unmarshal, the following can be\nused:\n\n\tia5:         causes strings to be marshaled as ASN.1, IA5String values\n\tomitempty:   causes empty slices to be skipped\n\tprintable:   causes strings to be marshaled as ASN.1, PrintableString values\n\tutf8:        causes strings to be marshaled as ASN.1, UTF8String values\n\tutc:         causes time.Time to be marshaled as ASN.1, UTCTime values\n\tgeneralized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshal(val)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/marshal.go:677:18) val])

JOKER FUNC asn1.MarshalWithParams has:
;; (defn MarshalWithParams
;;   "MarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalWithParams(val, params)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/marshal.go:683:28) val, ^String params])

JOKER FUNC asn1.Unmarshal has:
;; (defn Unmarshal
;;   "Unmarshal parses the DER-encoded ASN.1 data structure b\nand uses the reflect package to fill in an arbitrary value pointed at by val.\nBecause Unmarshal uses the reflect package, the structs\nbeing written to must use upper case field names.\n\nAn ASN.1 INTEGER can be written to an int, int32, int64,\nor *big.Int (from the math/big package).\nIf the encoded value does not fit in the Go type,\nUnmarshal returns a parse error.\n\nAn ASN.1 BIT STRING can be written to a BitString.\n\nAn ASN.1 OCTET STRING can be written to a []byte.\n\nAn ASN.1 OBJECT IDENTIFIER can be written to an\nObjectIdentifier.\n\nAn ASN.1 ENUMERATED can be written to an Enumerated.\n\nAn ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.\n\nAn ASN.1 PrintableString, IA5String, or NumericString can be written to a string.\n\nAny of the above ASN.1 values can be written to an interface{}.\nThe value stored in the interface has the corresponding Go type.\nFor integers, that type is int64.\n\nAn ASN.1 SEQUENCE OF x or SET OF x can be written\nto a slice if an x can be written to the slice's element type.\n\nAn ASN.1 SEQUENCE or SET can be written to a struct\nif each of the elements in the sequence can be\nwritten to the corresponding element in the struct.\n\nThe following tags on struct fields have special meaning to Unmarshal:\n\n\tapplication specifies that an APPLICATION tag is used\n\tprivate     specifies that a PRIVATE tag is used\n\tdefault:x   sets the default value for optional integer fields (only used if optional is also present)\n\texplicit    specifies that an additional, explicit tag wraps the implicit one\n\toptional    marks the field as ASN.1 OPTIONAL\n\tset         causes a SET, rather than a SEQUENCE type to be expected\n\ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n\nIf the type of the first field of a structure is RawContent then the raw\nASN1 contents of the struct will be stored in it.\n\nIf the type name of a slice element ends with \"SET\" then it's treated as if\nthe \"set\" tag was set on it. This can be used with nested slices where a\nstruct tag cannot be given.\n\nOther ASN.1 types are not supported; if it encounters them,\nUnmarshal returns a parse error.\nGo return type: (rest []int, err error)\nJoker return type: [^(vector-of Int) rest ^Error err]"
;;   {:added "1.0"
;;    :go "unmarshal(b, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/asn1/asn1.go:1053:18) b, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/asn1.go:1053:30) val])

JOKER FUNC asn1.UnmarshalWithParams has:
;; (defn UnmarshalWithParams
;;   "UnmarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\nGo return type: (rest []int, err error)\nJoker return type: [^(vector-of Int) rest ^Error err]"
;;   {:added "1.0"
;;    :go "unmarshalWithParams(b, val, params)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/asn1/asn1.go:1059:28) b, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/asn1.go:1059:40) val, ^String params])

JOKER FUNC ast.FileExports has:
;; (defn ^Bool FileExports
;;   "FileExports trims the AST for a Go source file in place such that\nonly exported nodes remain: all top-level identifiers which are not exported\nand their associated information (such as type, initial value, or function\nbody) are removed. Non-exported fields and methods of exported types are\nstripped. The File.Comments list is not changed.\n\nFileExports reports whether there are exported declarations.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "fileExports(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:28:22) src])

JOKER FUNC ast.FilterDecl has:
(defn ^Bool FilterDecl
  "FilterDecl trims the AST for a Go declaration in place by removing\nall names (including struct field and interface method names, but\nnot from parameter lists) that don't pass through the filter f.\n\nFilterDecl reports whether there are any declared names left after\nfiltering.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "filterDecl(decl, f)"}
  [decl, f])

JOKER FUNC ast.FilterFile has:
;; (defn ^Bool FilterFile
;;   "FilterFile trims the AST for a Go file in place by removing all\nnames from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. Import declarations are\nalways removed. The File.Comments list is not changed.\n\nFilterFile reports whether there are any top-level declarations\nleft after filtering.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "filterFile(src, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:258:21) src, f])

JOKER FUNC ast.FilterPackage has:
;; (defn ^Bool FilterPackage
;;   "FilterPackage trims the AST for a Go package in place by removing\nall names from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. The pkg.Files list is not\nchanged, so that file names and top-level package comments don't get\nlost.\n\nFilterPackage reports whether there are any top-level declarations\nleft after filtering.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "filterPackage(pkg, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:285:24) pkg, f])

JOKER FUNC ast.Fprint has:
;; (defn ^Error Fprint
;;   "Fprint prints the (sub-)tree starting at AST node x to w.\nIf fset != nil, position information is interpreted relative\nto that file set. Otherwise positions are printed as integer\nvalues (file set specific offsets).\n\nA non-nil FieldFilter f may be provided to control the output:\nstruct fields for which f(fieldname, fieldvalue) is true are\nprinted; all others are filtered from the output. Unexported\nstruct fields are never printed.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fprint(w, fset, x, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/print.go:39:15) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/print.go:39:31) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/print.go:39:49) x, f])

JOKER FUNC ast.Inspect has:
;; (defn Inspect
;;   "Inspect traverses an AST in depth-first order: It starts by calling\nf(node); node must not be nil. If f returns true, Inspect invokes f\nrecursively for each of the non-nil children of node, followed by a\ncall of f(nil).\n"
;;   {:added "1.0"
;;    :go "inspect(node, f)"}
;;   [node, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/ast/walk.go:384:27) f])

JOKER FUNC ast.IsExported has:
(defn ^Bool IsExported
  "IsExported reports whether name is an exported Go symbol\n(that is, whether it begins with an upper-case letter).\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isExported(name)"}
  [^String name])

JOKER FUNC ast.MergePackageFiles has:
;; (defn MergePackageFiles
;;   "MergePackageFiles creates a file AST by merging the ASTs of the\nfiles belonging to a package. The mode flags control merging behavior.\nGo return type: *File\nJoker return type: {:Doc ^{:List ^(vector-of {:Slash ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:63:8), :Text ^String})}, :Package ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:988:13), :Name ^{:NamePos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:241:11), :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:81:7)}}, :Decls ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/ast.go:53:11)), :Scope ^{:Outer ^ABEND947(recursive type reference involving ast.Scope), :Objects ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/scope.go:21:10)}, :Imports ^(vector-of {:Doc ^{:List ^(vector-of {:Slash ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:63:8), :Text ^String})}, :Name ^{:NamePos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:241:11), :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:81:7)}}, :Path ^{:ValuePos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:256:12), :Kind ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:257:12), :Value ^String}, :Comment ^{:List ^(vector-of {:Slash ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:63:8), :Text ^String})}, :EndPos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:836:11)}), :Unresolved ^(vector-of {:NamePos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:241:11), :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:81:7)}}), :Comments ^(vector-of {:List ^(vector-of {:Slash ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:63:8), :Text ^String})})}"
;;   {:added "1.0"
;;    :go "mergePackageFiles(pkg, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:344:28) pkg, mode])

JOKER FUNC ast.NewCommentMap has:
;; (defn NewCommentMap
;;   "NewCommentMap creates a new comment map by associating comment groups\nof the comments list with the nodes of the AST specified by node.\n\nA comment group g is associated with a node n if:\n\n  - g starts on the same line as n ends\n  - g starts on the line immediately following n, and there is\n    at least one empty line after g and before the next node\n  - g starts before n and is not associated to the node before n\n    via the previous rules\n\nNewCommentMap tries to associate a comment group to the \"largest\"\nnode possible: For instance, if the comment is a line comment\ntrailing an assignment, the comment is associated with the entire\nassignment rather than just the last operand in the assignment.\nGo return type: CommentMap\nJoker return type: ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/commentmap.go:35:17)"
;;   {:added "1.0"
;;    :go "newCommentMap(fset, node, comments)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/commentmap.go:143:25) fset, node, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/ast/commentmap.go:143:61) comments])

JOKER FUNC ast.NewIdent has:
;; (defn NewIdent
;;   "NewIdent creates a new Ident without position.\nUseful for ASTs generated by code other than the Go parser.\nGo return type: *Ident\nJoker return type: {:NamePos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:241:11), :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:81:7)}}"
;;   {:added "1.0"
;;    :go "newIdent(name)"}
;;   [^String name])

JOKER FUNC ast.NewObj has:
;; (defn NewObj
;;   "NewObj creates a new object of a given kind and name.\nGo return type: *Object\nJoker return type: {:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:81:7)}"
;;   {:added "1.0"
;;    :go "newObj(kind, name)"}
;;   [kind, ^String name])

JOKER FUNC ast.NewPackage has:
;; (defn NewPackage
;;   "NewPackage creates a new Package node from a set of File nodes. It resolves\nunresolved identifiers across files and updates each file's Unresolved list\naccordingly. If a non-nil importer and universe scope are provided, they are\nused to resolve identifiers not declared in any of the package files. Any\nremaining unresolved identifiers are reported as undeclared. If the files\nbelong to different packages, one package name is selected and files with\ndifferent package names are reported and then ignored.\nThe result is a package node and a scanner.ErrorList if there were errors.\nGo return type: (*Package, error)\nJoker return type: [{:Name ^String, :Scope ^{:Outer ^ABEND947(recursive type reference involving ast.Scope), :Objects ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/scope.go:21:10)}, :Imports ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/ast.go:1011:10), :Files ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/ast.go:1012:10)} Error]"
;;   {:added "1.0"
;;    :go "newPackage(fset, files, importer, universe)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/resolve.go:74:22) fset, ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/resolve.go:74:44) files, importer, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/resolve.go:74:90) universe])

JOKER FUNC ast.NewScope has:
;; (defn NewScope
;;   "NewScope creates a new scope nested in the outer scope.\nGo return type: *Scope\nJoker return type: {:Outer ^ABEND947(recursive type reference involving ast.Scope), :Objects ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/scope.go:21:10)}"
;;   {:added "1.0"
;;    :go "newScope(outer)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/scope.go:25:21) outer])

JOKER FUNC ast.NotNilFilter has:
;; (defn ^Bool NotNilFilter
;;   "NotNilFilter returns true for field values that are not nil;\nit returns false otherwise.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "notNilFilter(_, v)"}
;;   [^String _, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/print.go:22:31) v])

JOKER FUNC ast.PackageExports has:
;; (defn ^Bool PackageExports
;;   "PackageExports trims the AST for a Go package in place such that\nonly exported nodes remain. The pkg.Files list is not changed, so that\nfile names and top-level package comments don't get lost.\n\nPackageExports reports whether there are exported declarations;\nit returns false otherwise.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "packageExports(pkg)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:39:25) pkg])

JOKER FUNC ast.Print has:
;; (defn ^Error Print
;;   "Print prints x to standard output, skipping nil fields.\nPrint(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "print(fset, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/print.go:73:17) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/print.go:73:35) x])

JOKER FUNC ast.SortImports has:
;; (defn SortImports
;;   "SortImports sorts runs of consecutive import lines in import blocks in f.\nIt also removes duplicate imports when it is possible to do so without data loss.\n"
;;   {:added "1.0"
;;    :go "sortImports(fset, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/import.go:15:23) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/import.go:15:41) f])

JOKER FUNC ast.Walk has:
;; (defn Walk
;;   "Walk traverses an AST in depth-first order: It starts by calling\nv.Visit(node); node must not be nil. If the visitor w returned by\nv.Visit(node) is not nil, Walk is invoked recursively with visitor\nw for each of the non-nil children of node, followed by a call of\nw.Visit(nil).\n"
;;   {:added "1.0"
;;    :go "walk(v, node)"}
;;   [v, node])

JOKER FUNC atomic.AddInt32 has:
;; (defn AddInt32
;;   "AddInt32 atomically adds delta to *addr and returns the new value.\nGo return type: new int\nJoker return type: ^Int new"
;;   {:added "1.0"
;;    :go "addInt32(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:92:20) addr, delta])

JOKER FUNC atomic.AddInt64 has:
;; (defn AddInt64
;;   "AddInt64 atomically adds delta to *addr and returns the new value.\nGo return type: new int\nJoker return type: ^Int new"
;;   {:added "1.0"
;;    :go "addInt64(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:100:20) addr, delta])

JOKER FUNC atomic.AddUint32 has:
;; (defn AddUint32
;;   "AddUint32 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)).\nIn particular, to decrement x, do AddUint32(&x, ^uint32(0)).\nGo return type: new int\nJoker return type: ^Int new"
;;   {:added "1.0"
;;    :go "addUint32(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:97:21) addr, delta])

JOKER FUNC atomic.AddUint64 has:
;; (defn AddUint64
;;   "AddUint64 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)).\nIn particular, to decrement x, do AddUint64(&x, ^uint64(0)).\nGo return type: new uint64\nJoker return type: ^ABEND042(cannot find typename atomic.uint64) new"
;;   {:added "1.0"
;;    :go "addUint64(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:105:21) addr, delta])

JOKER FUNC atomic.AddUintptr has:
;; (defn AddUintptr
;;   "AddUintptr atomically adds delta to *addr and returns the new value.\nGo return type: new uintptr\nJoker return type: ^ABEND042(cannot find typename atomic.uintptr) new"
;;   {:added "1.0"
;;    :go "addUintptr(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:108:22) addr, delta])

JOKER FUNC atomic.CompareAndSwapInt32 has:
;; (defn CompareAndSwapInt32
;;   "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.\nGo return type: swapped bool\nJoker return type: ^Bool swapped"
;;   {:added "1.0"
;;    :go "compareAndSwapInt32(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:74:31) addr, old, new])

JOKER FUNC atomic.CompareAndSwapInt64 has:
;; (defn CompareAndSwapInt64
;;   "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.\nGo return type: swapped bool\nJoker return type: ^Bool swapped"
;;   {:added "1.0"
;;    :go "compareAndSwapInt64(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:77:31) addr, old, new])

JOKER FUNC atomic.CompareAndSwapPointer has:
;; (defn CompareAndSwapPointer
;;   "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.\nGo return type: swapped bool\nJoker return type: ^Bool swapped"
;;   {:added "1.0"
;;    :go "compareAndSwapPointer(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:89:33) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:89:59) old, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:89:59) new])

JOKER FUNC atomic.CompareAndSwapUint32 has:
;; (defn CompareAndSwapUint32
;;   "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.\nGo return type: swapped bool\nJoker return type: ^Bool swapped"
;;   {:added "1.0"
;;    :go "compareAndSwapUint32(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:80:32) addr, old, new])

JOKER FUNC atomic.CompareAndSwapUint64 has:
;; (defn CompareAndSwapUint64
;;   "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.\nGo return type: swapped bool\nJoker return type: ^Bool swapped"
;;   {:added "1.0"
;;    :go "compareAndSwapUint64(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:83:32) addr, old, new])

JOKER FUNC atomic.CompareAndSwapUintptr has:
;; (defn CompareAndSwapUintptr
;;   "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.\nGo return type: swapped bool\nJoker return type: ^Bool swapped"
;;   {:added "1.0"
;;    :go "compareAndSwapUintptr(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:86:33) addr, old, new])

JOKER FUNC atomic.LoadInt32 has:
;; (defn LoadInt32
;;   "LoadInt32 atomically loads *addr.\nGo return type: val int\nJoker return type: ^Int val"
;;   {:added "1.0"
;;    :go "loadInt32(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:111:21) addr])

JOKER FUNC atomic.LoadInt64 has:
;; (defn LoadInt64
;;   "LoadInt64 atomically loads *addr.\nGo return type: val int\nJoker return type: ^Int val"
;;   {:added "1.0"
;;    :go "loadInt64(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:114:21) addr])

JOKER FUNC atomic.LoadPointer has:
;; (defn LoadPointer
;;   "LoadPointer atomically loads *addr.\nGo return type: val\nJoker return type: ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:126:45) val"
;;   {:added "1.0"
;;    :go "loadPointer(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:126:23) addr])

JOKER FUNC atomic.LoadUint32 has:
;; (defn LoadUint32
;;   "LoadUint32 atomically loads *addr.\nGo return type: val int\nJoker return type: ^Int val"
;;   {:added "1.0"
;;    :go "loadUint32(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:117:22) addr])

JOKER FUNC atomic.LoadUint64 has:
;; (defn LoadUint64
;;   "LoadUint64 atomically loads *addr.\nGo return type: val uint64\nJoker return type: ^ABEND042(cannot find typename atomic.uint64) val"
;;   {:added "1.0"
;;    :go "loadUint64(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:120:22) addr])

JOKER FUNC atomic.LoadUintptr has:
;; (defn LoadUintptr
;;   "LoadUintptr atomically loads *addr.\nGo return type: val uintptr\nJoker return type: ^ABEND042(cannot find typename atomic.uintptr) val"
;;   {:added "1.0"
;;    :go "loadUintptr(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:123:23) addr])

JOKER FUNC atomic.StoreInt32 has:
;; (defn StoreInt32
;;   "StoreInt32 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeInt32(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:129:22) addr, val])

JOKER FUNC atomic.StoreInt64 has:
;; (defn StoreInt64
;;   "StoreInt64 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeInt64(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:132:22) addr, val])

JOKER FUNC atomic.StorePointer has:
;; (defn StorePointer
;;   "StorePointer atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storePointer(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:144:24) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:144:45) val])

JOKER FUNC atomic.StoreUint32 has:
;; (defn StoreUint32
;;   "StoreUint32 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeUint32(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:135:23) addr, val])

JOKER FUNC atomic.StoreUint64 has:
;; (defn StoreUint64
;;   "StoreUint64 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeUint64(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:138:23) addr, val])

JOKER FUNC atomic.StoreUintptr has:
;; (defn StoreUintptr
;;   "StoreUintptr atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeUintptr(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:141:24) addr, val])

JOKER FUNC atomic.SwapInt32 has:
;; (defn SwapInt32
;;   "SwapInt32 atomically stores new into *addr and returns the previous *addr value.\nGo return type: old int\nJoker return type: ^Int old"
;;   {:added "1.0"
;;    :go "swapInt32(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:56:21) addr, new])

JOKER FUNC atomic.SwapInt64 has:
;; (defn SwapInt64
;;   "SwapInt64 atomically stores new into *addr and returns the previous *addr value.\nGo return type: old int\nJoker return type: ^Int old"
;;   {:added "1.0"
;;    :go "swapInt64(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:59:21) addr, new])

JOKER FUNC atomic.SwapPointer has:
;; (defn SwapPointer
;;   "SwapPointer atomically stores new into *addr and returns the previous *addr value.\nGo return type: old\nJoker return type: ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:71:65) old"
;;   {:added "1.0"
;;    :go "swapPointer(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:71:23) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:71:44) new])

JOKER FUNC atomic.SwapUint32 has:
;; (defn SwapUint32
;;   "SwapUint32 atomically stores new into *addr and returns the previous *addr value.\nGo return type: old int\nJoker return type: ^Int old"
;;   {:added "1.0"
;;    :go "swapUint32(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:62:22) addr, new])

JOKER FUNC atomic.SwapUint64 has:
;; (defn SwapUint64
;;   "SwapUint64 atomically stores new into *addr and returns the previous *addr value.\nGo return type: old uint64\nJoker return type: ^ABEND042(cannot find typename atomic.uint64) old"
;;   {:added "1.0"
;;    :go "swapUint64(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:65:22) addr, new])

JOKER FUNC atomic.SwapUintptr has:
;; (defn SwapUintptr
;;   "SwapUintptr atomically stores new into *addr and returns the previous *addr value.\nGo return type: old uintptr\nJoker return type: ^ABEND042(cannot find typename atomic.uintptr) old"
;;   {:added "1.0"
;;    :go "swapUintptr(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:68:23) addr, new])

JOKER FUNC base32.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base32 stream decoder.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base32/base32.go:530:45)"
;;   {:added "1.0"
;;    :go "newDecoder(enc, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base32/base32.go:530:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base32/base32.go:530:34) r])

JOKER FUNC base32.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new base32 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase32 encodings operate in 5-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base32/base32.go:259:45)"
;;   {:added "1.0"
;;    :go "newEncoder(enc, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base32/base32.go:259:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base32/base32.go:259:34) w])

JOKER FUNC base32.NewEncoding has:
;; (defn NewEncoding
;;   "NewEncoding returns a new Encoding defined by the given alphabet,\nwhich must be a 32-byte string.\nGo return type: *Encoding\nJoker return type: {:encode ^(vector-of Int), :decodeMap ^(vector-of Int), :padChar ^ABEND042(cannot find typename base32.rune)}"
;;   {:added "1.0"
;;    :go "newEncoding(encoder)"}
;;   [^String encoder])

JOKER FUNC base64.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base64 stream decoder.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base64/base64.go:603:45)"
;;   {:added "1.0"
;;    :go "newDecoder(enc, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base64/base64.go:603:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base64/base64.go:603:34) r])

JOKER FUNC base64.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new base64 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase64 encodings operate in 4-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base64/base64.go:250:45)"
;;   {:added "1.0"
;;    :go "newEncoder(enc, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base64/base64.go:250:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base64/base64.go:250:34) w])

JOKER FUNC base64.NewEncoding has:
;; (defn NewEncoding
;;   "NewEncoding returns a new padded Encoding defined by the given alphabet,\nwhich must be a 64-byte string that does not contain the padding character\nor CR / LF ('\\r', '\\n').\nThe resulting Encoding uses the default padding character ('='),\nwhich may be changed or disabled via WithPadding.\nGo return type: *Encoding\nJoker return type: {:encode ^(vector-of Int), :decodeMap ^(vector-of Int), :padChar ^ABEND042(cannot find typename base64.rune), :strict ^Bool}"
;;   {:added "1.0"
;;    :go "newEncoding(encoder)"}
;;   [^String encoder])

JOKER FUNC bidi.AppendReverse has:
;; (defn AppendReverse
;;   "AppendReverse reverses the order of characters of in, appends them to out,\nand returns the result. Modifiers will still follow the runes they modify.\nBrackets are replaced with their counterparts.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendReverse(out, in)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go:189:28) out, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go:189:28) in])

JOKER FUNC bidi.DefaultDirection has:
;; (defn DefaultDirection
;;   "DefaultDirection sets the default direction for a Paragraph. The direction is\noverridden if the text contains directional characters.\nGo return type: Option\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go:55:13)"
;;   {:added "1.0"
;;    :go "defaultDirection(d)"}
;;   [d])

JOKER FUNC bidi.Lookup has:
;; (defn Lookup
;;   "Lookup returns properties for the first rune in s and the width in bytes of\nits encoding. The size will be 0 if s does not hold enough bytes to complete\nthe encoding.\nGo return type: (p Properties, sz int)\nJoker return type: [^{:entry ^ABEND042(cannot find typename bidi.uint8), :last ^ABEND042(cannot find typename bidi.uint8)} p ^Int sz]"
;;   {:added "1.0"
;;    :go "lookup(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/prop.go:87:15) s])

JOKER FUNC bidi.LookupRune has:
;; (defn LookupRune
;;   "LookupRune returns properties for r.\nGo return type: (p Properties, size int)\nJoker return type: [^{:entry ^ABEND042(cannot find typename bidi.uint8), :last ^ABEND042(cannot find typename bidi.uint8)} p ^Int size]"
;;   {:added "1.0"
;;    :go "lookupRune(r)"}
;;   [r])

JOKER FUNC bidi.LookupString has:
;; (defn LookupString
;;   "LookupString returns properties for the first rune in s and the width in\nbytes of its encoding. The size will be 0 if s does not hold enough bytes to\ncomplete the encoding.\nGo return type: (p Properties, sz int)\nJoker return type: [^{:entry ^ABEND042(cannot find typename bidi.uint8), :last ^ABEND042(cannot find typename bidi.uint8)} p ^Int sz]"
;;   {:added "1.0"
;;    :go "lookupString(s)"}
;;   [^String s])

JOKER FUNC bidi.ReverseString has:
(defn ^String ReverseString
  "ReverseString reverses the order of characters in s and returns a new string.\nModifiers will still follow the runes they modify. Brackets are replaced with\ntheir counterparts.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "reverseString(s)"}
  [^String s])

JOKER FUNC bidirule.Direction has:
;; (defn Direction
;;   "Direction reports the direction of the given label as defined by RFC 5893.\nThe Bidi Rule does not have to be applied to labels of the category\nLeftToRight.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go:137:26)"
;;   {:added "1.0"
;;    :go "direction(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go:137:18) b])

JOKER FUNC bidirule.DirectionString has:
;; (defn DirectionString
;;   "DirectionString reports the direction of the given label as defined by RFC\n5893. The Bidi Rule does not have to be applied to labels of the category\nLeftToRight.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go:155:32)"
;;   {:added "1.0"
;;    :go "directionString(s)"}
;;   [^String s])

JOKER FUNC bidirule.New has:
;; (defn New
;;   "New returns a Transformer that verifies that input adheres to the Bidi Rule.\nGo return type: *Transformer\nJoker return type: {:state ^ABEND042(cannot find typename bidirule.ruleState), :hasRTL ^Bool, :seen ^Int}"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC bidirule.Valid has:
;; (defn ^Bool Valid
;;   "Valid reports whether b conforms to the BiDi rule.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "valid(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go:172:14) b])

JOKER FUNC bidirule.ValidString has:
(defn ^Bool ValidString
  "ValidString reports whether s conforms to the BiDi rule.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "validString(s)"}
  [^String s])

JOKER FUNC big.Jacobi has:
;; (defn ^Int Jacobi
;;   "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.\nThe y argument must be an odd integer.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "jacobi(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/math/big/int.go:760:18) x, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/math/big/int.go:760:18) y])

JOKER FUNC big.NewFloat has:
;; (defn NewFloat
;;   "NewFloat allocates and returns a new Float set to x,\nwith precision 53 and rounding mode ToNearestEven.\nNewFloat panics with ErrNaN if x is a NaN.\nGo return type: *Float\nJoker return type: {:prec ^Int, :mode ^Int, :acc ^ABEND042(cannot find typename big.int8), :form ^ABEND042(cannot find typename big.form), :neg ^Bool, :mant ^ABEND042(cannot find typename big.nat), :exp ^Int}"
;;   {:added "1.0"
;;    :go "newFloat(x)"}
;;   [x])

JOKER FUNC big.NewInt has:
;; (defn NewInt
;;   "NewInt allocates and returns a new Int set to x.\nGo return type: *Int\nJoker return type: {:neg ^Bool, :abs ^ABEND042(cannot find typename big.nat)}"
;;   {:added "1.0"
;;    :go "newInt(x)"}
;;   [x])

JOKER FUNC big.NewRat has:
;; (defn NewRat
;;   "NewRat creates a new Rat with numerator a and denominator b.\nGo return type: *Rat\nJoker return type: {:a ^{:neg ^Bool, :abs ^ABEND042(cannot find typename big.nat)}, :b ^{:neg ^Bool, :abs ^ABEND042(cannot find typename big.nat)}}"
;;   {:added "1.0"
;;    :go "newRat(a, b)"}
;;   [a, b])

JOKER FUNC big.ParseFloat has:
;; (defn ParseFloat
;;   "ParseFloat is like f.Parse(s, base) with f set to the given precision\nand rounding mode.\nGo return type: (f *Float, b int, err error)\nJoker return type: [^{:prec ^Int, :mode ^Int, :acc ^ABEND042(cannot find typename big.int8), :form ^ABEND042(cannot find typename big.form), :neg ^Bool, :mant ^ABEND042(cannot find typename big.nat), :exp ^Int} f ^Int b ^Error err]"
;;   {:added "1.0"
;;    :go "parseFloat(s, base, prec, mode)"}
;;   [^String s, ^Int base, ^Int prec, mode])

JOKER FUNC binary.PutUvarint has:
;; (defn ^Int PutUvarint
;;   "PutUvarint encodes a uint64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutUvarint will panic.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "putUvarint(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/binary/varint.go:41:21) buf, x])

JOKER FUNC binary.PutVarint has:
;; (defn ^Int PutVarint
;;   "PutVarint encodes an int64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutVarint will panic.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "putVarint(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/binary/varint.go:78:20) buf, x])

JOKER FUNC binary.Read has:
;; (defn ^Error Read
;;   "Read reads structured binary data from r into data.\nData must be a pointer to a fixed-size value or a slice\nof fixed-size values.\nBytes read from r are decoded using the specified byte order\nand written to successive fields of the data.\nWhen decoding boolean values, a zero byte is decoded as false, and\nany other non-zero byte is decoded as true.\nWhen reading into structs, the field data for fields with\nblank (_) field names is skipped; i.e., blank field names\nmay be used for padding.\nWhen reading into a struct, all non-blank fields must be exported\nor Read may panic.\n\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nRead returns ErrUnexpectedEOF.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "read(r, order, data)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/binary/binary.go:161:13) r, order, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/binary/binary.go:161:46) data])

JOKER FUNC binary.ReadUvarint has:
;; (defn ReadUvarint
;;   "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\nGo return type: (uint64, error)\nJoker return type: [ABEND042(cannot find typename binary.uint64) Error]"
;;   {:added "1.0"
;;    :go "readUvarint(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/binary/varint.go:106:20) r])

JOKER FUNC binary.ReadVarint has:
;; (defn ReadVarint
;;   "ReadVarint reads an encoded signed integer from r and returns it as an int64.\nGo return type: (int, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readVarint(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/binary/varint.go:126:19) r])

JOKER FUNC binary.Size has:
;; (defn ^Int Size
;;   "Size returns how many bytes Write would generate to encode the value v, which\nmust be a fixed-size value or a slice of fixed-size values, or a pointer to such data.\nIf v is neither of these, Size returns -1.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "size(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/binary/binary.go:374:13) v])

JOKER FUNC binary.Uvarint has:
;; (defn Uvarint
;;   "Uvarint decodes a uint64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\nGo return type: (uint64, int)\nJoker return type: [ABEND042(cannot find typename binary.uint64) Int]"
;;   {:added "1.0"
;;    :go "uvarint(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/binary/varint.go:60:18) buf])

JOKER FUNC binary.Varint has:
;; (defn Varint
;;   "Varint decodes an int64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 with the following meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\nGo return type: (int, int)\nJoker return type: [Int Int]"
;;   {:added "1.0"
;;    :go "varint(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/binary/varint.go:94:17) buf])

JOKER FUNC binary.Write has:
;; (defn ^Error Write
;;   "Write writes the binary representation of data into w.\nData must be a fixed-size value or a slice of fixed-size\nvalues, or a pointer to such data.\nBoolean values encode as one byte: 1 for true, and 0 for false.\nBytes written to w are encoded using the specified byte order\nand read from successive fields of the data.\nWhen writing structs, zero values are written for fields\nwith blank (_) field names.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "write(w, order, data)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/binary/binary.go:260:14) w, order, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/binary/binary.go:260:47) data])

JOKER FUNC bits.LeadingZeros has:
(defn ^Int LeadingZeros
  "LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "leadingZeros(x)"}
  [^Int x])

JOKER FUNC bits.LeadingZeros16 has:
(defn ^Int LeadingZeros16
  "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "leadingZeros16(x)"}
  [^Int x])

JOKER FUNC bits.LeadingZeros32 has:
(defn ^Int LeadingZeros32
  "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "leadingZeros32(x)"}
  [x])

JOKER FUNC bits.LeadingZeros64 has:
(defn ^Int LeadingZeros64
  "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "leadingZeros64(x)"}
  [x])

JOKER FUNC bits.LeadingZeros8 has:
(defn ^Int LeadingZeros8
  "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "leadingZeros8(x)"}
  [x])

JOKER FUNC bits.Len has:
(defn ^Int Len
  "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "len(x)"}
  [^Int x])

JOKER FUNC bits.Len16 has:
;; (defn Len16
;;   "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\nGo return type: n int\nJoker return type: ^Int n"
;;   {:added "1.0"
;;    :go "len16(x)"}
;;   [^Int x])

JOKER FUNC bits.Len32 has:
;; (defn Len32
;;   "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\nGo return type: n int\nJoker return type: ^Int n"
;;   {:added "1.0"
;;    :go "len32(x)"}
;;   [x])

JOKER FUNC bits.Len64 has:
;; (defn Len64
;;   "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\nGo return type: n int\nJoker return type: ^Int n"
;;   {:added "1.0"
;;    :go "len64(x)"}
;;   [x])

JOKER FUNC bits.Len8 has:
(defn ^Int Len8
  "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "len8(x)"}
  [x])

JOKER FUNC bits.OnesCount has:
(defn ^Int OnesCount
  "OnesCount returns the number of one bits (\"population count\") in x.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "onesCount(x)"}
  [^Int x])

JOKER FUNC bits.OnesCount16 has:
(defn ^Int OnesCount16
  "OnesCount16 returns the number of one bits (\"population count\") in x.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "onesCount16(x)"}
  [^Int x])

JOKER FUNC bits.OnesCount32 has:
(defn ^Int OnesCount32
  "OnesCount32 returns the number of one bits (\"population count\") in x.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "onesCount32(x)"}
  [x])

JOKER FUNC bits.OnesCount64 has:
(defn ^Int OnesCount64
  "OnesCount64 returns the number of one bits (\"population count\") in x.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "onesCount64(x)"}
  [x])

JOKER FUNC bits.OnesCount8 has:
(defn ^Int OnesCount8
  "OnesCount8 returns the number of one bits (\"population count\") in x.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "onesCount8(x)"}
  [x])

JOKER FUNC bits.Reverse has:
(defn ^Int Reverse
  "Reverse returns the value of x with its bits in reversed order.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "reverse(x)"}
  [^Int x])

JOKER FUNC bits.Reverse16 has:
(defn ^Int Reverse16
  "Reverse16 returns the value of x with its bits in reversed order.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "reverse16(x)"}
  [^Int x])

JOKER FUNC bits.Reverse32 has:
(defn ^Int Reverse32
  "Reverse32 returns the value of x with its bits in reversed order.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "reverse32(x)"}
  [x])

JOKER FUNC bits.Reverse64 has:
;; (defn Reverse64
;;   "Reverse64 returns the value of x with its bits in reversed order.\nGo return type: uint64\nJoker return type: ABEND042(cannot find typename bits.uint64)"
;;   {:added "1.0"
;;    :go "reverse64(x)"}
;;   [x])

JOKER FUNC bits.Reverse8 has:
;; (defn Reverse8
;;   "Reverse8 returns the value of x with its bits in reversed order.\nGo return type: uint8\nJoker return type: ABEND042(cannot find typename bits.uint8)"
;;   {:added "1.0"
;;    :go "reverse8(x)"}
;;   [x])

JOKER FUNC bits.ReverseBytes has:
(defn ^Int ReverseBytes
  "ReverseBytes returns the value of x with its bytes in reversed order.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "reverseBytes(x)"}
  [^Int x])

JOKER FUNC bits.ReverseBytes16 has:
(defn ^Int ReverseBytes16
  "ReverseBytes16 returns the value of x with its bytes in reversed order.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "reverseBytes16(x)"}
  [^Int x])

JOKER FUNC bits.ReverseBytes32 has:
(defn ^Int ReverseBytes32
  "ReverseBytes32 returns the value of x with its bytes in reversed order.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "reverseBytes32(x)"}
  [x])

JOKER FUNC bits.ReverseBytes64 has:
;; (defn ReverseBytes64
;;   "ReverseBytes64 returns the value of x with its bytes in reversed order.\nGo return type: uint64\nJoker return type: ABEND042(cannot find typename bits.uint64)"
;;   {:added "1.0"
;;    :go "reverseBytes64(x)"}
;;   [x])

JOKER FUNC bits.RotateLeft has:
(defn ^Int RotateLeft
  "RotateLeft returns the value of x rotated left by (k mod UintSize) bits.\nTo rotate x right by k bits, call RotateLeft(x, -k).\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "rotateLeft(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC bits.RotateLeft16 has:
(defn ^Int RotateLeft16
  "RotateLeft16 returns the value of x rotated left by (k mod 16) bits.\nTo rotate x right by k bits, call RotateLeft16(x, -k).\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "rotateLeft16(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC bits.RotateLeft32 has:
(defn ^Int RotateLeft32
  "RotateLeft32 returns the value of x rotated left by (k mod 32) bits.\nTo rotate x right by k bits, call RotateLeft32(x, -k).\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "rotateLeft32(x, k)"}
  [x, ^Int k])

JOKER FUNC bits.RotateLeft64 has:
;; (defn RotateLeft64
;;   "RotateLeft64 returns the value of x rotated left by (k mod 64) bits.\nTo rotate x right by k bits, call RotateLeft64(x, -k).\nGo return type: uint64\nJoker return type: ABEND042(cannot find typename bits.uint64)"
;;   {:added "1.0"
;;    :go "rotateLeft64(x, k)"}
;;   [x, ^Int k])

JOKER FUNC bits.RotateLeft8 has:
;; (defn RotateLeft8
;;   "RotateLeft8 returns the value of x rotated left by (k mod 8) bits.\nTo rotate x right by k bits, call RotateLeft8(x, -k).\nGo return type: uint8\nJoker return type: ABEND042(cannot find typename bits.uint8)"
;;   {:added "1.0"
;;    :go "rotateLeft8(x, k)"}
;;   [x, ^Int k])

JOKER FUNC bits.TrailingZeros has:
(defn ^Int TrailingZeros
  "TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "trailingZeros(x)"}
  [^Int x])

JOKER FUNC bits.TrailingZeros16 has:
;; (defn TrailingZeros16
;;   "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.\nGo return type: n int\nJoker return type: ^Int n"
;;   {:added "1.0"
;;    :go "trailingZeros16(x)"}
;;   [^Int x])

JOKER FUNC bits.TrailingZeros32 has:
(defn ^Int TrailingZeros32
  "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "trailingZeros32(x)"}
  [x])

JOKER FUNC bits.TrailingZeros64 has:
(defn ^Int TrailingZeros64
  "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "trailingZeros64(x)"}
  [x])

JOKER FUNC bits.TrailingZeros8 has:
(defn ^Int TrailingZeros8
  "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "trailingZeros8(x)"}
  [x])

JOKER FUNC bufio.NewReadWriter has:
;; (defn NewReadWriter
;;   "NewReadWriter allocates a new ReadWriter that dispatches to r and w.\nGo return type: *ReadWriter\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newReadWriter(r, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/bufio/bufio.go:743:22) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/bufio/bufio.go:743:33) w])

JOKER FUNC bufio.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader whose buffer has the default size.\nGo return type: *Reader\nJoker return type: {:buf ^(vector-of Int), :rd ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:33:15), :r ^Int, :w ^Int, :err ^Error, :lastByte ^Int, :lastRuneSize ^Int}"
;;   {:added "1.0"
;;    :go "newReader(rd)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:61:19) rd])

JOKER FUNC bufio.NewReaderSize has:
;; (defn NewReaderSize
;;   "NewReaderSize returns a new Reader whose buffer has at least the specified\nsize. If the argument io.Reader is already a Reader with large enough\nsize, it returns the underlying Reader.\nGo return type: *Reader\nJoker return type: {:buf ^(vector-of Int), :rd ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:33:15), :r ^Int, :w ^Int, :err ^Error, :lastByte ^Int, :lastRuneSize ^Int}"
;;   {:added "1.0"
;;    :go "newReaderSize(rd, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:46:23) rd, ^Int size])

JOKER FUNC bufio.NewScanner has:
;; (defn NewScanner
;;   "NewScanner returns a new Scanner to read from r.\nThe split function defaults to ScanLines.\nGo return type: *Scanner\nJoker return type: {:r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/scan.go:31:15), :split ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/bufio/scan.go:65:16), :maxTokenSize ^Int, :token ^(vector-of Int), :buf ^(vector-of Int), :start ^Int, :end ^Int, :err ^Error, :empties ^Int, :scanCalled ^Bool, :done ^Bool}"
;;   {:added "1.0"
;;    :go "newScanner(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/scan.go:86:19) r])

JOKER FUNC bufio.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer whose buffer has the default size.\nGo return type: *Writer\nJoker return type: {:err ^Error, :buf ^(vector-of Int), :n ^Int, :wr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:530:6)}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:552:18) w])

JOKER FUNC bufio.NewWriterSize has:
;; (defn NewWriterSize
;;   "NewWriterSize returns a new Writer whose buffer has at least the specified\nsize. If the argument io.Writer is already a Writer with large enough\nsize, it returns the underlying Writer.\nGo return type: *Writer\nJoker return type: {:err ^Error, :buf ^(vector-of Int), :n ^Int, :wr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:530:6)}"
;;   {:added "1.0"
;;    :go "newWriterSize(w, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:536:22) w, ^Int size])

JOKER FUNC bufio.ScanBytes has:
;; (defn ScanBytes
;;   "ScanBytes is a split function for a Scanner that returns each byte as a token.\nGo return type: (advance int, token []int, err error)\nJoker return type: [^Int advance ^(vector-of Int) token ^Error err]"
;;   {:added "1.0"
;;    :go "scanBytes(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:284:21) data, atEOF])

JOKER FUNC bufio.ScanLines has:
;; (defn ScanLines
;;   "ScanLines is a split function for a Scanner that returns each line of\ntext, stripped of any trailing end-of-line marker. The returned line may\nbe empty. The end-of-line marker is one optional carriage return followed\nby one mandatory newline. In regular expression notation, it is `\\r?\\n`.\nThe last non-empty line of input will be returned even if it has no\nnewline.\nGo return type: (advance int, token []int, err error)\nJoker return type: [^Int advance ^(vector-of Int) token ^Error err]"
;;   {:added "1.0"
;;    :go "scanLines(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:345:21) data, atEOF])

JOKER FUNC bufio.ScanRunes has:
;; (defn ScanRunes
;;   "ScanRunes is a split function for a Scanner that returns each\nUTF-8-encoded rune as a token. The sequence of runes returned is\nequivalent to that from a range loop over the input as a string, which\nmeans that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\".\nBecause of the Scan interface, this makes it impossible for the client to\ndistinguish correctly encoded replacement runes from encoding errors.\nGo return type: (advance int, token []int, err error)\nJoker return type: [^Int advance ^(vector-of Int) token ^Error err]"
;;   {:added "1.0"
;;    :go "scanRunes(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:299:21) data, atEOF])

JOKER FUNC bufio.ScanWords has:
;; (defn ScanWords
;;   "ScanWords is a split function for a Scanner that returns each\nspace-separated word of text, with surrounding spaces deleted. It will\nnever return an empty string. The definition of space is set by\nunicode.IsSpace.\nGo return type: (advance int, token []int, err error)\nJoker return type: [^Int advance ^(vector-of Int) token ^Error err]"
;;   {:added "1.0"
;;    :go "scanWords(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:390:21) data, atEOF])

JOKER FUNC build.ArchChar has:
;; (defn ArchChar
;;   "ArchChar returns \"?\" and an error.\nIn earlier versions of Go, the returned string was used to derive\nthe compiler and linker tool names, the default object file suffix,\nand the default linker output name. As of Go 1.5, those strings\nno longer vary by architecture; they are compile, link, .o, and a.out, respectively.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "archChar(goarch)"}
;;   [^String goarch])

JOKER FUNC build.Import has:
;; (defn Import
;;   "Import is shorthand for Default.Import.\nGo return type: (*Package, error)\nJoker return type: [{:Dir ^String, :Name ^String, :ImportComment ^String, :Doc ^String, :ImportPath ^String, :Root ^String, :SrcRoot ^String, :PkgRoot ^String, :PkgTargetRoot ^String, :BinDir ^String, :Goroot ^Bool, :PkgObj ^String, :AllTags ^(vector-of String), :ConflictDir ^String, :BinaryOnly ^Bool, :GoFiles ^(vector-of String), :CgoFiles ^(vector-of String), :IgnoredGoFiles ^(vector-of String), :InvalidGoFiles ^(vector-of String), :CFiles ^(vector-of String), :CXXFiles ^(vector-of String), :MFiles ^(vector-of String), :HFiles ^(vector-of String), :FFiles ^(vector-of String), :SFiles ^(vector-of String), :SwigFiles ^(vector-of String), :SwigCXXFiles ^(vector-of String), :SysoFiles ^(vector-of String), :CgoCFLAGS ^(vector-of String), :CgoCPPFLAGS ^(vector-of String), :CgoCXXFLAGS ^(vector-of String), :CgoFFLAGS ^(vector-of String), :CgoLDFLAGS ^(vector-of String), :CgoPkgConfig ^(vector-of String), :Imports ^(vector-of String), :ImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:424:12), :TestGoFiles ^(vector-of String), :TestImports ^(vector-of String), :TestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:429:17), :XTestGoFiles ^(vector-of String), :XTestImports ^(vector-of String), :XTestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:432:17)} Error]"
;;   {:added "1.0"
;;    :go "import(path, srcDir, mode)"}
;;   [^String path, ^String srcDir, mode])

JOKER FUNC build.ImportDir has:
;; (defn ImportDir
;;   "ImportDir is shorthand for Default.ImportDir.\nGo return type: (*Package, error)\nJoker return type: [{:Dir ^String, :Name ^String, :ImportComment ^String, :Doc ^String, :ImportPath ^String, :Root ^String, :SrcRoot ^String, :PkgRoot ^String, :PkgTargetRoot ^String, :BinDir ^String, :Goroot ^Bool, :PkgObj ^String, :AllTags ^(vector-of String), :ConflictDir ^String, :BinaryOnly ^Bool, :GoFiles ^(vector-of String), :CgoFiles ^(vector-of String), :IgnoredGoFiles ^(vector-of String), :InvalidGoFiles ^(vector-of String), :CFiles ^(vector-of String), :CXXFiles ^(vector-of String), :MFiles ^(vector-of String), :HFiles ^(vector-of String), :FFiles ^(vector-of String), :SFiles ^(vector-of String), :SwigFiles ^(vector-of String), :SwigCXXFiles ^(vector-of String), :SysoFiles ^(vector-of String), :CgoCFLAGS ^(vector-of String), :CgoCPPFLAGS ^(vector-of String), :CgoCXXFLAGS ^(vector-of String), :CgoFFLAGS ^(vector-of String), :CgoLDFLAGS ^(vector-of String), :CgoPkgConfig ^(vector-of String), :Imports ^(vector-of String), :ImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:424:12), :TestGoFiles ^(vector-of String), :TestImports ^(vector-of String), :TestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:429:17), :XTestGoFiles ^(vector-of String), :XTestImports ^(vector-of String), :XTestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:432:17)} Error]"
;;   {:added "1.0"
;;    :go "importDir(dir, mode)"}
;;   [^String dir, mode])

JOKER FUNC build.IsLocalImport has:
(defn ^Bool IsLocalImport
  "IsLocalImport reports whether the import path is\na local import path, like \".\", \"..\", \"./foo\", or \"../foo\".\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isLocalImport(path)"}
  [^String path])

JOKER FUNC bytes.Compare has:
;; (defn ^Int Compare
;;   "Compare returns an integer comparing two byte slices lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\nA nil argument is equivalent to an empty slice.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "compare(a, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes_decl.go:24:19) a, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes_decl.go:24:19) b])

JOKER FUNC bytes.Contains has:
;; (defn ^Bool Contains
;;   "Contains reports whether subslice is within b.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "contains(b, subslice)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:72:27) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:72:27) subslice])

JOKER FUNC bytes.ContainsAny has:
;; (defn ^Bool ContainsAny
;;   "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "containsAny(b, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:77:20) b, ^String chars])

JOKER FUNC bytes.ContainsRune has:
;; (defn ^Bool ContainsRune
;;   "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "containsRune(b, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:82:21) b, r])

JOKER FUNC bytes.Count has:
;; (defn ^Int Count
;;   "Count counts the number of non-overlapping instances of sep in s.\nIf sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "count(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:52:19) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:52:19) sep])

JOKER FUNC bytes.Equal has:
;; (defn ^Bool Equal
;;   "Equal returns a boolean reporting whether a and b\nare the same length and contain the same bytes.\nA nil argument is equivalent to an empty slice.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "equal(a, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes_decl.go:17:17) a, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes_decl.go:17:17) b])

JOKER FUNC bytes.EqualFold has:
;; (defn ^Bool EqualFold
;;   "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "equalFold(s, t)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:779:21) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:779:21) t])

JOKER FUNC bytes.Fields has:
;; (defn Fields
;;   "Fields interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of subslices of s or an\nempty slice if s contains only white space.\nGo return type: [][]int\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "fields(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:283:15) s])

JOKER FUNC bytes.FieldsFunc has:
;; (defn FieldsFunc
;;   "FieldsFunc interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s at each run of code points c satisfying f(c) and\nreturns a slice of subslices of s. If all code points in s satisfy f(c), or\nlen(s) == 0, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\nGo return type: [][]int\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "fieldsFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:339:19) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:339:29) f])

JOKER FUNC bytes.HasPrefix has:
;; (defn ^Bool HasPrefix
;;   "HasPrefix tests whether the byte slice s begins with prefix.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "hasPrefix(s, prefix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:410:26) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:410:26) prefix])

JOKER FUNC bytes.HasSuffix has:
;; (defn ^Bool HasSuffix
;;   "HasSuffix tests whether the byte slice s ends with suffix.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "hasSuffix(s, suffix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:415:26) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:415:26) suffix])

JOKER FUNC bytes.Index has:
;; (defn ^Int Index
;;   "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "index(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:833:19) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:833:19) sep])

JOKER FUNC bytes.IndexAny has:
;; (defn ^Int IndexAny
;;   "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\nIt returns the byte index of the first occurrence in s of any of the Unicode\ncode points in chars. It returns -1 if chars is empty or if there is no code\npoint in common.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "indexAny(s, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:151:17) s, ^String chars])

JOKER FUNC bytes.IndexByte has:
;; (defn ^Int IndexByte
;;   "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "indexByte(b, c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes_decl.go:10:18) b, c])

JOKER FUNC bytes.IndexFunc has:
;; (defn ^Int IndexFunc
;;   "IndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "indexFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:603:18) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:603:28) f])

JOKER FUNC bytes.IndexRune has:
;; (defn ^Int IndexRune
;;   "IndexRune interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index of the first occurrence in s of the given rune.\nIt returns -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "indexRune(s, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:125:18) s, r])

JOKER FUNC bytes.Join has:
;; (defn Join
;;   "Join concatenates the elements of s to create a new byte slice. The separator\nsep is placed between elements in the resulting slice.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "join(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:387:13) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:387:27) sep])

JOKER FUNC bytes.LastIndex has:
;; (defn ^Int LastIndex
;;   "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "lastIndex(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:96:23) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:96:23) sep])

JOKER FUNC bytes.LastIndexAny has:
;; (defn ^Int LastIndexAny
;;   "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\npoints. It returns the byte index of the last occurrence in s of any of\nthe Unicode code points in chars. It returns -1 if chars is empty or if\nthere is no code point in common.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "lastIndexAny(s, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:187:21) s, ^String chars])

JOKER FUNC bytes.LastIndexByte has:
;; (defn ^Int LastIndexByte
;;   "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "lastIndexByte(s, c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:111:22) s, c])

JOKER FUNC bytes.LastIndexFunc has:
;; (defn ^Int LastIndexFunc
;;   "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the last Unicode\ncode point satisfying f(c), or -1 if none do.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "lastIndexFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:610:22) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:610:32) f])

JOKER FUNC bytes.Map has:
;; (defn Map
;;   "Map returns a copy of the byte slice s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the byte slice with no replacement. The characters in s and the\noutput are interpreted as UTF-8-encoded code points.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "map(mapping, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:423:18) mapping, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:423:39) s])

JOKER FUNC bytes.NewBuffer has:
;; (defn NewBuffer
;;   "NewBuffer creates and initializes a new Buffer using buf as its\ninitial contents. The new Buffer takes ownership of buf, and the\ncaller should not use buf after this call. NewBuffer is intended to\nprepare a Buffer to read existing data. It can also be used to size\nthe internal buffer for writing. To do that, buf should have the\ndesired capacity but a length of zero.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\nGo return type: *Buffer\nJoker return type: {:buf ^(vector-of Int), :off ^Int, :bootstrap ^(vector-of Int), :lastRead ^ABEND042(cannot find typename bytes.readOp)}"
;;   {:added "1.0"
;;    :go "newBuffer(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/buffer.go:450:20) buf])

JOKER FUNC bytes.NewBufferString has:
;; (defn NewBufferString
;;   "NewBufferString creates and initializes a new Buffer using string s as its\ninitial contents. It is intended to prepare a buffer to read an existing\nstring.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\nGo return type: *Buffer\nJoker return type: {:buf ^(vector-of Int), :off ^Int, :bootstrap ^(vector-of Int), :lastRead ^ABEND042(cannot find typename bytes.readOp)}"
;;   {:added "1.0"
;;    :go "newBufferString(s)"}
;;   [^String s])

JOKER FUNC bytes.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from b.\nGo return type: *Reader\nJoker return type: {:s ^(vector-of Int), :i ^Int, :prevRune ^Int}"
;;   {:added "1.0"
;;    :go "newReader(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/reader.go:156:18) b])

JOKER FUNC bytes.Repeat has:
;; (defn Repeat
;;   "Repeat returns a new byte slice consisting of count copies of b.\n\nIt panics if count is negative or if\nthe result of (len(b) * count) overflows.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "repeat(b, count)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:460:15) b, ^Int count])

JOKER FUNC bytes.Replace has:
;; (defn Replace
;;   "Replace returns a copy of the slice s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the slice\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune slice.\nIf n < 0, there is no limit on the number of replacements.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "replace(s, old, new, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:741:26) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:741:26) old, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:741:26) new, ^Int n])

JOKER FUNC bytes.Runes has:
;; (defn Runes
;;   "Runes interprets s as a sequence of UTF-8-encoded code points.\nIt returns a slice of runes (Unicode code points) equivalent to s.\nGo return type: []rune\nJoker return type: (vector-of ABEND042(cannot find typename bytes.rune))"
;;   {:added "1.0"
;;    :go "runes(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:723:14) s])

JOKER FUNC bytes.Split has:
;; (defn Split
;;   "Split slices s into all subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, Split splits after each UTF-8 sequence.\nIt is equivalent to SplitN with a count of -1.\nGo return type: [][]int\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "split(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:267:19) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:267:19) sep])

JOKER FUNC bytes.SplitAfter has:
;; (defn SplitAfter
;;   "SplitAfter slices s into all subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfter splits after each UTF-8 sequence.\nIt is equivalent to SplitAfterN with a count of -1.\nGo return type: [][]int\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "splitAfter(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:273:24) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:273:24) sep])

JOKER FUNC bytes.SplitAfterN has:
;; (defn SplitAfterN
;;   "SplitAfterN slices s into subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfterN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\nGo return type: [][]int\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "splitAfterN(s, sep, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:259:25) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:259:25) sep, ^Int n])

JOKER FUNC bytes.SplitN has:
;; (defn SplitN
;;   "SplitN slices s into subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, SplitN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\nGo return type: [][]int\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "splitN(s, sep, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:250:20) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:250:20) sep, ^Int n])

JOKER FUNC bytes.Title has:
;; (defn Title
;;   "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin\nwords mapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "title(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:536:14) s])

JOKER FUNC bytes.ToLower has:
;; (defn ToLower
;;   "ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toLower(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:484:16) s])

JOKER FUNC bytes.ToLowerSpecial has:
;; (defn ToLowerSpecial
;;   "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toLowerSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bytes/bytes.go:497:23) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:497:46) s])

JOKER FUNC bytes.ToTitle has:
;; (defn ToTitle
;;   "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toTitle(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:487:16) s])

JOKER FUNC bytes.ToTitleSpecial has:
;; (defn ToTitleSpecial
;;   "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toTitleSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bytes/bytes.go:503:23) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:503:46) s])

JOKER FUNC bytes.ToUpper has:
;; (defn ToUpper
;;   "ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toUpper(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:481:16) s])

JOKER FUNC bytes.ToUpperSpecial has:
;; (defn ToUpperSpecial
;;   "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toUpperSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bytes/bytes.go:491:23) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:491:46) s])

JOKER FUNC bytes.Trim has:
;; (defn Trim
;;   "Trim returns a subslice of s by slicing off all leading and\ntrailing UTF-8-encoded code points contained in cutset.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trim(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:699:13) s, ^String cutset])

JOKER FUNC bytes.TrimFunc has:
;; (defn TrimFunc
;;   "TrimFunc returns a subslice of s by slicing off all leading and trailing\nUTF-8-encoded code points c that satisfy f(c).\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:578:17) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:578:27) f])

JOKER FUNC bytes.TrimLeft has:
;; (defn TrimLeft
;;   "TrimLeft returns a subslice of s by slicing off all leading\nUTF-8-encoded code points contained in cutset.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimLeft(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:705:17) s, ^String cutset])

JOKER FUNC bytes.TrimLeftFunc has:
;; (defn TrimLeftFunc
;;   "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off\nall leading UTF-8-encoded code points c that satisfy f(c).\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimLeftFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:555:21) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:555:31) f])

JOKER FUNC bytes.TrimPrefix has:
;; (defn TrimPrefix
;;   "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimPrefix(s, prefix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:584:27) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:584:27) prefix])

JOKER FUNC bytes.TrimRight has:
;; (defn TrimRight
;;   "TrimRight returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points that are contained in cutset.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimRight(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:711:18) s, ^String cutset])

JOKER FUNC bytes.TrimRightFunc has:
;; (defn TrimRightFunc
;;   "TrimRightFunc returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points c that satisfy f(c).\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimRightFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:565:22) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:565:32) f])

JOKER FUNC bytes.TrimSpace has:
;; (defn TrimSpace
;;   "TrimSpace returns a subslice of s by slicing off all leading and\ntrailing white space, as defined by Unicode.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimSpace(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:717:18) s])

JOKER FUNC bytes.TrimSuffix has:
;; (defn TrimSuffix
;;   "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimSuffix(s, suffix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:593:27) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:593:27) suffix])

JOKER FUNC bzip2.NewReader has:
;; (defn NewReader
;;   "NewReader returns an io.Reader which decompresses bzip2 data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/bzip2/bzip2.go:46:29)"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/bzip2/bzip2.go:46:18) r])

JOKER FUNC cgi.Request has:
;; (defn Request
;;   "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/cgi/child.go:29:18) Error]"
;;   {:added "1.0"
;;    :go "request()"}
;;   [])

JOKER FUNC cgi.RequestFromMap has:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/cgi/child.go:52:49) Error]"
;;   {:added "1.0"
;;    :go "requestFromMap(params)"}
;;   [^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/cgi/child.go:52:28) params])

JOKER FUNC cgi.Serve has:
;; (defn ^Error Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "serve(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/cgi/child.go:146:20) handler])

JOKER FUNC cgo._cgo_panic has:
;; (defn _cgo_panic
;;   "go:linkname _cgo_panic _cgo_panic\ngo:cgo_export_static _cgo_panic\ngo:cgo_export_dynamic _cgo_panic\ngo:nosplit\ngo:norace\n"
;;   {:added "1.0"
;;    :go "_cgo_panic(a, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/cgo/callbacks.go:45:19) a, n])

JOKER FUNC cgo._runtime_cgocallback has:
;; (defn _runtime_cgocallback
;;   "cgocallback is defined in runtime\ngo:linkname _runtime_cgocallback runtime.cgocallback\n"
;;   {:added "1.0"
;;    :go "_runtime_cgocallback()"}
;;   [])

JOKER FUNC chacha20poly1305.New has:
;; (defn New
;;   "New returns a ChaCha20-Poly1305 AEAD that uses the given, 256-bit key.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/crypto/chacha20poly1305/chacha20poly1305.go:26:23) Error]"
;;   {:added "1.0"
;;    :go "new(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/chacha20poly1305/chacha20poly1305.go:26:14) key])

JOKER FUNC cipher.NewCBCDecrypter has:
;; (defn NewCBCDecrypter
;;   "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size and must match the iv used to encrypt the data.\nGo return type: BlockMode\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:45:16)"
;;   {:added "1.0"
;;    :go "newCBCDecrypter(b, iv)"}
;;   [b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cbc.go:105:34) iv])

JOKER FUNC cipher.NewCBCEncrypter has:
;; (defn NewCBCEncrypter
;;   "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size.\nGo return type: BlockMode\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:45:16)"
;;   {:added "1.0"
;;    :go "newCBCEncrypter(b, iv)"}
;;   [b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cbc.go:45:34) iv])

JOKER FUNC cipher.NewCFBDecrypter has:
;; (defn NewCFBDecrypter
;;   "NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\nGo return type: Stream\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newCFBDecrypter(block, iv)"}
;;   [block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cfb.go:60:38) iv])

JOKER FUNC cipher.NewCFBEncrypter has:
;; (defn NewCFBEncrypter
;;   "NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\nGo return type: Stream\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newCFBEncrypter(block, iv)"}
;;   [block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cfb.go:53:38) iv])

JOKER FUNC cipher.NewCTR has:
;; (defn NewCTR
;;   "NewCTR returns a Stream which encrypts/decrypts using the given Block in\ncounter mode. The length of iv must be the same as the Block's block size.\nGo return type: Stream\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newCTR(block, iv)"}
;;   [block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/ctr.go:35:29) iv])

JOKER FUNC cipher.NewGCM has:
;; (defn NewGCM
;;   "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode\nwith the standard nonce length.\n\nIn general, the GHASH operation performed by this implementation of GCM is not constant-time.\nAn exception is when the underlying Block was created by aes.NewCipher\non systems with hardware support for AES. See the crypto/aes package documentation for details.\nGo return type: (AEAD, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/gcm.go:16:11) Error]"
;;   {:added "1.0"
;;    :go "newGCM(cipher)"}
;;   [cipher])

JOKER FUNC cipher.NewGCMWithNonceSize has:
;; (defn NewGCMWithNonceSize
;;   "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which accepts nonces of the given length.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard nonce lengths. All other users should use\nNewGCM, which is faster and more resistant to misuse.\nGo return type: (AEAD, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/gcm.go:16:11) Error]"
;;   {:added "1.0"
;;    :go "newGCMWithNonceSize(cipher, size)"}
;;   [cipher, ^Int size])

JOKER FUNC cipher.NewGCMWithTagSize has:
;; (defn NewGCMWithTagSize
;;   "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which generates tags with the given length.\n\nTag sizes between 12 and 16 bytes are allowed.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard tag lengths. All other users should use\nNewGCM, which is more resistant to misuse.\nGo return type: (AEAD, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/gcm.go:16:11) Error]"
;;   {:added "1.0"
;;    :go "newGCMWithTagSize(cipher, tagSize)"}
;;   [cipher, ^Int tagSize])

JOKER FUNC cipher.NewOFB has:
;; (defn NewOFB
;;   "NewOFB returns a Stream that encrypts or decrypts using the block cipher b\nin output feedback mode. The initialization vector iv's length must be equal\nto b's block size.\nGo return type: Stream\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newOFB(b, iv)"}
;;   [b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/ofb.go:21:25) iv])

JOKER FUNC cmplx.Abs has:
;; (defn Abs
;;   "Abs returns the absolute value (also called the modulus) of x.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename cmplx.float64)"
;;   {:added "1.0"
;;    :go "abs(x)"}
;;   [x])

JOKER FUNC cmplx.Acos has:
;; (defn Acos
;;   "Acos returns the inverse cosine of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "acos(x)"}
;;   [x])

JOKER FUNC cmplx.Acosh has:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "acosh(x)"}
;;   [x])

JOKER FUNC cmplx.Asin has:
;; (defn Asin
;;   "Asin returns the inverse sine of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "asin(x)"}
;;   [x])

JOKER FUNC cmplx.Asinh has:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "asinh(x)"}
;;   [x])

JOKER FUNC cmplx.Atan has:
;; (defn Atan
;;   "Atan returns the inverse tangent of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "atan(x)"}
;;   [x])

JOKER FUNC cmplx.Atanh has:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "atanh(x)"}
;;   [x])

JOKER FUNC cmplx.Conj has:
;; (defn Conj
;;   "Conj returns the complex conjugate of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "conj(x)"}
;;   [x])

JOKER FUNC cmplx.Cos has:
;; (defn Cos
;;   "Cos returns the cosine of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "cos(x)"}
;;   [x])

JOKER FUNC cmplx.Cosh has:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "cosh(x)"}
;;   [x])

JOKER FUNC cmplx.Cot has:
;; (defn Cot
;;   "Cot returns the cotangent of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "cot(x)"}
;;   [x])

JOKER FUNC cmplx.Exp has:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "exp(x)"}
;;   [x])

JOKER FUNC cmplx.Inf has:
;; (defn Inf
;;   "Inf returns a complex infinity, complex(+Inf, +Inf).\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "inf()"}
;;   [])

JOKER FUNC cmplx.IsInf has:
(defn ^Bool IsInf
  "IsInf returns true if either real(x) or imag(x) is an infinity.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isInf(x)"}
  [x])

JOKER FUNC cmplx.IsNaN has:
(defn ^Bool IsNaN
  "IsNaN returns true if either real(x) or imag(x) is NaN\nand neither is an infinity.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isNaN(x)"}
  [x])

JOKER FUNC cmplx.Log has:
;; (defn Log
;;   "Log returns the natural logarithm of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "log(x)"}
;;   [x])

JOKER FUNC cmplx.Log10 has:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "log10(x)"}
;;   [x])

JOKER FUNC cmplx.NaN has:
;; (defn NaN
;;   "NaN returns a complex ``not-a-number'' value.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])

JOKER FUNC cmplx.Phase has:
;; (defn Phase
;;   "Phase returns the phase (also called the argument) of x.\nThe returned value is in the range [-Pi, Pi].\nGo return type: float64\nJoker return type: ABEND042(cannot find typename cmplx.float64)"
;;   {:added "1.0"
;;    :go "phase(x)"}
;;   [x])

JOKER FUNC cmplx.Polar has:
;; (defn Polar
;;   "Polar returns the absolute value r and phase θ of x,\nsuch that x = r * e**θi.\nThe phase is in the range [-Pi, Pi].\nGo return type: (r float64, θ float64)\nJoker return type: [^ABEND042(cannot find typename cmplx.float64) r ^ABEND042(cannot find typename cmplx.float64) θ]"
;;   {:added "1.0"
;;    :go "polar(x)"}
;;   [x])

JOKER FUNC cmplx.Pow has:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\nFor generalized compatibility with math.Pow:\n\tPow(0, ±0) returns 1+0i\n\tPow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "pow(x, y)"}
;;   [x, y])

JOKER FUNC cmplx.Rect has:
;; (defn Rect
;;   "Rect returns the complex number x with polar coordinates r, θ.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "rect(r, θ)"}
;;   [r, θ])

JOKER FUNC cmplx.Sin has:
;; (defn Sin
;;   "Sin returns the sine of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "sin(x)"}
;;   [x])

JOKER FUNC cmplx.Sinh has:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "sinh(x)"}
;;   [x])

JOKER FUNC cmplx.Sqrt has:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\nThe result r is chosen so that real(r) ≥ 0 and imag(r) has the same sign as imag(x).\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "sqrt(x)"}
;;   [x])

JOKER FUNC cmplx.Tan has:
;; (defn Tan
;;   "Tan returns the tangent of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "tan(x)"}
;;   [x])

JOKER FUNC cmplx.Tanh has:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\nGo return type: complex128\nJoker return type: ABEND042(cannot find typename cmplx.complex128)"
;;   {:added "1.0"
;;    :go "tanh(x)"}
;;   [x])

JOKER FUNC color.CMYKToRGB has:
;; (defn CMYKToRGB
;;   "CMYKToRGB converts a CMYK quadruple to an RGB triple.\nGo return type: (uint8, uint8, uint8)\nJoker return type: [ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)]"
;;   {:added "1.0"
;;    :go "cMYKToRGB(c, m, y, k)"}
;;   [c, m, y, k])

JOKER FUNC color.ModelFunc has:
;; (defn ModelFunc
;;   "ModelFunc returns a Model that invokes f to implement the conversion.\nGo return type: Model\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/image/color/color.go:142:12)"
;;   {:added "1.0"
;;    :go "modelFunc(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/color/color.go:147:18) f])

JOKER FUNC color.RGBToCMYK has:
;; (defn RGBToCMYK
;;   "RGBToCMYK converts an RGB triple to a CMYK quadruple.\nGo return type: (uint8, uint8, uint8, uint8)\nJoker return type: [ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)]"
;;   {:added "1.0"
;;    :go "rGBToCMYK(r, g, b)"}
;;   [r, g, b])

JOKER FUNC color.RGBToYCbCr has:
;; (defn RGBToYCbCr
;;   "RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\nGo return type: (uint8, uint8, uint8)\nJoker return type: [ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)]"
;;   {:added "1.0"
;;    :go "rGBToYCbCr(r, g, b)"}
;;   [r, g, b])

JOKER FUNC color.YCbCrToRGB has:
;; (defn YCbCrToRGB
;;   "YCbCrToRGB converts a Y'CbCr triple to an RGB triple.\nGo return type: (uint8, uint8, uint8)\nJoker return type: [ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)]"
;;   {:added "1.0"
;;    :go "yCbCrToRGB(y, cb, cr)"}
;;   [y, cb, cr])

JOKER FUNC constant.BinaryOp has:
;; (defn BinaryOp
;;   "BinaryOp returns the result of the binary expression x op y.\nThe operation must be defined for the operands. If one of the\noperands is Unknown, the result is Unknown.\nBinaryOp doesn't handle comparisons or shifts; use Compare\nor Shift instead.\n\nTo force integer division of Int operands, use op == token.QUO_ASSIGN\ninstead of token.QUO; the result is guaranteed to be Int in this case.\nDivision by zero leads to a run-time panic.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "binaryOp(x_, op, y_)"}
;;   [x_, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:1011:28) op, y_])

JOKER FUNC constant.BitLen has:
(defn ^Int BitLen
  "BitLen returns the number of bits required to represent\nthe absolute value x in binary representation; x must be an Int or an Unknown.\nIf x is Unknown, the result is 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "bitLen(x)"}
  [x])

JOKER FUNC constant.BoolVal has:
(defn ^Bool BoolVal
  "BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown.\nIf x is Unknown, the result is false.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "boolVal(x)"}
  [x])

JOKER FUNC constant.Bytes has:
;; (defn Bytes
;;   "Bytes returns the bytes for the absolute value of x in little-\nendian binary representation; x must be an Int.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "bytes(x)"}
;;   [x])

JOKER FUNC constant.Compare has:
;; (defn ^Bool Compare
;;   "Compare returns the result of the comparison x op y.\nThe comparison must be defined for the operands.\nIf one of the operands is Unknown, the result is\nfalse.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "compare(x_, op, y_)"}
;;   [x_, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:1247:27) op, y_])

JOKER FUNC constant.Denom has:
;; (defn Denom
;;   "Denom returns the denominator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int >= 1.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "denom(x)"}
;;   [x])

JOKER FUNC constant.Float32Val has:
;; (defn Float32Val
;;   "Float32Val is like Float64Val but for float32 instead of float64.\nGo return type: (float32, bool)\nJoker return type: [ABEND042(cannot find typename constant.float32) Bool]"
;;   {:added "1.0"
;;    :go "float32Val(x)"}
;;   [x])

JOKER FUNC constant.Float64Val has:
;; (defn Float64Val
;;   "Float64Val returns the nearest Go float64 value of x and whether the result is exact;\nx must be numeric or an Unknown, but not Complex. For values too small (too close to 0)\nto represent as float64, Float64Val silently underflows to 0. The result sign always\nmatches the sign of x, even for 0.\nIf x is Unknown, the result is (0, false).\nGo return type: (float64, bool)\nJoker return type: [ABEND042(cannot find typename constant.float64) Bool]"
;;   {:added "1.0"
;;    :go "float64Val(x)"}
;;   [x])

JOKER FUNC constant.Imag has:
;; (defn Imag
;;   "Imag returns the imaginary part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "imag(x)"}
;;   [x])

JOKER FUNC constant.Int64Val has:
;; (defn Int64Val
;;   "Int64Val returns the Go int64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\nGo return type: (int, bool)\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "int64Val(x)"}
;;   [x])

JOKER FUNC constant.MakeBool has:
;; (defn MakeBool
;;   "MakeBool returns the Bool value for b.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeBool(b)"}
;;   [b])

JOKER FUNC constant.MakeFloat64 has:
;; (defn MakeFloat64
;;   "MakeFloat64 returns the Float value for x.\nIf x is not finite, the result is an Unknown.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeFloat64(x)"}
;;   [x])

JOKER FUNC constant.MakeFromBytes has:
;; (defn MakeFromBytes
;;   "MakeFromBytes returns the Int value given the bytes of its little-endian\nbinary representation. An empty byte slice argument represents 0.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeFromBytes(bytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/constant/value.go:621:26) bytes])

JOKER FUNC constant.MakeFromLiteral has:
;; (defn MakeFromLiteral
;;   "MakeFromLiteral returns the corresponding integer, floating-point,\nimaginary, character, or string value for a Go literal string. The\ntok value must be one of token.INT, token.FLOAT, token.IMAG,\ntoken.CHAR, or token.STRING. The final argument must be zero.\nIf the literal string syntax is invalid, the result is an Unknown.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeFromLiteral(lit, tok, zero)"}
;;   [^String lit, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:378:38) tok, ^Int zero])

JOKER FUNC constant.MakeImag has:
;; (defn MakeImag
;;   "MakeImag returns the Complex value x*i;\nx must be Int, Float, or Unknown.\nIf x is Unknown, the result is Unknown.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeImag(x)"}
;;   [x])

JOKER FUNC constant.MakeInt64 has:
;; (defn MakeInt64
;;   "MakeInt64 returns the Int value for x.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeInt64(x)"}
;;   [x])

JOKER FUNC constant.MakeString has:
;; (defn MakeString
;;   "MakeString returns the String value for s.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeString(s)"}
;;   [^String s])

JOKER FUNC constant.MakeUint64 has:
;; (defn MakeUint64
;;   "MakeUint64 returns the Int value for x.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeUint64(x)"}
;;   [x])

JOKER FUNC constant.MakeUnknown has:
;; (defn MakeUnknown
;;   "MakeUnknown returns the Unknown value.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeUnknown()"}
;;   [])

JOKER FUNC constant.Num has:
;; (defn Num
;;   "Num returns the numerator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int\nwith the same sign as x.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "num(x)"}
;;   [x])

JOKER FUNC constant.Real has:
;; (defn Real
;;   "Real returns the real part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "real(x)"}
;;   [x])

JOKER FUNC constant.Shift has:
;; (defn Shift
;;   "Shift returns the result of the shift expression x op s\nwith op == token.SHL or token.SHR (<< or >>). x must be\nan Int or an Unknown. If x is Unknown, the result is x.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "shift(x, op, s)"}
;;   [x, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:1191:24) op, ^Int s])

JOKER FUNC constant.Sign has:
(defn ^Int Sign
  "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0;\nx must be numeric or Unknown. For complex values x, the sign is 0 if x == 0,\notherwise it is != 0. If x is Unknown, the result is 1.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "sign(x)"}
  [x])

JOKER FUNC constant.StringVal has:
(defn ^String StringVal
  "StringVal returns the Go string value of x, which must be a String or an Unknown.\nIf x is Unknown, the result is \"\".\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "stringVal(x)"}
  [x])

JOKER FUNC constant.ToComplex has:
;; (defn ToComplex
;;   "ToComplex converts x to a Complex value if x is representable as a Complex.\nOtherwise it returns an Unknown.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "toComplex(x)"}
;;   [x])

JOKER FUNC constant.ToFloat has:
;; (defn ToFloat
;;   "ToFloat converts x to a Float value if x is representable as a Float.\nOtherwise it returns an Unknown.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "toFloat(x)"}
;;   [x])

JOKER FUNC constant.ToInt has:
;; (defn ToInt
;;   "ToInt converts x to an Int value if x is representable as an Int.\nOtherwise it returns an Unknown.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "toInt(x)"}
;;   [x])

JOKER FUNC constant.Uint64Val has:
;; (defn Uint64Val
;;   "Uint64Val returns the Go uint64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\nGo return type: (uint64, bool)\nJoker return type: [ABEND042(cannot find typename constant.uint64) Bool]"
;;   {:added "1.0"
;;    :go "uint64Val(x)"}
;;   [x])

JOKER FUNC constant.UnaryOp has:
;; (defn UnaryOp
;;   "UnaryOp returns the result of the unary expression op y.\nThe operation must be defined for the operand.\nIf prec > 0 it specifies the ^ (xor) result size in bits.\nIf y is Unknown, the result is Unknown.\nGo return type: Value\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "unaryOp(op, y, prec)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:850:17) op, y, ^Int prec])

JOKER FUNC context.Background has:
;; (defn Background
;;   "Background returns a non-nil, empty Context. It is never canceled, has no\nvalues, and has no deadline. It is typically used by the main function,\ninitialization, and tests, and as the top-level Context for incoming\nrequests.\nGo return type: Context\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "background()"}
;;   [])

JOKER FUNC context.TODO has:
;; (defn TODO
;;   "TODO returns a non-nil, empty Context. Code should use context.TODO when\nit's unclear which Context to use or it is not yet available (because the\nsurrounding function has not yet been extended to accept a Context\nparameter). TODO is recognized by static analysis tools that determine\nwhether Contexts are propagated correctly in a program.\nGo return type: Context\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "tODO()"}
;;   [])

JOKER FUNC context.WithCancel has:
;; (defn WithCancel
;;   "WithCancel returns a copy of parent with a new Done channel. The returned\ncontext's Done channel is closed when the returned cancel function is called\nor when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\nGo return type: (ctx Context, cancel CancelFunc)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14) ctx ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/context/context.go:222:17) cancel]"
;;   {:added "1.0"
;;    :go "withCancel(parent)"}
;;   [parent])

JOKER FUNC context.WithDeadline has:
;; (defn WithDeadline
;;   "WithDeadline returns a copy of the parent context with the deadline adjusted\nto be no later than d. If the parent's deadline is already earlier than d,\nWithDeadline(parent, d) is semantically equivalent to parent. The returned\ncontext's Done channel is closed when the deadline expires, when the returned\ncancel function is called, or when the parent context's Done channel is\nclosed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\nGo return type: (Context, CancelFunc)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14) ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/context/context.go:222:17)]"
;;   {:added "1.0"
;;    :go "withDeadline(parent, d)"}
;;   [parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/context/context.go:384:37) d])

JOKER FUNC context.WithTimeout has:
;; (defn WithTimeout
;;   "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete:\n\n\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n\t\treturn slowOperation(ctx)\n\t}\nGo return type: (Context, CancelFunc)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14) ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/context/context.go:222:17)]"
;;   {:added "1.0"
;;    :go "withTimeout(parent, timeout)"}
;;   [parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/context/context.go:451:42) timeout])

JOKER FUNC context.WithValue has:
;; (defn WithValue
;;   "WithValue returns a copy of parent in which the value associated with key is\nval.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type\nstring or any other built-in type to avoid collisions between\npackages using context. Users of WithValue should define their own\ntypes for keys. To avoid allocating when assigning to an\ninterface{}, context keys often have concrete type\nstruct{}. Alternatively, exported context key variables' static\ntype should be a pointer or interface.\nGo return type: Context\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "withValue(parent, key, val)"}
;;   [parent, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:468:41) key, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:468:41) val])

JOKER FUNC cookiejar.New has:
;; (defn New
;;   "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\nGo return type: (*Jar, error)\nJoker return type: [{:psList ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/cookiejar/jar.go:34:23), :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/cookiejar/jar.go:64:5), :entries ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/cookiejar/jar.go:68:10), :nextSeqNum ^ABEND042(cannot find typename cookiejar.uint64)} Error]"
;;   {:added "1.0"
;;    :go "new(o)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/cookiejar/jar.go:77:12) o])

JOKER FUNC crc32.Checksum has:
;; (defn ^Int Checksum
;;   "Checksum returns the CRC-32 checksum of data\nusing the polynomial represented by the Table.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "checksum(data, tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc32/crc32.go:247:20) data, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc32/crc32.go:247:32) tab])

JOKER FUNC crc32.ChecksumIEEE has:
;; (defn ^Int ChecksumIEEE
;;   "ChecksumIEEE returns the CRC-32 checksum of data\nusing the IEEE polynomial.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "checksumIEEE(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc32/crc32.go:251:24) data])

JOKER FUNC crc32.MakeTable has:
;; (defn MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\nGo return type: *Table\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "makeTable(poly)"}
;;   [poly])

JOKER FUNC crc32.New has:
;; (defn New
;;   "New creates a new hash.Hash32 computing the CRC-32 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash32 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/crc32/crc32.go:147:22)"
;;   {:added "1.0"
;;    :go "new(tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc32/crc32.go:147:14) tab])

JOKER FUNC crc32.NewIEEE has:
;; (defn NewIEEE
;;   "NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using\nthe IEEE polynomial. Its Sum method will lay the value out in\nbig-endian byte order. The returned Hash32 also implements\nencoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal\nand unmarshal the internal state of the hash.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/crc32/crc32.go:159:16)"
;;   {:added "1.0"
;;    :go "newIEEE()"}
;;   [])

JOKER FUNC crc32.Update has:
;; (defn ^Int Update
;;   "Update returns the result of adding the bytes in p to the crc.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "update(crc, tab, p)"}
;;   [crc, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc32/crc32.go:210:29) tab, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc32/crc32.go:210:39) p])

JOKER FUNC crc64.Checksum has:
;; (defn Checksum
;;   "Checksum returns the CRC-64 checksum of data\nusing the polynomial represented by the Table.\nGo return type: uint64\nJoker return type: ABEND042(cannot find typename crc64.uint64)"
;;   {:added "1.0"
;;    :go "checksum(data, tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc64/crc64.go:199:20) data, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc64/crc64.go:199:32) tab])

JOKER FUNC crc64.MakeTable has:
;; (defn MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\nGo return type: *Table\nJoker return type: (vector-of ABEND042(cannot find typename crc64.uint64))"
;;   {:added "1.0"
;;    :go "makeTable(poly)"}
;;   [poly])

JOKER FUNC crc64.New has:
;; (defn New
;;   "New creates a new hash.Hash64 computing the CRC-64 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash64 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/crc64/crc64.go:88:22)"
;;   {:added "1.0"
;;    :go "new(tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc64/crc64.go:88:14) tab])

JOKER FUNC crc64.Update has:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\nGo return type: uint64\nJoker return type: ABEND042(cannot find typename crc64.uint64)"
;;   {:added "1.0"
;;    :go "update(crc, tab, p)"}
;;   [crc, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc64/crc64.go:181:29) tab, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc64/crc64.go:181:39) p])

JOKER FUNC crypto.RegisterHash has:
;; (defn RegisterHash
;;   "RegisterHash registers a function that returns a new instance of the given\nhash function. This is intended to be called from the init function in\npackages that implement hash functions.\n"
;;   {:added "1.0"
;;    :go "registerHash(h, f)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/crypto.go:100:29) f])

JOKER FUNC cryptobyte.NewBuilder has:
;; (defn NewBuilder
;;   "NewBuilder creates a Builder that appends its output to the given buffer.\nLike append(), the slice will be reallocated if its capacity is exceeded.\nUse Bytes to get the final buffer.\nGo return type: *Builder\nJoker return type: {:err ^Error, :result ^(vector-of Int), :fixedSize ^Bool, :child ^ABEND947(recursive type reference involving cryptobyte.Builder), :offset ^Int, :pendingLenLen ^Int, :pendingIsASN1 ^Bool, :inContinuation ^Bool}"
;;   {:added "1.0"
;;    :go "newBuilder(buffer)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:37:24) buffer])

JOKER FUNC cryptobyte.NewFixedBuilder has:
;; (defn NewFixedBuilder
;;   "NewFixedBuilder creates a Builder that appends its output into the given\nbuffer. This builder does not reallocate the output buffer. Writes that\nwould exceed the buffer's capacity are treated as an error.\nGo return type: *Builder\nJoker return type: {:err ^Error, :result ^(vector-of Int), :fixedSize ^Bool, :child ^ABEND947(recursive type reference involving cryptobyte.Builder), :offset ^Int, :pendingLenLen ^Int, :pendingIsASN1 ^Bool, :inContinuation ^Bool}"
;;   {:added "1.0"
;;    :go "newFixedBuilder(buffer)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:46:29) buffer])

JOKER FUNC csv.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader that reads from r.\nGo return type: *Reader\nJoker return type: {:Comma ^ABEND042(cannot find typename csv.rune), :Comment ^ABEND042(cannot find typename csv.rune), :FieldsPerRecord ^Int, :LazyQuotes ^Bool, :TrimLeadingSpace ^Bool, :ReuseRecord ^Bool, :TrailingComma ^Bool, :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/csv/reader.go:145:5), :numLine ^Int, :rawBuffer ^(vector-of Int), :recordBuffer ^(vector-of Int), :fieldIndexes ^(vector-of Int), :lastRecord ^(vector-of String)}"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/csv/reader.go:168:18) r])

JOKER FUNC csv.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\nGo return type: *Writer\nJoker return type: {:Comma ^ABEND042(cannot find typename csv.rune), :UseCRLF ^Bool, :w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/csv/writer.go:27:11)}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/csv/writer.go:31:18) w])

JOKER FUNC curve25519.ScalarBaseMult has:
;; (defn ScalarBaseMult
;;   "ScalarBaseMult sets dst to the product in*base where dst and base are the x\ncoordinates of group points, base is the standard generator and all values\nare in little-endian form.\n"
;;   {:added "1.0"
;;    :go "scalarBaseMult(dst, in)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:21:29) dst, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:21:29) in])

JOKER FUNC curve25519.ScalarMult has:
;; (defn ScalarMult
;;   "ScalarMult sets dst to the product in*base where dst and base are the x\ncoordinates of group points and all values are in little-endian form.\n"
;;   {:added "1.0"
;;    :go "scalarMult(dst, in, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31) dst, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31) in, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31) base])

JOKER FUNC debug.FreeOSMemory has:
;; (defn FreeOSMemory
;;   "FreeOSMemory forces a garbage collection followed by an\nattempt to return as much memory to the operating system\nas possible. (Even if this is not called, the runtime gradually\nreturns memory to the operating system in a background task.)\n"
;;   {:added "1.0"
;;    :go "freeOSMemory()"}
;;   [])

JOKER FUNC debug.PrintStack has:
;; (defn PrintStack
;;   "PrintStack prints to standard error the stack trace returned by runtime.Stack.\n"
;;   {:added "1.0"
;;    :go "printStack()"}
;;   [])

JOKER FUNC debug.ReadGCStats has:
;; (defn ReadGCStats
;;   "ReadGCStats reads statistics about garbage collection into stats.\nThe number of entries in the pause history is system-dependent;\nstats.Pause slice will be reused if large enough, reallocated otherwise.\nReadGCStats may use the full capacity of the stats.Pause slice.\nIf stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles\nsummarizing the distribution of pause time. For example, if\nlen(stats.PauseQuantiles) is 5, it will be filled with the minimum,\n25%, 50%, 75%, and maximum pause times.\n"
;;   {:added "1.0"
;;    :go "readGCStats(stats)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/debug/garbage.go:31:24) stats])

JOKER FUNC debug.SetGCPercent has:
(defn ^Int SetGCPercent
  "SetGCPercent sets the garbage collection target percentage:\na collection is triggered when the ratio of freshly allocated data\nto live data remaining after the previous collection reaches this percentage.\nSetGCPercent returns the previous setting.\nThe initial setting is the value of the GOGC environment variable\nat startup, or 100 if the variable is not set.\nA negative percentage disables garbage collection.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "setGCPercent(percent)"}
  [^Int percent])

JOKER FUNC debug.SetMaxStack has:
(defn ^Int SetMaxStack
  "SetMaxStack sets the maximum amount of memory that\ncan be used by a single goroutine stack.\nIf any goroutine exceeds this limit while growing its stack,\nthe program crashes.\nSetMaxStack returns the previous setting.\nThe initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.\n\nSetMaxStack is useful mainly for limiting the damage done by\ngoroutines that enter an infinite recursion. It only limits future\nstack growth.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "setMaxStack(bytes)"}
  [^Int bytes])

JOKER FUNC debug.SetMaxThreads has:
(defn ^Int SetMaxThreads
  "SetMaxThreads sets the maximum number of operating system\nthreads that the Go program can use. If it attempts to use more than\nthis many, the program crashes.\nSetMaxThreads returns the previous setting.\nThe initial setting is 10,000 threads.\n\nThe limit controls the number of operating system threads, not the number\nof goroutines. A Go program creates a new thread only when a goroutine\nis ready to run but all the existing threads are blocked in system calls, cgo calls,\nor are locked to other goroutines due to use of runtime.LockOSThread.\n\nSetMaxThreads is useful mainly for limiting the damage done by\nprograms that create an unbounded number of threads. The idea is\nto take down the program before it takes down the operating system.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "setMaxThreads(threads)"}
  [^Int threads])

JOKER FUNC debug.SetPanicOnFault has:
(defn ^Bool SetPanicOnFault
  "SetPanicOnFault controls the runtime's behavior when a program faults\nat an unexpected (non-nil) address. Such faults are typically caused by\nbugs such as runtime memory corruption, so the default response is to crash\nthe program. Programs working with memory-mapped files or unsafe\nmanipulation of memory may cause faults at non-nil addresses in less\ndramatic situations; SetPanicOnFault allows such programs to request\nthat the runtime trigger only a panic, not a crash.\nSetPanicOnFault applies only to the current goroutine.\nIt returns the previous setting.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "setPanicOnFault(enabled)"}
  [enabled])

JOKER FUNC debug.SetTraceback has:
;; (defn SetTraceback
;;   "SetTraceback sets the amount of detail printed by the runtime in\nthe traceback it prints before exiting due to an unrecovered panic\nor an internal runtime error.\nThe level argument takes the same values as the GOTRACEBACK\nenvironment variable. For example, SetTraceback(\"all\") ensure\nthat the program prints all goroutines when it crashes.\nSee the package runtime documentation for details.\nIf SetTraceback is called with a level lower than that of the\nenvironment variable, the call is ignored.\n"
;;   {:added "1.0"
;;    :go "setTraceback(level)"}
;;   [^String level])

JOKER FUNC debug.Stack has:
;; (defn Stack
;;   "Stack returns a formatted stack trace of the goroutine that calls it.\nIt calls runtime.Stack with a large enough buffer to capture the entire trace.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "stack()"}
;;   [])

JOKER FUNC debug.WriteHeapDump has:
;; (defn WriteHeapDump
;;   "WriteHeapDump writes a description of the heap and the objects in\nit to the given file descriptor.\n\nWriteHeapDump suspends the execution of all goroutines until the heap\ndump is completely written.  Thus, the file descriptor must not be\nconnected to a pipe or socket whose other end is in the same Go\nprocess; instead, use a temporary file or network socket.\n\nThe heap dump format is defined at https://golang.org/s/go15heapdump.\n"
;;   {:added "1.0"
;;    :go "writeHeapDump(fd)"}
;;   [fd])

JOKER FUNC des.NewCipher has:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/des/cipher.go:29:29) Error]"
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/des/cipher.go:29:20) key])

JOKER FUNC des.NewTripleDESCipher has:
;; (defn NewTripleDESCipher
;;   "NewTripleDESCipher creates and returns a new cipher.Block.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/des/cipher.go:73:38) Error]"
;;   {:added "1.0"
;;    :go "newTripleDESCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/des/cipher.go:73:29) key])

JOKER FUNC dnsmessage.NewBuilder has:
;; (defn NewBuilder
;;   "NewBuilder creates a new builder with compression disabled.\n\nNote: Most users will want to immediately enable compression with the\nEnableCompression method. See that method's comment for why you may or may\nnot want to enable compression.\n\nThe DNS message is appended to the provided initial buffer buf (which may be\nnil) as it is built. The final message is returned by the (*Builder).Finish\nmethod, which may return the same underlying array if there was sufficient\ncapacity in the slice.\nGo return type: Builder\nJoker return type: {:msg ^(vector-of Int), :section ^ABEND042(cannot find typename dnsmessage.section), :header ^ABEND042(cannot find typename dnsmessage.header), :start ^Int, :compression ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go:926:14)}"
;;   {:added "1.0"
;;    :go "newBuilder(buf, h)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go:939:21) buf, h])

JOKER FUNC dnsmessage.NewName has:
;; (defn NewName
;;   "NewName creates a new Name from a string.\nGo return type: (Name, error)\nJoker return type: [{:Data ^(vector-of Int), :Length ^ABEND042(cannot find typename dnsmessage.uint8)} Error]"
;;   {:added "1.0"
;;    :go "newName(name)"}
;;   [^String name])

JOKER FUNC doc.Examples has:
;; (defn Examples
;;   "Examples returns the examples found in the files, sorted by Name field.\nThe Order fields record the order in which the examples were encountered.\n\nPlayable Examples must be in a package whose name ends in \"_test\".\nAn Example is \"playable\" (the Play field is non-nil) in either of these\ncircumstances:\n  - The example function is self-contained: the function references only\n    identifiers from other packages (or predeclared identifiers, such as\n    \"int\") and the test file does not include a dot import.\n  - The entire test file is the example: the file contains exactly one\n    example function, zero test or benchmark functions, and at least one\n    top-level function, type, variable, or constant declaration other\n    than the example function.\nGo return type: []*Example\nJoker return type: (vector-of {:Name ^String, :Doc ^String, :Code ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/example.go:25:14), :Play ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/example.go:26:15), :Comments ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/example.go:27:17)), :Output ^String, :Unordered ^Bool, :EmptyOutput ^Bool, :Order ^Int})"
;;   {:added "1.0"
;;    :go "examples(files)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/go/doc/example.go:47:21) files])

JOKER FUNC doc.IsPredeclared has:
(defn ^Bool IsPredeclared
  "IsPredeclared reports whether s is a predeclared identifier.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isPredeclared(s)"}
  [^String s])

JOKER FUNC doc.New has:
;; (defn New
;;   "New computes the package documentation for the given package AST.\nNew takes ownership of the AST pkg and may edit or overwrite it.\nGo return type: *Package\nJoker return type: {:Doc ^String, :Name ^String, :ImportPath ^String, :Imports ^(vector-of String), :Filenames ^(vector-of String), :Notes ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/doc/doc.go:20:13), :Bugs ^(vector-of String), :Consts ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/doc.go:37:9), :order ^Int}), :Types ^(vector-of {:Doc ^String, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/doc.go:46:8), :Consts ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/doc.go:37:9), :order ^Int}), :Vars ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/doc.go:37:9), :order ^Int}), :Funcs ^(vector-of {:Doc ^String, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/doc.go:59:8), :Recv ^String, :Orig ^String, :Level ^Int}), :Methods ^(vector-of {:Doc ^String, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/doc.go:59:8), :Recv ^String, :Orig ^String, :Level ^Int})}), :Vars ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/doc.go:37:9), :order ^Int}), :Funcs ^(vector-of {:Doc ^String, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/doc.go:59:8), :Recv ^String, :Orig ^String, :Level ^Int})}"
;;   {:added "1.0"
;;    :go "new(pkg, importPath, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/doc/doc.go:94:14) pkg, ^String importPath, mode])

JOKER FUNC doc.Synopsis has:
(defn ^String Synopsis
  "Synopsis returns a cleaned version of the first sentence in s.\nThat sentence ends after the first period followed by space and\nnot preceded by exactly one uppercase letter. The result string\nhas no \\n, \\r, or \\t characters and uses only single spaces between\nwords. If s starts with any of the IllegalPrefixes, the result\nis the empty string.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "synopsis(s)"}
  [^String s])

JOKER FUNC doc.ToHTML has:
;; (defn ToHTML
;;   "ToHTML converts comment text to formatted HTML.\nThe comment was prepared by DocReader,\nso it is known not to have leading, trailing blank lines\nnor to have trailing spaces at the end of lines.\nThe comment markers have already been removed.\n\nEach span of unindented non-blank lines is converted into\na single paragraph. There is one exception to the rule: a span that\nconsists of a single line, is followed by another paragraph span,\nbegins with a capital letter, and contains no punctuation\nother than parentheses and commas is formatted as a heading.\n\nA span of indented lines is converted into a <pre> block,\nwith the common indent prefix removed.\n\nURLs in the comment text are converted into links; if the URL also appears\nin the words map, the link is taken from the map (if the corresponding map\nvalue is the empty string, the URL is not converted into a link).\n\nGo identifiers that appear in the words map are italicized; if the corresponding\nmap value is not the empty string, it is considered a URL and the word is converted\ninto a link.\n"
;;   {:added "1.0"
;;    :go "toHTML(w, text, words)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/comment.go:308:15) w, ^String text, ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/doc/comment.go:308:45) words])

JOKER FUNC doc.ToText has:
;; (defn ToText
;;   "ToText prepares comment text for presentation in textual output.\nIt wraps paragraphs of text to width or fewer Unicode code points\nand then prefixes each line with the indent. In preformatted sections\n(such as program text), it prefixes each non-blank line with preIndent.\n"
;;   {:added "1.0"
;;    :go "toText(w, text, indent, preIndent, width)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/comment.go:422:15) w, ^String text, ^String indent, ^String preIndent, ^Int width])

JOKER FUNC draw.Draw has:
;; (defn Draw
;;   "Draw calls DrawMask with a nil mask.\n"
;;   {:added "1.0"
;;    :go "draw(dst, r, src, sp, op)"}
;;   [dst, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:24) r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:45) src, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:61) sp, op])

JOKER FUNC draw.DrawMask has:
;; (defn DrawMask
;;   "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r\nin dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.\n"
;;   {:added "1.0"
;;    :go "drawMask(dst, r, src, sp, mask, mp, op)"}
;;   [dst, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:28) r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:49) src, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:65) sp, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:83) mask, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:99) mp, op])

JOKER FUNC driver.IsScanValue has:
;; (defn ^Bool IsScanValue
;;   "IsScanValue is equivalent to IsValue.\nIt exists for compatibility.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "isScanValue(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/database/sql/driver/types.go:188:20) v])

JOKER FUNC driver.IsValue has:
;; (defn ^Bool IsValue
;;   "IsValue reports whether v is a valid Value parameter type.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "isValue(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/database/sql/driver/types.go:175:16) v])

JOKER FUNC dsa.GenerateKey has:
;; (defn ^Error GenerateKey
;;   "GenerateKey generates a public&private key pair. The Parameters of the\nPrivateKey must already be valid (see GenerateParameters).\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "generateKey(priv, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:153:23) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/dsa/dsa.go:153:41) rand])

JOKER FUNC dsa.GenerateParameters has:
;; (defn ^Error GenerateParameters
;;   "GenerateParameters puts a random, valid set of DSA parameters into params.\nThis function can take many seconds, even on fast machines.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "generateParameters(params, rand, sizes)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:59:32) params, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/dsa/dsa.go:59:50) rand, sizes])

JOKER FUNC dsa.Sign has:
;; (defn Sign
;;   "Sign signs an arbitrary length hash (which should be the result of hashing a\nlarger message) using the private key, priv. It returns the signature as a\npair of integers. The security of the private key depends on the entropy of\nrand.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nBe aware that calling Sign with an attacker-controlled PrivateKey may\nrequire an arbitrary amount of CPU.\nGo return type: (r *, s *, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/dsa/dsa.go:199:65) r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/dsa/dsa.go:199:65) s ^Error err]"
;;   {:added "1.0"
;;    :go "sign(rand, priv, hash)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/dsa/dsa.go:199:16) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:199:32) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/dsa/dsa.go:199:50) hash])

JOKER FUNC dsa.Verify has:
;; (defn ^Bool Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. It\nreports whether the signature is valid.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "verify(pub, hash, r, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:267:17) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/dsa/dsa.go:267:34) hash, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:267:47) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:267:47) s])

JOKER FUNC dwarf.New has:
;; (defn New
;;   "New returns a new Data object initialized from the given parameters.\nRather than calling this function directly, clients should typically use\nthe DWARF method of the File type of the appropriate package debug/elf,\ndebug/macho, or debug/pe.\n\nThe []byte arguments are the data from the corresponding debug section\nin the object file; for example, for an ELF object, abbrev is the contents of\nthe \".debug_abbrev\" section.\nGo return type: (*Data, error)\nJoker return type: [{:abbrev ^(vector-of Int), :aranges ^(vector-of Int), :frame ^(vector-of Int), :info ^(vector-of Int), :line ^(vector-of Int), :pubnames ^(vector-of Int), :ranges ^(vector-of Int), :str ^(vector-of Int), :abbrevCache ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/dwarf/open.go:26:14), :order ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/dwarf/open.go:27:14), :typeCache ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/dwarf/open.go:28:14), :typeSigs ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/dwarf/open.go:29:14), :unit ^(vector-of ABEND042(cannot find typename dwarf.unit))} Error]"
;;   {:added "1.0"
;;    :go "new(abbrev, aranges, frame, info, line, pubnames, ranges, str)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) abbrev, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) aranges, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) frame, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) info, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) line, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) pubnames, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) ranges, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) str])

JOKER FUNC ecdsa.GenerateKey has:
;; (defn GenerateKey
;;   "GenerateKey generates a public and private key pair.\nGo return type: (*PrivateKey, error)\nJoker return type: [{:D ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:57:5)} Error]"
;;   {:added "1.0"
;;    :go "generateKey(c, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:105:20) c, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:105:41) rand])

JOKER FUNC ecdsa.Sign has:
;; (defn Sign
;;   "Sign signs a hash (which should be the result of hashing a larger message)\nusing the private key, priv. If the hash is longer than the bit-length of the\nprivate key's curve order, the hash will be truncated to that length.  It\nreturns the signature as a pair of integers. The security of the private key\ndepends on the entropy of rand.\nGo return type: (r *, s *, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:65) r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:65) s ^Error err]"
;;   {:added "1.0"
;;    :go "sign(rand, priv, hash)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:16) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:32) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:50) hash])

JOKER FUNC ecdsa.Verify has:
;; (defn ^Bool Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. Its\nreturn value records whether the signature is valid.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "verify(pub, hash, r, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:234:17) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/ecdsa/ecdsa.go:234:34) hash, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:234:47) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:234:47) s])

JOKER FUNC elf.NewFile has:
;; (defn NewFile
;;   "NewFile creates a new File for accessing an ELF binary in an underlying reader.\nThe ELF binary is expected to start at position 0 in the ReaderAt.\nGo return type: (*File, error)\nJoker return type: [{:Sections ^(vector-of {:sr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:95:6), :compressionType ^Int, :compressionOffset ^Int}), :Progs ^(vector-of {:sr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:162:6)}), :closer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:55:12), :gnuNeed ^(vector-of ABEND042(cannot find typename elf.verneed)), :gnuVersym ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:235:16) r])

JOKER FUNC elf.Open has:
;; (defn Open
;;   "Open opens the named file using os.Open and prepares it for use as an ELF binary.\nGo return type: (*File, error)\nJoker return type: [{:Sections ^(vector-of {:sr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:95:6), :compressionType ^Int, :compressionOffset ^Int}), :Progs ^(vector-of {:sr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:162:6)}), :closer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:55:12), :gnuNeed ^(vector-of ABEND042(cannot find typename elf.verneed)), :gnuVersym ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC elf.R_INFO has:
;; (defn R_INFO
;;   "Go return type: uint64\nJoker return type: ABEND042(cannot find typename elf.uint64)"
;;   {:added "1.0"
;;    :go "r_INFO(sym, typ)"}
;;   [sym, typ])

JOKER FUNC elf.R_INFO32 has:
(defn ^Int R_INFO32
  "Go return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "r_INFO32(sym, typ)"}
  [sym, typ])

JOKER FUNC elf.R_SYM32 has:
(defn ^Int R_SYM32
  "Go return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "r_SYM32(info)"}
  [info])

JOKER FUNC elf.R_SYM64 has:
(defn ^Int R_SYM64
  "Go return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "r_SYM64(info)"}
  [info])

JOKER FUNC elf.R_TYPE32 has:
(defn ^Int R_TYPE32
  "Go return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "r_TYPE32(info)"}
  [info])

JOKER FUNC elf.R_TYPE64 has:
(defn ^Int R_TYPE64
  "Go return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "r_TYPE64(info)"}
  [info])

JOKER FUNC elf.ST_BIND has:
(defn ^Int ST_BIND
  "Go return type: SymBind\nJoker return type: Int"
  {:added "1.0"
   :go "sT_BIND(info)"}
  [info])

JOKER FUNC elf.ST_INFO has:
;; (defn ST_INFO
;;   "Go return type: uint8\nJoker return type: ABEND042(cannot find typename elf.uint8)"
;;   {:added "1.0"
;;    :go "sT_INFO(bind, typ)"}
;;   [bind, typ])

JOKER FUNC elf.ST_TYPE has:
(defn ^Int ST_TYPE
  "Go return type: SymType\nJoker return type: Int"
  {:added "1.0"
   :go "sT_TYPE(info)"}
  [info])

JOKER FUNC elf.ST_VISIBILITY has:
(defn ^Int ST_VISIBILITY
  "Go return type: SymVis\nJoker return type: Int"
  {:added "1.0"
   :go "sT_VISIBILITY(other)"}
  [other])

JOKER FUNC elliptic.GenerateKey has:
;; (defn GenerateKey
;;   "GenerateKey returns a public/private key pair. The private key is\ngenerated using the given reader, which must return random data.\nGo return type: (priv []int, x *, y *, err error)\nJoker return type: [^(vector-of Int) priv ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/elliptic/elliptic.go:276:67) x ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/elliptic/elliptic.go:276:67) y ^Error err]"
;;   {:added "1.0"
;;    :go "generateKey(curve, rand)"}
;;   [curve, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/elliptic/elliptic.go:276:36) rand])

JOKER FUNC elliptic.Marshal has:
;; (defn Marshal
;;   "Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "marshal(curve, x, y)"}
;;   [curve, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/elliptic/elliptic.go:305:32) x, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/elliptic/elliptic.go:305:32) y])

JOKER FUNC elliptic.P224 has:
;; (defn P224
;;   "P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n\nThe cryptographic operations are implemented using constant-time algorithms.\nGo return type: Curve\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p224()"}
;;   [])

JOKER FUNC elliptic.P256 has:
;; (defn P256
;;   "P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n\nThe cryptographic operations are implemented using constant-time algorithms.\nGo return type: Curve\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p256()"}
;;   [])

JOKER FUNC elliptic.P384 has:
;; (defn P384
;;   "P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n\nThe cryptographic operations do not use constant-time algorithms.\nGo return type: Curve\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p384()"}
;;   [])

JOKER FUNC elliptic.P521 has:
;; (defn P521
;;   "P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n\nThe cryptographic operations do not use constant-time algorithms.\nGo return type: Curve\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p521()"}
;;   [])

JOKER FUNC elliptic.Unmarshal has:
;; (defn Unmarshal
;;   "Unmarshal converts a point, serialized by Marshal, into an x, y pair.\nIt is an error if the point is not in uncompressed form or is not on the curve.\nOn error, x = nil.\nGo return type: (x *, y *)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/elliptic/elliptic.go:321:49) x ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/elliptic/elliptic.go:321:49) y]"
;;   {:added "1.0"
;;    :go "unmarshal(curve, data)"}
;;   [curve, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/elliptic/elliptic.go:321:34) data])

JOKER FUNC errors.New has:
(defn ^Error New
  "New returns an error that formats as the given text.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "new(text)"}
  [^String text])

JOKER FUNC exec.Command has:
;; (defn Command
;;   "Command returns the Cmd struct to execute the named program with\nthe given arguments.\n\nIt sets only the Path and Args in the returned structure.\n\nIf name contains no path separators, Command uses LookPath to\nresolve name to a complete path if possible. Otherwise it uses name\ndirectly as Path.\n\nThe returned Cmd's Args field is constructed from the command name\nfollowed by the elements of arg, so arg should not include the\ncommand name itself. For example, Command(\"echo\", \"hello\").\nArgs[0] is always name, not the possibly resolved Path.\nGo return type: *Cmd\nJoker return type: {:Path ^String, :Args ^(vector-of String), :Env ^(vector-of String), :Dir ^String, :Stdin ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:93:8), :Stdout ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:110:9), :Stderr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:111:9), :ExtraFiles ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:118:16)), :SysProcAttr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:122:15), :Process ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:125:11), :ProcessState ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:129:16), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:131:18), :lookPathErr ^Error, :finished ^Bool, :childFiles ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:134:21)), :closeAfterStart ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:135:20)), :closeAfterWait ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:136:20)), :goroutine ^(vector-of ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/os/exec/exec.go:137:20)), :errch ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/exec/exec.go:138:18), :waitDone ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/exec/exec.go:139:18)}"
;;   {:added "1.0"
;;    :go "command(name, arg)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/exec/exec.go:155:31) arg])

JOKER FUNC exec.CommandContext has:
;; (defn CommandContext
;;   "CommandContext is like Command but includes a context.\n\nThe provided context is used to kill the process (by calling\nos.Process.Kill) if the context becomes done before the command\ncompletes on its own.\nGo return type: *Cmd\nJoker return type: {:Path ^String, :Args ^(vector-of String), :Env ^(vector-of String), :Dir ^String, :Stdin ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:93:8), :Stdout ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:110:9), :Stderr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:111:9), :ExtraFiles ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:118:16)), :SysProcAttr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:122:15), :Process ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:125:11), :ProcessState ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:129:16), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:131:18), :lookPathErr ^Error, :finished ^Bool, :childFiles ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:134:21)), :closeAfterStart ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:135:20)), :closeAfterWait ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:136:20)), :goroutine ^(vector-of ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/os/exec/exec.go:137:20)), :errch ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/exec/exec.go:138:18), :waitDone ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/exec/exec.go:139:18)}"
;;   {:added "1.0"
;;    :go "commandContext(ctx, name, arg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:175:25) ctx, ^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/exec/exec.go:175:59) arg])

JOKER FUNC exec.LookPath has:
;; (defn LookPath
;;   "LookPath searches for an executable named file in the\ndirectories named by the PATH environment variable.\nIf file contains a slash, it is tried directly and the PATH is not consulted.\nThe result may be an absolute path or a path relative to the current directory.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "lookPath(file)"}
;;   [^String file])

JOKER FUNC expvar.Do has:
;; (defn Do
;;   "Do calls f for each exported variable.\nThe global variable map is locked during the iteration,\nbut existing entries may be concurrently updated.\n"
;;   {:added "1.0"
;;    :go "do(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/expvar/expvar.go:306:11) f])

JOKER FUNC expvar.Get has:
;; (defn Get
;;   "Get retrieves a named exported variable. It returns nil if the name has\nnot been registered.\nGo return type: Var\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/expvar/expvar.go:40:10)"
;;   {:added "1.0"
;;    :go "get(name)"}
;;   [^String name])

JOKER FUNC expvar.Handler has:
;; (defn Handler
;;   "Handler returns the expvar HTTP Handler.\n\nThis is only needed to install the handler in a non-standard location.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/expvar/expvar.go:332:16)"
;;   {:added "1.0"
;;    :go "handler()"}
;;   [])

JOKER FUNC expvar.NewFloat has:
;; (defn NewFloat
;;   "Go return type: *Float\nJoker return type: {:f ^ABEND042(cannot find typename expvar.uint64)}"
;;   {:added "1.0"
;;    :go "newFloat(name)"}
;;   [^String name])

JOKER FUNC expvar.NewInt has:
;; (defn NewInt
;;   "Go return type: *Int\nJoker return type: {:i ^Int}"
;;   {:added "1.0"
;;    :go "newInt(name)"}
;;   [^String name])

JOKER FUNC expvar.NewMap has:
;; (defn NewMap
;;   "Go return type: *Map\nJoker return type: {:m ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/expvar/expvar.go:102:9), :keysMu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/expvar/expvar.go:103:9), :keys ^(vector-of String)}"
;;   {:added "1.0"
;;    :go "newMap(name)"}
;;   [^String name])

JOKER FUNC expvar.NewString has:
;; (defn NewString
;;   "Go return type: *String\nJoker return type: {:s ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/expvar/expvar.go:216:4)}"
;;   {:added "1.0"
;;    :go "newString(name)"}
;;   [^String name])

JOKER FUNC expvar.Publish has:
;; (defn Publish
;;   "Publish declares a named exported variable. This should be called from a\npackage's init function when it creates its Vars. If the name is already\nregistered then this will log.Panic.\n"
;;   {:added "1.0"
;;    :go "publish(name, v)"}
;;   [^String name, v])

JOKER FUNC fcgi.ProcessEnv has:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\nJoker return type: ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "processEnv(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fcgi/child.go:358:19) r])

JOKER FUNC fcgi.Serve has:
;; (defn ^Error Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fcgi/child.go:331:14) l, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fcgi/child.go:331:36) handler])

JOKER FUNC filepath.Abs has:
;; (defn Abs
;;   "Abs returns an absolute representation of path.\nIf the path is not absolute it will be joined with the current\nworking directory to turn it into an absolute path. The absolute\npath name for a given file is not guaranteed to be unique.\nAbs calls Clean on the result.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "abs(path)"}
;;   [^String path])

JOKER FUNC filepath.Base has:
(defn ^String Base
  "Base returns the last element of path.\nTrailing path separators are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of separators, Base returns a single separator.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "base(path)"}
  [^String path])

JOKER FUNC filepath.Clean has:
(defn ^String Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple Separator elements with a single one.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path,\n\t   assuming Separator is '/'.\n\nThe returned path ends in a slash only if it represents a root directory,\nsuch as \"/\" on Unix or `C:\\` on Windows.\n\nFinally, any occurrences of slash are replaced by Separator.\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "clean(path)"}
  [^String path])

JOKER FUNC filepath.Dir has:
(defn ^String Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element, Dir calls Clean on the path and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of separators, Dir returns a single separator.\nThe returned path does not end in a separator unless it is the root directory.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "dir(path)"}
  [^String path])

JOKER FUNC filepath.EvalSymlinks has:
;; (defn EvalSymlinks
;;   "EvalSymlinks returns the path name after the evaluation of any symbolic\nlinks.\nIf path is relative the result will be relative to the current directory,\nunless one of the components is an absolute symbolic link.\nEvalSymlinks calls Clean on the result.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "evalSymlinks(path)"}
;;   [^String path])

JOKER FUNC filepath.Ext has:
(defn ^String Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final element of path; it is empty if there is\nno dot.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "ext(path)"}
  [^String path])

JOKER FUNC filepath.FromSlash has:
(defn ^String FromSlash
  "FromSlash returns the result of replacing each slash ('/') character\nin path with a separator character. Multiple slashes are replaced\nby multiple separators.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "fromSlash(path)"}
  [^String path])

JOKER FUNC filepath.Glob has:
;; (defn Glob
;;   "Glob returns the names of all files matching pattern or nil\nif there is no matching file. The syntax of patterns is the same\nas in Match. The pattern may describe hierarchical names such as\n/usr/*/bin/ed (assuming the Separator is '/').\n\nGlob ignores file system errors such as I/O errors reading directories.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\nGo return type: (matches []string, err error)\nJoker return type: [^(vector-of String) matches ^Error err]"
;;   {:added "1.0"
;;    :go "glob(pattern)"}
;;   [^String pattern])

JOKER FUNC filepath.HasPrefix has:
(defn ^Bool HasPrefix
  "HasPrefix exists for historical compatibility and should not be used.\n\nDeprecated: HasPrefix does not respect path boundaries and\ndoes not ignore case when required.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "hasPrefix(p, prefix)"}
  [^String p, ^String prefix])

JOKER FUNC filepath.IsAbs has:
(defn ^Bool IsAbs
  "IsAbs reports whether the path is absolute.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isAbs(path)"}
  [^String path])

JOKER FUNC filepath.Join has:
;; (defn ^String Join
;;   "Join joins any number of path elements into a single path, adding\na Separator if necessary. Join calls Clean on the result; in particular,\nall empty strings are ignored.\nOn Windows, the result is a UNC path if and only if the first path\nelement is a UNC path.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "join(elem)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/path/filepath/path.go:209:16) elem])

JOKER FUNC filepath.Match has:
;; (defn Match
;;   "Match reports whether name matches the shell file name pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-Separator characters\n\t\t'?'         matches any single non-Separator character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nOn Windows, escaping is disabled. Instead, '\\\\' is treated as\npath separator.\nGo return type: (matched bool, err error)\nJoker return type: [^Bool matched ^Error err]"
;;   {:added "1.0"
;;    :go "match(pattern, name)"}
;;   [^String pattern, ^String name])

JOKER FUNC filepath.Rel has:
;; (defn Rel
;;   "Rel returns a relative path that is lexically equivalent to targpath when\njoined to basepath with an intervening separator. That is,\nJoin(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.\nOn success, the returned path will always be relative to basepath,\neven if basepath and targpath share no elements.\nAn error is returned if targpath can't be made relative to basepath or if\nknowing the current working directory would be necessary to compute it.\nRel calls Clean on the result.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "rel(basepath, targpath)"}
;;   [^String basepath, ^String targpath])

JOKER FUNC filepath.Split has:
;; (defn Split
;;   "Split splits path immediately following the final Separator,\nseparating it into a directory and file name component.\nIf there is no Separator in path, Split returns an empty dir\nand file set to path.\nThe returned values have the property that path = dir+file.\nGo return type: (dir string, file string)\nJoker return type: [^String dir ^String file]"
;;   {:added "1.0"
;;    :go "split(path)"}
;;   [^String path])

JOKER FUNC filepath.SplitList has:
;; (defn SplitList
;;   "SplitList splits a list of paths joined by the OS-specific ListSeparator,\nusually found in PATH or GOPATH environment variables.\nUnlike strings.Split, SplitList returns an empty slice when passed an empty\nstring.\nGo return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "splitList(path)"}
;;   [^String path])

JOKER FUNC filepath.ToSlash has:
(defn ^String ToSlash
  "ToSlash returns the result of replacing each separator character\nin path with a slash ('/') character. Multiple separators are\nreplaced by multiple slashes.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "toSlash(path)"}
  [^String path])

JOKER FUNC filepath.VolumeName has:
(defn ^String VolumeName
  "VolumeName returns leading volume name.\nGiven \"C:\\foo\\bar\" it returns \"C:\" on Windows.\nGiven \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\".\nOn other platforms it returns \"\".\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "volumeName(path)"}
  [^String path])

JOKER FUNC filepath.Walk has:
(defn ^Error Walk
  "Walk walks the file tree rooted at root, calling walkFn for each file or\ndirectory in the tree, including root. All errors that arise visiting files\nand directories are filtered by walkFn. The files are walked in lexical\norder, which makes the output deterministic but means that for very\nlarge directories Walk can be inefficient.\nWalk does not follow symbolic links.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "walk(root, walkFn)"}
  [^String root, walkFn])

JOKER FUNC flag.Arg has:
(defn ^String Arg
  "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument\nafter flags have been processed. Arg returns an empty string if the\nrequested element does not exist.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "arg(i)"}
  [^Int i])

JOKER FUNC flag.Args has:
;; (defn Args
;;   "Args returns the non-flag command-line arguments.\nGo return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "args()"}
;;   [])

JOKER FUNC flag.Bool has:
(defn ^Bool Bool
  "Bool defines a bool flag with specified name, default value, and usage string.\nThe return value is the address of a bool variable that stores the value of the flag.\nGo return type: *bool\nJoker return type: Bool"
  {:added "1.0"
   :go "bool(name, value, usage)"}
  [^String name, value, ^String usage])

JOKER FUNC flag.BoolVar has:
;; (defn BoolVar
;;   "BoolVar defines a bool flag with specified name, default value, and usage string.\nThe argument p points to a bool variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "boolVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:583:16) p, ^String name, value, ^String usage])

JOKER FUNC flag.Duration has:
;; (defn Duration
;;   "Duration defines a time.Duration flag with specified name, default value, and usage string.\nThe return value is the address of a time.Duration variable that stores the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\nGo return type: *\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:783:64)"
;;   {:added "1.0"
;;    :go "duration(name, value, usage)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:783:34) value, ^String usage])

JOKER FUNC flag.DurationVar has:
;; (defn DurationVar
;;   "DurationVar defines a time.Duration flag with specified name, default value, and usage string.\nThe argument p points to a time.Duration variable in which to store the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n"
;;   {:added "1.0"
;;    :go "durationVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:767:20) p, ^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:767:55) value, ^String usage])

JOKER FUNC flag.Float64 has:
;; (defn Float64
;;   "Float64 defines a float64 flag with specified name, default value, and usage string.\nThe return value is the address of a float64 variable that stores the value of the flag.\nGo return type: *float64\nJoker return type: ABEND042(cannot find typename flag.float64)"
;;   {:added "1.0"
;;    :go "float64(name, value, usage)"}
;;   [^String name, value, ^String usage])

JOKER FUNC flag.Float64Var has:
;; (defn Float64Var
;;   "Float64Var defines a float64 flag with specified name, default value, and usage string.\nThe argument p points to a float64 variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "float64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:739:19) p, ^String name, value, ^String usage])

JOKER FUNC flag.Int has:
(defn ^Int Int
  "Int defines an int flag with specified name, default value, and usage string.\nThe return value is the address of an int variable that stores the value of the flag.\nGo return type: *int\nJoker return type: Int"
  {:added "1.0"
   :go "int(name, value, usage)"}
  [^String name, ^Int value, ^String usage])

JOKER FUNC flag.Int64 has:
(defn ^Int Int64
  "Int64 defines an int64 flag with specified name, default value, and usage string.\nThe return value is the address of an int64 variable that stores the value of the flag.\nGo return type: *int\nJoker return type: Int"
  {:added "1.0"
   :go "int64(name, value, usage)"}
  [^String name, value, ^String usage])

JOKER FUNC flag.Int64Var has:
;; (defn Int64Var
;;   "Int64Var defines an int64 flag with specified name, default value, and usage string.\nThe argument p points to an int64 variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "int64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:635:17) p, ^String name, value, ^String usage])

JOKER FUNC flag.IntVar has:
;; (defn IntVar
;;   "IntVar defines an int flag with specified name, default value, and usage string.\nThe argument p points to an int variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "intVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:609:15) p, ^String name, ^Int value, ^String usage])

JOKER FUNC flag.Lookup has:
;; (defn Lookup
;;   "Lookup returns the Flag structure of the named command-line flag,\nreturning nil if none exists.\nGo return type: *Flag\nJoker return type: {:Name ^String, :Usage ^String, :Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/flag/flag.go:248:12), :DefValue ^String}"
;;   {:added "1.0"
;;    :go "lookup(name)"}
;;   [^String name])

JOKER FUNC flag.NArg has:
(defn ^Int NArg
  "NArg is the number of arguments remaining after flags have been processed.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "nArg()"}
  [])

JOKER FUNC flag.NFlag has:
(defn ^Int NFlag
  "NFlag returns the number of command-line flags that have been set.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "nFlag()"}
  [])

JOKER FUNC flag.NewFlagSet has:
;; (defn NewFlagSet
;;   "NewFlagSet returns a new, empty flag set with the specified name and\nerror handling property. If the name is not empty, it will be printed\nin the default usage message and in error messages.\nGo return type: *FlagSet\nJoker return type: {:Usage ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/flag/flag.go:280:8), :name ^String, :parsed ^Bool, :actual ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/flag/flag.go:284:16), :formal ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/flag/flag.go:285:16), :args ^(vector-of String), :errorHandling ^Int, :output ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:288:16)}"
;;   {:added "1.0"
;;    :go "newFlagSet(name, errorHandling)"}
;;   [^String name, errorHandling])

JOKER FUNC flag.Parse has:
;; (defn Parse
;;   "Parse parses the command-line flags from os.Args[1:]. Must be called\nafter all flags are defined and before flags are accessed by the program.\n"
;;   {:added "1.0"
;;    :go "parse()"}
;;   [])

JOKER FUNC flag.Parsed has:
(defn ^Bool Parsed
  "Parsed reports whether the command-line flags have been parsed.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "parsed()"}
  [])

JOKER FUNC flag.PrintDefaults has:
;; (defn PrintDefaults
;;   "PrintDefaults prints, to standard error unless configured otherwise,\na usage message showing the default settings of all defined\ncommand-line flags.\nFor an integer valued flag x, the default output has the form\n\t-x int\n\t\tusage-message-for-x (default 7)\nThe usage message will appear on a separate line for anything but\na bool flag with a one-byte name. For bool flags, the type is\nomitted and if the flag name is one byte the usage message appears\non the same line. The parenthetical default is omitted if the\ndefault is the zero value for the type. The listed type, here int,\ncan be changed by placing a back-quoted name in the flag's usage\nstring; the first such item in the message is taken to be a parameter\nname to show in the message and the back quotes are stripped from\nthe message when displayed. For instance, given\n\tflag.String(\"I\", \"\", \"search `directory` for include files\")\nthe output will be\n\t-I directory\n\t\tsearch directory for include files.\n"
;;   {:added "1.0"
;;    :go "printDefaults()"}
;;   [])

JOKER FUNC flag.Set has:
(defn ^Error Set
  "Set sets the value of the named command-line flag.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "set(name, value)"}
  [^String name, ^String value])

JOKER FUNC flag.String has:
(defn ^String String
  "String defines a string flag with specified name, default value, and usage string.\nThe return value is the address of a string variable that stores the value of the flag.\nGo return type: *string\nJoker return type: String"
  {:added "1.0"
   :go "string(name, value, usage)"}
  [^String name, ^String value, ^String usage])

JOKER FUNC flag.StringVar has:
;; (defn StringVar
;;   "StringVar defines a string flag with specified name, default value, and usage string.\nThe argument p points to a string variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "stringVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:713:18) p, ^String name, ^String value, ^String usage])

JOKER FUNC flag.Uint has:
(defn ^Int Uint
  "Uint defines a uint flag with specified name, default value, and usage string.\nThe return value is the address of a uint variable that stores the value of the flag.\nGo return type: *int\nJoker return type: Int"
  {:added "1.0"
   :go "uint(name, value, usage)"}
  [^String name, ^Int value, ^String usage])

JOKER FUNC flag.Uint64 has:
;; (defn Uint64
;;   "Uint64 defines a uint64 flag with specified name, default value, and usage string.\nThe return value is the address of a uint64 variable that stores the value of the flag.\nGo return type: *uint64\nJoker return type: ABEND042(cannot find typename flag.uint64)"
;;   {:added "1.0"
;;    :go "uint64(name, value, usage)"}
;;   [^String name, value, ^String usage])

JOKER FUNC flag.Uint64Var has:
;; (defn Uint64Var
;;   "Uint64Var defines a uint64 flag with specified name, default value, and usage string.\nThe argument p points to a uint64 variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "uint64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:687:18) p, ^String name, value, ^String usage])

JOKER FUNC flag.UintVar has:
;; (defn UintVar
;;   "UintVar defines a uint flag with specified name, default value, and usage string.\nThe argument p points to a uint variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "uintVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:661:16) p, ^String name, ^Int value, ^String usage])

JOKER FUNC flag.UnquoteUsage has:
;; (defn UnquoteUsage
;;   "UnquoteUsage extracts a back-quoted name from the usage\nstring for a flag and returns it and the un-quoted usage.\nGiven \"a `name` to show\" it returns (\"name\", \"a name to show\").\nIf there are no back quotes, the name is an educated guess of the\ntype of the flag's value, or the empty string if the flag is boolean.\nGo return type: (name string, usage string)\nJoker return type: [^String name ^String usage]"
;;   {:added "1.0"
;;    :go "unquoteUsage(flag)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:422:24) flag])

JOKER FUNC flag.Var has:
;; (defn Var
;;   "Var defines a flag with the specified name and usage string. The type and\nvalue of the flag are represented by the first argument, of type Value, which\ntypically holds a user-defined implementation of Value. For instance, the\ncaller could create a flag that turns a comma-separated string into a slice\nof strings by giving the slice the methods of Value; in particular, Set would\ndecompose the comma-separated string into the slice.\n"
;;   {:added "1.0"
;;    :go "var(value, name, usage)"}
;;   [value, ^String name, ^String usage])

JOKER FUNC flag.Visit has:
;; (defn Visit
;;   "Visit visits the command-line flags in lexicographical order, calling fn\nfor each. It visits only those flags that have been set.\n"
;;   {:added "1.0"
;;    :go "visit(fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/flag/flag.go:364:15) fn])

JOKER FUNC flag.VisitAll has:
;; (defn VisitAll
;;   "VisitAll visits the command-line flags in lexicographical order, calling\nfn for each. It visits all flags, even those not set.\n"
;;   {:added "1.0"
;;    :go "visitAll(fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/flag/flag.go:350:18) fn])

JOKER FUNC flate.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new ReadCloser that can be used\nto read the uncompressed version of r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser\nwhen finished reading.\n\nThe ReadCloser returned by NewReader also implements Resetter.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/inflate.go:796:29)"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/inflate.go:796:18) r])

JOKER FUNC flate.NewReaderDict has:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but initializes the reader\nwith a preset dictionary. The returned Reader behaves as if\nthe uncompressed data stream started with the given dictionary,\nwhich has already been read. NewReaderDict is typically used\nto read data compressed by NewWriterDict.\n\nThe ReadCloser returned by NewReader also implements Resetter.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/inflate.go:815:46)"
;;   {:added "1.0"
;;    :go "newReaderDict(r, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/inflate.go:815:22) r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/flate/inflate.go:815:38) dict])

JOKER FUNC flate.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer compressing data at the given level.\nFollowing zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\nhigher levels typically run slower but compress more. Level 0\n(NoCompression) does not attempt any compression; it only adds the\nnecessary DEFLATE framing.\nLevel -1 (DefaultCompression) uses the default compression level.\nLevel -2 (HuffmanOnly) will use Huffman compression only, giving\na very fast compression for all types of input, but sacrificing considerable\ncompression efficiency.\n\nIf level is in the range [-2, 9] then the error returned will be nil.\nOtherwise the error returned will be non-nil.\nGo return type: (*Writer, error)\nJoker return type: [{:d ^ABEND042(cannot find typename flate.compressor), :dict ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "newWriter(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/deflate.go:666:18) w, ^Int level])

JOKER FUNC flate.NewWriterDict has:
;; (defn NewWriterDict
;;   "NewWriterDict is like NewWriter but initializes the new\nWriter with a preset dictionary. The returned Writer behaves\nas if the dictionary had been written to it without producing\nany compressed output. The compressed data written to w\ncan only be decompressed by a Reader initialized with the\nsame dictionary.\nGo return type: (*Writer, error)\nJoker return type: [{:d ^ABEND042(cannot find typename flate.compressor), :dict ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "newWriterDict(w, level, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/deflate.go:680:22) w, ^Int level, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/flate/deflate.go:680:49) dict])

JOKER FUNC fmt.Errorf has:
;; (defn ^Error Errorf
;;   "Errorf formats according to a format specifier and returns the string\nas a value that satisfies error.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "errorf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:211:30) a])

JOKER FUNC fmt.Fprint has:
;; (defn Fprint
;;   "Fprint formats using the default formats for its operands and writes to w.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "fprint(w, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/print.go:220:15) w, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:220:28) a])

JOKER FUNC fmt.Fprintf has:
;; (defn Fprintf
;;   "Fprintf formats according to a format specifier and writes to w.\nIt returns the number of bytes written and any write error encountered.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "fprintf(w, format, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/print.go:186:16) w, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:186:44) a])

JOKER FUNC fmt.Fprintln has:
;; (defn Fprintln
;;   "Fprintln formats using the default formats for its operands and writes to w.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "fprintln(w, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/print.go:252:17) w, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:252:30) a])

JOKER FUNC fmt.Fscan has:
;; (defn Fscan
;;   "Fscan scans text read from r, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "fscan(r, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/scan.go:121:14) r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:121:27) a])

JOKER FUNC fmt.Fscanf has:
;; (defn Fscanf
;;   "Fscanf scans text read from r, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "fscanf(r, format, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/scan.go:141:15) r, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:141:43) a])

JOKER FUNC fmt.Fscanln has:
;; (defn Fscanln
;;   "Fscanln is similar to Fscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "fscanln(r, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/scan.go:130:16) r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:130:29) a])

JOKER FUNC fmt.Print has:
;; (defn Print
;;   "Print formats using the default formats for its operands and writes to standard output.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "print(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:231:14) a])

JOKER FUNC fmt.Printf has:
;; (defn Printf
;;   "Printf formats according to a format specifier and writes to standard output.\nIt returns the number of bytes written and any write error encountered.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "printf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:196:30) a])

JOKER FUNC fmt.Println has:
;; (defn Println
;;   "Println formats using the default formats for its operands and writes to standard output.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "println(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:263:16) a])

JOKER FUNC fmt.Scan has:
;; (defn Scan
;;   "Scan scans text read from standard input, storing successive\nspace-separated values into successive arguments. Newlines count\nas space. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "scan(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:63:13) a])

JOKER FUNC fmt.Scanf has:
;; (defn Scanf
;;   "Scanf scans text read from standard input, storing successive\nspace-separated values into successive arguments as determined by\nthe format. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\nNewlines in the input must match newlines in the format.\nThe one exception: the verb %c always scans the next rune in the\ninput, even if it is a space (or tab etc.) or newline.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "scanf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:80:29) a])

JOKER FUNC fmt.Scanln has:
;; (defn Scanln
;;   "Scanln is similar to Scan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "scanln(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:69:15) a])

JOKER FUNC fmt.Sprint has:
;; (defn ^String Sprint
;;   "Sprint formats using the default formats for its operands and returns the resulting string.\nSpaces are added between operands when neither is a string.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "sprint(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:237:15) a])

JOKER FUNC fmt.Sprintf has:
;; (defn ^String Sprintf
;;   "Sprintf formats according to a format specifier and returns the resulting string.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "sprintf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:201:31) a])

JOKER FUNC fmt.Sprintln has:
;; (defn ^String Sprintln
;;   "Sprintln formats using the default formats for its operands and returns the resulting string.\nSpaces are always added between operands and a newline is appended.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "sprintln(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:269:17) a])

JOKER FUNC fmt.Sscan has:
;; (defn Sscan
;;   "Sscan scans the argument string, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "sscan(str, a)"}
;;   [^String str, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:99:26) a])

JOKER FUNC fmt.Sscanf has:
;; (defn Sscanf
;;   "Sscanf scans the argument string, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "sscanf(str, format, a)"}
;;   [^String str, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:113:42) a])

JOKER FUNC fmt.Sscanln has:
;; (defn Sscanln
;;   "Sscanln is similar to Sscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "sscanln(str, a)"}
;;   [^String str, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:105:28) a])

JOKER FUNC fnv.New128 has:
;; (defn New128
;;   "New128 returns a new 128-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:70:15)"
;;   {:added "1.0"
;;    :go "new128()"}
;;   [])

JOKER FUNC fnv.New128a has:
;; (defn New128a
;;   "New128a returns a new 128-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:79:16)"
;;   {:added "1.0"
;;    :go "new128a()"}
;;   [])

JOKER FUNC fnv.New32 has:
;; (defn New32
;;   "New32 returns a new 32-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:42:14)"
;;   {:added "1.0"
;;    :go "new32()"}
;;   [])

JOKER FUNC fnv.New32a has:
;; (defn New32a
;;   "New32a returns a new 32-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:49:15)"
;;   {:added "1.0"
;;    :go "new32a()"}
;;   [])

JOKER FUNC fnv.New64 has:
;; (defn New64
;;   "New64 returns a new 64-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:56:14)"
;;   {:added "1.0"
;;    :go "new64()"}
;;   [])

JOKER FUNC fnv.New64a has:
;; (defn New64a
;;   "New64a returns a new 64-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:63:15)"
;;   {:added "1.0"
;;    :go "new64a()"}
;;   [])

JOKER FUNC format.Node has:
;; (defn ^Error Node
;;   "Node formats node in canonical gofmt style and writes the result to dst.\n\nThe node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n[]ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,\nor ast.Stmt. Node does not modify node. Imports are not sorted for\nnodes representing partial source files (for instance, if the node is\nnot an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).\n\nThe function may return early (before the entire result is written)\nand return a formatting error, for instance due to an incorrect AST.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "node(dst, fset, node)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/format/format.go:42:15) dst, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/format/format.go:42:31) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/format/format.go:42:52) node])

JOKER FUNC format.Source has:
;; (defn Source
;;   "Source formats src in canonical gofmt style and returns the result\nor an (I/O or syntax) error. src is expected to be a syntactically\ncorrect Go source file, or a list of Go declarations or statements.\n\nIf src is a partial source file, the leading and trailing space of src\nis applied to the result (such that it has the same leading and trailing\nspace as src), and the result is indented by the same amount as the first\nline of src containing code. Imports are not sorted for partial source files.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "source(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/format/format.go:91:17) src])

JOKER FUNC gif.Decode has:
;; (defn Decode
;;   "Decode reads a GIF image from r and returns the first embedded\nimage as an image.Image.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:561:27) Error]"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:561:15) r])

JOKER FUNC gif.DecodeAll has:
;; (defn DecodeAll
;;   "DecodeAll reads a GIF image from r and returns the sequential frames\nand timing information.\nGo return type: (*GIF, error)\nJoker return type: [{:Image ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:571:11)), :Delay ^(vector-of Int), :LoopCount ^Int, :Disposal ^(vector-of Int), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:593:9), :BackgroundIndex ^Int} Error]"
;;   {:added "1.0"
;;    :go "decodeAll(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:601:18) r])

JOKER FUNC gif.DecodeConfig has:
;; (defn DecodeConfig
;;   "DecodeConfig returns the global color model and dimensions of a GIF image\nwithout decoding the entire image.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:623:33) Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:623:21) r])

JOKER FUNC gif.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in GIF format.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "encode(w, m, o)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/writer.go:418:15) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/writer.go:418:28) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/image/gif/writer.go:418:43) o])

JOKER FUNC gif.EncodeAll has:
;; (defn ^Error EncodeAll
;;   "EncodeAll writes the images in g to w in GIF format with the\ngiven loop count and delay between frames.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "encodeAll(w, g)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/writer.go:372:18) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/image/gif/writer.go:372:31) g])

JOKER FUNC gob.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from the io.Reader.\nIf r does not also implement io.ByteReader, it will be wrapped in a\nbufio.Reader.\nGo return type: *Decoder\nJoker return type: {:mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/decoder.go:27:15), :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/decoder.go:28:15), :buf ^ABEND042(cannot find typename gob.decBuffer), :wireType ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/gob/decoder.go:30:15), :decoderCache ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/gob/decoder.go:31:15), :ignorerCache ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/gob/decoder.go:32:15), :freeList ^ABEND042(cannot find typename gob.decoderState), :countBuf ^(vector-of Int), :err ^Error}"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/decoder.go:41:19) r])

JOKER FUNC gob.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that will transmit on the io.Writer.\nGo return type: *Encoder\nJoker return type: {:mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/encoder.go:17:13), :w ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/encoder.go:18:15)), :sent ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/gob/encoder.go:19:13), :countState ^ABEND042(cannot find typename gob.encoderState), :freeList ^ABEND042(cannot find typename gob.encoderState), :byteBuf ^ABEND042(cannot find typename gob.encBuffer), :err ^Error}"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/encoder.go:33:19) w])

JOKER FUNC gob.Register has:
;; (defn Register
;;   "Register records a type, identified by a value for that type, under its\ninternal type name. That name will identify the concrete type of a value\nsent or received as an interface variable. Only types that will be\ntransferred as implementations of interface values need to be registered.\nExpecting to be used only during initialization, it panics if the mapping\nbetween types and names is not a bijection.\n"
;;   {:added "1.0"
;;    :go "register(value)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/gob/type.go:836:21) value])

JOKER FUNC gob.RegisterName has:
;; (defn RegisterName
;;   "RegisterName is like Register but uses the provided name rather than the\ntype's default.\n"
;;   {:added "1.0"
;;    :go "registerName(name, value)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/gob/type.go:807:38) value])

JOKER FUNC gosym.NewLineTable has:
;; (defn NewLineTable
;;   "NewLineTable returns a new PC/line table\ncorresponding to the encoded data.\nText must be the start address of the\ncorresponding text segment.\nGo return type: *LineTable\nJoker return type: {:Data ^(vector-of Int), :PC ^ABEND042(cannot find typename gosym.uint64), :Line ^Int, :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/gosym/pclntab.go:36:11), :go12 ^Int, :binary ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/gosym/pclntab.go:38:11), :quantum ^Int, :ptrsize ^Int, :functab ^(vector-of Int), :nfunctab ^Int, :filetab ^(vector-of Int), :nfiletab ^Int, :fileMap ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/pclntab.go:45:11), :strings ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/pclntab.go:46:11)}"
;;   {:added "1.0"
;;    :go "newLineTable(data, text)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/pclntab.go:124:24) data, text])

JOKER FUNC gosym.NewTable has:
;; (defn NewTable
;;   "NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF),\nreturning an in-memory representation.\nStarting with Go 1.3, the Go symbol table no longer includes symbol data.\nGo return type: (*Table, error)\nJoker return type: [{:Syms ^(vector-of {:Value ^ABEND042(cannot find typename gosym.uint64), :Type ^Int, :Name ^String, :GoType ^ABEND042(cannot find typename gosym.uint64), :Func ^{:Entry ^ABEND042(cannot find typename gosym.uint64), :End ^ABEND042(cannot find typename gosym.uint64), :Params ^(vector-of ABEND947(recursive type reference involving gosym.Sym)), :Locals ^(vector-of ABEND947(recursive type reference involving gosym.Sym)), :FrameSize ^Int, :LineTable ^{:Data ^(vector-of Int), :PC ^ABEND042(cannot find typename gosym.uint64), :Line ^Int, :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/gosym/pclntab.go:36:11), :go12 ^Int, :binary ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/gosym/pclntab.go:38:11), :quantum ^Int, :ptrsize ^Int, :functab ^(vector-of Int), :nfunctab ^Int, :filetab ^(vector-of Int), :nfiletab ^Int, :fileMap ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/pclntab.go:45:11), :strings ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/pclntab.go:46:11)}, :Obj ^{:Funcs ^(vector-of ABEND947(recursive type reference involving gosym.Func)), :Paths ^(vector-of ABEND947(recursive type reference involving gosym.Sym))}}}), :Funcs ^(vector-of {:Entry ^ABEND042(cannot find typename gosym.uint64), :End ^ABEND042(cannot find typename gosym.uint64), :Params ^(vector-of ABEND947(recursive type reference involving gosym.Sym)), :Locals ^(vector-of ABEND947(recursive type reference involving gosym.Sym)), :FrameSize ^Int, :LineTable ^{:Data ^(vector-of Int), :PC ^ABEND042(cannot find typename gosym.uint64), :Line ^Int, :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/gosym/pclntab.go:36:11), :go12 ^Int, :binary ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/gosym/pclntab.go:38:11), :quantum ^Int, :ptrsize ^Int, :functab ^(vector-of Int), :nfunctab ^Int, :filetab ^(vector-of Int), :nfiletab ^Int, :fileMap ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/pclntab.go:45:11), :strings ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/pclntab.go:46:11)}, :Obj ^{:Funcs ^(vector-of ABEND947(recursive type reference involving gosym.Func)), :Paths ^(vector-of ABEND947(recursive type reference involving gosym.Sym))}}), :Files ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/symtab.go:121:8), :Objs ^(vector-of {:Funcs ^(vector-of ABEND947(recursive type reference involving gosym.Func)), :Paths ^(vector-of ABEND947(recursive type reference involving gosym.Sym))}), :go12line ^{:Data ^(vector-of Int), :PC ^ABEND042(cannot find typename gosym.uint64), :Line ^Int, :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/gosym/pclntab.go:36:11), :go12 ^Int, :binary ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/gosym/pclntab.go:38:11), :quantum ^Int, :ptrsize ^Int, :functab ^(vector-of Int), :nfunctab ^Int, :filetab ^(vector-of Int), :nfiletab ^Int, :fileMap ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/pclntab.go:45:11), :strings ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/pclntab.go:46:11)}} Error]"
;;   {:added "1.0"
;;    :go "newTable(symtab, pcln)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/symtab.go:283:22) symtab, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/debug/gosym/symtab.go:283:35) pcln])

JOKER FUNC gzip.NewReader has:
;; (defn NewReader
;;   "NewReader creates a new Reader reading the given reader.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nIt is the caller's responsibility to call Close on the Reader when done.\n\nThe Reader.Header fields will be valid in the Reader returned.\nGo return type: (*Reader, error)\nJoker return type: [{:r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gunzip.go:76:15), :decompressor ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gunzip.go:77:15), :digest ^Int, :size ^Int, :buf ^(vector-of Int), :err ^Error, :multistream ^Bool} Error]"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gunzip.go:92:18) r])

JOKER FUNC gzip.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer.\nWrites to the returned writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nCallers that wish to set the fields in Writer.Header must do so before\nthe first call to Write, Flush, or Close.\nGo return type: *Writer\nJoker return type: {:w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:30:14), :level ^Int, :wroteHeader ^Bool, :compressor ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:33:15), :digest ^Int, :size ^Int, :closed ^Bool, :buf ^(vector-of Int), :err ^Error}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:49:18) w])

JOKER FUNC gzip.NewWriterLevel has:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\nGo return type: (*Writer, error)\nJoker return type: [{:w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:30:14), :level ^Int, :wroteHeader ^Bool, :compressor ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:33:15), :digest ^Int, :size ^Int, :closed ^Bool, :buf ^(vector-of Int), :err ^Error} Error]"
;;   {:added "1.0"
;;    :go "newWriterLevel(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:60:23) w, ^Int level])

JOKER FUNC heap.Fix has:
;; (defn Fix
;;   "Fix re-establishes the heap ordering after the element at index i has changed its value.\nChanging the value of the element at index i and then calling Fix is equivalent to,\nbut less expensive than, calling Remove(h, i) followed by a Push of the new value.\nThe complexity is O(log(n)) where n = h.Len().\n"
;;   {:added "1.0"
;;    :go "fix(h, i)"}
;;   [h, ^Int i])

JOKER FUNC heap.Init has:
;; (defn Init
;;   "Init establishes the heap invariants required by the other routines in this package.\nInit is idempotent with respect to the heap invariants\nand may be called whenever the heap invariants may have been invalidated.\nIts complexity is O(n) where n = h.Len().\n"
;;   {:added "1.0"
;;    :go "init(h)"}
;;   [h])

JOKER FUNC heap.Pop has:
;; (defn Pop
;;   "Pop removes the minimum element (according to Less) from the heap\nand returns it. The complexity is O(log(n)) where n = h.Len().\nIt is equivalent to Remove(h, 0).\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/heap/heap.go:62:23)"
;;   {:added "1.0"
;;    :go "pop(h)"}
;;   [h])

JOKER FUNC heap.Push has:
;; (defn Push
;;   "Push pushes the element x onto the heap. The complexity is\nO(log(n)) where n = h.Len().\n"
;;   {:added "1.0"
;;    :go "push(h, x)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/heap/heap.go:53:26) x])

JOKER FUNC heap.Remove has:
;; (defn Remove
;;   "Remove removes the element at index i from the heap.\nThe complexity is O(log(n)) where n = h.Len().\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/heap/heap.go:72:33)"
;;   {:added "1.0"
;;    :go "remove(h, i)"}
;;   [h, ^Int i])

JOKER FUNC hex.Decode has:
;; (defn Decode
;;   "Decode decodes src into DecodedLen(len(src)) bytes,\nreturning the actual number of bytes written to dst.\n\nDecode expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, Decode returns the number\nof bytes decoded before the error.\nGo return type: (int, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "decode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:57:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:57:22) src])

JOKER FUNC hex.DecodeString has:
;; (defn DecodeString
;;   "DecodeString returns the bytes represented by the hexadecimal string s.\n\nDecodeString expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, DecodeString returns\nthe bytes decoded before the error.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "decodeString(s)"}
;;   [^String s])

JOKER FUNC hex.DecodedLen has:
(defn ^Int DecodedLen
  "DecodedLen returns the length of a decoding of x source bytes.\nSpecifically, it returns x / 2.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "decodedLen(x)"}
  [^Int x])

JOKER FUNC hex.Dump has:
;; (defn ^String Dump
;;   "Dump returns a string that contains a hex dump of the given data. The format\nof the hex dump matches the output of `hexdump -C` on the command line.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "dump(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:118:16) data])

JOKER FUNC hex.Dumper has:
;; (defn Dumper
;;   "Dumper returns a WriteCloser that writes a hex dump of all written data to\nw. The format of the dump matches the output of `hexdump -C` on the command\nline.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:204:26)"
;;   {:added "1.0"
;;    :go "dumper(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:204:15) w])

JOKER FUNC hex.Encode has:
;; (defn ^Int Encode
;;   "Encode encodes src into EncodedLen(len(src))\nbytes of dst. As a convenience, it returns the number\nof bytes written to dst, but this value is always EncodedLen(len(src)).\nEncode implements hexadecimal encoding.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "encode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:25:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:25:22) src])

JOKER FUNC hex.EncodeToString has:
;; (defn ^String EncodeToString
;;   "EncodeToString returns the hexadecimal encoding of src.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "encodeToString(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:96:25) src])

JOKER FUNC hex.EncodedLen has:
(defn ^Int EncodedLen
  "EncodedLen returns the length of an encoding of n source bytes.\nSpecifically, it returns n * 2.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "encodedLen(n)"}
  [^Int n])

JOKER FUNC hex.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder returns an io.Reader that decodes hexadecimal characters from r.\nNewDecoder expects that r contain only an even number of hexadecimal characters.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:165:30)"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:165:19) r])

JOKER FUNC hex.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:136:30)"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:136:19) w])

JOKER FUNC hmac.Equal has:
;; (defn ^Bool Equal
;;   "Equal compares two MACs for equality without leaking timing information.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "equal(mac1, mac2)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/hmac/hmac.go:96:23) mac1, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/hmac/hmac.go:96:23) mac2])

JOKER FUNC hmac.New has:
;; (defn New
;;   "New returns a new HMAC hash using the given hash.Hash type and key.\nNote that unlike other hash implementations in the standard library,\nthe returned Hash does not implement encoding.BinaryMarshaler\nor encoding.BinaryUnmarshaler.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/hmac/hmac.go:70:42)"
;;   {:added "1.0"
;;    :go "new(h, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/hmac/hmac.go:70:12) h, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/hmac/hmac.go:70:34) key])

JOKER FUNC hpack.AppendHuffmanString has:
;; (defn AppendHuffmanString
;;   "AppendHuffmanString appends s, as encoded in Huffman codes, to dst\nand returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendHuffmanString(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:160:30) dst, ^String s])

JOKER FUNC hpack.HuffmanDecode has:
;; (defn HuffmanDecode
;;   "HuffmanDecode decodes the string in v and writes the expanded\nresult to w, returning the number of bytes written to w and the\nWrite call's return value. At most one Write call is made.\nGo return type: (int, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "huffmanDecode(w, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:21:22) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:21:35) v])

JOKER FUNC hpack.HuffmanDecodeToString has:
;; (defn HuffmanDecodeToString
;;   "HuffmanDecodeToString decodes the string in v.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "huffmanDecodeToString(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:32:30) v])

JOKER FUNC hpack.HuffmanEncodeLength has:
;; (defn HuffmanEncodeLength
;;   "HuffmanEncodeLength returns the number of bytes required to encode\ns in Huffman codes. The result is round up to byte boundary.\nGo return type: uint64\nJoker return type: ABEND042(cannot find typename hpack.uint64)"
;;   {:added "1.0"
;;    :go "huffmanEncodeLength(s)"}
;;   [^String s])

JOKER FUNC hpack.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder with the provided maximum dynamic\ntable size. The emitFunc will be called for each valid field\nparsed, in the same goroutine as calls to Write, before Write returns.\nGo return type: *Decoder\nJoker return type: {:dynTab ^ABEND042(cannot find typename hpack.dynamicTable), :emit ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go:81:9), :emitEnabled ^Bool, :maxStrLen ^Int, :buf ^(vector-of Int), :saveBuf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go:94:10)}"
;;   {:added "1.0"
;;    :go "newDecoder(maxDynamicTableSize, emitFunc)"}
;;   [maxDynamicTableSize, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go:100:54) emitFunc])

JOKER FUNC hpack.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new Encoder which performs HPACK encoding. An\nencoded data is written to w.\nGo return type: *Encoder\nJoker return type: {:dynTab ^ABEND042(cannot find typename hpack.dynamicTable), :minSize ^Int, :maxSizeLimit ^Int, :tableSizeUpdate ^Bool, :w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/encode.go:29:18), :buf ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/encode.go:35:19) w])

JOKER FUNC html.EscapeString has:
(defn ^String EscapeString
  "EscapeString escapes special characters like \"<\" to become \"&lt;\". It\nescapes only five such characters: <, >, &, ' and \".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "escapeString(s)"}
  [^String s])

JOKER FUNC html.UnescapeString has:
(defn ^String UnescapeString
  "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a\nlarger range of entities than EscapeString escapes. For example, \"&aacute;\"\nunescapes to \"á\", as does \"&#225;\" and \"&#xE1;\".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "unescapeString(s)"}
  [^String s])

JOKER FUNC http.CanonicalHeaderKey has:
(defn ^String CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "canonicalHeaderKey(s)"}
  [^String s])

JOKER FUNC http.DetectContentType has:
;; (defn ^String DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "detectContentType(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/http/sniff.go:21:29) data])

JOKER FUNC http.Error has:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n"
;;   {:added "1.0"
;;    :go "error(w, error, code)"}
;;   [w, ^String error, ^Int code])

JOKER FUNC http.FileServer has:
;; (defn FileServer
;;   "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\nGo return type: Handler\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "fileServer(root)"}
;;   [root])

JOKER FUNC http.Get has:
;; (defn Get
;;   "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\nGo return type: (resp *Response, err error)\nJoker return type: [^{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:319:6)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:115:7)} resp ^Error err]"
;;   {:added "1.0"
;;    :go "get(url)"}
;;   [^String url])

JOKER FUNC http.Handle has:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n"
;;   {:added "1.0"
;;    :go "handle(pattern, handler)"}
;;   [^String pattern, handler])

JOKER FUNC http.HandleFunc has:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n"
;;   {:added "1.0"
;;    :go "handleFunc(pattern, handler)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/server.go:2406:41) handler])

JOKER FUNC http.Head has:
;; (defn Head
;;   "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\nGo return type: (resp *Response, err error)\nJoker return type: [^{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:319:6)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:115:7)} resp ^Error err]"
;;   {:added "1.0"
;;    :go "head(url)"}
;;   [^String url])

JOKER FUNC http.ListenAndServe has:
(defn ^Error ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "listenAndServe(addr, handler)"}
  [^String addr, handler])

JOKER FUNC http.ListenAndServeTLS has:
(defn ^Error ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "listenAndServeTLS(addr, certFile, keyFile, handler)"}
  [^String addr, ^String certFile, ^String keyFile, handler])

JOKER FUNC http.MaxBytesReader has:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:1056:65)"
;;   {:added "1.0"
;;    :go "maxBytesReader(w, r, n)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:1056:41) r, n])

JOKER FUNC http.NewFileTransport has:
;; (defn NewFileTransport
;;   "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\nGo return type: RoundTripper\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/client.go:115:19)"
;;   {:added "1.0"
;;    :go "newFileTransport(fs)"}
;;   [fs])

JOKER FUNC http.NewRequest has:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\nGo return type: (*Request, error)\nJoker return type: [{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:319:6)} Error]"
;;   {:added "1.0"
;;    :go "newRequest(method, url, body)"}
;;   [^String method, ^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:792:42) body])

JOKER FUNC http.NewServeMux has:
;; (defn NewServeMux
;;   "NewServeMux allocates and returns a new ServeMux.\nGo return type: *ServeMux\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/server.go:2150:8), :m ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/server.go:2151:8), :hosts ^Bool}"
;;   {:added "1.0"
;;    :go "newServeMux()"}
;;   [])

JOKER FUNC http.NotFound has:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n"
;;   {:added "1.0"
;;    :go "notFound(w, r)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/server.go:1981:35) r])

JOKER FUNC http.NotFoundHandler has:
;; (defn NotFoundHandler
;;   "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\nGo return type: Handler\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "notFoundHandler()"}
;;   [])

JOKER FUNC http.ParseHTTPVersion has:
;; (defn ParseHTTPVersion
;;   "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\nGo return type: (major int, minor int, ok bool)\nJoker return type: [^Int major ^Int minor ^Bool ok]"
;;   {:added "1.0"
;;    :go "parseHTTPVersion(vers)"}
;;   [^String vers])

JOKER FUNC http.ParseTime has:
;; (defn ParseTime
;;   "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\nGo return type: (t, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/header.go:86:32) t ^Error err]"
;;   {:added "1.0"
;;    :go "parseTime(text)"}
;;   [^String text])

JOKER FUNC http.Post has:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\nGo return type: (resp *Response, err error)\nJoker return type: [^{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:319:6)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:115:7)} resp ^Error err]"
;;   {:added "1.0"
;;    :go "post(url, contentType, body)"}
;;   [^String url, ^String contentType, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/client.go:748:41) body])

JOKER FUNC http.PostForm has:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\nGo return type: (resp *Response, err error)\nJoker return type: [^{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:319:6)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:115:7)} resp ^Error err]"
;;   {:added "1.0"
;;    :go "postForm(url, data)"}
;;   [^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/client.go:785:32) data])

JOKER FUNC http.ProxyFromEnvironment has:
;; (defn ProxyFromEnvironment
;;   "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/transport.go:345:43) Error]"
;;   {:added "1.0"
;;    :go "proxyFromEnvironment(req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/transport.go:345:31) req])

JOKER FUNC http.ProxyURL has:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/transport.go:351:34)"
;;   {:added "1.0"
;;    :go "proxyURL(fixedURL)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/transport.go:351:24) fixedURL])

JOKER FUNC http.ReadRequest has:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\nGo return type: (*Request, error)\nJoker return type: [{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:319:6)} Error]"
;;   {:added "1.0"
;;    :go "readRequest(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:942:20) b])

JOKER FUNC http.ReadResponse has:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\nGo return type: (*Response, error)\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:66:7), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:127:7), :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:181:7), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:241:7), :PostForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:248:11), :MultipartForm ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:253:17), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:297:7), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving http.Response), :ctx ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:319:6)}, :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:115:7)} Error]"
;;   {:added "1.0"
;;    :go "readResponse(r, req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/response.go:148:21) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/response.go:148:40) req])

JOKER FUNC http.Redirect has:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n"
;;   {:added "1.0"
;;    :go "redirect(w, r, url, code)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/server.go:2020:35) r, ^String url, ^Int code])

JOKER FUNC http.RedirectHandler has:
;; (defn RedirectHandler
;;   "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\nGo return type: Handler\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "redirectHandler(url, code)"}
;;   [^String url, ^Int code])

JOKER FUNC http.Serve has:
;; (defn ^Error Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/server.go:2421:14) l, handler])

JOKER FUNC http.ServeContent has:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n"
;;   {:added "1.0"
;;    :go "serveContent(w, req, name, modtime, content)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fs.go:151:41) req, ^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fs.go:151:72) modtime, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fs.go:151:91) content])

JOKER FUNC http.ServeFile has:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n"
;;   {:added "1.0"
;;    :go "serveFile(w, r, name)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fs.go:670:36) r, ^String name])

JOKER FUNC http.ServeTLS has:
;; (defn ^Error ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "serveTLS(l, handler, certFile, keyFile)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/server.go:2438:17) l, handler, ^String certFile, ^String keyFile])

JOKER FUNC http.SetCookie has:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n"
;;   {:added "1.0"
;;    :go "setCookie(w, cookie)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/cookie.go:157:41) cookie])

JOKER FUNC http.StatusText has:
(defn ^String StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "statusText(code)"}
  [^Int code])

JOKER FUNC http.StripPrefix has:
;; (defn StripPrefix
;;   "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\nGo return type: Handler\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "stripPrefix(prefix, h)"}
;;   [^String prefix, h])

JOKER FUNC http.TimeoutHandler has:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\nGo return type: Handler\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "timeoutHandler(h, dt, msg)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/server.go:3106:35) dt, ^String msg])

JOKER FUNC httpguts.HeaderValuesContainsToken has:
;; (defn ^Bool HeaderValuesContainsToken
;;   "HeaderValuesContainsToken reports whether any string in values\ncontains the provided token, ASCII case-insensitively.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "headerValuesContainsToken(values, token)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http/httpguts/httplex.go:106:39) values, ^String token])

JOKER FUNC httpguts.IsTokenRune has:
(defn ^Bool IsTokenRune
  "Go return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isTokenRune(r)"}
  [r])

JOKER FUNC httpguts.PunycodeHostPort has:
;; (defn PunycodeHostPort
;;   "PunycodeHostPort returns the IDNA Punycode version\nof the provided \"host\" or \"host:port\" string.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "punycodeHostPort(v)"}
;;   [^String v])

JOKER FUNC httpguts.ValidHeaderFieldName has:
(defn ^Bool ValidHeaderFieldName
  "ValidHeaderFieldName reports whether v is a valid HTTP/1.x header name.\nHTTP/2 imposes the additional restriction that uppercase ASCII\nletters are not allowed.\n\n RFC 7230 says:\n  header-field   = field-name \":\" OWS field-value OWS\n  field-name     = token\n  token          = 1*tchar\n  tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /\n          \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "validHeaderFieldName(v)"}
  [^String v])

JOKER FUNC httpguts.ValidHeaderFieldValue has:
(defn ^Bool ValidHeaderFieldValue
  "ValidHeaderFieldValue reports whether v is a valid \"field-value\" according to\nhttp://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 :\n\n       message-header = field-name \":\" [ field-value ]\n       field-value    = *( field-content | LWS )\n       field-content  = <the OCTETs making up the field-value\n                        and consisting of either *TEXT or combinations\n                        of token, separators, and quoted-string>\n\nhttp://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2 :\n\n       TEXT           = <any OCTET except CTLs,\n                         but including LWS>\n       LWS            = [CRLF] 1*( SP | HT )\n       CTL            = <any US-ASCII control character\n                        (octets 0 - 31) and DEL (127)>\n\nRFC 7230 says:\n field-value    = *( field-content / obs-fold )\n obj-fold       =  N/A to http2, and deprecated\n field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n field-vchar    = VCHAR / obs-text\n obs-text       = %x80-FF\n VCHAR          = \"any visible [USASCII] character\"\n\nhttp2 further says: \"Similarly, HTTP/2 allows header field values\nthat are not valid. While most of the values that can be encoded\nwill not alter header field parsing, carriage return (CR, ASCII\n0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII\n0x0) might be exploited by an attacker if they are translated\nverbatim. Any request or response that contains a character not\npermitted in a header field value MUST be treated as malformed\n(Section 8.1.2.6). Valid characters are defined by the\nfield-content ABNF rule in Section 3.2 of [RFC7230].\"\n\nThis function does not (yet?) properly handle the rejection of\nstrings that begin or end with SP or HTAB.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "validHeaderFieldValue(v)"}
  [^String v])

JOKER FUNC httpguts.ValidHostHeader has:
(defn ^Bool ValidHostHeader
  "ValidHostHeader reports whether h is a valid host header.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "validHostHeader(h)"}
  [^String h])

JOKER FUNC httpguts.ValidTrailerHeader has:
(defn ^Bool ValidTrailerHeader
  "ValidTrailerHeader reports whether name is a valid header field name to appear\nin trailers.\nSee RFC 7230, Section 4.1.2\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "validTrailerHeader(name)"}
  [^String name])

JOKER FUNC httpproxy.FromEnvironment has:
;; (defn FromEnvironment
;;   "FromEnvironment returns a Config instance populated from the\nenvironment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the\nlowercase versions thereof). HTTPS_PROXY takes precedence over\nHTTP_PROXY for https requests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed. An error\nis returned if the value is a different form.\nGo return type: *Config\nJoker return type: {:HTTPProxy ^String, :HTTPSProxy ^String, :NoProxy ^String, :CGI ^Bool}"
;;   {:added "1.0"
;;    :go "fromEnvironment()"}
;;   [])

JOKER FUNC httptest.NewRecorder has:
;; (defn NewRecorder
;;   "NewRecorder returns an initialized ResponseRecorder.\nGo return type: *ResponseRecorder\nJoker return type: {:Code ^Int, :HeaderMap ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/recorder.go:35:12), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/recorder.go:39:8), :Flushed ^Bool, :result ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/recorder.go:44:15), :snapHeader ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/recorder.go:45:14), :wroteHeader ^Bool}"
;;   {:added "1.0"
;;    :go "newRecorder()"}
;;   [])

JOKER FUNC httptest.NewRequest has:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\nGo return type: *\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/httptest.go:41:57)"
;;   {:added "1.0"
;;    :go "newRequest(method, target, body)"}
;;   [^String method, ^String target, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/httptest.go:41:45) body])

JOKER FUNC httptest.NewServer has:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\nGo return type: *Server\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:28:11), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:33:7), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:37:10), :certificate ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:40:15), :wg ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:44:5), :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:46:9), :closed ^Bool, :conns ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httptest/server.go:48:9), :client ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:52:10)}"
;;   {:added "1.0"
;;    :go "newServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:80:24) handler])

JOKER FUNC httptest.NewTLSServer has:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\nGo return type: *Server\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:28:11), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:33:7), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:37:10), :certificate ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:40:15), :wg ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:44:5), :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:46:9), :closed ^Bool, :conns ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httptest/server.go:48:9), :client ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:52:10)}"
;;   {:added "1.0"
;;    :go "newTLSServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:160:27) handler])

JOKER FUNC httptest.NewUnstartedServer has:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\nGo return type: *Server\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:28:11), :TLS ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:33:7), :Config ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:37:10), :certificate ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:40:15), :wg ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:44:5), :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:46:9), :closed ^Bool, :conns ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httptest/server.go:48:9), :client ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:52:10)}"
;;   {:added "1.0"
;;    :go "newUnstartedServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:92:33) handler])

JOKER FUNC httptrace.ContextClientTrace has:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\nGo return type: *ClientTrace\nJoker return type: {:GetConn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:85:10), :GotConn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:91:10), :PutIdleConn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:101:14), :GotFirstResponseByte ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:105:23), :Got100Continue ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:109:17), :Got1xxResponse ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:115:17), :DNSStart ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:118:11), :DNSDone ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:121:10), :ConnectStart ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:126:15), :ConnectDone ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:133:14), :TLSHandshakeStart ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:138:20), :TLSHandshakeDone ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:143:19), :WroteHeaderField ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:148:19), :WroteHeaders ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:152:15), :Wait100Continue ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:158:18), :WroteRequest ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:163:15)}"
;;   {:added "1.0"
;;    :go "contextClientTrace(ctx)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptrace/trace.go:24:29) ctx])

JOKER FUNC httptrace.WithClientTrace has:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptrace/trace.go:34:63)"
;;   {:added "1.0"
;;    :go "withClientTrace(ctx, trace)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptrace/trace.go:34:26) ctx, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptrace/trace.go:34:49) trace])

JOKER FUNC httputil.DumpRequest has:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequest(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/dump.go:191:22) req, body])

JOKER FUNC httputil.DumpRequestOut has:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequestOut(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/dump.go:66:25) req, body])

JOKER FUNC httputil.DumpResponse has:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpResponse(resp, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/dump.go:281:24) resp, body])

JOKER FUNC httputil.NewChunkedReader has:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/httputil.go:20:36)"
;;   {:added "1.0"
;;    :go "newChunkedReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/httputil.go:20:25) r])

JOKER FUNC httputil.NewChunkedWriter has:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/httputil.go:35:36)"
;;   {:added "1.0"
;;    :go "newChunkedWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/httputil.go:35:25) w])

JOKER FUNC httputil.NewClientConn has:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\nGo return type: *ClientConn\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:231:18), :c ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:232:18), :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:233:19), :re ^Error, :we ^Error, :lastbody ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:235:18), :nread ^Int, :nwritten ^Int, :pipereq ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httputil/persist.go:237:18), :pipe ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:239:11), :writeReq ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httputil/persist.go:240:11)}"
;;   {:added "1.0"
;;    :go "newClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:248:22) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:248:34) r])

JOKER FUNC httputil.NewProxyClientConn has:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\nGo return type: *ClientConn\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:231:18), :c ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:232:18), :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:233:19), :re ^Error, :we ^Error, :lastbody ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:235:18), :nread ^Int, :nwritten ^Int, :pipereq ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httputil/persist.go:237:18), :pipe ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:239:11), :writeReq ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httputil/persist.go:240:11)}"
;;   {:added "1.0"
;;    :go "newProxyClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:265:27) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:265:39) r])

JOKER FUNC httputil.NewServerConn has:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\nGo return type: *ServerConn\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:38:18), :c ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:39:18), :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:40:19), :re ^Error, :we ^Error, :lastbody ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:42:18), :nread ^Int, :nwritten ^Int, :pipereq ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httputil/persist.go:44:18), :pipe ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:46:7)}"
;;   {:added "1.0"
;;    :go "newServerConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:54:22) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:54:34) r])

JOKER FUNC httputil.NewSingleHostReverseProxy has:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\nGo return type: *ReverseProxy\nJoker return type: {:Director ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httputil/reverseproxy.go:35:11), :Transport ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/reverseproxy.go:39:12), :FlushInterval ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/reverseproxy.go:45:16), :ErrorLog ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/reverseproxy.go:51:12), :BufferPool ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/httputil/reverseproxy.go:79:17), :ModifyResponse ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httputil/reverseproxy.go:67:17), :ErrorHandler ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httputil/reverseproxy.go:74:15)}"
;;   {:added "1.0"
;;    :go "newSingleHostReverseProxy(target)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/reverseproxy.go:103:39) target])

JOKER FUNC idna.BidiRule has:
;; (defn BidiRule
;;   "BidiRule enables the Bidi rule as defined in RFC 5893. Any application\nthat relies on proper validation of labels should include this rule.\nGo return type: Option\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13)"
;;   {:added "1.0"
;;    :go "bidiRule()"}
;;   [])

JOKER FUNC idna.MapForLookup has:
;; (defn MapForLookup
;;   "MapForLookup sets validation and mapping options such that a given IDN is\ntransformed for domain name lookup according to the requirements set out in\nSection 5 of RFC 5891. The mappings follow the recommendations of RFC 5894,\nRFC 5895 and UTS 46. It does not add the Bidi Rule. Use the BidiRule option\nto add this check.\n\nThe mappings include normalization and mapping case, width and other\ncompatibility mappings.\nGo return type: Option\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13)"
;;   {:added "1.0"
;;    :go "mapForLookup()"}
;;   [])

JOKER FUNC idna.New has:
;; (defn New
;;   "New creates a new Profile.\n\nWith no options, the returned Profile is the most permissive and equals the\nPunycode Profile. Options can be passed to further restrict the Profile. The\nMapForLookup and ValidateForRegistration options set a collection of options,\nfor lookup and registration purposes respectively, which can be tailored by\nadding more fine-grained options, where later options override earlier\noptions.\nGo return type: *Profile\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "new(o)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:189:12) o])

JOKER FUNC idna.RemoveLeadingDots has:
;; (defn RemoveLeadingDots
;;   "RemoveLeadingDots removes leading label separators. Leading runes that map to\ndots, such as U+3002 IDEOGRAPHIC FULL STOP, are removed as well.\n\nThis is the behavior suggested by the UTS #46 and is adopted by some\nbrowsers.\nGo return type: Option\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13)"
;;   {:added "1.0"
;;    :go "removeLeadingDots(remove)"}
;;   [remove])

JOKER FUNC idna.StrictDomainName has:
;; (defn StrictDomainName
;;   "StrictDomainName limits the set of permissible ASCII characters to those\nallowed in domain names as defined in RFC 1034 (A-Z, a-z, 0-9 and the\nhyphen). This is set by default for MapForLookup and ValidateForRegistration.\n\nThis option is useful, for instance, for browsers that allow characters\noutside this range, for example a '_' (U+005F LOW LINE). See\nhttp://www.rfc-editor.org/std/std3.txt for more details This option\ncorresponds to the UseSTD3ASCIIRules option in UTS #46.\nGo return type: Option\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13)"
;;   {:added "1.0"
;;    :go "strictDomainName(use)"}
;;   [use])

JOKER FUNC idna.ToASCII has:
;; (defn ToASCII
;;   "ToASCII is a wrapper for Punycode.ToASCII.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "toASCII(s)"}
;;   [^String s])

JOKER FUNC idna.ToUnicode has:
;; (defn ToUnicode
;;   "ToUnicode is a wrapper for Punycode.ToUnicode.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "toUnicode(s)"}
;;   [^String s])

JOKER FUNC idna.Transitional has:
;; (defn Transitional
;;   "Transitional sets a Profile to use the Transitional mapping as defined in UTS\n#46. This will cause, for example, \"ß\" to be mapped to \"ss\". Using the\ntransitional mapping provides a compromise between IDNA2003 and IDNA2008\ncompatibility. It is used by most browsers when resolving domain names. This\noption is only meaningful if combined with MapForLookup.\nGo return type: Option\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13)"
;;   {:added "1.0"
;;    :go "transitional(transitional)"}
;;   [transitional])

JOKER FUNC idna.ValidateForRegistration has:
;; (defn ValidateForRegistration
;;   "ValidateForRegistration sets validation options to verify that a given IDN is\nproperly formatted for registration as defined by Section 4 of RFC 5891.\nGo return type: Option\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13)"
;;   {:added "1.0"
;;    :go "validateForRegistration()"}
;;   [])

JOKER FUNC idna.ValidateLabels has:
;; (defn ValidateLabels
;;   "ValidateLabels sets whether to check the mandatory label validation criteria\nas defined in Section 5.4 of RFC 5891. This includes testing for correct use\nof hyphens ('-'), normalization, validity of runes, and the context rules.\nGo return type: Option\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13)"
;;   {:added "1.0"
;;    :go "validateLabels(enable)"}
;;   [enable])

JOKER FUNC idna.VerifyDNSLength has:
;; (defn VerifyDNSLength
;;   "VerifyDNSLength sets whether a Profile should fail if any of the IDN parts\nare longer than allowed by the RFC.\nGo return type: Option\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13)"
;;   {:added "1.0"
;;    :go "verifyDNSLength(verify)"}
;;   [verify])

JOKER FUNC image.Decode has:
;; (defn Decode
;;   "Decode decodes an image that has been encoded in a registered format.\nThe string returned is the format name used during format registration.\nFormat registration is typically done by an init function in the codec-\nspecific package.\nGo return type: (Image, string, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/image/image.go:36:12) String Error]"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/format.go:78:15) r])

JOKER FUNC image.DecodeConfig has:
;; (defn DecodeConfig
;;   "DecodeConfig decodes the color model and dimensions of an image that has\nbeen encoded in a registered format. The string returned is the format name\nused during format registration. Format registration is typically done by\nan init function in the codec-specific package.\nGo return type: (Config, string, error)\nJoker return type: [{:ColorModel ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/image.go:30:16), :Width ^Int, :Height ^Int} String Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/format.go:92:21) r])

JOKER FUNC image.NewAlpha has:
;; (defn NewAlpha
;;   "NewAlpha returns a new Alpha image with the given bounds.\nGo return type: *Alpha\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newAlpha(r)"}
;;   [r])

JOKER FUNC image.NewAlpha16 has:
;; (defn NewAlpha16
;;   "NewAlpha16 returns a new Alpha16 image with the given bounds.\nGo return type: *Alpha16\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newAlpha16(r)"}
;;   [r])

JOKER FUNC image.NewCMYK has:
;; (defn NewCMYK
;;   "NewCMYK returns a new CMYK image with the given bounds.\nGo return type: *CMYK\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newCMYK(r)"}
;;   [r])

JOKER FUNC image.NewGray has:
;; (defn NewGray
;;   "NewGray returns a new Gray image with the given bounds.\nGo return type: *Gray\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newGray(r)"}
;;   [r])

JOKER FUNC image.NewGray16 has:
;; (defn NewGray16
;;   "NewGray16 returns a new Gray16 image with the given bounds.\nGo return type: *Gray16\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newGray16(r)"}
;;   [r])

JOKER FUNC image.NewNRGBA has:
;; (defn NewNRGBA
;;   "NewNRGBA returns a new NRGBA image with the given bounds.\nGo return type: *NRGBA\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newNRGBA(r)"}
;;   [r])

JOKER FUNC image.NewNRGBA64 has:
;; (defn NewNRGBA64
;;   "NewNRGBA64 returns a new NRGBA64 image with the given bounds.\nGo return type: *NRGBA64\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newNRGBA64(r)"}
;;   [r])

JOKER FUNC image.NewNYCbCrA has:
;; (defn NewNYCbCrA
;;   "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample\nratio.\nGo return type: *NYCbCrA\nJoker return type: {:A ^(vector-of ABEND042(cannot find typename image.uint8)), :AStride ^Int}"
;;   {:added "1.0"
;;    :go "newNYCbCrA(r, subsampleRatio)"}
;;   [r, subsampleRatio])

JOKER FUNC image.NewPaletted has:
;; (defn NewPaletted
;;   "NewPaletted returns a new Paletted image with the given width, height and\npalette.\nGo return type: *Paletted\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}, :Palette ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/image.go:925:10)}"
;;   {:added "1.0"
;;    :go "newPaletted(r, p)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/image.go:1019:33) p])

JOKER FUNC image.NewRGBA has:
;; (defn NewRGBA
;;   "NewRGBA returns a new RGBA image with the given bounds.\nGo return type: *RGBA\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newRGBA(r)"}
;;   [r])

JOKER FUNC image.NewRGBA64 has:
;; (defn NewRGBA64
;;   "NewRGBA64 returns a new RGBA64 image with the given bounds.\nGo return type: *RGBA64\nJoker return type: {:Pix ^(vector-of ABEND042(cannot find typename image.uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newRGBA64(r)"}
;;   [r])

JOKER FUNC image.NewUniform has:
;; (defn NewUniform
;;   "Go return type: *Uniform\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/names.go:25:4)}"
;;   {:added "1.0"
;;    :go "newUniform(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/names.go:50:19) c])

JOKER FUNC image.NewYCbCr has:
;; (defn NewYCbCr
;;   "NewYCbCr returns a new YCbCr image with the given bounds and subsample\nratio.\nGo return type: *YCbCr\nJoker return type: {:Y ^(vector-of ABEND042(cannot find typename image.uint8)), :Cb ^(vector-of ABEND042(cannot find typename image.uint8)), :Cr ^(vector-of ABEND042(cannot find typename image.uint8)), :YStride ^Int, :CStride ^Int, :SubsampleRatio ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "newYCbCr(r, subsampleRatio)"}
;;   [r, subsampleRatio])

JOKER FUNC image.Pt has:
;; (defn Pt
;;   "Pt is shorthand for Point{X, Y}.\nGo return type: Point\nJoker return type: {:X ^Int, :Y ^Int}"
;;   {:added "1.0"
;;    :go "pt(X, Y)"}
;;   [^Int X, ^Int Y])

JOKER FUNC image.Rect has:
;; (defn Rect
;;   "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned\nrectangle has minimum and maximum coordinates swapped if necessary so that\nit is well-formed.\nGo return type: Rectangle\nJoker return type: {:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}"
;;   {:added "1.0"
;;    :go "rect(x0, y0, x1, y1)"}
;;   [^Int x0, ^Int y0, ^Int x1, ^Int y1])

JOKER FUNC image.RegisterFormat has:
;; (defn RegisterFormat
;;   "RegisterFormat registers an image format for use by Decode.\nName is the name of the format, like \"jpeg\" or \"png\".\nMagic is the magic prefix that identifies the format's encoding. The magic\nstring can contain \"?\" wildcards that each match any one byte.\nDecode is the function that decodes the encoded image.\nDecodeConfig is the function that decodes just its configuration.\n"
;;   {:added "1.0"
;;    :go "registerFormat(name, magic, decode, decodeConfig)"}
;;   [^String name, ^String magic, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/format.go:32:48) decode, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/format.go:32:93) decodeConfig])

JOKER FUNC importer.Default has:
;; (defn Default
;;   "Default returns an Importer for the compiler that built the running binary.\nIf available, the result implements types.ImporterFrom.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/importer/importer.go:75:16)"
;;   {:added "1.0"
;;    :go "default()"}
;;   [])

JOKER FUNC importer.For has:
;; (defn For
;;   "For returns an Importer for importing from installed packages\nfor the compilers \"gc\" and \"gccgo\", or for importing directly\nfrom the source if the compiler argument is \"source\". In this\nlatter case, importing may fail under circumstances where the\nexported API is not entirely defined in pure Go source code\n(if the package API depends on cgo-defined entities, the type\nchecker won't have access to those).\n\nIf lookup is nil, the default package lookup mechanism for the\ngiven compiler is used, and the resulting importer attempts\nto resolve relative and absolute import paths to canonical\nimport path IDs before finding the imported file.\n\nIf lookup is non-nil, then the returned importer calls lookup\neach time it needs to resolve an import path. In this mode\nthe importer can only be invoked with canonical import paths\n(not relative or absolute ones); it is assumed that the translation\nto canonical import paths is being done by the client of the\nimporter.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/importer/importer.go:42:42)"
;;   {:added "1.0"
;;    :go "for(compiler, lookup)"}
;;   [^String compiler, lookup])

JOKER FUNC io.Copy has:
;; (defn Copy
;;   "Copy copies from src to dst until either EOF is reached\non src or an error occurs. It returns the number of bytes\ncopied and the first error encountered while copying, if any.\n\nA successful Copy returns err == nil, not err == EOF.\nBecause Copy is defined to read from src until EOF, it does\nnot treat an EOF from Read as an error to be reported.\n\nIf src implements the WriterTo interface,\nthe copy is implemented by calling src.WriteTo(dst).\nOtherwise, if dst implements the ReaderFrom interface,\nthe copy is implemented by calling dst.ReadFrom(src).\nGo return type: (written int, err error)\nJoker return type: [^Int written ^Error err]"
;;   {:added "1.0"
;;    :go "copy(dst, src)"}
;;   [dst, src])

JOKER FUNC io.CopyBuffer has:
;; (defn CopyBuffer
;;   "CopyBuffer is identical to Copy except that it stages through the\nprovided buffer (if one is required) rather than allocating a\ntemporary one. If buf is nil, one is allocated; otherwise if it has\nzero length, CopyBuffer panics.\nGo return type: (written int, err error)\nJoker return type: [^Int written ^Error err]"
;;   {:added "1.0"
;;    :go "copyBuffer(dst, src, buf)"}
;;   [dst, src, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/io.go:371:45) buf])

JOKER FUNC io.CopyN has:
;; (defn CopyN
;;   "CopyN copies n bytes (or until an error) from src to dst.\nIt returns the number of bytes copied and the earliest\nerror encountered while copying.\nOn return, written == n if and only if err == nil.\n\nIf dst implements the ReaderFrom interface,\nthe copy is implemented using it.\nGo return type: (written int, err error)\nJoker return type: [^Int written ^Error err]"
;;   {:added "1.0"
;;    :go "copyN(dst, src, n)"}
;;   [dst, src, n])

JOKER FUNC io.LimitReader has:
;; (defn LimitReader
;;   "LimitReader returns a Reader that reads from r\nbut stops with EOF after n bytes.\nThe underlying implementation is a *LimitedReader.\nGo return type: Reader\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "limitReader(r, n)"}
;;   [r, n])

JOKER FUNC io.MultiReader has:
;; (defn MultiReader
;;   "MultiReader returns a Reader that's the logical concatenation of\nthe provided input readers. They're read sequentially. Once all\ninputs have returned EOF, Read will return EOF.  If any of the readers\nreturn a non-nil, non-EOF error, Read will return that error.\nGo return type: Reader\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "multiReader(readers)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/io/multi.go:48:26) readers])

JOKER FUNC io.MultiWriter has:
;; (defn MultiWriter
;;   "MultiWriter creates a writer that duplicates its writes to all the\nprovided writers, similar to the Unix tee(1) command.\n\nEach write is written to each listed writer, one at a time.\nIf a listed writer returns an error, that overall write operation\nstops and returns the error; it does not continue down the list.\nGo return type: Writer\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/io/io.go:90:13)"
;;   {:added "1.0"
;;    :go "multiWriter(writers)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/io/multi.go:102:26) writers])

JOKER FUNC io.NewSectionReader has:
;; (defn NewSectionReader
;;   "NewSectionReader returns a SectionReader that reads from r\nstarting at offset off and stops with EOF after n bytes.\nGo return type: *SectionReader\nJoker return type: {:r ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/io/io.go:211:15), :base ^Int, :off ^Int, :limit ^Int}"
;;   {:added "1.0"
;;    :go "newSectionReader(r, off, n)"}
;;   [r, off, n])

JOKER FUNC io.Pipe has:
;; (defn Pipe
;;   "Pipe creates a synchronous in-memory pipe.\nIt can be used to connect code expecting an io.Reader\nwith code expecting an io.Writer.\n\nReads and Writes on the pipe are matched one to one\nexcept when multiple Reads are needed to consume a single Write.\nThat is, each Write to the PipeWriter blocks until it has satisfied\none or more Reads from the PipeReader that fully consume\nthe written data.\nThe data is copied directly from the Write to the corresponding\nRead (or Reads); there is no internal buffering.\n\nIt is safe to call Read and Write in parallel with each other or with Close.\nParallel calls to Read and parallel calls to Write are also safe:\nthe individual calls will be gated sequentially.\nGo return type: (*PipeReader, *PipeWriter)\nJoker return type: [{:p ^ABEND042(cannot find typename io.pipe)} {:p ^ABEND042(cannot find typename io.pipe)}]"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC io.ReadAtLeast has:
;; (defn ReadAtLeast
;;   "ReadAtLeast reads from r into buf until it has read at least min bytes.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading fewer than min bytes,\nReadAtLeast returns ErrUnexpectedEOF.\nIf min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\nOn return, n >= min if and only if err == nil.\nIf r returns an error having read at least min bytes, the error is dropped.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "readAtLeast(r, buf, min)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/io.go:304:32) buf, ^Int min])

JOKER FUNC io.ReadFull has:
;; (defn ReadFull
;;   "ReadFull reads exactly len(buf) bytes from r into buf.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nReadFull returns ErrUnexpectedEOF.\nOn return, n == len(buf) if and only if err == nil.\nIf r returns an error having read at least len(buf) bytes, the error is dropped.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "readFull(r, buf)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/io.go:328:29) buf])

JOKER FUNC io.TeeReader has:
;; (defn TeeReader
;;   "TeeReader returns a Reader that writes to w what it reads from r.\nAll reads from r performed through it are matched with\ncorresponding writes to w. There is no internal buffering -\nthe write must complete before the read completes.\nAny error encountered while writing is reported as a read error.\nGo return type: Reader\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "teeReader(r, w)"}
;;   [r, w])

JOKER FUNC io.WriteString has:
;; (defn WriteString
;;   "WriteString writes the contents of the string s to w, which accepts a slice of bytes.\nIf w implements a WriteString method, it is invoked directly.\nOtherwise, w.Write is called exactly once.\nGo return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "writeString(w, s)"}
;;   [w, ^String s])

JOKER FUNC iotest.DataErrReader has:
;; (defn DataErrReader
;;   "DataErrReader changes the way errors are handled by a Reader. Normally, a\nReader returns an error (typically EOF) from the first Read call after the\nlast piece of data is read. DataErrReader wraps a Reader and changes its\nbehavior so the final error is returned along with the final data, instead\nof in the first call after the final data.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:45:33)"
;;   {:added "1.0"
;;    :go "dataErrReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:45:22) r])

JOKER FUNC iotest.HalfReader has:
;; (defn HalfReader
;;   "HalfReader returns a Reader that implements Read\nby reading half as many requested bytes from r.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:30:30)"
;;   {:added "1.0"
;;    :go "halfReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:30:19) r])

JOKER FUNC iotest.NewReadLogger has:
;; (defn NewReadLogger
;;   "NewReadLogger returns a reader that behaves like r except\nthat it logs (using log.Printf) each read to standard error,\nprinting the prefix and the hexadecimal data read.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/logger.go:52:48)"
;;   {:added "1.0"
;;    :go "newReadLogger(prefix, r)"}
;;   [^String prefix, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/logger.go:52:37) r])

JOKER FUNC iotest.NewWriteLogger has:
;; (defn NewWriteLogger
;;   "NewWriteLogger returns a writer that behaves like w except\nthat it logs (using log.Printf) each write to standard error,\nprinting the prefix and the hexadecimal data written.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/logger.go:30:49)"
;;   {:added "1.0"
;;    :go "newWriteLogger(prefix, w)"}
;;   [^String prefix, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/logger.go:30:38) w])

JOKER FUNC iotest.OneByteReader has:
;; (defn OneByteReader
;;   "OneByteReader returns a Reader that implements\neach non-empty Read by reading one byte from r.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:15:33)"
;;   {:added "1.0"
;;    :go "oneByteReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:15:22) r])

JOKER FUNC iotest.TimeoutReader has:
;; (defn TimeoutReader
;;   "TimeoutReader returns ErrTimeout on the second read\nwith no data. Subsequent calls to read succeed.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:75:33)"
;;   {:added "1.0"
;;    :go "timeoutReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:75:22) r])

JOKER FUNC iotest.TruncateWriter has:
;; (defn TruncateWriter
;;   "TruncateWriter returns a Writer that writes to w\nbut stops silently after n bytes.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/writer.go:11:43)"
;;   {:added "1.0"
;;    :go "truncateWriter(w, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/writer.go:11:23) w, n])

JOKER FUNC ioutil.NopCloser has:
;; (defn NopCloser
;;   "NopCloser returns a ReadCloser with a no-op Close method wrapping\nthe provided Reader r.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:118:29)"
;;   {:added "1.0"
;;    :go "nopCloser(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:118:18) r])

JOKER FUNC ioutil.ReadAll has:
;; (defn ReadAll
;;   "ReadAll reads from r until an error or EOF and returns the data it read.\nA successful call returns err == nil, not err == EOF. Because ReadAll is\ndefined to read from src until EOF, it does not treat an EOF from Read\nas an error to be reported.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "readAll(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:44:16) r])

JOKER FUNC ioutil.ReadDir has:
;; (defn ReadDir
;;   "ReadDir reads the directory named by dirname and returns\na list of directory entries sorted by filename.\nGo return type: ([], error)\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:96:33)) Error]"
;;   {:added "1.0"
;;    :go "readDir(dirname)"}
;;   [^String dirname])

JOKER FUNC ioutil.ReadFile has:
;; (defn ReadFile
;;   "ReadFile reads the file named by filename and returns the contents.\nA successful call returns err == nil, not err == EOF. Because ReadFile\nreads the whole file, it does not treat an EOF from Read as an error\nto be reported.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "readFile(filename)"}
;;   [^String filename])

JOKER FUNC ioutil.TempDir has:
;; (defn TempDir
;;   "TempDir creates a new temporary directory in the directory dir\nwith a name beginning with prefix and returns the path of the\nnew directory. If dir is the empty string, TempDir uses the\ndefault directory for temporary files (see os.TempDir).\nMultiple programs calling TempDir simultaneously\nwill not choose the same directory. It is the caller's responsibility\nto remove the directory when no longer needed.\nGo return type: (name string, err error)\nJoker return type: [^String name ^Error err]"
;;   {:added "1.0"
;;    :go "tempDir(dir, prefix)"}
;;   [^String dir, ^String prefix])

JOKER FUNC ioutil.TempFile has:
;; (defn TempFile
;;   "TempFile creates a new temporary file in the directory dir,\nopens the file for reading and writing, and returns the resulting *os.File.\nThe filename is generated by taking pattern and adding a random\nstring to the end. If pattern includes a \"*\", the random string\nreplaces the last \"*\".\nIf dir is the empty string, TempFile uses the default directory\nfor temporary files (see os.TempDir).\nMultiple programs calling TempFile simultaneously\nwill not choose the same file. The caller can use f.Name()\nto find the pathname of the file. It is the caller's responsibility\nto remove the file when no longer needed.\nGo return type: (f *, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/tempfile.go:50:40) f ^Error err]"
;;   {:added "1.0"
;;    :go "tempFile(dir, pattern)"}
;;   [^String dir, ^String pattern])

JOKER FUNC ioutil.WriteFile has:
;; (defn ^Error WriteFile
;;   "WriteFile writes data to a file named by filename.\nIf the file does not exist, WriteFile creates it with permissions perm;\notherwise WriteFile truncates it before writing.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "writeFile(filename, data, perm)"}
;;   [^String filename, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/ioutil/ioutil.go:79:38) data, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:79:51) perm])

JOKER FUNC jpeg.Decode has:
;; (defn Decode
;;   "Decode reads a JPEG image from r and returns it as an image.Image.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/reader.go:777:27) Error]"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/reader.go:777:15) r])

JOKER FUNC jpeg.DecodeConfig has:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a JPEG image without\ndecoding the entire image.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/reader.go:784:33) Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/reader.go:784:21) r])

JOKER FUNC jpeg.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\noptions. Default parameters are used if a nil *Options is passed.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "encode(w, m, o)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/writer.go:575:15) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/writer.go:575:28) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/image/jpeg/writer.go:575:43) o])

JOKER FUNC json.Compact has:
;; (defn ^Error Compact
;;   "Compact appends to dst the JSON-encoded src with\ninsignificant space characters elided.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "compact(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/json/indent.go:11:18) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/indent.go:11:37) src])

JOKER FUNC json.HTMLEscape has:
;; (defn HTMLEscape
;;   "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029\ncharacters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029\nso that the JSON will be safe to embed inside HTML <script> tags.\nFor historical reasons, web browsers don't honor standard HTML\nescaping within <script> tags, so an alternative JSON encoding must\nbe used.\n"
;;   {:added "1.0"
;;    :go "hTMLEscape(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/json/encode.go:194:21) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/encode.go:194:40) src])

JOKER FUNC json.Indent has:
;; (defn ^Error Indent
;;   "Indent appends to dst an indented form of the JSON-encoded src.\nEach element in a JSON object or array begins on a new,\nindented line beginning with prefix followed by one or more\ncopies of indent according to the indentation nesting.\nThe data appended to dst does not begin with the prefix nor\nany indentation, to make it easier to embed inside other formatted JSON data.\nAlthough leading space characters (space, tab, carriage return, newline)\nat the beginning of src are dropped, trailing space characters\nat the end of src are preserved and copied to dst.\nFor example, if src has no trailing spaces, neither will dst;\nif src ends in a trailing newline, so will dst.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "indent(dst, src, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/json/indent.go:79:17) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/indent.go:79:36) src, ^String prefix, ^String indent])

JOKER FUNC json.Marshal has:
;; (defn Marshal
;;   "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively.\nIf an encountered value implements the Marshaler interface\nand is not a nil pointer, Marshal calls its MarshalJSON method\nto produce JSON. If no MarshalJSON method is present but the\nvalue implements encoding.TextMarshaler instead, Marshal calls\nits MarshalText method and encodes the result as a JSON string.\nThe nil pointer exception is not strictly necessary\nbut mimics a similar, necessary exception in the behavior of\nUnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers.\n\nString values encode as JSON strings coerced to valid UTF-8,\nreplacing invalid bytes with the Unicode replacement rune.\nThe angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\nto keep some browsers from misinterpreting JSON output as HTML.\nAmpersand \"&\" is also escaped to \"\\u0026\" for the same reason.\nThis escaping can be disabled using an Encoder that had SetEscapeHTML(false)\ncalled on it.\n\nArray and slice values encode as JSON arrays, except that\n[]byte encodes as a base64-encoded string, and a nil slice\nencodes as the null JSON value.\n\nStruct values encode as JSON objects.\nEach exported struct field becomes a member of the object, using the\nfield name as the object key, unless the field is omitted for one of the\nreasons given below.\n\nThe encoding of each struct field can be customized by the format string\nstored under the \"json\" key in the struct field's tag.\nThe format string gives the name of the field, possibly followed by a\ncomma-separated list of options. The name may be empty in order to\nspecify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted\nfrom the encoding if the field has an empty value, defined as\nfalse, 0, a nil pointer, a nil interface value, and any empty array,\nslice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted.\nNote that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n  // Field appears in JSON as key \"myName\".\n  Field int `json:\"myName\"`\n\n  // Field appears in JSON as key \"myName\" and\n  // the field is omitted from the object if its value is empty,\n  // as defined above.\n  Field int `json:\"myName,omitempty\"`\n\n  // Field appears in JSON as key \"Field\" (the default), but\n  // the field is skipped if empty.\n  // Note the leading comma.\n  Field int `json:\",omitempty\"`\n\n  // Field is ignored by this package.\n  Field int `json:\"-\"`\n\n  // Field appears in JSON as key \"-\".\n  Field int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a\nJSON-encoded string. It applies only to fields of string, floating point,\ninteger, or boolean types. This extra level of encoding is sometimes used\nwhen communicating with JavaScript programs:\n\n   Int64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of\nonly Unicode letters, digits, and ASCII punctuation except quotation\nmarks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields\nwere fields in the outer struct, subject to the usual Go visibility rules amended\nas described in the next paragraph.\nAn anonymous struct field with a name given in its JSON tag is treated as\nhaving that name, rather than being anonymous.\nAn anonymous struct field of interface type is treated the same as having\nthat type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when\ndeciding which field to marshal or unmarshal. If there are\nmultiple fields at the same level, and that level is the least\nnested (and would therefore be the nesting level selected by the\nusual Go rules), the following extra rules apply:\n\n1) Of those fields, if any are JSON-tagged, only tagged fields are considered,\neven if there are multiple untagged fields that would otherwise conflict.\n\n2) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1.\nPrior to Go 1.1, anonymous struct fields were ignored. To force ignoring of\nan anonymous struct field in both current and earlier versions, give the field\na JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a\nstring, an integer type, or implement encoding.TextMarshaler. The map keys\nare sorted and used as JSON object keys by applying the following rules,\nsubject to the UTF-8 coercion described for string values above:\n  - string keys are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to.\nA nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface.\nA nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON.\nAttempting to encode such a value causes Marshal to return\nan UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not\nhandle them. Passing cyclic structures to Marshal will result in\nan infinite recursion.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/json/encode.go:157:16) v])

JOKER FUNC json.MarshalIndent has:
;; (defn MarshalIndent
;;   "MarshalIndent is like Marshal but applies Indent to format the output.\nEach JSON element in the output will begin on a new line beginning with prefix\nfollowed by one or more copies of indent according to the indentation nesting.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalIndent(v, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/json/encode.go:175:22) v, ^String prefix, ^String indent])

JOKER FUNC json.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from r.\n\nThe decoder introduces its own buffering and may\nread data from r beyond the JSON values requested.\nGo return type: *Decoder\nJoker return type: {:r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:15:10), :buf ^(vector-of Int), :d ^ABEND042(cannot find typename json.decodeState), :scanp ^Int, :scanned ^Int, :scan ^ABEND042(cannot find typename json.scanner), :err ^Error, :tokenState ^Int, :tokenStack ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:31:19) r])

JOKER FUNC json.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\nGo return type: *Encoder\nJoker return type: {:w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:176:13), :err ^Error, :escapeHTML ^Bool, :indentBuf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:180:16), :indentPrefix ^String, :indentValue ^String}"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:186:19) w])

JOKER FUNC json.Unmarshal has:
;; (defn ^Error Unmarshal
;;   "Unmarshal parses the JSON-encoded data and stores the result\nin the value pointed to by v. If v is nil or not a pointer,\nUnmarshal returns an InvalidUnmarshalError.\n\nUnmarshal uses the inverse of the encodings that\nMarshal uses, allocating maps, slices, and pointers as necessary,\nwith the following additional rules:\n\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of\nthe JSON being the JSON literal null. In that case, Unmarshal sets\nthe pointer to nil. Otherwise, Unmarshal unmarshals the JSON into\nthe value pointed at by the pointer. If the pointer is nil, Unmarshal\nallocates a new value for it to point to.\n\nTo unmarshal JSON into a value implementing the Unmarshaler interface,\nUnmarshal calls that value's UnmarshalJSON method, including\nwhen the input is a JSON null.\nOtherwise, if the value implements encoding.TextUnmarshaler\nand the input is a JSON quoted string, Unmarshal calls that value's\nUnmarshalText method with the unquoted form of the string.\n\nTo unmarshal JSON into a struct, Unmarshal matches incoming object\nkeys to the keys used by Marshal (either the struct field name or its tag),\npreferring an exact match but also accepting a case-insensitive match. By\ndefault, object keys which don't have a corresponding struct field are\nignored (see Decoder.DisallowUnknownFields for an alternative).\n\nTo unmarshal JSON into an interface value,\nUnmarshal stores one of these in the interface value:\n\n\tbool, for JSON booleans\n\tfloat64, for JSON numbers\n\tstring, for JSON strings\n\t[]interface{}, for JSON arrays\n\tmap[string]interface{}, for JSON objects\n\tnil for JSON null\n\nTo unmarshal a JSON array into a slice, Unmarshal resets the slice length\nto zero and then appends each element to the slice.\nAs a special case, to unmarshal an empty JSON array into a slice,\nUnmarshal replaces the slice with a new empty slice.\n\nTo unmarshal a JSON array into a Go array, Unmarshal decodes\nJSON array elements into corresponding Go array elements.\nIf the Go array is smaller than the JSON array,\nthe additional JSON array elements are discarded.\nIf the JSON array is smaller than the Go array,\nthe additional Go array elements are set to zero values.\n\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to\nuse. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal\nreuses the existing map, keeping existing entries. Unmarshal then stores\nkey-value pairs from the JSON object into the map. The map's key type must\neither be a string, an integer, or implement encoding.TextUnmarshaler.\n\nIf a JSON value is not appropriate for a given target type,\nor if a JSON number overflows the target type, Unmarshal\nskips that field and completes the unmarshaling as best it can.\nIf no more serious errors are encountered, Unmarshal returns\nan UnmarshalTypeError describing the earliest such error. In any\ncase, it's not guaranteed that all the remaining fields following\nthe problematic one will be unmarshaled into the target object.\n\nThe JSON null value unmarshals into an interface, map, pointer, or slice\nby setting that Go value to nil. Because null is often used in JSON to mean\n``not present,'' unmarshaling a JSON null into any other Go type has no effect\non the value and produces no error.\n\nWhen unmarshaling quoted strings, invalid UTF-8 or\ninvalid UTF-16 surrogate pairs are not treated as an error.\nInstead, they are replaced by the Unicode replacement\ncharacter U+FFFD.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "unmarshal(data, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/decode.go:96:21) data, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/json/decode.go:96:31) v])

JOKER FUNC json.Valid has:
;; (defn ^Bool Valid
;;   "Valid reports whether data is a valid JSON encoding.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "valid(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/scanner.go:19:17) data])

JOKER FUNC jsonrpc.Dial has:
;; (defn Dial
;;   "Dial connects to a JSON-RPC server at the specified network address.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:118:38) Error]"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC jsonrpc.NewClient has:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\nGo return type: *\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:113:42)"
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:113:21) conn])

JOKER FUNC jsonrpc.NewClientCodec has:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:37:46)"
;;   {:added "1.0"
;;    :go "newClientCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:37:26) conn])

JOKER FUNC jsonrpc.NewServerCodec has:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/server.go:37:46)"
;;   {:added "1.0"
;;    :go "newServerCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/server.go:37:26) conn])

JOKER FUNC jsonrpc.ServeConn has:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n"
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/server.go:132:21) conn])

JOKER FUNC list.New has:
;; (defn New
;;   "New returns an initialized list.\nGo return type: *List\nJoker return type: {:root ^{:next ^ABEND947(recursive type reference involving list.Element), :prev ^ABEND947(recursive type reference involving list.Element), :list ^ABEND947(recursive type reference involving list.List), :Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/list/list.go:27:8)}, :len ^Int}"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC log.Fatal has:
;; (defn Fatal
;;   "Fatal is equivalent to Print() followed by a call to os.Exit(1).\n"
;;   {:added "1.0"
;;    :go "fatal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:305:14) v])

JOKER FUNC log.Fatalf has:
;; (defn Fatalf
;;   "Fatalf is equivalent to Printf() followed by a call to os.Exit(1).\n"
;;   {:added "1.0"
;;    :go "fatalf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:311:30) v])

JOKER FUNC log.Fatalln has:
;; (defn Fatalln
;;   "Fatalln is equivalent to Println() followed by a call to os.Exit(1).\n"
;;   {:added "1.0"
;;    :go "fatalln(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:317:16) v])

JOKER FUNC log.Flags has:
(defn ^Int Flags
  "Flags returns the output flags for the standard logger.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "flags()"}
  [])

JOKER FUNC log.New has:
;; (defn New
;;   "New creates a new Logger. The out variable sets the\ndestination to which log data will be written.\nThe prefix appears at the beginning of each generated log line.\nThe flag argument defines the logging properties.\nGo return type: *Logger\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:51:9), :prefix ^String, :flag ^Int, :out ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:54:9), :buf ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "new(out, prefix, flag)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:62:14) out, ^String prefix, ^Int flag])

JOKER FUNC log.Output has:
(defn ^Error Output
  "Output writes the output for a logging event. The string s contains\nthe text to print after the prefix specified by the flags of the\nLogger. A newline is appended if the last character of s is not\nalready a newline. Calldepth is the count of the number of\nframes to skip when computing the file name and line number\nif Llongfile or Lshortfile is set; a value of 1 will print the details\nfor the caller of Output.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "output(calldepth, s)"}
  [^Int calldepth, ^String s])

JOKER FUNC log.Panic has:
;; (defn Panic
;;   "Panic is equivalent to Print() followed by a call to panic().\n"
;;   {:added "1.0"
;;    :go "panic(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:323:14) v])

JOKER FUNC log.Panicf has:
;; (defn Panicf
;;   "Panicf is equivalent to Printf() followed by a call to panic().\n"
;;   {:added "1.0"
;;    :go "panicf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:330:30) v])

JOKER FUNC log.Panicln has:
;; (defn Panicln
;;   "Panicln is equivalent to Println() followed by a call to panic().\n"
;;   {:added "1.0"
;;    :go "panicln(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:337:16) v])

JOKER FUNC log.Prefix has:
(defn ^String Prefix
  "Prefix returns the output prefix for the standard logger.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "prefix()"}
  [])

JOKER FUNC log.Print has:
;; (defn Print
;;   "Print calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Print.\n"
;;   {:added "1.0"
;;    :go "print(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:288:14) v])

JOKER FUNC log.Printf has:
;; (defn Printf
;;   "Printf calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Printf.\n"
;;   {:added "1.0"
;;    :go "printf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:294:30) v])

JOKER FUNC log.Println has:
;; (defn Println
;;   "Println calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Println.\n"
;;   {:added "1.0"
;;    :go "println(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:300:16) v])

JOKER FUNC log.SetFlags has:
;; (defn SetFlags
;;   "SetFlags sets the output flags for the standard logger.\n"
;;   {:added "1.0"
;;    :go "setFlags(flag)"}
;;   [^Int flag])

JOKER FUNC log.SetOutput has:
;; (defn SetOutput
;;   "SetOutput sets the output destination for the standard logger.\n"
;;   {:added "1.0"
;;    :go "setOutput(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:258:18) w])

JOKER FUNC log.SetPrefix has:
;; (defn SetPrefix
;;   "SetPrefix sets the output prefix for the standard logger.\n"
;;   {:added "1.0"
;;    :go "setPrefix(prefix)"}
;;   [^String prefix])

JOKER FUNC lzw.NewReader has:
;; (defn NewReader
;;   "NewReader creates a new io.ReadCloser.\nReads from the returned io.ReadCloser read and decompress data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when\nfinished reading.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. It must equal the litWidth\nused during compression.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/lzw/reader.go:239:56)"
;;   {:added "1.0"
;;    :go "newReader(r, order, litWidth)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/lzw/reader.go:239:18) r, order, ^Int litWidth])

JOKER FUNC lzw.NewWriter has:
;; (defn NewWriter
;;   "NewWriter creates a new io.WriteCloser.\nWrites to the returned io.WriteCloser are compressed and written to w.\nIt is the caller's responsibility to call Close on the WriteCloser when\nfinished writing.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/lzw/writer.go:241:56)"
;;   {:added "1.0"
;;    :go "newWriter(w, order, litWidth)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/lzw/writer.go:241:18) w, order, ^Int litWidth])

JOKER FUNC macho.NewFatFile has:
;; (defn NewFatFile
;;   "NewFatFile creates a new FatFile for accessing all the Mach-O images in a\nuniversal binary. The Mach-O binary is expected to start at position 0 in\nthe ReaderAt.\nGo return type: (*FatFile, error)\nJoker return type: [{:Magic ^Int, :Arches ^(vector-of {}), :closer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/fat.go:18:9)} Error]"
;;   {:added "1.0"
;;    :go "newFatFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/fat.go:45:19) r])

JOKER FUNC macho.NewFile has:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Mach-O binary in an underlying reader.\nThe Mach-O binary is expected to start at position 0 in the ReaderAt.\nGo return type: (*File, error)\nJoker return type: [{:ByteOrder ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:24:12), :Loads ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/debug/macho/file.go:35:11)), :Sections ^(vector-of {:Relocs ^(vector-of {:Addr ^Int, :Value ^Int, :Type ^ABEND042(cannot find typename macho.uint8), :Len ^ABEND042(cannot find typename macho.uint8), :Pcrel ^Bool, :Extern ^Bool, :Scattered ^Bool}), :sr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:124:6)}), :Symtab ^{:Syms ^(vector-of {:Name ^String, :Type ^ABEND042(cannot find typename macho.uint8), :Sect ^ABEND042(cannot find typename macho.uint8), :Desc ^Int, :Value ^ABEND042(cannot find typename macho.uint64)})}, :Dysymtab ^{:IndirectSyms ^(vector-of Int)}, :closer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:31:9)} Error]"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:228:16) r])

JOKER FUNC macho.Open has:
;; (defn Open
;;   "Open opens the named file using os.Open and prepares it for use as a Mach-O binary.\nGo return type: (*File, error)\nJoker return type: [{:ByteOrder ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:24:12), :Loads ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/debug/macho/file.go:35:11)), :Sections ^(vector-of {:Relocs ^(vector-of {:Addr ^Int, :Value ^Int, :Type ^ABEND042(cannot find typename macho.uint8), :Len ^ABEND042(cannot find typename macho.uint8), :Pcrel ^Bool, :Extern ^Bool, :Scattered ^Bool}), :sr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:124:6)}), :Symtab ^{:Syms ^(vector-of {:Name ^String, :Type ^ABEND042(cannot find typename macho.uint8), :Sect ^ABEND042(cannot find typename macho.uint8), :Desc ^Int, :Value ^ABEND042(cannot find typename macho.uint64)})}, :Dysymtab ^{:IndirectSyms ^(vector-of Int)}, :closer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:31:9)} Error]"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC macho.OpenFat has:
;; (defn OpenFat
;;   "OpenFat opens the named file using os.Open and prepares it for use as a Mach-O\nuniversal binary.\nGo return type: (*FatFile, error)\nJoker return type: [{:Magic ^Int, :Arches ^(vector-of {}), :closer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/fat.go:18:9)} Error]"
;;   {:added "1.0"
;;    :go "openFat(name)"}
;;   [^String name])

JOKER FUNC mail.ParseAddress has:
;; (defn ParseAddress
;;   "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\nGo return type: (*Address, error)\nJoker return type: [{:Name ^String, :Address ^String} Error]"
;;   {:added "1.0"
;;    :go "parseAddress(address)"}
;;   [^String address])

JOKER FUNC mail.ParseAddressList has:
;; (defn ParseAddressList
;;   "ParseAddressList parses the given string as a list of addresses.\nGo return type: ([]*Address, error)\nJoker return type: [(vector-of {:Name ^String, :Address ^String}) Error]"
;;   {:added "1.0"
;;    :go "parseAddressList(list)"}
;;   [^String list])

JOKER FUNC mail.ParseDate has:
;; (defn ParseDate
;;   "ParseDate parses an RFC 5322 date string.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/mail/message.go:95:30) Error]"
;;   {:added "1.0"
;;    :go "parseDate(date)"}
;;   [^String date])

JOKER FUNC mail.ReadMessage has:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\nGo return type: (msg *Message, err error)\nJoker return type: [^{:Header ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/mail/message.go:106:13), :Body ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/mail/message.go:46:9)} msg ^Error err]"
;;   {:added "1.0"
;;    :go "readMessage(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/mail/message.go:52:20) r])

JOKER FUNC math.Abs has:
;; (defn Abs
;;   "Abs returns the absolute value of x.\n\nSpecial cases are:\n\tAbs(±Inf) = +Inf\n\tAbs(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "abs(x)"}
;;   [x])

JOKER FUNC math.Acos has:
;; (defn Acos
;;   "Acos returns the arccosine, in radians, of x.\n\nSpecial case is:\n\tAcos(x) = NaN if x < -1 or x > 1\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "acos(x)"}
;;   [x])

JOKER FUNC math.Acosh has:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nSpecial cases are:\n\tAcosh(+Inf) = +Inf\n\tAcosh(x) = NaN if x < 1\n\tAcosh(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "acosh(x)"}
;;   [x])

JOKER FUNC math.Asin has:
;; (defn Asin
;;   "Asin returns the arcsine, in radians, of x.\n\nSpecial cases are:\n\tAsin(±0) = ±0\n\tAsin(x) = NaN if x < -1 or x > 1\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "asin(x)"}
;;   [x])

JOKER FUNC math.Asinh has:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nSpecial cases are:\n\tAsinh(±0) = ±0\n\tAsinh(±Inf) = ±Inf\n\tAsinh(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "asinh(x)"}
;;   [x])

JOKER FUNC math.Atan has:
;; (defn Atan
;;   "Atan returns the arctangent, in radians, of x.\n\nSpecial cases are:\n     Atan(±0) = ±0\n     Atan(±Inf) = ±Pi/2\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "atan(x)"}
;;   [x])

JOKER FUNC math.Atan2 has:
;; (defn Atan2
;;   "Atan2 returns the arc tangent of y/x, using\nthe signs of the two to determine the quadrant\nof the return value.\n\nSpecial cases are (in order):\n\tAtan2(y, NaN) = NaN\n\tAtan2(NaN, x) = NaN\n\tAtan2(+0, x>=0) = +0\n\tAtan2(-0, x>=0) = -0\n\tAtan2(+0, x<=-0) = +Pi\n\tAtan2(-0, x<=-0) = -Pi\n\tAtan2(y>0, 0) = +Pi/2\n\tAtan2(y<0, 0) = -Pi/2\n\tAtan2(+Inf, +Inf) = +Pi/4\n\tAtan2(-Inf, +Inf) = -Pi/4\n\tAtan2(+Inf, -Inf) = 3Pi/4\n\tAtan2(-Inf, -Inf) = -3Pi/4\n\tAtan2(y, +Inf) = 0\n\tAtan2(y>0, -Inf) = +Pi\n\tAtan2(y<0, -Inf) = -Pi\n\tAtan2(+Inf, x) = +Pi/2\n\tAtan2(-Inf, x) = -Pi/2\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "atan2(y, x)"}
;;   [y, x])

JOKER FUNC math.Atanh has:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nSpecial cases are:\n\tAtanh(1) = +Inf\n\tAtanh(±0) = ±0\n\tAtanh(-1) = -Inf\n\tAtanh(x) = NaN if x < -1 or x > 1\n\tAtanh(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "atanh(x)"}
;;   [x])

JOKER FUNC math.Cbrt has:
;; (defn Cbrt
;;   "Cbrt returns the cube root of x.\n\nSpecial cases are:\n\tCbrt(±0) = ±0\n\tCbrt(±Inf) = ±Inf\n\tCbrt(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "cbrt(x)"}
;;   [x])

JOKER FUNC math.Ceil has:
;; (defn Ceil
;;   "Ceil returns the least integer value greater than or equal to x.\n\nSpecial cases are:\n\tCeil(±0) = ±0\n\tCeil(±Inf) = ±Inf\n\tCeil(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "ceil(x)"}
;;   [x])

JOKER FUNC math.Copysign has:
;; (defn Copysign
;;   "Copysign returns a value with the magnitude\nof x and the sign of y.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "copysign(x, y)"}
;;   [x, y])

JOKER FUNC math.Cos has:
;; (defn Cos
;;   "Cos returns the cosine of the radian argument x.\n\nSpecial cases are:\n\tCos(±Inf) = NaN\n\tCos(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "cos(x)"}
;;   [x])

JOKER FUNC math.Cosh has:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nSpecial cases are:\n\tCosh(±0) = 1\n\tCosh(±Inf) = +Inf\n\tCosh(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "cosh(x)"}
;;   [x])

JOKER FUNC math.Dim has:
;; (defn Dim
;;   "Dim returns the maximum of x-y or 0.\n\nSpecial cases are:\n\tDim(+Inf, +Inf) = NaN\n\tDim(-Inf, -Inf) = NaN\n\tDim(x, NaN) = Dim(NaN, x) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "dim(x, y)"}
;;   [x, y])

JOKER FUNC math.Erf has:
;; (defn Erf
;;   "Erf returns the error function of x.\n\nSpecial cases are:\n\tErf(+Inf) = 1\n\tErf(-Inf) = -1\n\tErf(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "erf(x)"}
;;   [x])

JOKER FUNC math.Erfc has:
;; (defn Erfc
;;   "Erfc returns the complementary error function of x.\n\nSpecial cases are:\n\tErfc(+Inf) = 0\n\tErfc(-Inf) = 2\n\tErfc(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "erfc(x)"}
;;   [x])

JOKER FUNC math.Erfcinv has:
;; (defn Erfcinv
;;   "Erfcinv returns the inverse of Erfc(x).\n\nSpecial cases are:\n\tErfcinv(0) = +Inf\n\tErfcinv(2) = -Inf\n\tErfcinv(x) = NaN if x < 0 or x > 2\n\tErfcinv(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "erfcinv(x)"}
;;   [x])

JOKER FUNC math.Erfinv has:
;; (defn Erfinv
;;   "Erfinv returns the inverse error function of x.\n\nSpecial cases are:\n\tErfinv(1) = +Inf\n\tErfinv(-1) = -Inf\n\tErfinv(x) = NaN if x < -1 or x > 1\n\tErfinv(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "erfinv(x)"}
;;   [x])

JOKER FUNC math.Exp has:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nSpecial cases are:\n\tExp(+Inf) = +Inf\n\tExp(NaN) = NaN\nVery large values overflow to 0 or +Inf.\nVery small values underflow to 1.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "exp(x)"}
;;   [x])

JOKER FUNC math.Exp2 has:
;; (defn Exp2
;;   "Exp2 returns 2**x, the base-2 exponential of x.\n\nSpecial cases are the same as Exp.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "exp2(x)"}
;;   [x])

JOKER FUNC math.Expm1 has:
;; (defn Expm1
;;   "Expm1 returns e**x - 1, the base-e exponential of x minus 1.\nIt is more accurate than Exp(x) - 1 when x is near zero.\n\nSpecial cases are:\n\tExpm1(+Inf) = +Inf\n\tExpm1(-Inf) = -1\n\tExpm1(NaN) = NaN\nVery large values overflow to -1 or +Inf.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "expm1(x)"}
;;   [x])

JOKER FUNC math.Float32bits has:
(defn ^Int Float32bits
  "Float32bits returns the IEEE 754 binary representation of f.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "float32bits(f)"}
  [f])

JOKER FUNC math.Float32frombits has:
;; (defn Float32frombits
;;   "Float32frombits returns the floating point number corresponding\nto the IEEE 754 binary representation b.\nGo return type: float32\nJoker return type: ABEND042(cannot find typename math.float32)"
;;   {:added "1.0"
;;    :go "float32frombits(b)"}
;;   [b])

JOKER FUNC math.Float64bits has:
;; (defn Float64bits
;;   "Float64bits returns the IEEE 754 binary representation of f.\nGo return type: uint64\nJoker return type: ABEND042(cannot find typename math.uint64)"
;;   {:added "1.0"
;;    :go "float64bits(f)"}
;;   [f])

JOKER FUNC math.Float64frombits has:
;; (defn Float64frombits
;;   "Float64frombits returns the floating point number corresponding\nthe IEEE 754 binary representation b.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "float64frombits(b)"}
;;   [b])

JOKER FUNC math.Floor has:
;; (defn Floor
;;   "Floor returns the greatest integer value less than or equal to x.\n\nSpecial cases are:\n\tFloor(±0) = ±0\n\tFloor(±Inf) = ±Inf\n\tFloor(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "floor(x)"}
;;   [x])

JOKER FUNC math.Frexp has:
;; (defn Frexp
;;   "Frexp breaks f into a normalized fraction\nand an integral power of two.\nIt returns frac and exp satisfying f == frac × 2**exp,\nwith the absolute value of frac in the interval [½, 1).\n\nSpecial cases are:\n\tFrexp(±0) = ±0, 0\n\tFrexp(±Inf) = ±Inf, 0\n\tFrexp(NaN) = NaN, 0\nGo return type: (frac float64, exp int)\nJoker return type: [^ABEND042(cannot find typename math.float64) frac ^Int exp]"
;;   {:added "1.0"
;;    :go "frexp(f)"}
;;   [f])

JOKER FUNC math.Gamma has:
;; (defn Gamma
;;   "Gamma returns the Gamma function of x.\n\nSpecial cases are:\n\tGamma(+Inf) = +Inf\n\tGamma(+0) = +Inf\n\tGamma(-0) = -Inf\n\tGamma(x) = NaN for integer x < 0\n\tGamma(-Inf) = NaN\n\tGamma(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "gamma(x)"}
;;   [x])

JOKER FUNC math.Hypot has:
;; (defn Hypot
;;   "Hypot returns Sqrt(p*p + q*q), taking care to avoid\nunnecessary overflow and underflow.\n\nSpecial cases are:\n\tHypot(±Inf, q) = +Inf\n\tHypot(p, ±Inf) = +Inf\n\tHypot(NaN, q) = NaN\n\tHypot(p, NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "hypot(p, q)"}
;;   [p, q])

JOKER FUNC math.Ilogb has:
(defn ^Int Ilogb
  "Ilogb returns the binary exponent of x as an integer.\n\nSpecial cases are:\n\tIlogb(±Inf) = MaxInt32\n\tIlogb(0) = MinInt32\n\tIlogb(NaN) = MaxInt32\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "ilogb(x)"}
  [x])

JOKER FUNC math.Inf has:
;; (defn Inf
;;   "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "inf(sign)"}
;;   [^Int sign])

JOKER FUNC math.IsInf has:
(defn ^Bool IsInf
  "IsInf reports whether f is an infinity, according to sign.\nIf sign > 0, IsInf reports whether f is positive infinity.\nIf sign < 0, IsInf reports whether f is negative infinity.\nIf sign == 0, IsInf reports whether f is either infinity.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isInf(f, sign)"}
  [f, ^Int sign])

JOKER FUNC math.IsNaN has:
;; (defn IsNaN
;;   "IsNaN reports whether f is an IEEE 754 ``not-a-number'' value.\nGo return type: is bool\nJoker return type: ^Bool is"
;;   {:added "1.0"
;;    :go "isNaN(f)"}
;;   [f])

JOKER FUNC math.J0 has:
;; (defn J0
;;   "J0 returns the order-zero Bessel function of the first kind.\n\nSpecial cases are:\n\tJ0(±Inf) = 0\n\tJ0(0) = 1\n\tJ0(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "j0(x)"}
;;   [x])

JOKER FUNC math.J1 has:
;; (defn J1
;;   "J1 returns the order-one Bessel function of the first kind.\n\nSpecial cases are:\n\tJ1(±Inf) = 0\n\tJ1(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "j1(x)"}
;;   [x])

JOKER FUNC math.Jn has:
;; (defn Jn
;;   "Jn returns the order-n Bessel function of the first kind.\n\nSpecial cases are:\n\tJn(n, ±Inf) = 0\n\tJn(n, NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "jn(n, x)"}
;;   [^Int n, x])

JOKER FUNC math.Ldexp has:
;; (defn Ldexp
;;   "Ldexp is the inverse of Frexp.\nIt returns frac × 2**exp.\n\nSpecial cases are:\n\tLdexp(±0, exp) = ±0\n\tLdexp(±Inf, exp) = ±Inf\n\tLdexp(NaN, exp) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "ldexp(frac, exp)"}
;;   [frac, ^Int exp])

JOKER FUNC math.Lgamma has:
;; (defn Lgamma
;;   "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\n\nSpecial cases are:\n\tLgamma(+Inf) = +Inf\n\tLgamma(0) = +Inf\n\tLgamma(-integer) = +Inf\n\tLgamma(-Inf) = -Inf\n\tLgamma(NaN) = NaN\nGo return type: (lgamma float64, sign int)\nJoker return type: [^ABEND042(cannot find typename math.float64) lgamma ^Int sign]"
;;   {:added "1.0"
;;    :go "lgamma(x)"}
;;   [x])

JOKER FUNC math.Log has:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nSpecial cases are:\n\tLog(+Inf) = +Inf\n\tLog(0) = -Inf\n\tLog(x < 0) = NaN\n\tLog(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "log(x)"}
;;   [x])

JOKER FUNC math.Log10 has:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\nThe special cases are the same as for Log.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "log10(x)"}
;;   [x])

JOKER FUNC math.Log1p has:
;; (defn Log1p
;;   "Log1p returns the natural logarithm of 1 plus its argument x.\nIt is more accurate than Log(1 + x) when x is near zero.\n\nSpecial cases are:\n\tLog1p(+Inf) = +Inf\n\tLog1p(±0) = ±0\n\tLog1p(-1) = -Inf\n\tLog1p(x < -1) = NaN\n\tLog1p(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "log1p(x)"}
;;   [x])

JOKER FUNC math.Log2 has:
;; (defn Log2
;;   "Log2 returns the binary logarithm of x.\nThe special cases are the same as for Log.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "log2(x)"}
;;   [x])

JOKER FUNC math.Logb has:
;; (defn Logb
;;   "Logb returns the binary exponent of x.\n\nSpecial cases are:\n\tLogb(±Inf) = +Inf\n\tLogb(0) = -Inf\n\tLogb(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "logb(x)"}
;;   [x])

JOKER FUNC math.Max has:
;; (defn Max
;;   "Max returns the larger of x or y.\n\nSpecial cases are:\n\tMax(x, +Inf) = Max(+Inf, x) = +Inf\n\tMax(x, NaN) = Max(NaN, x) = NaN\n\tMax(+0, ±0) = Max(±0, +0) = +0\n\tMax(-0, -0) = -0\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "max(x, y)"}
;;   [x, y])

JOKER FUNC math.Min has:
;; (defn Min
;;   "Min returns the smaller of x or y.\n\nSpecial cases are:\n\tMin(x, -Inf) = Min(-Inf, x) = -Inf\n\tMin(x, NaN) = Min(NaN, x) = NaN\n\tMin(-0, ±0) = Min(±0, -0) = -0\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "min(x, y)"}
;;   [x, y])

JOKER FUNC math.Mod has:
;; (defn Mod
;;   "Mod returns the floating-point remainder of x/y.\nThe magnitude of the result is less than y and its\nsign agrees with that of x.\n\nSpecial cases are:\n\tMod(±Inf, y) = NaN\n\tMod(NaN, y) = NaN\n\tMod(x, 0) = NaN\n\tMod(x, ±Inf) = x\n\tMod(x, NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "mod(x, y)"}
;;   [x, y])

JOKER FUNC math.Modf has:
;; (defn Modf
;;   "Modf returns integer and fractional floating-point numbers\nthat sum to f. Both values have the same sign as f.\n\nSpecial cases are:\n\tModf(±Inf) = ±Inf, NaN\n\tModf(NaN) = NaN, NaN\nGo return type: (int float64, frac float64)\nJoker return type: [^ABEND042(cannot find typename math.float64) int ^ABEND042(cannot find typename math.float64) frac]"
;;   {:added "1.0"
;;    :go "modf(f)"}
;;   [f])

JOKER FUNC math.NaN has:
;; (defn NaN
;;   "NaN returns an IEEE 754 ``not-a-number'' value.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])

JOKER FUNC math.Nextafter has:
;; (defn Nextafter
;;   "Nextafter returns the next representable float64 value after x towards y.\n\nSpecial cases are:\n\tNextafter(x, x)   = x\n\tNextafter(NaN, y) = NaN\n\tNextafter(x, NaN) = NaN\nGo return type: r float64\nJoker return type: ^ABEND042(cannot find typename math.float64) r"
;;   {:added "1.0"
;;    :go "nextafter(x, y)"}
;;   [x, y])

JOKER FUNC math.Nextafter32 has:
;; (defn Nextafter32
;;   "Nextafter32 returns the next representable float32 value after x towards y.\n\nSpecial cases are:\n\tNextafter32(x, x)   = x\n\tNextafter32(NaN, y) = NaN\n\tNextafter32(x, NaN) = NaN\nGo return type: r float32\nJoker return type: ^ABEND042(cannot find typename math.float32) r"
;;   {:added "1.0"
;;    :go "nextafter32(x, y)"}
;;   [x, y])

JOKER FUNC math.Pow has:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\n\nSpecial cases are (in order):\n\tPow(x, ±0) = 1 for any x\n\tPow(1, y) = 1 for any y\n\tPow(x, 1) = x for any x\n\tPow(NaN, y) = NaN\n\tPow(x, NaN) = NaN\n\tPow(±0, y) = ±Inf for y an odd integer < 0\n\tPow(±0, -Inf) = +Inf\n\tPow(±0, +Inf) = +0\n\tPow(±0, y) = +Inf for finite y < 0 and not an odd integer\n\tPow(±0, y) = ±0 for y an odd integer > 0\n\tPow(±0, y) = +0 for finite y > 0 and not an odd integer\n\tPow(-1, ±Inf) = 1\n\tPow(x, +Inf) = +Inf for |x| > 1\n\tPow(x, -Inf) = +0 for |x| > 1\n\tPow(x, +Inf) = +0 for |x| < 1\n\tPow(x, -Inf) = +Inf for |x| < 1\n\tPow(+Inf, y) = +Inf for y > 0\n\tPow(+Inf, y) = +0 for y < 0\n\tPow(-Inf, y) = Pow(-0, -y)\n\tPow(x, y) = NaN for finite x < 0 and finite non-integer y\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "pow(x, y)"}
;;   [x, y])

JOKER FUNC math.Pow10 has:
;; (defn Pow10
;;   "Pow10 returns 10**n, the base-10 exponential of n.\n\nSpecial cases are:\n\tPow10(n) =    0 for n < -323\n\tPow10(n) = +Inf for n > 308\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "pow10(n)"}
;;   [^Int n])

JOKER FUNC math.Remainder has:
;; (defn Remainder
;;   "Remainder returns the IEEE 754 floating-point remainder of x/y.\n\nSpecial cases are:\n\tRemainder(±Inf, y) = NaN\n\tRemainder(NaN, y) = NaN\n\tRemainder(x, 0) = NaN\n\tRemainder(x, ±Inf) = x\n\tRemainder(x, NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "remainder(x, y)"}
;;   [x, y])

JOKER FUNC math.Round has:
;; (defn Round
;;   "Round returns the nearest integer, rounding half away from zero.\n\nSpecial cases are:\n\tRound(±0) = ±0\n\tRound(±Inf) = ±Inf\n\tRound(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "round(x)"}
;;   [x])

JOKER FUNC math.RoundToEven has:
;; (defn RoundToEven
;;   "RoundToEven returns the nearest integer, rounding ties to even.\n\nSpecial cases are:\n\tRoundToEven(±0) = ±0\n\tRoundToEven(±Inf) = ±Inf\n\tRoundToEven(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "roundToEven(x)"}
;;   [x])

JOKER FUNC math.Signbit has:
(defn ^Bool Signbit
  "Signbit returns true if x is negative or negative zero.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "signbit(x)"}
  [x])

JOKER FUNC math.Sin has:
;; (defn Sin
;;   "Sin returns the sine of the radian argument x.\n\nSpecial cases are:\n\tSin(±0) = ±0\n\tSin(±Inf) = NaN\n\tSin(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "sin(x)"}
;;   [x])

JOKER FUNC math.Sincos has:
;; (defn Sincos
;;   "Sincos returns Sin(x), Cos(x).\n\nSpecial cases are:\n\tSincos(±0) = ±0, 1\n\tSincos(±Inf) = NaN, NaN\n\tSincos(NaN) = NaN, NaN\nGo return type: (sin float64, cos float64)\nJoker return type: [^ABEND042(cannot find typename math.float64) sin ^ABEND042(cannot find typename math.float64) cos]"
;;   {:added "1.0"
;;    :go "sincos(x)"}
;;   [x])

JOKER FUNC math.Sinh has:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nSpecial cases are:\n\tSinh(±0) = ±0\n\tSinh(±Inf) = ±Inf\n\tSinh(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "sinh(x)"}
;;   [x])

JOKER FUNC math.Sqrt has:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\n\nSpecial cases are:\n\tSqrt(+Inf) = +Inf\n\tSqrt(±0) = ±0\n\tSqrt(x < 0) = NaN\n\tSqrt(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "sqrt(x)"}
;;   [x])

JOKER FUNC math.Tan has:
;; (defn Tan
;;   "Tan returns the tangent of the radian argument x.\n\nSpecial cases are:\n\tTan(±0) = ±0\n\tTan(±Inf) = NaN\n\tTan(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "tan(x)"}
;;   [x])

JOKER FUNC math.Tanh has:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nSpecial cases are:\n\tTanh(±0) = ±0\n\tTanh(±Inf) = ±1\n\tTanh(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "tanh(x)"}
;;   [x])

JOKER FUNC math.Trunc has:
;; (defn Trunc
;;   "Trunc returns the integer value of x.\n\nSpecial cases are:\n\tTrunc(±0) = ±0\n\tTrunc(±Inf) = ±Inf\n\tTrunc(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "trunc(x)"}
;;   [x])

JOKER FUNC math.Y0 has:
;; (defn Y0
;;   "Y0 returns the order-zero Bessel function of the second kind.\n\nSpecial cases are:\n\tY0(+Inf) = 0\n\tY0(0) = -Inf\n\tY0(x < 0) = NaN\n\tY0(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "y0(x)"}
;;   [x])

JOKER FUNC math.Y1 has:
;; (defn Y1
;;   "Y1 returns the order-one Bessel function of the second kind.\n\nSpecial cases are:\n\tY1(+Inf) = 0\n\tY1(0) = -Inf\n\tY1(x < 0) = NaN\n\tY1(NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "y1(x)"}
;;   [x])

JOKER FUNC math.Yn has:
;; (defn Yn
;;   "Yn returns the order-n Bessel function of the second kind.\n\nSpecial cases are:\n\tYn(n, +Inf) = 0\n\tYn(n ≥ 0, 0) = -Inf\n\tYn(n < 0, 0) = +Inf if n is odd, -Inf if n is even\n\tYn(n, x < 0) = NaN\n\tYn(n, NaN) = NaN\nGo return type: float64\nJoker return type: ABEND042(cannot find typename math.float64)"
;;   {:added "1.0"
;;    :go "yn(n, x)"}
;;   [^Int n, x])

JOKER FUNC md5.New has:
;; (defn New
;;   "New returns a new hash.Hash computing the MD5 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/md5/md5.go:130:12)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC md5.Sum has:
;; (defn Sum
;;   "Sum returns the MD5 checksum of the data.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/md5/md5.go:204:15) data])

JOKER FUNC mime.AddExtensionType has:
(defn ^Error AddExtensionType
  "AddExtensionType sets the MIME type associated with\nthe extension ext to typ. The extension should begin with\na leading dot, as in \".html\".\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "addExtensionType(ext, typ)"}
  [^String ext, ^String typ])

JOKER FUNC mime.ExtensionsByType has:
;; (defn ExtensionsByType
;;   "ExtensionsByType returns the extensions known to be associated with the MIME\ntype typ. The returned extensions will each begin with a leading dot, as in\n\".html\". When typ has no associated extensions, ExtensionsByType returns an\nnil slice.\nGo return type: ([]string, error)\nJoker return type: [(vector-of String) Error]"
;;   {:added "1.0"
;;    :go "extensionsByType(typ)"}
;;   [^String typ])

JOKER FUNC mime.FormatMediaType has:
;; (defn ^String FormatMediaType
;;   "FormatMediaType serializes mediatype t and the parameters\nparam as a media type conforming to RFC 2045 and RFC 2616.\nThe type and parameter names are written in lower-case.\nWhen any of the arguments result in a standard violation then\nFormatMediaType returns the empty string.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "formatMediaType(t, param)"}
;;   [^String t, ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/mime/mediatype.go:20:38) param])

JOKER FUNC mime.ParseMediaType has:
;; (defn ParseMediaType
;;   "ParseMediaType parses a media type value and any optional\nparameters, per RFC 1521.  Media types are the values in\nContent-Type and Content-Disposition headers (RFC 2183).\nOn success, ParseMediaType returns the media type converted\nto lowercase and trimmed of white space and a non-nil map.\nIf there is an error parsing the optional parameter,\nthe media type will be returned along with the error\nErrInvalidMediaParameter.\nThe returned map, params, maps from the lowercase\nattribute to the attribute value with its case preserved.\nGo return type: (mediatype string, params, err error)\nJoker return type: [^String mediatype ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/mime/mediatype.go:111:57) params ^Error err]"
;;   {:added "1.0"
;;    :go "parseMediaType(v)"}
;;   [^String v])

JOKER FUNC mime.TypeByExtension has:
(defn ^String TypeByExtension
  "TypeByExtension returns the MIME type associated with the file extension ext.\nThe extension ext should begin with a leading dot, as in \".html\".\nWhen ext has no associated type, TypeByExtension returns \"\".\n\nExtensions are looked up first case-sensitively, then case-insensitively.\n\nThe built-in table is small but on unix it is augmented by the local\nsystem's mime.types file(s) if available under one or more of these\nnames:\n\n  /etc/mime.types\n  /etc/apache2/mime.types\n  /etc/apache/mime.types\n\nOn Windows, MIME types are extracted from the registry.\n\nText types have the charset parameter set to \"utf-8\" by default.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "typeByExtension(ext)"}
  [^String ext])

JOKER FUNC multipart.NewReader has:
;; (defn NewReader
;;   "NewReader creates a new multipart Reader reading from r using the\ngiven MIME boundary.\n\nThe boundary is usually obtained from the \"boundary\" parameter of\nthe message's \"Content-Type\" header. Use mime.ParseMediaType to\nparse such headers.\nGo return type: *Reader\nJoker return type: {:bufReader ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/multipart.go:289:13), :currentPart ^{:Header ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/multipart.go:43:9), :mr ^ABEND947(recursive type reference involving multipart.Reader), :disposition ^String, :dispositionParams ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/mime/multipart/multipart.go:48:20), :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/multipart.go:53:4), :n ^Int, :total ^Int, :err ^Error, :readErr ^Error}, :partsRead ^Int, :nl ^(vector-of Int), :nlDashBoundary ^(vector-of Int), :dashBoundaryDash ^(vector-of Int), :dashBoundary ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "newReader(r, boundary)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/multipart.go:99:18) r, ^String boundary])

JOKER FUNC multipart.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new multipart Writer with a random boundary,\nwriting to w.\nGo return type: *Writer\nJoker return type: {:w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/writer.go:20:11), :boundary ^String, :lastpart ^ABEND042(cannot find typename multipart.part)}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/writer.go:27:18) w])

JOKER FUNC net.CIDRMask has:
;; (defn CIDRMask
;;   "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\nGo return type: IPMask\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "cIDRMask(ones, bits)"}
;;   [^Int ones, ^Int bits])

JOKER FUNC net.Dial has:
;; (defn Dial
;;   "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\nGo return type: (Conn, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.DialIP has:
;; (defn DialIP
;;   "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\nGo return type: (*IPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialIP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/iprawsock.go:211:42) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/iprawsock.go:211:42) raddr])

JOKER FUNC net.DialTCP has:
;; (defn DialTCP
;;   "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\nGo return type: (*TCPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialTCP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/tcpsock.go:206:43) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/tcpsock.go:206:43) raddr])

JOKER FUNC net.DialTimeout has:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (Conn, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "dialTimeout(network, address, timeout)"}
;;   [^String network, ^String address, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/dial.go:313:51) timeout])

JOKER FUNC net.DialUDP has:
;; (defn DialUDP
;;   "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\nGo return type: (*UDPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialUDP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:205:43) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:205:43) raddr])

JOKER FUNC net.DialUnix has:
;; (defn DialUnix
;;   "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\nGo return type: (*UnixConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialUnix(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:200:44) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:200:44) raddr])

JOKER FUNC net.FileConn has:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\nGo return type: (c Conn, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:113:11) c ^Error err]"
;;   {:added "1.0"
;;    :go "fileConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/file.go:21:17) f])

JOKER FUNC net.FileListener has:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\nGo return type: (ln Listener, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:365:15) ln ^Error err]"
;;   {:added "1.0"
;;    :go "fileListener(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/file.go:33:21) f])

JOKER FUNC net.FilePacketConn has:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\nGo return type: (c PacketConn, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:303:17) c ^Error err]"
;;   {:added "1.0"
;;    :go "filePacketConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/file.go:45:23) f])

JOKER FUNC net.IPv4 has:
;; (defn IPv4
;;   "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\nGo return type: IP\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "iPv4(a, b, c, d)"}
;;   [a, b, c, d])

JOKER FUNC net.IPv4Mask has:
;; (defn IPv4Mask
;;   "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\nGo return type: IPMask\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "iPv4Mask(a, b, c, d)"}
;;   [a, b, c, d])

JOKER FUNC net.InterfaceAddrs has:
;; (defn InterfaceAddrs
;;   "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\nGo return type: ([]Addr, error)\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:105:11)) Error]"
;;   {:added "1.0"
;;    :go "interfaceAddrs()"}
;;   [])

JOKER FUNC net.InterfaceByIndex has:
;; (defn InterfaceByIndex
;;   "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\nGo return type: (*Interface, error)\nJoker return type: [{:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int} Error]"
;;   {:added "1.0"
;;    :go "interfaceByIndex(index)"}
;;   [^Int index])

JOKER FUNC net.InterfaceByName has:
;; (defn InterfaceByName
;;   "InterfaceByName returns the interface specified by name.\nGo return type: (*Interface, error)\nJoker return type: [{:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int} Error]"
;;   {:added "1.0"
;;    :go "interfaceByName(name)"}
;;   [^String name])

JOKER FUNC net.Interfaces has:
;; (defn Interfaces
;;   "Interfaces returns a list of the system's network interfaces.\nGo return type: ([]Interface, error)\nJoker return type: [(vector-of {:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int}) Error]"
;;   {:added "1.0"
;;    :go "interfaces()"}
;;   [])

JOKER FUNC net.JoinHostPort has:
(defn ^String JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "joinHostPort(host, port)"}
  [^String host, ^String port])

JOKER FUNC net.Listen has:
;; (defn Listen
;;   "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (Listener, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:365:15) Error]"
;;   {:added "1.0"
;;    :go "listen(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ListenIP has:
;; (defn ListenIP
;;   "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nGo return type: (*IPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenIP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/iprawsock.go:230:37) laddr])

JOKER FUNC net.ListenMulticastUDP has:
;; (defn ListenMulticastUDP
;;   "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\nGo return type: (*UDPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenMulticastUDP(network, ifi, gaddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:265:45) ifi, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:265:63) gaddr])

JOKER FUNC net.ListenPacket has:
;; (defn ListenPacket
;;   "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (PacketConn, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:303:17) Error]"
;;   {:added "1.0"
;;    :go "listenPacket(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ListenTCP has:
;; (defn ListenTCP
;;   "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\nGo return type: (*TCPListener, error)\nJoker return type: [{:fd ^ABEND042(cannot find typename net.netFD)} Error]"
;;   {:added "1.0"
;;    :go "listenTCP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/tcpsock.go:323:38) laddr])

JOKER FUNC net.ListenUDP has:
;; (defn ListenUDP
;;   "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\nGo return type: (*UDPConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUDP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:231:38) laddr])

JOKER FUNC net.ListenUnix has:
;; (defn ListenUnix
;;   "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\nGo return type: (*UnixListener, error)\nJoker return type: [{:fd ^ABEND042(cannot find typename net.netFD), :path ^String, :unlink ^Bool, :unlinkOnce ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/unixsock.go:221:13)} Error]"
;;   {:added "1.0"
;;    :go "listenUnix(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:314:39) laddr])

JOKER FUNC net.ListenUnixgram has:
;; (defn ListenUnixgram
;;   "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\nGo return type: (*UnixConn, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUnixgram(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:334:43) laddr])

JOKER FUNC net.LookupAddr has:
;; (defn LookupAddr
;;   "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\nGo return type: (names []string, err error)\nJoker return type: [^(vector-of String) names ^Error err]"
;;   {:added "1.0"
;;    :go "lookupAddr(addr)"}
;;   [^String addr])

JOKER FUNC net.LookupCNAME has:
;; (defn LookupCNAME
;;   "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\nGo return type: (cname string, err error)\nJoker return type: [^String cname ^Error err]"
;;   {:added "1.0"
;;    :go "lookupCNAME(host)"}
;;   [^String host])

JOKER FUNC net.LookupHost has:
;; (defn LookupHost
;;   "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\nGo return type: (addrs []string, err error)\nJoker return type: [^(vector-of String) addrs ^Error err]"
;;   {:added "1.0"
;;    :go "lookupHost(host)"}
;;   [^String host])

JOKER FUNC net.LookupIP has:
;; (defn LookupIP
;;   "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\nGo return type: ([]IP, error)\nJoker return type: [(vector-of (vector-of Int)) Error]"
;;   {:added "1.0"
;;    :go "lookupIP(host)"}
;;   [^String host])

JOKER FUNC net.LookupMX has:
;; (defn LookupMX
;;   "LookupMX returns the DNS MX records for the given domain name sorted by preference.\nGo return type: ([]*MX, error)\nJoker return type: [(vector-of {:Host ^String, :Pref ^Int}) Error]"
;;   {:added "1.0"
;;    :go "lookupMX(name)"}
;;   [^String name])

JOKER FUNC net.LookupNS has:
;; (defn LookupNS
;;   "LookupNS returns the DNS NS records for the given domain name.\nGo return type: ([]*NS, error)\nJoker return type: [(vector-of {:Host ^String}) Error]"
;;   {:added "1.0"
;;    :go "lookupNS(name)"}
;;   [^String name])

JOKER FUNC net.LookupPort has:
;; (defn LookupPort
;;   "LookupPort looks up the port for the given network and service.\nGo return type: (port int, err error)\nJoker return type: [^Int port ^Error err]"
;;   {:added "1.0"
;;    :go "lookupPort(network, service)"}
;;   [^String network, ^String service])

JOKER FUNC net.LookupSRV has:
;; (defn LookupSRV
;;   "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\nGo return type: (cname string, addrs []*SRV, err error)\nJoker return type: [^String cname ^(vector-of {:Target ^String, :Port ^Int, :Priority ^Int, :Weight ^Int}) addrs ^Error err]"
;;   {:added "1.0"
;;    :go "lookupSRV(service, proto, name)"}
;;   [^String service, ^String proto, ^String name])

JOKER FUNC net.LookupTXT has:
;; (defn LookupTXT
;;   "LookupTXT returns the DNS TXT records for the given domain name.\nGo return type: ([]string, error)\nJoker return type: [(vector-of String) Error]"
;;   {:added "1.0"
;;    :go "lookupTXT(name)"}
;;   [^String name])

JOKER FUNC net.ParseCIDR has:
;; (defn ParseCIDR
;;   "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\nGo return type: (IP, *IPNet, error)\nJoker return type: [(vector-of Int) {:IP ^(vector-of Int), :Mask ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "parseCIDR(s)"}
;;   [^String s])

JOKER FUNC net.ParseIP has:
;; (defn ParseIP
;;   "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\nGo return type: IP\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "parseIP(s)"}
;;   [^String s])

JOKER FUNC net.ParseMAC has:
;; (defn ParseMAC
;;   "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\nGo return type: (hw HardwareAddr, err error)\nJoker return type: [^(vector-of Int) hw ^Error err]"
;;   {:added "1.0"
;;    :go "parseMAC(s)"}
;;   [^String s])

JOKER FUNC net.Pipe has:
;; (defn Pipe
;;   "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\nGo return type: (Conn, Conn)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:113:11) ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:113:11)]"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC net.ResolveIPAddr has:
;; (defn ResolveIPAddr
;;   "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (*IPAddr, error)\nJoker return type: [{:IP ^(vector-of Int), :Zone ^String} Error]"
;;   {:added "1.0"
;;    :go "resolveIPAddr(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ResolveTCPAddr has:
;; (defn ResolveTCPAddr
;;   "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (*TCPAddr, error)\nJoker return type: [{:IP ^(vector-of Int), :Port ^Int, :Zone ^String} Error]"
;;   {:added "1.0"
;;    :go "resolveTCPAddr(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ResolveUDPAddr has:
;; (defn ResolveUDPAddr
;;   "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (*UDPAddr, error)\nJoker return type: [{:IP ^(vector-of Int), :Port ^Int, :Zone ^String} Error]"
;;   {:added "1.0"
;;    :go "resolveUDPAddr(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ResolveUnixAddr has:
;; (defn ResolveUnixAddr
;;   "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\nGo return type: (*UnixAddr, error)\nJoker return type: [{:Name ^String, :Net ^String} Error]"
;;   {:added "1.0"
;;    :go "resolveUnixAddr(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.SplitHostPort has:
;; (defn SplitHostPort
;;   "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\nGo return type: (host string, port string, err error)\nJoker return type: [^String host ^String port ^Error err]"
;;   {:added "1.0"
;;    :go "splitHostPort(hostport)"}
;;   [^String hostport])

JOKER FUNC nettest.TestConn has:
;; (defn TestConn
;;   "TestConn tests that a net.Conn implementation properly satisfies the interface.\nThe tests should not produce any false positives, but may experience\nfalse negatives. Thus, some issues may only be detected when the test is\nrun multiple times. For maximal effectiveness, run the tests under the\nrace detector.\n"
;;   {:added "1.0"
;;    :go "testConn(t, mp)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/net/nettest/conntest.go:37:17) t, mp])

JOKER FUNC os.Chdir has:
(defn ^Error Chdir
  "Chdir changes the current working directory to the named directory.\nIf there is an error, it will be of type *PathError.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "chdir(dir)"}
  [^String dir])

JOKER FUNC os.Chmod has:
(defn ^Error Chmod
  "Chmod changes the mode of the named file to mode.\nIf the file is a symbolic link, it changes the mode of the link's target.\nIf there is an error, it will be of type *PathError.\n\nA different subset of the mode bits are used, depending on the\noperating system.\n\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and\nModeSticky are used.\n\nOn Windows, the mode must be non-zero but otherwise only the 0200\nbit (owner writable) of mode is used; it controls whether the\nfile's read-only attribute is set or cleared. attribute. The other\nbits are currently unused. Use mode 0400 for a read-only file and\n0600 for a readable+writable file.\n\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,\nand ModeTemporary are used.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "chmod(name, mode)"}
  [^String name, mode])

JOKER FUNC os.Chown has:
(defn ^Error Chown
  "Chown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link's target.\nA uid or gid of -1 means to not change that value.\nIf there is an error, it will be of type *PathError.\n\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\nEPLAN9 error, wrapped in *PathError.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "chown(name, uid, gid)"}
  [^String name, ^Int uid, ^Int gid])

JOKER FUNC os.Chtimes has:
;; (defn ^Error Chtimes
;;   "Chtimes changes the access and modification times of the named\nfile, similar to the Unix utime() or utimes() functions.\n\nThe underlying filesystem may truncate or round the values to a\nless precise time unit.\nIf there is an error, it will be of type *PathError.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "chtimes(name, atime, mtime)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/file_posix.go:140:33) atime, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/file_posix.go:140:50) mtime])

JOKER FUNC os.Clearenv has:
;; (defn Clearenv
;;   "Clearenv deletes all environment variables.\n"
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])

JOKER FUNC os.Create has:
;; (defn Create
;;   "Create creates the named file with mode 0666 (before umask), truncating\nit if it already exists. If successful, methods on the returned\nFile can be used for I/O; the associated file descriptor has mode\nO_RDWR.\nIf there is an error, it will be of type *PathError.\nGo return type: (*File, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "create(name)"}
;;   [^String name])

JOKER FUNC os.Environ has:
;; (defn Environ
;;   "Environ returns a copy of strings representing the environment,\nin the form \"key=value\".\nGo return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "environ()"}
;;   [])

JOKER FUNC os.Executable has:
;; (defn Executable
;;   "Executable returns the path name for the executable that started\nthe current process. There is no guarantee that the path is still\npointing to the correct executable. If a symlink was used to start\nthe process, depending on the operating system, the result might\nbe the symlink or the path it pointed to. If a stable result is\nneeded, path/filepath.EvalSymlinks might help.\n\nExecutable returns an absolute path unless an error occurred.\n\nThe main use case is finding resources located relative to an\nexecutable.\n\nExecutable is not supported on nacl.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "executable()"}
;;   [])

JOKER FUNC os.Exit has:
;; (defn Exit
;;   "Exit causes the current program to exit with the given status code.\nConventionally, code zero indicates success, non-zero an error.\nThe program terminates immediately; deferred functions are not run.\n"
;;   {:added "1.0"
;;    :go "exit(code)"}
;;   [^Int code])

JOKER FUNC os.Expand has:
;; (defn ^String Expand
;;   "Expand replaces ${var} or $var in the string based on the mapping function.\nFor example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "expand(s, mapping)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/os/env.go:16:31) mapping])

JOKER FUNC os.ExpandEnv has:
(defn ^String ExpandEnv
  "ExpandEnv replaces ${var} or $var in the string according to the values\nof the current environment variables. References to undefined\nvariables are replaced by the empty string.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "expandEnv(s)"}
  [^String s])

JOKER FUNC os.FindProcess has:
;; (defn FindProcess
;;   "FindProcess looks for a running process by its pid.\n\nThe Process it returns can be used to obtain information\nabout the underlying operating system process.\n\nOn Unix systems, FindProcess always succeeds and returns a Process\nfor the given pid, regardless of whether the process exists.\nGo return type: (*Process, error)\nJoker return type: [{:Pid ^Int, :handle ^ABEND042(cannot find typename os.uintptr), :isdone ^Int, :sigMu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec.go:21:9)} Error]"
;;   {:added "1.0"
;;    :go "findProcess(pid)"}
;;   [^Int pid])

JOKER FUNC os.Getegid has:
(defn ^Int Getegid
  "Getegid returns the numeric effective group id of the caller.\n\nOn Windows, it returns -1.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "getegid()"}
  [])

JOKER FUNC os.Getenv has:
(defn ^String Getenv
  "Getenv retrieves the value of the environment variable named by the key.\nIt returns the value, which will be empty if the variable is not present.\nTo distinguish between an empty value and an unset value, use LookupEnv.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "getenv(key)"}
  [^String key])

JOKER FUNC os.Geteuid has:
(defn ^Int Geteuid
  "Geteuid returns the numeric effective user id of the caller.\n\nOn Windows, it returns -1.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "geteuid()"}
  [])

JOKER FUNC os.Getgid has:
(defn ^Int Getgid
  "Getgid returns the numeric group id of the caller.\n\nOn Windows, it returns -1.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "getgid()"}
  [])

JOKER FUNC os.Getgroups has:
;; (defn Getgroups
;;   "Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n\nOn Windows, it returns syscall.EWINDOWS. See the os/user package\nfor a possible alternative.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "getgroups()"}
;;   [])

JOKER FUNC os.Getpagesize has:
(defn ^Int Getpagesize
  "Getpagesize returns the underlying system's memory page size.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "getpagesize()"}
  [])

JOKER FUNC os.Getpid has:
(defn ^Int Getpid
  "Getpid returns the process id of the caller.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "getpid()"}
  [])

JOKER FUNC os.Getppid has:
(defn ^Int Getppid
  "Getppid returns the process id of the caller's parent.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "getppid()"}
  [])

JOKER FUNC os.Getuid has:
(defn ^Int Getuid
  "Getuid returns the numeric user id of the caller.\n\nOn Windows, it returns -1.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "getuid()"}
  [])

JOKER FUNC os.Getwd has:
;; (defn Getwd
;;   "Getwd returns a rooted path name corresponding to the\ncurrent directory. If the current directory can be\nreached via multiple paths (due to symbolic links),\nGetwd may return any one of them.\nGo return type: (dir string, err error)\nJoker return type: [^String dir ^Error err]"
;;   {:added "1.0"
;;    :go "getwd()"}
;;   [])

JOKER FUNC os.Hostname has:
;; (defn Hostname
;;   "Hostname returns the host name reported by the kernel.\nGo return type: (name string, err error)\nJoker return type: [^String name ^Error err]"
;;   {:added "1.0"
;;    :go "hostname()"}
;;   [])

JOKER FUNC os.IsExist has:
(defn ^Bool IsExist
  "IsExist returns a boolean indicating whether the error is known to report\nthat a file or directory already exists. It is satisfied by ErrExist as\nwell as some syscall errors.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isExist(err)"}
  [err])

JOKER FUNC os.IsNotExist has:
(defn ^Bool IsNotExist
  "IsNotExist returns a boolean indicating whether the error is known to\nreport that a file or directory does not exist. It is satisfied by\nErrNotExist as well as some syscall errors.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isNotExist(err)"}
  [err])

JOKER FUNC os.IsPathSeparator has:
(defn ^Bool IsPathSeparator
  "IsPathSeparator reports whether c is a directory separator character.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isPathSeparator(c)"}
  [c])

JOKER FUNC os.IsPermission has:
(defn ^Bool IsPermission
  "IsPermission returns a boolean indicating whether the error is known to\nreport that permission is denied. It is satisfied by ErrPermission as well\nas some syscall errors.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isPermission(err)"}
  [err])

JOKER FUNC os.IsTimeout has:
(defn ^Bool IsTimeout
  "IsTimeout returns a boolean indicating whether the error is known\nto report that a timeout occurred.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isTimeout(err)"}
  [err])

JOKER FUNC os.Lchown has:
(defn ^Error Lchown
  "Lchown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link itself.\nIf there is an error, it will be of type *PathError.\n\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped\nin *PathError.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "lchown(name, uid, gid)"}
  [^String name, ^Int uid, ^Int gid])

JOKER FUNC os.Link has:
(defn ^Error Link
  "Link creates newname as a hard link to the oldname file.\nIf there is an error, it will be of type *LinkError.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "link(oldname, newname)"}
  [^String oldname, ^String newname])

JOKER FUNC os.LookupEnv has:
;; (defn LookupEnv
;;   "LookupEnv retrieves the value of the environment variable named\nby the key. If the variable is present in the environment the\nvalue (which may be empty) is returned and the boolean is true.\nOtherwise the returned value will be empty and the boolean will\nbe false.\nGo return type: (string, bool)\nJoker return type: [String Bool]"
;;   {:added "1.0"
;;    :go "lookupEnv(key)"}
;;   [^String key])

JOKER FUNC os.Lstat has:
;; (defn Lstat
;;   "Lstat returns a FileInfo describing the named file.\nIf the file is a symbolic link, the returned FileInfo\ndescribes the symbolic link. Lstat makes no attempt to follow the link.\nIf there is an error, it will be of type *PathError.\nGo return type: (FileInfo, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/os/types.go:21:15) Error]"
;;   {:added "1.0"
;;    :go "lstat(name)"}
;;   [^String name])

JOKER FUNC os.Mkdir has:
(defn ^Error Mkdir
  "Mkdir creates a new directory with the specified name and permission\nbits (before umask).\nIf there is an error, it will be of type *PathError.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "mkdir(name, perm)"}
  [^String name, perm])

JOKER FUNC os.MkdirAll has:
(defn ^Error MkdirAll
  "MkdirAll creates a directory named path,\nalong with any necessary parents, and returns nil,\nor else returns an error.\nThe permission bits perm (before umask) are used for all\ndirectories that MkdirAll creates.\nIf path is already a directory, MkdirAll does nothing\nand returns nil.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "mkdirAll(path, perm)"}
  [^String path, perm])

JOKER FUNC os.NewFile has:
;; (defn NewFile
;;   "NewFile returns a new File with the given file descriptor and\nname. The returned value will be nil if fd is not a valid file\ndescriptor. On Unix systems, if the file descriptor is in\nnon-blocking mode, NewFile will attempt to return a pollable File\n(one for which the SetDeadline methods work).\nGo return type: *File\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newFile(fd, name)"}
;;   [fd, ^String name])

JOKER FUNC os.NewSyscallError has:
(defn ^Error NewSyscallError
  "NewSyscallError returns, as an error, a new SyscallError\nwith the given system call name and error details.\nAs a convenience, if err is nil, NewSyscallError returns nil.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "newSyscallError(syscall, err)"}
  [^String syscall, err])

JOKER FUNC os.Open has:
;; (defn Open
;;   "Open opens the named file for reading. If successful, methods on\nthe returned file can be used for reading; the associated file\ndescriptor has mode O_RDONLY.\nIf there is an error, it will be of type *PathError.\nGo return type: (*File, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC os.OpenFile has:
;; (defn OpenFile
;;   "OpenFile is the generalized open call; most users will use Open\nor Create instead. It opens the named file with specified flag\n(O_RDONLY etc.) and perm (before umask), if applicable. If successful,\nmethods on the returned File can be used for I/O.\nIf there is an error, it will be of type *PathError.\nGo return type: (*File, error)\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "openFile(name, flag, perm)"}
;;   [^String name, ^Int flag, perm])

JOKER FUNC os.Pipe has:
;; (defn Pipe
;;   "Pipe returns a connected pair of Files; reads from r return bytes written to w.\nIt returns the files and an error, if any.\nGo return type: (r *File, w *File, err error)\nJoker return type: [^{} r ^{} w ^Error err]"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC os.Readlink has:
;; (defn Readlink
;;   "Readlink returns the destination of the named symbolic link.\nIf there is an error, it will be of type *PathError.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "readlink(name)"}
;;   [^String name])

JOKER FUNC os.Remove has:
(defn ^Error Remove
  "Remove removes the named file or (empty) directory.\nIf there is an error, it will be of type *PathError.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "remove(name)"}
  [^String name])

JOKER FUNC os.RemoveAll has:
(defn ^Error RemoveAll
  "RemoveAll removes path and any children it contains.\nIt removes everything it can but returns the first error\nit encounters. If the path does not exist, RemoveAll\nreturns nil (no error).\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "removeAll(path)"}
  [^String path])

JOKER FUNC os.Rename has:
(defn ^Error Rename
  "Rename renames (moves) oldpath to newpath.\nIf newpath already exists and is not a directory, Rename replaces it.\nOS-specific restrictions may apply when oldpath and newpath are in different directories.\nIf there is an error, it will be of type *LinkError.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "rename(oldpath, newpath)"}
  [^String oldpath, ^String newpath])

JOKER FUNC os.SameFile has:
(defn ^Bool SameFile
  "SameFile reports whether fi1 and fi2 describe the same file.\nFor example, on Unix this means that the device and inode fields\nof the two underlying structures are identical; on other systems\nthe decision may be based on the path names.\nSameFile only applies to results returned by this package's Stat.\nIt returns false in other cases.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "sameFile(fi1, fi2)"}
  [fi1, fi2])

JOKER FUNC os.Setenv has:
(defn ^Error Setenv
  "Setenv sets the value of the environment variable named by the key.\nIt returns an error, if any.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "setenv(key, value)"}
  [^String key, ^String value])

JOKER FUNC os.StartProcess has:
;; (defn StartProcess
;;   "StartProcess starts a new process with the program, arguments and attributes\nspecified by name, argv and attr. The argv slice will become os.Args in the\nnew process, so it normally starts with the program name.\n\nIf the calling goroutine has locked the operating system thread\nwith runtime.LockOSThread and modified any inheritable OS-level\nthread state (for example, Linux or Plan 9 name spaces), the new\nprocess will inherit the caller's thread state.\n\nStartProcess is a low-level interface. The os/exec package provides\nhigher-level interfaces.\n\nIf there is an error, it will be of type *PathError.\nGo return type: (*Process, error)\nJoker return type: [{:Pid ^Int, :handle ^ABEND042(cannot find typename os.uintptr), :isdone ^Int, :sigMu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec.go:21:9)} Error]"
;;   {:added "1.0"
;;    :go "startProcess(name, argv, attr)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec.go:100:37) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/os/exec.go:100:52) attr])

JOKER FUNC os.Stat has:
;; (defn Stat
;;   "Stat returns a FileInfo describing the named file.\nIf there is an error, it will be of type *PathError.\nGo return type: (FileInfo, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/os/types.go:21:15) Error]"
;;   {:added "1.0"
;;    :go "stat(name)"}
;;   [^String name])

JOKER FUNC os.Symlink has:
(defn ^Error Symlink
  "Symlink creates newname as a symbolic link to oldname.\nIf there is an error, it will be of type *LinkError.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "symlink(oldname, newname)"}
  [^String oldname, ^String newname])

JOKER FUNC os.TempDir has:
(defn ^String TempDir
  "TempDir returns the default directory to use for temporary files.\n\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp.\nOn Windows, it uses GetTempPath, returning the first non-empty\nvalue from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.\nOn Plan 9, it returns /tmp.\n\nThe directory is neither guaranteed to exist nor have accessible\npermissions.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "tempDir()"}
  [])

JOKER FUNC os.Truncate has:
(defn ^Error Truncate
  "Truncate changes the size of the named file.\nIf the file is a symbolic link, it changes the size of the link's target.\nIf there is an error, it will be of type *PathError.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "truncate(name, size)"}
  [^String name, size])

JOKER FUNC os.Unsetenv has:
(defn ^Error Unsetenv
  "Unsetenv unsets a single environment variable.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "unsetenv(key)"}
  [^String key])

JOKER FUNC os.UserCacheDir has:
;; (defn UserCacheDir
;;   "UserCacheDir returns the default root directory to use for user-specific\ncached data. Users should create their own application-specific subdirectory\nwithin this one and use that.\n\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by\nhttps://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html if\nnon-empty, else $HOME/.cache.\nOn Darwin, it returns $HOME/Library/Caches.\nOn Windows, it returns %LocalAppData%.\nOn Plan 9, it returns $home/lib/cache.\n\nIf the location cannot be determined (for example, $HOME is not defined),\nthen it will return an error.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "userCacheDir()"}
;;   [])

JOKER FUNC parse.IsEmptyTree has:
(defn ^Bool IsEmptyTree
  "IsEmptyTree reports whether this tree (node) is empty of everything but space.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isEmptyTree(n)"}
  [n])

JOKER FUNC parse.New has:
;; (defn New
;;   "New allocates a new parse tree with the given name.\nGo return type: *Tree\nJoker return type: {:Name ^String, :ParseName ^String, :Root ^{:tr ^ABEND947(recursive type reference involving parse.Tree), :Nodes ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/text/template/parse/node.go:21:11))}, :text ^String, :funcs ^(vector-of ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/text/template/parse/parse.go:26:14)), :lex ^ABEND042(cannot find typename parse.lexer), :token ^(vector-of ABEND042(cannot find typename parse.item)), :peekCount ^Int, :vars ^(vector-of String), :treeSet ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/text/template/parse/parse.go:31:12)}"
;;   {:added "1.0"
;;    :go "new(name, funcs)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/text/template/parse/parse.go:125:29) funcs])

JOKER FUNC parse.NewIdentifier has:
;; (defn NewIdentifier
;;   "NewIdentifier returns a new IdentifierNode with the given identifier name.\nGo return type: *IdentifierNode\nJoker return type: {:tr ^{:Name ^String, :ParseName ^String, :Root ^{:tr ^ABEND947(recursive type reference involving parse.Tree), :Nodes ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/text/template/parse/node.go:21:11))}, :text ^String, :funcs ^(vector-of ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/text/template/parse/parse.go:26:14)), :lex ^ABEND042(cannot find typename parse.lexer), :token ^(vector-of ABEND042(cannot find typename parse.item)), :peekCount ^Int, :vars ^(vector-of String), :treeSet ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/text/template/parse/parse.go:31:12)}, :Ident ^String}"
;;   {:added "1.0"
;;    :go "newIdentifier(ident)"}
;;   [^String ident])

JOKER FUNC parse.Parse has:
;; (defn Parse
;;   "Parse returns a map from template name to parse.Tree, created by parsing the\ntemplates described in the argument string. The top-level template will be\ngiven the specified name. If an error is encountered, parsing stops and an\nempty map is returned with the error.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/text/template/parse/parse.go:51:88) Error]"
;;   {:added "1.0"
;;    :go "parse(name, text, leftDelim, rightDelim, funcs)"}
;;   [^String name, ^String text, ^String leftDelim, ^String rightDelim, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/text/template/parse/parse.go:51:60) funcs])

JOKER FUNC parser.ParseDir has:
;; (defn ParseDir
;;   "ParseDir calls ParseFile for all files with names ending in \".go\" in the\ndirectory specified by path and returns a map of package name -> package\nAST with all the packages found.\n\nIf filter != nil, only the files with os.FileInfo entries passing through\nthe filter (and ending in \".go\") are considered. The mode bits are passed\nto ParseFile unchanged. Position information is recorded in fset, which\nmust not be nil.\n\nIf the directory couldn't be read, a nil map and the respective error are\nreturned. If a parse error occurred, a non-nil but incomplete map and the\nfirst error encountered are returned.\nGo return type: (pkgs, first error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/parser/interface.go:135:97) pkgs ^Error first]"
;;   {:added "1.0"
;;    :go "parseDir(fset, path, filter, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/parser/interface.go:135:20) fset, ^String path, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/parser/interface.go:135:56) filter, mode])

JOKER FUNC parser.ParseExpr has:
;; (defn ParseExpr
;;   "ParseExpr is a convenience function for obtaining the AST of an expression x.\nThe position information recorded in the AST is undefined. The filename used\nin error messages is the empty string.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/parser/interface.go:230:27) Error]"
;;   {:added "1.0"
;;    :go "parseExpr(x)"}
;;   [^String x])

JOKER FUNC parser.ParseExprFrom has:
;; (defn ParseExprFrom
;;   "ParseExprFrom is a convenience function for parsing an expression.\nThe arguments have the same meaning as for ParseFile, but the source must\nbe a valid Go (type or value) expression. Specifically, fset must not\nbe nil.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/parser/interface.go:176:87) Error]"
;;   {:added "1.0"
;;    :go "parseExprFrom(fset, filename, src, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/parser/interface.go:176:25) fset, ^String filename, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/parser/interface.go:176:62) src, mode])

JOKER FUNC parser.ParseFile has:
;; (defn ParseFile
;;   "ParseFile parses the source code of a single Go source file and returns\nthe corresponding ast.File node. The source code may be provided via\nthe filename of the source file, or via the src parameter.\n\nIf src != nil, ParseFile parses the source from src and the filename is\nonly used when recording position information. The type of the argument\nfor the src parameter must be string, []byte, or io.Reader.\nIf src == nil, ParseFile parses the file specified by filename.\n\nThe mode parameter controls the amount of source text parsed and other\noptional parser functionality. Position information is recorded in the\nfile set fset, which must not be nil.\n\nIf the source couldn't be read, the returned AST is nil and the error\nindicates the specific failure. If the source was read but syntax\nerrors were found, the result is a partial AST (with ast.Bad* nodes\nrepresenting the fragments of erroneous source code). Multiple errors\nare returned via a scanner.ErrorList which is sorted by file position.\nGo return type: (f *, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/parser/interface.go:80:86) f ^Error err]"
;;   {:added "1.0"
;;    :go "parseFile(fset, filename, src, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/parser/interface.go:80:21) fset, ^String filename, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/parser/interface.go:80:58) src, mode])

JOKER FUNC path.Base has:
(defn ^String Base
  "Base returns the last element of path.\nTrailing slashes are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of slashes, Base returns \"/\".\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "base(path)"}
  [^String path])

JOKER FUNC path.Clean has:
(defn ^String Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple slashes with a single slash.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path.\n\nThe returned path ends in a slash only if it is the root \"/\".\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "clean(path)"}
  [^String path])

JOKER FUNC path.Dir has:
(defn ^String Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element using Split, the path is Cleaned and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of slashes followed by non-slash bytes, Dir\nreturns a single slash. In any other case, the returned path does not end in a\nslash.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "dir(path)"}
  [^String path])

JOKER FUNC path.Ext has:
(defn ^String Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final slash-separated element of path;\nit is empty if there is no dot.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "ext(path)"}
  [^String path])

JOKER FUNC path.IsAbs has:
(defn ^Bool IsAbs
  "IsAbs reports whether the path is absolute.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isAbs(path)"}
  [^String path])

JOKER FUNC path.Join has:
;; (defn ^String Join
;;   "Join joins any number of path elements into a single path, adding a\nseparating slash if necessary. The result is Cleaned; in particular,\nall empty strings are ignored.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "join(elem)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/path/path.go:155:16) elem])

JOKER FUNC path.Match has:
;; (defn Match
;;   "Match reports whether name matches the shell pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-/ characters\n\t\t'?'         matches any single non-/ character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\nGo return type: (matched bool, err error)\nJoker return type: [^Bool matched ^Error err]"
;;   {:added "1.0"
;;    :go "match(pattern, name)"}
;;   [^String pattern, ^String name])

JOKER FUNC path.Split has:
;; (defn Split
;;   "Split splits path immediately following the final slash,\nseparating it into a directory and file name component.\nIf there is no slash in path, Split returns an empty dir and\nfile set to path.\nThe returned values have the property that path = dir+file.\nGo return type: (dir string, file string)\nJoker return type: [^String dir ^String file]"
;;   {:added "1.0"
;;    :go "split(path)"}
;;   [^String path])

JOKER FUNC pe.NewFile has:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a PE binary in an underlying reader.\nGo return type: (*File, error)\nJoker return type: [{:OptionalHeader ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/debug/pe/file.go:25:17), :Sections ^(vector-of {:Relocs ^(vector-of {:VirtualAddress ^Int, :SymbolTableIndex ^Int, :Type ^Int}), :sr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/pe/section.go:95:6)}), :Symbols ^(vector-of {:Name ^String, :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND042(cannot find typename pe.uint8)}), :COFFSymbols ^(vector-of {:Name ^(vector-of ABEND042(cannot find typename pe.uint8)), :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND042(cannot find typename pe.uint8), :NumberOfAuxSymbols ^ABEND042(cannot find typename pe.uint8)}), :StringTable ^(vector-of Int), :closer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/pe/file.go:31:9)} Error]"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/pe/file.go:69:16) r])

JOKER FUNC pe.Open has:
;; (defn Open
;;   "Open opens the named file using os.Open and prepares it for use as a PE binary.\nGo return type: (*File, error)\nJoker return type: [{:OptionalHeader ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/debug/pe/file.go:25:17), :Sections ^(vector-of {:Relocs ^(vector-of {:VirtualAddress ^Int, :SymbolTableIndex ^Int, :Type ^Int}), :sr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/pe/section.go:95:6)}), :Symbols ^(vector-of {:Name ^String, :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND042(cannot find typename pe.uint8)}), :COFFSymbols ^(vector-of {:Name ^(vector-of ABEND042(cannot find typename pe.uint8)), :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND042(cannot find typename pe.uint8), :NumberOfAuxSymbols ^ABEND042(cannot find typename pe.uint8)}), :StringTable ^(vector-of Int), :closer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/pe/file.go:31:9)} Error]"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC pem.Decode has:
;; (defn Decode
;;   "Decode will find the next PEM formatted block (certificate, private key\netc) in the input. It returns that block and the remainder of the input. If\nno PEM data is found, p is nil and the whole of the input is returned in\nrest.\nGo return type: (p *Block, rest []int)\nJoker return type: [^{:Type ^String, :Headers ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/pem/pem.go:29:10), :Bytes ^(vector-of Int)} p ^(vector-of Int) rest]"
;;   {:added "1.0"
;;    :go "decode(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/pem/pem.go:78:18) data])

JOKER FUNC pem.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the PEM encoding of b to out.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "encode(out, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/pem/pem.go:256:17) out, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/pem/pem.go:256:30) b])

JOKER FUNC pem.EncodeToMemory has:
;; (defn EncodeToMemory
;;   "EncodeToMemory returns the PEM encoding of b.\n\nIf b has invalid headers and cannot be encoded,\nEncodeToMemory returns nil. If it is important to\nreport details about this error case, use Encode instead.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "encodeToMemory(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/pem/pem.go:326:23) b])

JOKER FUNC plan9obj.NewFile has:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Plan 9 binary in an underlying reader.\nThe Plan 9 binary is expected to start at position 0 in the ReaderAt.\nGo return type: (*File, error)\nJoker return type: [{:Sections ^(vector-of {:sr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/plan9obj/file.go:53:6)}), :closer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/plan9obj/file.go:30:11)} Error]"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/plan9obj/file.go:135:16) r])

JOKER FUNC plan9obj.Open has:
;; (defn Open
;;   "Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.\nGo return type: (*File, error)\nJoker return type: [{:Sections ^(vector-of {:sr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/plan9obj/file.go:53:6)}), :closer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/plan9obj/file.go:30:11)} Error]"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC plugin.Open has:
;; (defn Open
;;   "Open opens a Go plugin.\nIf a path has already been opened, then the existing *Plugin is returned.\nIt is safe for concurrent use by multiple goroutines.\nGo return type: (*Plugin, error)\nJoker return type: [{:pluginpath ^String, :err ^String, :loaded ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/plugin/plugin.go:24:13), :syms ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/plugin/plugin.go:25:13)} Error]"
;;   {:added "1.0"
;;    :go "open(path)"}
;;   [^String path])

JOKER FUNC png.Decode has:
;; (defn Decode
;;   "Decode reads a PNG image from r and returns it as an image.Image.\nThe type of Image returned depends on the PNG contents.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/reader.go:952:27) Error]"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/reader.go:952:15) r])

JOKER FUNC png.DecodeConfig has:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a PNG image without\ndecoding the entire image.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/reader.go:976:33) Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/reader.go:976:21) r])

JOKER FUNC png.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in PNG format. Any Image may be\nencoded, but images that are not image.NRGBA might be encoded lossily.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "encode(w, m)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/writer.go:523:15) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/writer.go:523:28) m])

JOKER FUNC poly1305.Sum has:
;; (defn Sum
;;   "Sum generates an authenticator for m using a one-time key and puts the\n16-byte result into out. Authenticating two different messages with the same\nkey allows an attacker to forge messages at will.\n"
;;   {:added "1.0"
;;    :go "sum(out, m, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:14) out, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:27) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:39) key])

JOKER FUNC poly1305.Verify has:
;; (defn ^Bool Verify
;;   "Verify returns true if mac is a valid authenticator for m with the given\nkey.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "verify(mac, m, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/poly1305.go:29:17) mac, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/poly1305.go:29:30) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/poly1305.go:29:42) key])

JOKER FUNC pprof.Cmdline has:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n"
;;   {:added "1.0"
;;    :go "cmdline(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:83:16) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:83:39) r])

JOKER FUNC pprof.Do has:
;; (defn Do
;;   "Do calls f with a copy of the parent context with the\ngiven labels added to the parent's label map.\nEach key/value pair in labels is inserted into the label map in the\norder provided, overriding any previous value for the same key.\nThe augmented label map will be set for the duration of the call to f\nand restored once f returns.\n"
;;   {:added "1.0"
;;    :go "do(ctx, labels, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/runtime.go:31:13) ctx, labels, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/runtime.go:31:49) f])

JOKER FUNC pprof.ForLabels has:
;; (defn ForLabels
;;   "ForLabels invokes f with each label set on the context.\nThe function f should return true to continue iteration or false to stop iteration early.\n"
;;   {:added "1.0"
;;    :go "forLabels(ctx, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:78:20) ctx, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/label.go:78:39) f])

JOKER FUNC pprof.Handler has:
;; (defn Handler
;;   "Handler returns an HTTP handler that serves the named profile.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:221:27)"
;;   {:added "1.0"
;;    :go "handler(name)"}
;;   [^String name])

JOKER FUNC pprof.Index has:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n"
;;   {:added "1.0"
;;    :go "index(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:264:14) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:264:37) r])

JOKER FUNC pprof.Label has:
;; (defn Label
;;   "Label returns the value of the label with the given key on ctx, and a boolean indicating\nwhether that label exists.\nGo return type: (string, bool)\nJoker return type: [String Bool]"
;;   {:added "1.0"
;;    :go "label(ctx, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:70:16) ctx, ^String key])

JOKER FUNC pprof.Labels has:
;; (defn Labels
;;   "Labels takes an even number of strings representing key-value pairs\nand makes a LabelSet containing them.\nA label overwrites a prior label with the same key.\nGo return type: LabelSet\nJoker return type: {:list ^(vector-of ABEND042(cannot find typename pprof.label))}"
;;   {:added "1.0"
;;    :go "labels(args)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/runtime/pprof/label.go:57:18) args])

JOKER FUNC pprof.Lookup has:
;; (defn Lookup
;;   "Lookup returns the profile with the given name, or nil if no such profile exists.\nGo return type: *Profile\nJoker return type: {:name ^String, :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/pprof.go:134:8), :m ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/runtime/pprof/pprof.go:135:8), :count ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:136:8), :write ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:137:8)}"
;;   {:added "1.0"
;;    :go "lookup(name)"}
;;   [^String name])

JOKER FUNC pprof.NewProfile has:
;; (defn NewProfile
;;   "NewProfile creates a new profile with the given name.\nIf a profile with that name already exists, NewProfile panics.\nThe convention is to use a 'import/path.' prefix to create\nseparate name spaces for each package.\nFor compatibility with various tools that read pprof data,\nprofile names should not contain spaces.\nGo return type: *Profile\nJoker return type: {:name ^String, :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/pprof.go:134:8), :m ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/runtime/pprof/pprof.go:135:8), :count ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:136:8), :write ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:137:8)}"
;;   {:added "1.0"
;;    :go "newProfile(name)"}
;;   [^String name])

JOKER FUNC pprof.Profile has:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n"
;;   {:added "1.0"
;;    :go "profile(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:116:16) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:116:39) r])

JOKER FUNC pprof.Profiles has:
;; (defn Profiles
;;   "Profiles returns a slice of all the known profiles, sorted by name.\nGo return type: []*Profile\nJoker return type: (vector-of {:name ^String, :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/pprof.go:134:8), :m ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/runtime/pprof/pprof.go:135:8), :count ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:136:8), :write ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:137:8)})"
;;   {:added "1.0"
;;    :go "profiles()"}
;;   [])

JOKER FUNC pprof.SetGoroutineLabels has:
;; (defn SetGoroutineLabels
;;   "SetGoroutineLabels sets the current goroutine's labels to match ctx.\nThis is a lower-level API than Do, which should be used instead when possible.\n"
;;   {:added "1.0"
;;    :go "setGoroutineLabels(ctx)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/runtime.go:20:29) ctx])

JOKER FUNC pprof.StartCPUProfile has:
;; (defn ^Error StartCPUProfile
;;   "StartCPUProfile enables CPU profiling for the current process.\nWhile profiling, the profile will be buffered and written to w.\nStartCPUProfile returns an error if profiling is already enabled.\n\nOn Unix-like systems, StartCPUProfile does not work by default for\nGo code built with -buildmode=c-archive or -buildmode=c-shared.\nStartCPUProfile relies on the SIGPROF signal, but that signal will\nbe delivered to the main program's SIGPROF signal handler (if any)\nnot to the one used by Go. To make it work, call os/signal.Notify\nfor syscall.SIGPROF, but note that doing so may break any profiling\nbeing done by the main program.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "startCPUProfile(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/pprof.go:740:24) w])

JOKER FUNC pprof.StopCPUProfile has:
;; (defn StopCPUProfile
;;   "StopCPUProfile stops the current CPU profile, if any.\nStopCPUProfile only returns after all the writes for the\nprofile have completed.\n"
;;   {:added "1.0"
;;    :go "stopCPUProfile()"}
;;   [])

JOKER FUNC pprof.Symbol has:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n"
;;   {:added "1.0"
;;    :go "symbol(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:174:15) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:174:38) r])

JOKER FUNC pprof.Trace has:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n"
;;   {:added "1.0"
;;    :go "trace(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:145:14) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:145:37) r])

JOKER FUNC pprof.WithLabels has:
;; (defn WithLabels
;;   "WithLabels returns a new context.Context with the given labels added.\nA label overwrites a prior label with the same key.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:39:55)"
;;   {:added "1.0"
;;    :go "withLabels(ctx, labels)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:39:21) ctx, labels])

JOKER FUNC pprof.WriteHeapProfile has:
;; (defn ^Error WriteHeapProfile
;;   "WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0).\nIt is preserved for backwards compatibility.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "writeHeapProfile(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/pprof.go:520:25) w])

JOKER FUNC printer.Fprint has:
;; (defn ^Error Fprint
;;   "Fprint \"pretty-prints\" an AST node to output.\nIt calls Config.Fprint with default settings.\nNote that gofmt uses tabs for indentation but spaces for alignment;\nuse format.Node (package go/format) for output that matches gofmt.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fprint(output, fset, node)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/printer/printer.go:1359:20) output, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/printer/printer.go:1359:36) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/printer/printer.go:1359:57) node])

JOKER FUNC quick.Check has:
;; (defn ^Error Check
;;   "Check looks for an input to f, any function that returns bool,\nsuch that f returns false. It calls f repeatedly, with arbitrary\nvalues for each argument. If f returns false on a given input,\nCheck returns that input as a *CheckError.\nFor example:\n\n\tfunc TestOddMultipleOfThree(t *testing.T) {\n\t\tf := func(x int) bool {\n\t\t\ty := OddMultipleOfThree(x)\n\t\t\treturn y%2 == 1 && y%3 == 0\n\t\t}\n\t\tif err := quick.Check(f, nil); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "check(f, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/testing/quick/quick.go:262:14) f, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/testing/quick/quick.go:262:34) config])

JOKER FUNC quick.CheckEqual has:
;; (defn ^Error CheckEqual
;;   "CheckEqual looks for an input on which f and g return different results.\nIt calls f and g repeatedly with arbitrary values for each argument.\nIf f and g return different answers, CheckEqual returns a *CheckEqualError\ndescribing the input and the outputs.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "checkEqual(f, g, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/testing/quick/quick.go:301:22) f, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/testing/quick/quick.go:301:22) g, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/testing/quick/quick.go:301:42) config])

JOKER FUNC quick.Value has:
;; (defn Value
;;   "Value returns an arbitrary value of the given type.\nIf the type implements the Generator interface, that will be used.\nNote: To create arbitrary values for structs, all the fields must be exported.\nGo return type: (value, ok bool)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/quick/quick.go:59:52) value ^Bool ok]"
;;   {:added "1.0"
;;    :go "value(t, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/quick/quick.go:59:14) t, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/testing/quick/quick.go:59:33) rand])

JOKER FUNC quotedprintable.NewReader has:
;; (defn NewReader
;;   "NewReader returns a quoted-printable reader, decoding from r.\nGo return type: *Reader\nJoker return type: {:br ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/quotedprintable/reader.go:18:8), :rerr ^Error, :line ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/quotedprintable/reader.go:24:18) r])

JOKER FUNC quotedprintable.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\nGo return type: *Writer\nJoker return type: {:Binary ^Bool, :w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/quotedprintable/writer.go:17:7), :i ^Int, :line ^(vector-of Int), :cr ^Bool}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/quotedprintable/writer.go:24:18) w])

JOKER FUNC rand.ExpFloat64 has:
;; (defn ExpFloat64
;;   "ExpFloat64 returns an exponentially distributed float64 in the range\n(0, +math.MaxFloat64] with an exponential distribution whose rate parameter\n(lambda) is 1 and whose mean is 1/lambda (1) from the default Source.\nTo produce a distribution with a different rate parameter,\ncallers can adjust the output using:\n\n sample = ExpFloat64() / desiredRateParameter\nGo return type: float64\nJoker return type: ABEND042(cannot find typename rand.float64)"
;;   {:added "1.0"
;;    :go "expFloat64()"}
;;   [])

JOKER FUNC rand.Float32 has:
;; (defn Float32
;;   "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\nGo return type: float32\nJoker return type: ABEND042(cannot find typename rand.float32)"
;;   {:added "1.0"
;;    :go "float32()"}
;;   [])

JOKER FUNC rand.Float64 has:
;; (defn Float64
;;   "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename rand.float64)"
;;   {:added "1.0"
;;    :go "float64()"}
;;   [])

JOKER FUNC rand.Int31 has:
(defn ^Int Int31
  "Int31 returns a non-negative pseudo-random 31-bit integer as an int32\nfrom the default Source.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "int31()"}
  [])

JOKER FUNC rand.Int31n has:
(defn ^Int Int31n
  "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "int31n(n)"}
  [n])

JOKER FUNC rand.Int63 has:
(defn ^Int Int63
  "Int63 returns a non-negative pseudo-random 63-bit integer as an int64\nfrom the default Source.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "int63()"}
  [])

JOKER FUNC rand.Int63n has:
(defn ^Int Int63n
  "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "int63n(n)"}
  [n])

JOKER FUNC rand.Intn has:
(defn ^Int Intn
  "Intn returns, as an int, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "intn(n)"}
  [^Int n])

JOKER FUNC rand.New has:
;; (defn New
;;   "New returns a new Rand that uses random values from src\nto generate other random values.\nGo return type: *Rand\nJoker return type: {:src ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/math/rand/rand.go:25:13), :s64 ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/math/rand/rand.go:36:15), :readVal ^Int, :readPos ^ABEND042(cannot find typename rand.int8)}"
;;   {:added "1.0"
;;    :go "new(src)"}
;;   [src])

JOKER FUNC rand.NewSource has:
;; (defn NewSource
;;   "NewSource returns a new pseudo-random Source seeded with the given value.\nUnlike the default Source used by top-level functions, this source is not\nsafe for concurrent use by multiple goroutines.\nGo return type: Source\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/math/rand/rand.go:25:13)"
;;   {:added "1.0"
;;    :go "newSource(seed)"}
;;   [seed])

JOKER FUNC rand.NewZipf has:
;; (defn NewZipf
;;   "NewZipf returns a Zipf variate generator.\nThe generator generates values k ∈ [0, imax]\nsuch that P(k) is proportional to (v + k) ** (-s).\nRequirements: s > 1 and v >= 1.\nGo return type: *Zipf\nJoker return type: {:r ^{:src ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/math/rand/rand.go:25:13), :s64 ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/math/rand/rand.go:36:15), :readVal ^Int, :readPos ^ABEND042(cannot find typename rand.int8)}, :imax ^ABEND042(cannot find typename rand.float64), :v ^ABEND042(cannot find typename rand.float64), :q ^ABEND042(cannot find typename rand.float64), :s ^ABEND042(cannot find typename rand.float64), :oneminusQ ^ABEND042(cannot find typename rand.float64), :oneminusQinv ^ABEND042(cannot find typename rand.float64), :hxm ^ABEND042(cannot find typename rand.float64), :hx0minusHxm ^ABEND042(cannot find typename rand.float64)}"
;;   {:added "1.0"
;;    :go "newZipf(r, s, v, imax)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/math/rand/zipf.go:39:16) r, s, v, imax])

JOKER FUNC rand.NormFloat64 has:
;; (defn NormFloat64
;;   "NormFloat64 returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with\nstandard normal distribution (mean = 0, stddev = 1)\nfrom the default Source.\nTo produce a different normal distribution, callers can\nadjust the output using:\n\n sample = NormFloat64() * desiredStdDev + desiredMean\nGo return type: float64\nJoker return type: ABEND042(cannot find typename rand.float64)"
;;   {:added "1.0"
;;    :go "normFloat64()"}
;;   [])

JOKER FUNC rand.Perm has:
;; (defn Perm
;;   "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n)\nfrom the default Source.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "perm(n)"}
;;   [^Int n])

JOKER FUNC rand.Prime has:
;; (defn Prime
;;   "Prime returns a number, p, of the given size, such that p is prime\nwith high probability.\nPrime will return error for any error returned by rand.Read or if bits < 2.\nGo return type: (p *, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rand/util.go:31:42) p ^Error err]"
;;   {:added "1.0"
;;    :go "prime(rand, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rand/util.go:31:17) rand, ^Int bits])

JOKER FUNC rand.Seed has:
;; (defn Seed
;;   "Seed uses the provided seed value to initialize the default Source to a\ndeterministic state. If Seed is not called, the generator behaves as\nif seeded by Seed(1). Seed values that have the same remainder when\ndivided by 2^31-1 generate the same pseudo-random sequence.\nSeed, unlike the Rand.Seed method, is safe for concurrent use.\n"
;;   {:added "1.0"
;;    :go "seed(seed)"}
;;   [seed])

JOKER FUNC rand.Shuffle has:
;; (defn Shuffle
;;   "Shuffle pseudo-randomizes the order of elements using the default Source.\nn is the number of elements. Shuffle panics if n < 0.\nswap swaps the elements with indexes i and j.\n"
;;   {:added "1.0"
;;    :go "shuffle(n, swap)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/math/rand/rand.go:346:26) swap])

JOKER FUNC rand.Uint32 has:
(defn ^Int Uint32
  "Uint32 returns a pseudo-random 32-bit value as a uint32\nfrom the default Source.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "uint32()"}
  [])

JOKER FUNC rand.Uint64 has:
;; (defn Uint64
;;   "Uint64 returns a pseudo-random 64-bit value as a uint64\nfrom the default Source.\nGo return type: uint64\nJoker return type: ABEND042(cannot find typename rand.uint64)"
;;   {:added "1.0"
;;    :go "uint64()"}
;;   [])

JOKER FUNC rc4.NewCipher has:
;; (defn NewCipher
;;   "NewCipher creates and returns a new Cipher. The key argument should be the\nRC4 key, at least 1 byte and at most 256 bytes.\nGo return type: (*Cipher, error)\nJoker return type: [{:s ^(vector-of Int), :i ^ABEND042(cannot find typename rc4.uint8), :j ^ABEND042(cannot find typename rc4.uint8)} Error]"
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rc4/rc4.go:31:20) key])

JOKER FUNC reflect.Append has:
;; (defn Append
;;   "Append appends the values x to a slice s and returns the resulting slice.\nAs in Go, each x's value must be assignable to the slice's element type.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "append(s, x)"}
;;   [s, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/reflect/value.go:1890:24) x])

JOKER FUNC reflect.AppendSlice has:
;; (defn AppendSlice
;;   "AppendSlice appends a slice t to a slice s and returns the resulting slice.\nThe slices s and t must have the same element type.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "appendSlice(s, t)"}
;;   [s, t])

JOKER FUNC reflect.ArrayOf has:
;; (defn ArrayOf
;;   "ArrayOf returns the array type with the given count and element type.\nFor example, if t represents int, ArrayOf(5, t) represents [5]int.\n\nIf the resulting type would be larger than the available address space,\nArrayOf panics.\nGo return type: Type\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "arrayOf(count, elem)"}
;;   [^Int count, elem])

JOKER FUNC reflect.ChanOf has:
;; (defn ChanOf
;;   "ChanOf returns the channel type with the given direction and element type.\nFor example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.\n\nThe gc runtime imposes a limit of 64 kB on channel element types.\nIf t's size is equal to or exceeds this limit, ChanOf panics.\nGo return type: Type\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "chanOf(dir, t)"}
;;   [dir, t])

JOKER FUNC reflect.Copy has:
(defn ^Int Copy
  "Copy copies the contents of src into dst until either\ndst has been filled or src has been exhausted.\nIt returns the number of elements copied.\nDst and src each must have kind Slice or Array, and\ndst and src must have the same element type.\n\nAs a special case, src can have kind String if the element type of dst is kind Uint8.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "copy(dst, src)"}
  [dst, src])

JOKER FUNC reflect.DeepEqual has:
;; (defn ^Bool DeepEqual
;;   "DeepEqual reports whether x and y are ``deeply equal,'' defined as follows.\nTwo values of identical type are deeply equal if one of the following cases applies.\nValues of distinct types are never deeply equal.\n\nArray values are deeply equal when their corresponding elements are deeply equal.\n\nStruct values are deeply equal if their corresponding fields,\nboth exported and unexported, are deeply equal.\n\nFunc values are deeply equal if both are nil; otherwise they are not deeply equal.\n\nInterface values are deeply equal if they hold deeply equal concrete values.\n\nMap values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they are the same map object or their corresponding keys\n(matched using Go equality) map to deeply equal values.\n\nPointer values are deeply equal if they are equal using Go's == operator\nor if they point to deeply equal values.\n\nSlice values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they point to the same initial entry of the same underlying array\n(that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.\nNote that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))\nare not deeply equal.\n\nOther values - numbers, bools, strings, and channels - are deeply equal\nif they are equal using Go's == operator.\n\nIn general DeepEqual is a recursive relaxation of Go's == operator.\nHowever, this idea is impossible to implement without some inconsistency.\nSpecifically, it is possible for a value to be unequal to itself,\neither because it is of func type (uncomparable in general)\nor because it is a floating-point NaN value (not equal to itself in floating-point comparison),\nor because it is an array, struct, or interface containing\nsuch a value.\nOn the other hand, pointer values are always equal to themselves,\neven if they point at or contain such problematic values,\nbecause they compare equal using Go's == operator, and that\nis a sufficient condition to be deeply equal, regardless of content.\nDeepEqual has been defined so that the same short-cut applies\nto slices and maps: if x and y are the same slice or the same map,\nthey are deeply equal regardless of content.\n\nAs DeepEqual traverses the data values it may find a cycle. The\nsecond and subsequent times that DeepEqual compares two pointer\nvalues that have been compared before, it treats the values as\nequal rather than examining the values to which they point.\nThis ensures that DeepEqual terminates.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "deepEqual(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/deepequal.go:187:21) x, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/deepequal.go:187:21) y])

JOKER FUNC reflect.FuncOf has:
;; (defn FuncOf
;;   "FuncOf returns the function type with the given argument and result types.\nFor example if k represents int and e represents string,\nFuncOf([]Type{k}, []Type{e}, false) represents func(int) string.\n\nThe variadic argument controls whether the function is variadic. FuncOf\npanics if the in[len(in)-1] does not represent a slice and variadic is\ntrue.\nGo return type: Type\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "funcOf(in, out, variadic)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/type.go:1924:21) in, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/type.go:1924:21) out, variadic])

JOKER FUNC reflect.Indirect has:
;; (defn Indirect
;;   "Indirect returns the value that v points to.\nIf v is a nil pointer, Indirect returns a zero Value.\nIf v is not a pointer, Indirect returns v.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "indirect(v)"}
;;   [v])

JOKER FUNC reflect.MakeChan has:
;; (defn MakeChan
;;   "MakeChan creates a new channel with the specified type and buffer size.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "makeChan(typ, buffer)"}
;;   [typ, ^Int buffer])

JOKER FUNC reflect.MakeFunc has:
;; (defn MakeFunc
;;   "MakeFunc returns a new function of the given Type\nthat wraps the function fn. When called, that new function\ndoes the following:\n\n\t- converts its arguments to a slice of Values.\n\t- runs results := fn(args).\n\t- returns the results as a slice of Values, one per formal result.\n\nThe implementation fn can assume that the argument Value slice\nhas the number and type of arguments given by typ.\nIf typ describes a variadic function, the final Value is itself\na slice representing the variadic arguments, as in the\nbody of a variadic function. The result Value slice returned by fn\nmust have the number and type of results given by typ.\n\nThe Value.Call method allows the caller to invoke a typed function\nin terms of Values; in contrast, MakeFunc allows the caller to implement\na typed function in terms of Values.\n\nThe Examples section of the documentation includes an illustration\nof how to use MakeFunc to build a swap function for different types.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "makeFunc(typ, fn)"}
;;   [typ, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/reflect/makefunc.go:48:28) fn])

JOKER FUNC reflect.MakeMap has:
;; (defn MakeMap
;;   "MakeMap creates a new map with the specified type.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "makeMap(typ)"}
;;   [typ])

JOKER FUNC reflect.MakeMapWithSize has:
;; (defn MakeMapWithSize
;;   "MakeMapWithSize creates a new map with the specified type\nand initial space for approximately n elements.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "makeMapWithSize(typ, n)"}
;;   [typ, ^Int n])

JOKER FUNC reflect.MakeSlice has:
;; (defn MakeSlice
;;   "MakeSlice creates a new zero-initialized slice value\nfor the specified slice type, length, and capacity.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "makeSlice(typ, len, cap)"}
;;   [typ, ^Int len, ^Int cap])

JOKER FUNC reflect.MapOf has:
;; (defn MapOf
;;   "MapOf returns the map type with the given key and element types.\nFor example, if k represents int and e represents string,\nMapOf(k, e) represents map[int]string.\n\nIf the key type is not a valid map key type (that is, if it does\nnot implement Go's == operator), MapOf panics.\nGo return type: Type\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "mapOf(key, elem)"}
;;   [key, elem])

JOKER FUNC reflect.New has:
;; (defn New
;;   "New returns a Value representing a pointer to a new zero value\nfor the specified type. That is, the returned Value's Type is PtrTo(typ).\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "new(typ)"}
;;   [typ])

JOKER FUNC reflect.NewAt has:
;; (defn NewAt
;;   "NewAt returns a Value representing a pointer to a value of the\nspecified type, using p as that pointer.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "newAt(typ, p)"}
;;   [typ, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:2227:24) p])

JOKER FUNC reflect.PtrTo has:
;; (defn PtrTo
;;   "PtrTo returns the pointer type with element t.\nFor example, if t represents type Foo, PtrTo(t) represents *Foo.\nGo return type: Type\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "ptrTo(t)"}
;;   [t])

JOKER FUNC reflect.Select has:
;; (defn Select
;;   "Select executes a select operation described by the list of cases.\nLike the Go select statement, it blocks until at least one of the cases\ncan proceed, makes a uniform pseudo-random choice,\nand then executes that case. It returns the index of the chosen case\nand, if that case was a receive operation, the value received and a\nboolean indicating whether the value corresponds to a send on the channel\n(as opposed to a zero value received because the channel is closed).\nGo return type: (chosen int, recv Value, recvOK bool)\nJoker return type: [^Int chosen ^{:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)} recv ^Bool recvOK]"
;;   {:added "1.0"
;;    :go "select(cases)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/value.go:2025:19) cases])

JOKER FUNC reflect.SliceOf has:
;; (defn SliceOf
;;   "SliceOf returns the slice type with element type t.\nFor example, if t represents int, SliceOf(t) represents []int.\nGo return type: Type\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "sliceOf(t)"}
;;   [t])

JOKER FUNC reflect.StructOf has:
;; (defn StructOf
;;   "StructOf returns the struct type containing fields.\nThe Offset and Index fields are ignored and computed as they would be\nby the compiler.\n\nStructOf currently does not generate wrapper methods for embedded\nfields and panics if passed unexported StructFields.\nThese limitations may be lifted in a future version.\nGo return type: Type\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "structOf(fields)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/type.go:2349:22) fields])

JOKER FUNC reflect.Swapper has:
;; (defn Swapper
;;   "Swapper returns a function that swaps the elements in the provided\nslice.\n\nSwapper panics if the provided interface is not a slice.\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/reflect/swapper.go:13:33)"
;;   {:added "1.0"
;;    :go "swapper(slice)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/swapper.go:13:20) slice])

JOKER FUNC reflect.TypeOf has:
;; (defn TypeOf
;;   "TypeOf returns the reflection Type that represents the dynamic type of i.\nIf i is a nil interface value, TypeOf returns nil.\nGo return type: Type\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "typeOf(i)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:1376:15) i])

JOKER FUNC reflect.ValueOf has:
;; (defn ValueOf
;;   "ValueOf returns a new Value initialized to the concrete value\nstored in the interface i. ValueOf(nil) returns the zero Value.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "valueOf(i)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/value.go:2182:16) i])

JOKER FUNC reflect.Zero has:
;; (defn Zero
;;   "Zero returns a Value representing the zero value for the specified type.\nThe result is different from the zero value of the Value struct,\nwhich represents no value at all.\nFor example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.\nThe returned value is neither addressable nor settable.\nGo return type: Value\nJoker return type: {:typ ^ABEND042(cannot find typename reflect.rtype), :ptr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6)}"
;;   {:added "1.0"
;;    :go "zero(typ)"}
;;   [typ])

JOKER FUNC regexp.Compile has:
;; (defn Compile
;;   "Compile parses a regular expression and returns, if successful,\na Regexp object that can be used to match against text.\n\nWhen matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses the one that a backtracking search would have found first.\nThis so-called leftmost-first matching is the same semantics\nthat Perl, Python, and other implementations use, although this\npackage implements it without the expense of backtracking.\nFor POSIX leftmost-longest matching, see CompilePOSIX.\nGo return type: (*Regexp, error)\nJoker return type: [{:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:86:10), :machine ^(vector-of ABEND042(cannot find typename regexp.machine))} Error]"
;;   {:added "1.0"
;;    :go "compile(expr)"}
;;   [^String expr])

JOKER FUNC regexp.CompilePOSIX has:
;; (defn CompilePOSIX
;;   "CompilePOSIX is like Compile but restricts the regular expression\nto POSIX ERE (egrep) syntax and changes the match semantics to\nleftmost-longest.\n\nThat is, when matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses a match that is as long as possible.\nThis so-called leftmost-longest matching is the same semantics\nthat early regular expression implementations used and that POSIX\nspecifies.\n\nHowever, there can be multiple leftmost-longest matches, with different\nsubmatch choices, and here this package diverges from POSIX.\nAmong the possible leftmost-longest matches, this package chooses\nthe one that a backtracking search would have found first, while POSIX\nspecifies that the match be chosen to maximize the length of the first\nsubexpression, then the second, and so on from left to right.\nThe POSIX rule is computationally prohibitive and not even well-defined.\nSee https://swtch.com/~rsc/regexp/regexp2.html#posix for details.\nGo return type: (*Regexp, error)\nJoker return type: [{:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:86:10), :machine ^(vector-of ABEND042(cannot find typename regexp.machine))} Error]"
;;   {:added "1.0"
;;    :go "compilePOSIX(expr)"}
;;   [^String expr])

JOKER FUNC regexp.Match has:
;; (defn Match
;;   "MatchString reports whether the byte slice b\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\nGo return type: (matched bool, err error)\nJoker return type: [^Bool matched ^Error err]"
;;   {:added "1.0"
;;    :go "match(pattern, b)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/regexp.go:475:30) b])

JOKER FUNC regexp.MatchReader has:
;; (defn MatchReader
;;   "MatchReader reports whether the text returned by the RuneReader\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\nGo return type: (matched bool, err error)\nJoker return type: [^Bool matched ^Error err]"
;;   {:added "1.0"
;;    :go "matchReader(pattern, r)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:453:36) r])

JOKER FUNC regexp.MatchString has:
;; (defn MatchString
;;   "MatchString reports whether the string s\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\nGo return type: (matched bool, err error)\nJoker return type: [^Bool matched ^Error err]"
;;   {:added "1.0"
;;    :go "matchString(pattern, s)"}
;;   [^String pattern, ^String s])

JOKER FUNC regexp.MustCompile has:
;; (defn MustCompile
;;   "MustCompile is like Compile but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\nGo return type: *Regexp\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:86:10), :machine ^(vector-of ABEND042(cannot find typename regexp.machine))}"
;;   {:added "1.0"
;;    :go "mustCompile(str)"}
;;   [^String str])

JOKER FUNC regexp.MustCompilePOSIX has:
;; (defn MustCompilePOSIX
;;   "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\nGo return type: *Regexp\nJoker return type: {:mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:86:10), :machine ^(vector-of ABEND042(cannot find typename regexp.machine))}"
;;   {:added "1.0"
;;    :go "mustCompilePOSIX(str)"}
;;   [^String str])

JOKER FUNC regexp.QuoteMeta has:
(defn ^String QuoteMeta
  "QuoteMeta returns a string that escapes all regular expression metacharacters\ninside the argument text; the returned string is a regular expression matching\nthe literal text.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "quoteMeta(s)"}
  [^String s])

JOKER FUNC ring.New has:
;; (defn New
;;   "New creates a ring of n elements.\nGo return type: *Ring\nJoker return type: {:next ^ABEND947(recursive type reference involving ring.Ring), :prev ^ABEND947(recursive type reference involving ring.Ring), :Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/ring/ring.go:16:13)}"
;;   {:added "1.0"
;;    :go "new(n)"}
;;   [^Int n])

JOKER FUNC route.FetchRIB has:
;; (defn FetchRIB
;;   "FetchRIB fetches a routing information base from the operating\nsystem.\n\nThe provided af must be an address family.\n\nThe provided arg must be a RIBType-specific argument.\nWhen RIBType is related to routes, arg might be a set of route\nflags. When RIBType is related to network interfaces, arg might be\nan interface index or a set of interface flags. In most cases, zero\nmeans a wildcard.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "fetchRIB(af, typ, arg)"}
;;   [^Int af, typ, ^Int arg])

JOKER FUNC route.ParseRIB has:
;; (defn ParseRIB
;;   "ParseRIB parses b as a routing information base and returns a list\nof routing messages.\nGo return type: ([]Message, error)\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/vendor/golang_org/x/net/route/message.go:10:14)) Error]"
;;   {:added "1.0"
;;    :go "parseRIB(typ, b)"}
;;   [typ, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/route/message.go:33:30) b])

JOKER FUNC rpc.Accept has:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n"
;;   {:added "1.0"
;;    :go "accept(lis)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:692:17) lis])

JOKER FUNC rpc.Dial has:
;; (defn Dial
;;   "Dial connects to an RPC server at the specified network address.\nGo return type: (*Client, error)\nJoker return type: [{:codec ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/rpc/client.go:63:18), :reqMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:44:11), :request ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:47:11), :seq ^ABEND042(cannot find typename rpc.uint64), :pending ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/rpc/client.go:49:11), :closing ^Bool, :shutdown ^Bool} Error]"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC rpc.DialHTTP has:
;; (defn DialHTTP
;;   "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\nGo return type: (*Client, error)\nJoker return type: [{:codec ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/rpc/client.go:63:18), :reqMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:44:11), :request ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:47:11), :seq ^ABEND042(cannot find typename rpc.uint64), :pending ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/rpc/client.go:49:11), :closing ^Bool, :shutdown ^Bool} Error]"
;;   {:added "1.0"
;;    :go "dialHTTP(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC rpc.DialHTTPPath has:
;; (defn DialHTTPPath
;;   "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\nGo return type: (*Client, error)\nJoker return type: [{:codec ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/rpc/client.go:63:18), :reqMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:44:11), :request ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:47:11), :seq ^ABEND042(cannot find typename rpc.uint64), :pending ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/rpc/client.go:49:11), :closing ^Bool, :shutdown ^Bool} Error]"
;;   {:added "1.0"
;;    :go "dialHTTPPath(network, address, path)"}
;;   [^String network, ^String address, ^String path])

JOKER FUNC rpc.HandleHTTP has:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n"
;;   {:added "1.0"
;;    :go "handleHTTP()"}
;;   [])

JOKER FUNC rpc.NewClient has:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\nGo return type: *Client\nJoker return type: {:codec ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/rpc/client.go:63:18), :reqMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:44:11), :request ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:47:11), :seq ^ABEND042(cannot find typename rpc.uint64), :pending ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/rpc/client.go:49:11), :closing ^Bool, :shutdown ^Bool}"
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:193:21) conn])

JOKER FUNC rpc.NewClientWithCodec has:
;; (defn NewClientWithCodec
;;   "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\nGo return type: *Client\nJoker return type: {:codec ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/rpc/client.go:63:18), :reqMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:44:11), :request ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:47:11), :seq ^ABEND042(cannot find typename rpc.uint64), :pending ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/rpc/client.go:49:11), :closing ^Bool, :shutdown ^Bool}"
;;   {:added "1.0"
;;    :go "newClientWithCodec(codec)"}
;;   [codec])

JOKER FUNC rpc.NewServer has:
;; (defn NewServer
;;   "NewServer returns a new Server.\nGo return type: *Server\nJoker return type: {:serviceMap ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:190:13), :reqLock ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:191:13), :freeReq ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :next ^ABEND947(recursive type reference involving rpc.Request)}, :respLock ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:193:13), :freeResp ^{:ServiceMethod ^String, :Seq ^ABEND042(cannot find typename rpc.uint64), :Error ^String, :next ^ABEND947(recursive type reference involving rpc.Response)}}"
;;   {:added "1.0"
;;    :go "newServer()"}
;;   [])

JOKER FUNC rpc.Register has:
;; (defn ^Error Register
;;   "Register publishes the receiver's methods in the DefaultServer.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "register(rcvr)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/rpc/server.go:642:20) rcvr])

JOKER FUNC rpc.RegisterName has:
;; (defn ^Error RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "registerName(name, rcvr)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/rpc/server.go:646:37) rcvr])

JOKER FUNC rpc.ServeCodec has:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n"
;;   {:added "1.0"
;;    :go "serveCodec(codec)"}
;;   [codec])

JOKER FUNC rpc.ServeConn has:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n"
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:673:21) conn])

JOKER FUNC rpc.ServeRequest has:
(defn ^Error ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "serveRequest(codec)"}
  [codec])

JOKER FUNC rsa.DecryptOAEP has:
;; (defn DecryptOAEP
;;   "OAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter, if not nil, is used to blind the private-key operation\nand avoid timing side-channel attacks. Blinding is purely internal to this\nfunction – the random data need not match that used when encrypting.\n\nThe label parameter must match the value given when encrypting. See\nEncryptOAEP for details.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "decryptOAEP(hash, random, priv, ciphertext, label)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:569:23) hash, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:569:41) random, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/rsa.go:569:57) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:569:81) ciphertext, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:569:95) label])

JOKER FUNC rsa.DecryptPKCS1v15 has:
;; (defn DecryptPKCS1v15
;;   "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n\nNote that whether this function returns an error or not discloses secret\ninformation. If an attacker can cause this function to run repeatedly and\nlearn whether each instance returned an error then they can decrypt and\nforge signatures as if they had the private key. See\nDecryptPKCS1v15SessionKey for a way of solving this problem.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "decryptPKCS1v15(rand, priv, ciphertext)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:76:27) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:76:43) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:76:67) ciphertext])

JOKER FUNC rsa.DecryptPKCS1v15SessionKey has:
;; (defn ^Error DecryptPKCS1v15SessionKey
;;   "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\nIt returns an error if the ciphertext is the wrong length or if the\nciphertext is greater than the public modulus. Otherwise, no error is\nreturned. If the padding is valid, the resulting plaintext message is copied\ninto key. Otherwise, key is unchanged. These alternatives occur in constant\ntime. It is intended that the user of this function generate a random\nsession key beforehand and continue the protocol with the resulting value.\nThis will remove any possibility that an attacker can learn any information\nabout the plaintext.\nSee ``Chosen Ciphertext Attacks Against Protocols Based on the RSA\nEncryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n(Crypto '98).\n\nNote that if the session key is too small then it may be possible for an\nattacker to brute-force it. If they can do that then they can learn whether\na random value was used (because it'll be different for the same ciphertext)\nand thus whether the padding was correct. This defeats the point of this\nfunction. Using at least a 16-byte key will protect against this attack.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "decryptPKCS1v15SessionKey(rand, priv, ciphertext, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:109:37) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:109:53) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:109:77) ciphertext, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:109:89) key])

JOKER FUNC rsa.EncryptOAEP has:
;; (defn EncryptOAEP
;;   "EncryptOAEP encrypts the given message with RSA-OAEP.\n\nOAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same ciphertext.\n\nThe label parameter may contain arbitrary data that will not be encrypted,\nbut which gives important context to the message. For example, if a given\npublic key is used to decrypt two types of messages then distinct label\nvalues could be used to ensure that a ciphertext for one purpose cannot be\nused for another by an attacker. If not required it can be empty.\n\nThe message must be no longer than the length of the public modulus minus\ntwice the hash length, minus a further 2.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "encryptOAEP(hash, random, pub, msg, label)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:376:23) hash, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:376:41) random, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/rsa.go:376:56) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:376:72) msg, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:376:86) label])

JOKER FUNC rsa.EncryptPKCS1v15 has:
;; (defn EncryptPKCS1v15
;;   "EncryptPKCS1v15 encrypts the given message with RSA and the padding\nscheme from PKCS#1 v1.5.  The message must be no longer than the\nlength of the public modulus minus 11 bytes.\n\nThe rand parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same\nciphertext.\n\nWARNING: use of this function to encrypt plaintexts other than\nsession keys is dangerous. Use RSA OAEP in new protocols.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "encryptPKCS1v15(rand, pub, msg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:39:27) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:39:42) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:39:58) msg])

JOKER FUNC rsa.GenerateKey has:
;; (defn GenerateKey
;;   "GenerateKey generates an RSA keypair of the given bit size using the\nrandom source random (for example, crypto/rand.Reader).\nGo return type: (*PrivateKey, error)\nJoker return type: [{:D ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:90:13), :Primes ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:91:15)), :Precomputed ^{:Dp ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:150:10), :Dq ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:150:10), :Qinv ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:151:10), :CRTValues ^(vector-of {:Exp ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:162:9), :Coeff ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:163:9), :R ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:164:9)})}} Error]"
;;   {:added "1.0"
;;    :go "generateKey(random, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:207:25) random, ^Int bits])

JOKER FUNC rsa.GenerateMultiPrimeKey has:
;; (defn GenerateMultiPrimeKey
;;   "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\nsize and the given random source, as suggested in [1]. Although the public\nkeys are compatible (actually, indistinguishable) from the 2-prime case,\nthe private keys are not. Thus it may not be possible to export multi-prime\nprivate keys in certain formats or to subsequently import them into other\ncode.\n\nTable 1 in [2] suggests maximum numbers of primes for a given size.\n\n[1] US patent 4405829 (1972, expired)\n[2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\nGo return type: (*PrivateKey, error)\nJoker return type: [{:D ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:90:13), :Primes ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:91:15)), :Precomputed ^{:Dp ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:150:10), :Dq ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:150:10), :Qinv ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:151:10), :CRTValues ^(vector-of {:Exp ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:162:9), :Coeff ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:163:9), :R ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:164:9)})}} Error]"
;;   {:added "1.0"
;;    :go "generateMultiPrimeKey(random, nprimes, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:222:35) random, ^Int nprimes, ^Int bits])

JOKER FUNC rsa.SignPKCS1v15 has:
;; (defn SignPKCS1v15
;;   "SignPKCS1v15 calculates the signature of hashed using\nRSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must\nbe the result of hashing the input message using the given hash\nfunction. If hash is zero, hashed is signed directly. This isn't\nadvisable except for interoperability.\n\nIf rand is not nil then RSA blinding will be used to avoid timing\nside-channel attacks.\n\nThis function is deterministic. Thus, if the set of possible\nmessages is small, an attacker may be able to build a map from\nmessages to signatures and identify the signed messages. As ever,\nsignatures provide authenticity, not confidentiality.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "signPKCS1v15(rand, priv, hash, hashed)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:24) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:40) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:58) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:78) hashed])

JOKER FUNC rsa.SignPSS has:
;; (defn SignPSS
;;   "SignPSS calculates the signature of hashed using RSASSA-PSS [1].\nNote that hashed must be the result of hashing the input message using the\ngiven hash function. The opts argument may be nil, in which case sensible\ndefaults are used.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "signPSS(rand, priv, hash, hashed, opts)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pss.go:249:19) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pss.go:249:35) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pss.go:249:53) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pss.go:249:73) hashed, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pss.go:249:86) opts])

JOKER FUNC rsa.VerifyPKCS1v15 has:
;; (defn ^Error VerifyPKCS1v15
;;   "VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. If hash is zero then hashed is used directly. This\nisn't advisable except for interoperability.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "verifyPKCS1v15(pub, hash, hashed, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:268:25) pub, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:268:42) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:268:62) hashed, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:268:74) sig])

JOKER FUNC rsa.VerifyPSS has:
;; (defn ^Error VerifyPSS
;;   "VerifyPSS verifies a PSS signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. The opts argument may be nil, in which case sensible\ndefaults are used.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "verifyPSS(pub, hash, hashed, sig, opts)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pss.go:274:20) pub, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pss.go:274:37) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pss.go:274:57) hashed, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pss.go:274:69) sig, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pss.go:274:82) opts])

JOKER FUNC runtime.BlockProfile has:
;; (defn BlockProfile
;;   "BlockProfile returns n, the number of records in the current blocking profile.\nIf len(p) >= n, BlockProfile copies the profile into p and returns n, true.\nIf len(p) < n, BlockProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.blockprofile flag instead\nof calling BlockProfile directly.\nGo return type: (n int, ok bool)\nJoker return type: [^Int n ^Bool ok]"
;;   {:added "1.0"
;;    :go "blockProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:634:21) p])

JOKER FUNC runtime.Breakpoint has:
;; (defn Breakpoint
;;   "Breakpoint executes a breakpoint trap.\n"
;;   {:added "1.0"
;;    :go "breakpoint()"}
;;   [])

JOKER FUNC runtime.CPUProfile has:
;; (defn CPUProfile
;;   "CPUProfile panics.\nIt formerly provided raw access to chunks of\na pprof-format profile generated by the runtime.\nThe details of generating that format have changed,\nso this functionality has been removed.\n\nDeprecated: use the runtime/pprof package,\nor the handlers in the net/http/pprof package,\nor the testing package's -test.cpuprofile flag instead.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "cPUProfile()"}
;;   [])

JOKER FUNC runtime.Caller has:
;; (defn Caller
;;   "Caller reports file and line number information about function invocations on\nthe calling goroutine's stack. The argument skip is the number of stack frames\nto ascend, with 0 identifying the caller of Caller.  (For historical reasons the\nmeaning of skip differs between Caller and Callers.) The return values report the\nprogram counter, file name, and line number within the file of the corresponding\ncall. The boolean ok is false if it was not possible to recover the information.\nGo return type: (pc uintptr, file string, line int, ok bool)\nJoker return type: [^ABEND042(cannot find typename runtime.uintptr) pc ^String file ^Int line ^Bool ok]"
;;   {:added "1.0"
;;    :go "caller(skip)"}
;;   [^Int skip])

JOKER FUNC runtime.Callers has:
;; (defn ^Int Callers
;;   "Callers fills the slice pc with the return program counters of function invocations\non the calling goroutine's stack. The argument skip is the number of stack frames\nto skip before recording in pc, with 0 identifying the frame for Callers itself and\n1 identifying the caller of Callers.\nIt returns the number of entries written to pc.\n\nTo translate these PCs into symbolic information such as function\nnames and line numbers, use CallersFrames. CallersFrames accounts\nfor inlined functions and adjusts the return program counters into\ncall program counters. Iterating over the returned slice of PCs\ndirectly is discouraged, as is using FuncForPC on any of the\nreturned PCs, since these cannot account for inlining or return\nprogram counter adjustment.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "callers(skip, pc)"}
;;   [^Int skip, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/extern.go:211:27) pc])

JOKER FUNC runtime.CallersFrames has:
;; (defn CallersFrames
;;   "CallersFrames takes a slice of PC values returned by Callers and\nprepares to return function/file/line information.\nDo not change the slice until you are done with the Frames.\nGo return type: *Frames\nJoker return type: {:callers ^(vector-of ABEND042(cannot find typename runtime.uintptr)), :stackExpander ^ABEND042(cannot find typename runtime.stackExpander), :elideWrapper ^Bool}"
;;   {:added "1.0"
;;    :go "callersFrames(callers)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/symtab.go:91:28) callers])

JOKER FUNC runtime.FuncForPC has:
;; (defn FuncForPC
;;   "FuncForPC returns a *Func describing the function that contains the\ngiven program counter address, or else nil.\n\nIf pc represents multiple functions because of inlining, it returns\nthe *Func describing the outermost function.\nGo return type: *Func\nJoker return type: {:opaque ^{}}"
;;   {:added "1.0"
;;    :go "funcForPC(pc)"}
;;   [pc])

JOKER FUNC runtime.GC has:
;; (defn GC
;;   "GC runs a garbage collection and blocks the caller until the\ngarbage collection is complete. It may also block the entire\nprogram.\n"
;;   {:added "1.0"
;;    :go "gC()"}
;;   [])

JOKER FUNC runtime.GOMAXPROCS has:
(defn ^Int GOMAXPROCS
  "GOMAXPROCS sets the maximum number of CPUs that can be executing\nsimultaneously and returns the previous setting. If n < 1, it does not\nchange the current setting.\nThe number of logical CPUs on the local machine can be queried with NumCPU.\nThis call will go away when the scheduler improves.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "gOMAXPROCS(n)"}
  [^Int n])

JOKER FUNC runtime.GOROOT has:
(defn ^String GOROOT
  "GOROOT returns the root of the Go tree. It uses the\nGOROOT environment variable, if set at process start,\nor else the root used during the Go build.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "gOROOT()"}
  [])

JOKER FUNC runtime.Goexit has:
;; (defn Goexit
;;   "Goexit terminates the goroutine that calls it. No other goroutine is affected.\nGoexit runs all deferred calls before terminating the goroutine. Because Goexit\nis not a panic, any recover calls in those deferred functions will return nil.\n\nCalling Goexit from the main goroutine terminates that goroutine\nwithout func main returning. Since func main has not returned,\nthe program continues execution of other goroutines.\nIf all other goroutines exit, the program crashes.\n"
;;   {:added "1.0"
;;    :go "goexit()"}
;;   [])

JOKER FUNC runtime.GoroutineProfile has:
;; (defn GoroutineProfile
;;   "GoroutineProfile returns n, the number of records in the active goroutine stack profile.\nIf len(p) >= n, GoroutineProfile copies the profile into p and returns n, true.\nIf len(p) < n, GoroutineProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling GoroutineProfile directly.\nGo return type: (n int, ok bool)\nJoker return type: [^Int n ^Bool ok]"
;;   {:added "1.0"
;;    :go "goroutineProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:720:25) p])

JOKER FUNC runtime.Gosched has:
;; (defn Gosched
;;   "Gosched yields the processor, allowing other goroutines to run. It does not\nsuspend the current goroutine, so execution resumes automatically.\n"
;;   {:added "1.0"
;;    :go "gosched()"}
;;   [])

JOKER FUNC runtime.KeepAlive has:
;; (defn KeepAlive
;;   "KeepAlive marks its argument as currently reachable.\nThis ensures that the object is not freed, and its finalizer is not run,\nbefore the point in the program where KeepAlive is called.\n\nA very simplified example showing where KeepAlive is required:\n\ttype File struct { d int }\n\td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n\t// ... do something if err != nil ...\n\tp := &File{d}\n\truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n\tvar buf [10]byte\n\tn, err := syscall.Read(p.d, buf[:])\n\t// Ensure p is not finalized until Read returns.\n\truntime.KeepAlive(p)\n\t// No more uses of p after this point.\n\nWithout the KeepAlive call, the finalizer could run at the start of\nsyscall.Read, closing the file descriptor before syscall.Read makes\nthe actual system call.\n"
;;   {:added "1.0"
;;    :go "keepAlive(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:446:18) x])

JOKER FUNC runtime.LockOSThread has:
;; (defn LockOSThread
;;   "LockOSThread wires the calling goroutine to its current operating system thread.\nThe calling goroutine will always execute in that thread,\nand no other goroutine will execute in it,\nuntil the calling goroutine has made as many calls to\nUnlockOSThread as to LockOSThread.\nIf the calling goroutine exits without unlocking the thread,\nthe thread will be terminated.\n\nAll init functions are run on the startup thread. Calling LockOSThread\nfrom an init function will cause the main function to be invoked on\nthat thread.\n\nA goroutine should call LockOSThread before calling OS services or\nnon-Go library functions that depend on per-thread state.\n"
;;   {:added "1.0"
;;    :go "lockOSThread()"}
;;   [])

JOKER FUNC runtime.MemProfile has:
;; (defn MemProfile
;;   "MemProfile returns a profile of memory allocated and freed per allocation\nsite.\n\nMemProfile returns n, the number of records in the current memory profile.\nIf len(p) >= n, MemProfile copies the profile into p and returns n, true.\nIf len(p) < n, MemProfile does not change p and returns n, false.\n\nIf inuseZero is true, the profile includes allocation records\nwhere r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.\nThese are sites where memory was allocated, but it has all\nbeen released back to the runtime.\n\nThe returned profile may be up to two garbage collection cycles old.\nThis is to avoid skewing the profile toward allocations; because\nallocations happen in real time but frees are delayed until the garbage\ncollector performs sweeping, the profile only accounts for allocations\nthat have had a chance to be freed by the garbage collector.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.memprofile flag instead\nof calling MemProfile directly.\nGo return type: (n int, ok bool)\nJoker return type: [^Int n ^Bool ok]"
;;   {:added "1.0"
;;    :go "memProfile(p, inuseZero)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:543:19) p, inuseZero])

JOKER FUNC runtime.MutexProfile has:
;; (defn MutexProfile
;;   "MutexProfile returns n, the number of records in the current mutex profile.\nIf len(p) >= n, MutexProfile copies the profile into p and returns n, true.\nOtherwise, MutexProfile does not change p, and returns n, false.\n\nMost clients should use the runtime/pprof package\ninstead of calling MutexProfile directly.\nGo return type: (n int, ok bool)\nJoker return type: [^Int n ^Bool ok]"
;;   {:added "1.0"
;;    :go "mutexProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:669:21) p])

JOKER FUNC runtime.NumCPU has:
(defn ^Int NumCPU
  "NumCPU returns the number of logical CPUs usable by the current process.\n\nThe set of available CPUs is checked by querying the operating system\nat process startup. Changes to operating system CPU allocation after\nprocess startup are not reflected.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "numCPU()"}
  [])

JOKER FUNC runtime.NumCgoCall has:
(defn ^Int NumCgoCall
  "NumCgoCall returns the number of cgo calls made by the current process.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "numCgoCall()"}
  [])

JOKER FUNC runtime.NumGoroutine has:
(defn ^Int NumGoroutine
  "NumGoroutine returns the number of goroutines that currently exist.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "numGoroutine()"}
  [])

JOKER FUNC runtime.ReadMemStats has:
;; (defn ReadMemStats
;;   "ReadMemStats populates m with memory allocator statistics.\n\nThe returned memory allocator statistics are up to date as of the\ncall to ReadMemStats. This is in contrast with a heap profile,\nwhich is a snapshot as of the most recently completed garbage\ncollection cycle.\n"
;;   {:added "1.0"
;;    :go "readMemStats(m)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/mstats.go:457:21) m])

JOKER FUNC runtime.ReadTrace has:
;; (defn ReadTrace
;;   "ReadTrace returns the next chunk of binary tracing data, blocking until data\nis available. If tracing is turned off and all the data accumulated while it\nwas on has been returned, ReadTrace returns nil. The caller must copy the\nreturned data before calling ReadTrace again.\nReadTrace must be called from one goroutine at a time.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "readTrace()"}
;;   [])

JOKER FUNC runtime.SetBlockProfileRate has:
;; (defn SetBlockProfileRate
;;   "SetBlockProfileRate controls the fraction of goroutine blocking events\nthat are reported in the blocking profile. The profiler aims to sample\nan average of one blocking event per rate nanoseconds spent blocked.\n\nTo include every blocking event in the profile, pass rate = 1.\nTo turn off profiling entirely, pass rate <= 0.\n"
;;   {:added "1.0"
;;    :go "setBlockProfileRate(rate)"}
;;   [^Int rate])

JOKER FUNC runtime.SetCPUProfileRate has:
;; (defn SetCPUProfileRate
;;   "SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\nIf hz <= 0, SetCPUProfileRate turns off profiling.\nIf the profiler is on, the rate cannot be changed without first turning it off.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.cpuprofile flag instead of calling\nSetCPUProfileRate directly.\n"
;;   {:added "1.0"
;;    :go "setCPUProfileRate(hz)"}
;;   [^Int hz])

JOKER FUNC runtime.SetCgoTraceback has:
;; (defn SetCgoTraceback
;;   "SetCgoTraceback records three C functions to use to gather\ntraceback information from C code and to convert that traceback\ninformation into symbolic information. These are used when printing\nstack traces for a program that uses cgo.\n\nThe traceback and context functions may be called from a signal\nhandler, and must therefore use only async-signal safe functions.\nThe symbolizer function may be called while the program is\ncrashing, and so must be cautious about using memory.  None of the\nfunctions may call back into Go.\n\nThe context function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t Context;\n\t};\n\nIf the Context field is 0, the context function is being called to\nrecord the current traceback context. It should record in the\nContext field whatever information is needed about the current\npoint of execution to later produce a stack trace, probably the\nstack pointer and PC. In this case the context function will be\ncalled from C code.\n\nIf the Context field is not 0, then it is a value returned by a\nprevious call to the context function. This case is called when the\ncontext is no longer needed; that is, when the Go code is returning\nto its C code caller. This permits the context function to release\nany associated resources.\n\nWhile it would be correct for the context function to record a\ncomplete a stack trace whenever it is called, and simply copy that\nout in the traceback function, in a typical program the context\nfunction will be called many times without ever recording a\ntraceback for that context. Recording a complete stack trace in a\ncall to the context function is likely to be inefficient.\n\nThe traceback function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext    uintptr\n\t\tSigContext uintptr\n\t\tBuf        *uintptr\n\t\tMax        uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t  Context;\n\t\tuintptr_t  SigContext;\n\t\tuintptr_t* Buf;\n\t\tuintptr_t  Max;\n\t};\n\nThe Context field will be zero to gather a traceback from the\ncurrent program execution point. In this case, the traceback\nfunction will be called from C code.\n\nOtherwise Context will be a value previously returned by a call to\nthe context function. The traceback function should gather a stack\ntrace from that saved point in the program execution. The traceback\nfunction may be called from an execution thread other than the one\nthat recorded the context, but only when the context is known to be\nvalid and unchanging. The traceback function may also be called\ndeeper in the call stack on the same thread that recorded the\ncontext. The traceback function may be called multiple times with\nthe same Context value; it will usually be appropriate to cache the\nresult, if possible, the first time this is called for a specific\ncontext value.\n\nIf the traceback function is called from a signal handler on a Unix\nsystem, SigContext will be the signal context argument passed to\nthe signal handler (a C ucontext_t* cast to uintptr_t). This may be\nused to start tracing at the point where the signal occurred. If\nthe traceback function is not called from a signal handler,\nSigContext will be zero.\n\nBuf is where the traceback information should be stored. It should\nbe PC values, such that Buf[0] is the PC of the caller, Buf[1] is\nthe PC of that function's caller, and so on.  Max is the maximum\nnumber of entries to store.  The function should store a zero to\nindicate the top of the stack, or that the caller is on a different\nstack, presumably a Go stack.\n\nUnlike runtime.Callers, the PC values returned should, when passed\nto the symbolizer function, return the file/line of the call\ninstruction.  No additional subtraction is required or appropriate.\n\nOn all platforms, the traceback function is invoked when a call from\nGo to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,\nand freebsd/amd64, the traceback function is also invoked when a\nsignal is received by a thread that is executing a cgo call. The\ntraceback function should not make assumptions about when it is\ncalled, as future versions of Go may make additional calls.\n\nThe symbolizer function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tPC      uintptr // program counter to fetch information for\n\t\tFile    *byte   // file name (NUL terminated)\n\t\tLineno  uintptr // line number\n\t\tFunc    *byte   // function name (NUL terminated)\n\t\tEntry   uintptr // function entry point\n\t\tMore    uintptr // set non-zero if more info for this PC\n\t\tData    uintptr // unused by runtime, available for function\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t PC;\n\t\tchar*     File;\n\t\tuintptr_t Lineno;\n\t\tchar*     Func;\n\t\tuintptr_t Entry;\n\t\tuintptr_t More;\n\t\tuintptr_t Data;\n\t};\n\nThe PC field will be a value returned by a call to the traceback\nfunction.\n\nThe first time the function is called for a particular traceback,\nall the fields except PC will be 0. The function should fill in the\nother fields if possible, setting them to 0/nil if the information\nis not available. The Data field may be used to store any useful\ninformation across calls. The More field should be set to non-zero\nif there is more information for this PC, zero otherwise. If More\nis set non-zero, the function will be called again with the same\nPC, and may return different information (this is intended for use\nwith inlined functions). If More is zero, the function will be\ncalled with the next PC value in the traceback. When the traceback\nis complete, the function will be called once more with PC set to\nzero; this may be used to free any information. Each call will\nleave the fields of the struct set to the same values they had upon\nreturn, except for the PC field when the More field is zero. The\nfunction must not keep a copy of the struct pointer between calls.\n\nWhen calling SetCgoTraceback, the version argument is the version\nnumber of the structs that the functions expect to receive.\nCurrently this must be zero.\n\nThe symbolizer function may be nil, in which case the results of\nthe traceback function will be displayed as numbers. If the\ntraceback function is nil, the symbolizer function will never be\ncalled. The context function may be nil, in which case the\ntraceback function will only be called with the context field set\nto zero.  If the context function is nil, then calls from Go to C\nto Go will not show a traceback for the C portion of the call stack.\n\nSetCgoTraceback should be called only once, ideally from an init function.\n"
;;   {:added "1.0"
;;    :go "setCgoTraceback(version, traceback, context, symbolizer)"}
;;   [^Int version, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66) traceback, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66) context, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66) symbolizer])

JOKER FUNC runtime.SetFinalizer has:
;; (defn SetFinalizer
;;   "SetFinalizer sets the finalizer associated with obj to the provided\nfinalizer function. When the garbage collector finds an unreachable block\nwith an associated finalizer, it clears the association and runs\nfinalizer(obj) in a separate goroutine. This makes obj reachable again,\nbut now without an associated finalizer. Assuming that SetFinalizer\nis not called again, the next time the garbage collector sees\nthat obj is unreachable, it will free obj.\n\nSetFinalizer(obj, nil) clears any finalizer associated with obj.\n\nThe argument obj must be a pointer to an object allocated by calling\nnew, by taking the address of a composite literal, or by taking the\naddress of a local variable.\nThe argument finalizer must be a function that takes a single argument\nto which obj's type can be assigned, and can have arbitrary ignored return\nvalues. If either of these is not true, SetFinalizer may abort the\nprogram.\n\nFinalizers are run in dependency order: if A points at B, both have\nfinalizers, and they are otherwise unreachable, only the finalizer\nfor A runs; once A is freed, the finalizer for B can run.\nIf a cyclic structure includes a block with a finalizer, that\ncycle is not guaranteed to be garbage collected and the finalizer\nis not guaranteed to run, because there is no ordering that\nrespects the dependencies.\n\nThe finalizer is scheduled to run at some arbitrary time after the\nprogram can no longer reach the object to which obj points.\nThere is no guarantee that finalizers will run before a program exits,\nso typically they are useful only for releasing non-memory resources\nassociated with an object during a long-running program.\nFor example, an os.File object could use a finalizer to close the\nassociated operating system file descriptor when a program discards\nan os.File without calling Close, but it would be a mistake\nto depend on a finalizer to flush an in-memory I/O buffer such as a\nbufio.Writer, because the buffer would not be flushed at program exit.\n\nIt is not guaranteed that a finalizer will run if the size of *obj is\nzero bytes.\n\nIt is not guaranteed that a finalizer will run for objects allocated\nin initializers for package-level variables. Such objects may be\nlinker-allocated, not heap-allocated.\n\nA finalizer may run as soon as an object becomes unreachable.\nIn order to use finalizers correctly, the program must ensure that\nthe object is reachable until it is no longer required.\nObjects stored in global variables, or that can be found by tracing\npointers from a global variable, are reachable. For other objects,\npass the object to a call of the KeepAlive function to mark the\nlast point in the function where the object must be reachable.\n\nFor example, if p points to a struct that contains a file descriptor d,\nand p has a finalizer that closes that file descriptor, and if the last\nuse of p in a function is a call to syscall.Write(p.d, buf, size), then\np may be unreachable as soon as the program enters syscall.Write. The\nfinalizer may run at that moment, closing p.d, causing syscall.Write\nto fail because it is writing to a closed file descriptor (or, worse,\nto an entirely different file descriptor opened by a different goroutine).\nTo avoid this problem, call runtime.KeepAlive(p) after the call to\nsyscall.Write.\n\nA single goroutine runs all finalizers for a program, sequentially.\nIf a finalizer must run for a long time, it should do so by starting\na new goroutine.\n"
;;   {:added "1.0"
;;    :go "setFinalizer(obj, finalizer)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:309:23) obj, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:309:46) finalizer])

JOKER FUNC runtime.SetMutexProfileFraction has:
(defn ^Int SetMutexProfileFraction
  "SetMutexProfileFraction controls the fraction of mutex contention events\nthat are reported in the mutex profile. On average 1/rate events are\nreported. The previous rate is returned.\n\nTo turn off profiling entirely, pass rate 0.\nTo just read the current rate, pass rate < 0.\n(For n>1 the details of sampling may change.)\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "setMutexProfileFraction(rate)"}
  [^Int rate])

JOKER FUNC runtime.Stack has:
;; (defn ^Int Stack
;;   "Stack formats a stack trace of the calling goroutine into buf\nand returns the number of bytes written to buf.\nIf all is true, Stack formats stack traces of all other goroutines\ninto buf after the trace for the current goroutine.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "stack(buf, all)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:780:16) buf, all])

JOKER FUNC runtime.StartTrace has:
(defn ^Error StartTrace
  "StartTrace enables tracing for the current process.\nWhile tracing, the data will be buffered and available via ReadTrace.\nStartTrace returns an error if tracing is already enabled.\nMost clients should use the runtime/trace package or the testing package's\n-test.trace flag instead of calling StartTrace directly.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "startTrace()"}
  [])

JOKER FUNC runtime.StopTrace has:
;; (defn StopTrace
;;   "StopTrace stops tracing, if it was previously enabled.\nStopTrace only returns after all the reads for the trace have completed.\n"
;;   {:added "1.0"
;;    :go "stopTrace()"}
;;   [])

JOKER FUNC runtime.ThreadCreateProfile has:
;; (defn ThreadCreateProfile
;;   "ThreadCreateProfile returns n, the number of records in the thread creation profile.\nIf len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true.\nIf len(p) < n, ThreadCreateProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling ThreadCreateProfile directly.\nGo return type: (n int, ok bool)\nJoker return type: [^Int n ^Bool ok]"
;;   {:added "1.0"
;;    :go "threadCreateProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:698:28) p])

JOKER FUNC runtime.UnlockOSThread has:
;; (defn UnlockOSThread
;;   "UnlockOSThread undoes an earlier call to LockOSThread.\nIf this drops the number of active LockOSThread calls on the\ncalling goroutine to zero, it unwires the calling goroutine from\nits fixed operating system thread.\nIf there are no active LockOSThread calls, this is a no-op.\n\nBefore calling UnlockOSThread, the caller must ensure that the OS\nthread is suitable for running other goroutines. If the caller made\nany permanent changes to the state of the thread that would affect\nother goroutines, it should not call this function and thus leave\nthe goroutine locked to the OS thread until the goroutine (and\nhence the thread) exits.\n"
;;   {:added "1.0"
;;    :go "unlockOSThread()"}
;;   [])

JOKER FUNC runtime.Version has:
(defn ^String Version
  "Version returns the Go tree's version string.\nIt is either the commit hash and date at the time of the build or,\nwhen possible, a release tag like \"go1.3\".\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "version()"}
  [])

JOKER FUNC runtime._ExternalCode has:
;; (defn _ExternalCode
;;   ""
;;   {:added "1.0"
;;    :go "_ExternalCode()"}
;;   [])

JOKER FUNC runtime._GC has:
;; (defn _GC
;;   ""
;;   {:added "1.0"
;;    :go "_GC()"}
;;   [])

JOKER FUNC runtime._LostExternalCode has:
;; (defn _LostExternalCode
;;   ""
;;   {:added "1.0"
;;    :go "_LostExternalCode()"}
;;   [])

JOKER FUNC runtime._LostSIGPROFDuringAtomic64 has:
;; (defn _LostSIGPROFDuringAtomic64
;;   ""
;;   {:added "1.0"
;;    :go "_LostSIGPROFDuringAtomic64()"}
;;   [])

JOKER FUNC runtime._System has:
;; (defn _System
;;   ""
;;   {:added "1.0"
;;    :go "_System()"}
;;   [])

JOKER FUNC runtime._VDSO has:
;; (defn _VDSO
;;   ""
;;   {:added "1.0"
;;    :go "_VDSO()"}
;;   [])

JOKER FUNC runtime._cgo_panic_internal has:
;; (defn _cgo_panic_internal
;;   ""
;;   {:added "1.0"
;;    :go "_cgo_panic_internal(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/cgocallback.go:11:28) p])

JOKER FUNC scanner.PrintError has:
;; (defn PrintError
;;   "PrintError is a utility function that prints a list of errors to w,\none error per line, if the err parameter is an ErrorList. Otherwise\nit prints the err string.\n"
;;   {:added "1.0"
;;    :go "printError(w, err)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/scanner/errors.go:116:19) w, err])

JOKER FUNC scanner.TokenString has:
(defn ^String TokenString
  "TokenString returns a printable string for a token or Unicode character.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "tokenString(tok)"}
  [tok])

JOKER FUNC sha1.New has:
;; (defn New
;;   "New returns a new hash.Hash computing the SHA1 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha1/sha1.go:120:12)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC sha1.Sum has:
;; (defn Sum
;;   "Sum returns the SHA-1 checksum of the data.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha1/sha1.go:260:15) data])

JOKER FUNC sha256.New has:
;; (defn New
;;   "New returns a new hash.Hash computing the SHA256 checksum. The Hash\nalso implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha256/sha256.go:180:12)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC sha256.New224 has:
;; (defn New224
;;   "New224 returns a new hash.Hash computing the SHA224 checksum.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha256/sha256.go:187:15)"
;;   {:added "1.0"
;;    :go "new224()"}
;;   [])

JOKER FUNC sha256.Sum224 has:
;; (defn Sum224
;;   "Sum224 returns the SHA224 checksum of the data.\nGo return type: sum224 []int\nJoker return type: ^(vector-of Int) sum224"
;;   {:added "1.0"
;;    :go "sum224(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha256/sha256.go:281:18) data])

JOKER FUNC sha256.Sum256 has:
;; (defn Sum256
;;   "Sum256 returns the SHA256 checksum of the data.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum256(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha256/sha256.go:273:18) data])

JOKER FUNC sha512.New has:
;; (defn New
;;   "New returns a new hash.Hash computing the SHA-512 checksum.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha512/sha512.go:224:12)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC sha512.New384 has:
;; (defn New384
;;   "New384 returns a new hash.Hash computing the SHA-384 checksum.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha512/sha512.go:245:15)"
;;   {:added "1.0"
;;    :go "new384()"}
;;   [])

JOKER FUNC sha512.New512_224 has:
;; (defn New512_224
;;   "New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha512/sha512.go:231:19)"
;;   {:added "1.0"
;;    :go "new512_224()"}
;;   [])

JOKER FUNC sha512.New512_256 has:
;; (defn New512_256
;;   "New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha512/sha512.go:238:19)"
;;   {:added "1.0"
;;    :go "new512_256()"}
;;   [])

JOKER FUNC sha512.Sum384 has:
;; (defn Sum384
;;   "Sum384 returns the SHA384 checksum of the data.\nGo return type: sum384 []int\nJoker return type: ^(vector-of Int) sum384"
;;   {:added "1.0"
;;    :go "sum384(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:351:18) data])

JOKER FUNC sha512.Sum512 has:
;; (defn Sum512
;;   "Sum512 returns the SHA512 checksum of the data.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "sum512(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:343:18) data])

JOKER FUNC sha512.Sum512_224 has:
;; (defn Sum512_224
;;   "Sum512_224 returns the Sum512/224 checksum of the data.\nGo return type: sum224 []int\nJoker return type: ^(vector-of Int) sum224"
;;   {:added "1.0"
;;    :go "sum512_224(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:361:22) data])

JOKER FUNC sha512.Sum512_256 has:
;; (defn Sum512_256
;;   "Sum512_256 returns the Sum512/256 checksum of the data.\nGo return type: sum256 []int\nJoker return type: ^(vector-of Int) sum256"
;;   {:added "1.0"
;;    :go "sum512_256(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:371:22) data])

JOKER FUNC signal.Ignore has:
;; (defn Ignore
;;   "Ignore causes the provided signals to be ignored. If they are received by\nthe program, nothing will happen. Ignore undoes the effect of any prior\ncalls to Notify for the provided signals.\nIf no signals are provided, all incoming signals will be ignored.\n"
;;   {:added "1.0"
;;    :go "ignore(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:85:17) sig])

JOKER FUNC signal.Ignored has:
;; (defn ^Bool Ignored
;;   "Ignored reports whether sig is currently ignored.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ignored(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/signal/signal.go:90:18) sig])

JOKER FUNC signal.Notify has:
;; (defn Notify
;;   "Notify causes package signal to relay incoming signals to c.\nIf no signals are provided, all incoming signals will be relayed to c.\nOtherwise, just the provided signals will.\n\nPackage signal will not block sending to c: the caller must ensure\nthat c has sufficient buffer space to keep up with the expected\nsignal rate. For a channel used for notification of just one signal value,\na buffer of size 1 is sufficient.\n\nIt is allowed to call Notify multiple times with the same channel:\neach call expands the set of signals sent to that channel.\nThe only way to remove signals from the set is to call Stop.\n\nIt is allowed to call Notify multiple times with different channels\nand the same signals: each channel receives copies of incoming\nsignals independently.\n"
;;   {:added "1.0"
;;    :go "notify(c, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/signal/signal.go:111:15) c, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:111:37) sig])

JOKER FUNC signal.Reset has:
;; (defn Reset
;;   "Reset undoes the effect of any prior calls to Notify for the provided\nsignals.\nIf no signals are provided, all signal handlers will be reset.\n"
;;   {:added "1.0"
;;    :go "reset(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:155:16) sig])

JOKER FUNC signal.Stop has:
;; (defn Stop
;;   "Stop causes package signal to stop relaying incoming signals to c.\nIt undoes the effect of all prior calls to Notify using c.\nWhen Stop returns, it is guaranteed that c will receive no more signals.\n"
;;   {:added "1.0"
;;    :go "stop(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/signal/signal.go:162:13) c])

JOKER FUNC smtp.CRAMMD5Auth has:
;; (defn CRAMMD5Auth
;;   "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\nGo return type: Auth\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/smtp/auth.go:15:11)"
;;   {:added "1.0"
;;    :go "cRAMMD5Auth(username, secret)"}
;;   [^String username, ^String secret])

JOKER FUNC smtp.Dial has:
;; (defn Dial
;;   "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\nGo return type: (*Client, error)\nJoker return type: [{:Text ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/smtp/smtp.go:33:8), :conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/smtp/smtp.go:36:7), :tls ^Bool, :serverName ^String, :ext ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/smtp/smtp.go:41:6), :auth ^(vector-of String), :localName ^String, :didHello ^Bool, :helloError ^Error} Error]"
;;   {:added "1.0"
;;    :go "dial(addr)"}
;;   [^String addr])

JOKER FUNC smtp.NewClient has:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\nGo return type: (*Client, error)\nJoker return type: [{:Text ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/smtp/smtp.go:33:8), :conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/smtp/smtp.go:36:7), :tls ^Bool, :serverName ^String, :ext ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/smtp/smtp.go:41:6), :auth ^(vector-of String), :localName ^String, :didHello ^Bool, :helloError ^Error} Error]"
;;   {:added "1.0"
;;    :go "newClient(conn, host)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/smtp/smtp.go:62:21) conn, ^String host])

JOKER FUNC smtp.PlainAuth has:
;; (defn PlainAuth
;;   "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\nGo return type: Auth\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/smtp/auth.go:15:11)"
;;   {:added "1.0"
;;    :go "plainAuth(identity, username, password, host)"}
;;   [^String identity, ^String username, ^String password, ^String host])

JOKER FUNC smtp.SendMail has:
;; (defn ^Error SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "sendMail(addr, a, from, to, msg)"}
;;   [^String addr, a, ^String from, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/smtp/smtp.go:319:52) to, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/smtp/smtp.go:319:66) msg])

JOKER FUNC sort.Float64s has:
;; (defn Float64s
;;   "Float64s sorts a slice of float64s in increasing order\n(not-a-number values are treated as less than other values).\n"
;;   {:added "1.0"
;;    :go "float64s(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:311:17) a])

JOKER FUNC sort.Float64sAreSorted has:
;; (defn ^Bool Float64sAreSorted
;;   "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order\n(not-a-number values are treated as less than other values).\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "float64sAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:321:26) a])

JOKER FUNC sort.Ints has:
;; (defn Ints
;;   "Ints sorts a slice of ints in increasing order.\n"
;;   {:added "1.0"
;;    :go "ints(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:307:13) a])

JOKER FUNC sort.IntsAreSorted has:
;; (defn ^Bool IntsAreSorted
;;   "IntsAreSorted tests whether a slice of ints is sorted in increasing order.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "intsAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:317:22) a])

JOKER FUNC sort.IsSorted has:
(defn ^Bool IsSorted
  "IsSorted reports whether data is sorted.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isSorted(data)"}
  [data])

JOKER FUNC sort.Reverse has:
;; (defn Reverse
;;   "Reverse returns the reverse order for data.\nGo return type: Interface\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/sort.go:14:16)"
;;   {:added "1.0"
;;    :go "reverse(data)"}
;;   [data])

JOKER FUNC sort.Search has:
;; (defn ^Int Search
;;   "Search uses binary search to find and return the smallest index i\nin [0, n) at which f(i) is true, assuming that on the range [0, n),\nf(i) == true implies f(i+1) == true. That is, Search requires that\nf is false for some (possibly empty) prefix of the input range [0, n)\nand then true for the (possibly empty) remainder; Search returns\nthe first true index. If there is no such index, Search returns n.\n(Note that the \"not found\" return value is not -1 as in, for instance,\nstrings.Index.)\nSearch calls f(i) only for i in the range [0, n).\n\nA common use of Search is to find the index i for a value x in\na sorted, indexable data structure such as an array or slice.\nIn this case, the argument f, typically a closure, captures the value\nto be searched for, and how the data structure is indexed and\nordered.\n\nFor instance, given a slice data sorted in ascending order,\nthe call Search(len(data), func(i int) bool { return data[i] >= 23 })\nreturns the smallest index i such that data[i] >= 23. If the caller\nwants to find whether 23 is in the slice, it must test data[i] == 23\nseparately.\n\nSearching data sorted in descending order would use the <=\noperator instead of the >= operator.\n\nTo complete the example above, the following code tries to find the value\nx in an integer slice data sorted in ascending order:\n\n\tx := 23\n\ti := sort.Search(len(data), func(i int) bool { return data[i] >= x })\n\tif i < len(data) && data[i] == x {\n\t\t// x is present at data[i]\n\t} else {\n\t\t// x is not present in data,\n\t\t// but i is the index where it would be inserted.\n\t}\n\nAs a more whimsical example, this program guesses your number:\n\n\tfunc GuessingGame() {\n\t\tvar s string\n\t\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\t\tanswer := sort.Search(100, func(i int) bool {\n\t\t\tfmt.Printf(\"Is your number <= %d? \", i)\n\t\t\tfmt.Scanf(\"%s\", &s)\n\t\t\treturn s != \"\" && s[0] == 'y'\n\t\t})\n\t\tfmt.Printf(\"Your number is %d.\\n\", answer)\n\t}\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "search(n, f)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/search.go:59:22) f])

JOKER FUNC sort.SearchFloat64s has:
;; (defn ^Int SearchFloat64s
;;   "SearchFloat64s searches for x in a sorted slice of float64s and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "searchFloat64s(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/search.go:92:23) a, x])

JOKER FUNC sort.SearchInts has:
;; (defn ^Int SearchInts
;;   "SearchInts searches for x in a sorted slice of ints and returns the index\nas specified by Search. The return value is the index to insert x if x is\nnot present (it could be len(a)).\nThe slice must be sorted in ascending order.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "searchInts(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/search.go:83:19) a, ^Int x])

JOKER FUNC sort.SearchStrings has:
;; (defn ^Int SearchStrings
;;   "SearchStrings searches for x in a sorted slice of strings and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "searchStrings(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/search.go:101:22) a, ^String x])

JOKER FUNC sort.Slice has:
;; (defn Slice
;;   "Slice sorts the provided slice given the provided less function.\n\nThe sort is not guaranteed to be stable. For a stable sort, use\nSliceStable.\n\nThe function panics if the provided interface is not a slice.\n"
;;   {:added "1.0"
;;    :go "slice(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/slice.go:17:18) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/slice.go:17:36) less])

JOKER FUNC sort.SliceIsSorted has:
;; (defn ^Bool SliceIsSorted
;;   "SliceIsSorted tests whether a slice is sorted.\n\nThe function panics if the provided interface is not a slice.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sliceIsSorted(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/slice.go:37:26) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/slice.go:37:44) less])

JOKER FUNC sort.SliceStable has:
;; (defn SliceStable
;;   "SliceStable sorts the provided slice given the provided less\nfunction while keeping the original order of equal elements.\n\nThe function panics if the provided interface is not a slice.\n"
;;   {:added "1.0"
;;    :go "sliceStable(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/slice.go:28:24) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/slice.go:28:42) less])

JOKER FUNC sort.Sort has:
;; (defn Sort
;;   "Sort sorts data.\nIt makes one call to data.Len to determine n, and O(n*log(n)) calls to\ndata.Less and data.Swap. The sort is not guaranteed to be stable.\n"
;;   {:added "1.0"
;;    :go "sort(data)"}
;;   [data])

JOKER FUNC sort.Stable has:
;; (defn Stable
;;   "Stable sorts data while keeping the original order of equal elements.\n\nIt makes one call to data.Len to determine n, O(n*log(n)) calls to\ndata.Less and O(n*log(n)*log(n)) calls to data.Swap.\n"
;;   {:added "1.0"
;;    :go "stable(data)"}
;;   [data])

JOKER FUNC sort.Strings has:
;; (defn Strings
;;   "Strings sorts a slice of strings in increasing order.\n"
;;   {:added "1.0"
;;    :go "strings(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:314:16) a])

JOKER FUNC sort.StringsAreSorted has:
;; (defn ^Bool StringsAreSorted
;;   "StringsAreSorted tests whether a slice of strings is sorted in increasing order.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "stringsAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:324:25) a])

JOKER FUNC sql.Drivers has:
;; (defn Drivers
;;   "Drivers returns a sorted list of the names of the registered drivers.\nGo return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "drivers()"}
;;   [])

JOKER FUNC sql.Named has:
;; (defn Named
;;   "Named provides a more concise way to create NamedArg values.\n\nExample usage:\n\n    db.ExecContext(ctx, `\n        delete from Invoice\n        where\n            TimeCreated < @end\n            and TimeCreated >= @start;`,\n        sql.Named(\"start\", startTime),\n        sql.Named(\"end\", endTime),\n    )\nGo return type: NamedArg\nJoker return type: {:_Named_Fields_Required ^{}, :Name ^String, :Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/database/sql/sql.go:95:8)}"
;;   {:added "1.0"
;;    :go "named(name, value)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/database/sql/sql.go:110:31) value])

JOKER FUNC sql.Open has:
;; (defn Open
;;   "Open opens a database specified by its database driver name and a\ndriver-specific data source name, usually consisting of at least a\ndatabase name and connection information.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpen may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the Open\nfunction should be called just once. It is rarely necessary to\nclose a DB.\nGo return type: (*DB, error)\nJoker return type: [{:waitDuration ^Int, :connector ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:354:12), :numClosed ^ABEND042(cannot find typename sql.uint64), :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:360:15), :freeConn ^(vector-of ABEND042(cannot find typename sql.driverConn)), :connRequests ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:362:15), :nextRequest ^ABEND042(cannot find typename sql.uint64), :numOpen ^Int, :openerCh ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:370:20), :resetterCh ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:371:20), :closed ^Bool, :dep ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:373:20), :lastPut ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:374:20), :maxIdle ^Int, :maxOpen ^Int, :maxLifetime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:377:20), :cleanerCh ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:378:20), :waitCount ^Int, :maxIdleClosed ^Int, :maxLifetimeClosed ^Int, :stop ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/database/sql/sql.go:383:7)} Error]"
;;   {:added "1.0"
;;    :go "open(driverName, dataSourceName)"}
;;   [^String driverName, ^String dataSourceName])

JOKER FUNC sql.OpenDB has:
;; (defn OpenDB
;;   "OpenDB opens a database using a Connector, allowing drivers to\nbypass a string based data source name.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpenDB may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the OpenDB\nfunction should be called just once. It is rarely necessary to\nclose a DB.\nGo return type: *DB\nJoker return type: {:waitDuration ^Int, :connector ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:354:12), :numClosed ^ABEND042(cannot find typename sql.uint64), :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:360:15), :freeConn ^(vector-of ABEND042(cannot find typename sql.driverConn)), :connRequests ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:362:15), :nextRequest ^ABEND042(cannot find typename sql.uint64), :numOpen ^Int, :openerCh ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:370:20), :resetterCh ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:371:20), :closed ^Bool, :dep ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:373:20), :lastPut ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:374:20), :maxIdle ^Int, :maxOpen ^Int, :maxLifetime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:377:20), :cleanerCh ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:378:20), :waitCount ^Int, :maxIdleClosed ^Int, :maxLifetimeClosed ^Int, :stop ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/database/sql/sql.go:383:7)}"
;;   {:added "1.0"
;;    :go "openDB(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:660:15) c])

JOKER FUNC sql.Register has:
;; (defn Register
;;   "Register makes a database driver available by the provided name.\nIf Register is called twice with the same name or if driver is nil,\nit panics.\n"
;;   {:added "1.0"
;;    :go "register(name, driver)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:44:35) driver])

JOKER FUNC strconv.AppendBool has:
;; (defn AppendBool
;;   "AppendBool appends \"true\" or \"false\", according to the value of b,\nto dst and returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendBool(dst, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/atob.go:30:21) dst, b])

JOKER FUNC strconv.AppendFloat has:
;; (defn AppendFloat
;;   "AppendFloat appends the string form of the floating-point number f,\nas generated by FormatFloat, to dst and returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendFloat(dst, f, fmt, prec, bitSize)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/ftoa.go:51:22) dst, f, fmt, ^Int prec, ^Int bitSize])

JOKER FUNC strconv.AppendInt has:
;; (defn AppendInt
;;   "AppendInt appends the string form of the integer i,\nas generated by FormatInt, to dst and returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendInt(dst, i, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/itoa.go:40:20) dst, i, ^Int base])

JOKER FUNC strconv.AppendQuote has:
;; (defn AppendQuote
;;   "AppendQuote appends a double-quoted Go string literal representing s,\nas generated by Quote, to dst and returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuote(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:117:22) dst, ^String s])

JOKER FUNC strconv.AppendQuoteRune has:
;; (defn AppendQuoteRune
;;   "AppendQuoteRune appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRune, to dst and returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteRune(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:156:26) dst, r])

JOKER FUNC strconv.AppendQuoteRuneToASCII has:
;; (defn AppendQuoteRuneToASCII
;;   "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToASCII, to dst and returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteRuneToASCII(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:170:33) dst, r])

JOKER FUNC strconv.AppendQuoteRuneToGraphic has:
;; (defn AppendQuoteRuneToGraphic
;;   "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToGraphic, to dst and returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteRuneToGraphic(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:184:35) dst, r])

JOKER FUNC strconv.AppendQuoteToASCII has:
;; (defn AppendQuoteToASCII
;;   "AppendQuoteToASCII appends a double-quoted Go string literal representing s,\nas generated by QuoteToASCII, to dst and returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteToASCII(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:130:29) dst, ^String s])

JOKER FUNC strconv.AppendQuoteToGraphic has:
;; (defn AppendQuoteToGraphic
;;   "AppendQuoteToGraphic appends a double-quoted Go string literal representing s,\nas generated by QuoteToGraphic, to dst and returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteToGraphic(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:143:31) dst, ^String s])

JOKER FUNC strconv.AppendUint has:
;; (defn AppendUint
;;   "AppendUint appends the string form of the unsigned integer i,\nas generated by FormatUint, to dst and returns the extended buffer.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendUint(dst, i, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/itoa.go:50:21) dst, i, ^Int base])

JOKER FUNC strconv.Atoi has:
;; (defn Atoi
;;   "Atoi returns the result of ParseInt(s, 10, 0) converted to type int.\nGo return type: (int, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "atoi(s)"}
;;   [^String s])

JOKER FUNC strconv.CanBackquote has:
(defn ^Bool CanBackquote
  "CanBackquote reports whether the string s can be represented\nunchanged as a single-line backquoted string without control\ncharacters other than tab.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "canBackquote(s)"}
  [^String s])

JOKER FUNC strconv.FormatBool has:
(defn ^String FormatBool
  "FormatBool returns \"true\" or \"false\" according to the value of b.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "formatBool(b)"}
  [b])

JOKER FUNC strconv.FormatFloat has:
(defn ^String FormatFloat
  "FormatFloat converts the floating-point number f to a string,\naccording to the format fmt and precision prec. It rounds the\nresult assuming that the original was obtained from a floating-point\nvalue of bitSize bits (32 for float32, 64 for float64).\n\nThe format fmt is one of\n'b' (-ddddp±ddd, a binary exponent),\n'e' (-d.dddde±dd, a decimal exponent),\n'E' (-d.ddddE±dd, a decimal exponent),\n'f' (-ddd.dddd, no exponent),\n'g' ('e' for large exponents, 'f' otherwise), or\n'G' ('E' for large exponents, 'f' otherwise).\n\nThe precision prec controls the number of digits (excluding the exponent)\nprinted by the 'e', 'E', 'f', 'g', and 'G' formats.\nFor 'e', 'E', and 'f' it is the number of digits after the decimal point.\nFor 'g' and 'G' it is the maximum number of significant digits (trailing\nzeros are removed).\nThe special precision -1 uses the smallest number of digits\nnecessary such that ParseFloat will return f exactly.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "formatFloat(f, fmt, prec, bitSize)"}
  [f, fmt, ^Int prec, ^Int bitSize])

JOKER FUNC strconv.FormatInt has:
(defn ^String FormatInt
  "FormatInt returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "formatInt(i, base)"}
  [i, ^Int base])

JOKER FUNC strconv.FormatUint has:
(defn ^String FormatUint
  "FormatUint returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "formatUint(i, base)"}
  [i, ^Int base])

JOKER FUNC strconv.IsGraphic has:
(defn ^Bool IsGraphic
  "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, and Zs.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isGraphic(r)"}
  [r])

JOKER FUNC strconv.IsPrint has:
(defn ^Bool IsPrint
  "IsPrint reports whether the rune is defined as printable by Go, with\nthe same definition as unicode.IsPrint: letters, numbers, punctuation,\nsymbols and ASCII space.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isPrint(r)"}
  [r])

JOKER FUNC strconv.Itoa has:
(defn ^String Itoa
  "Itoa is shorthand for FormatInt(int64(i), 10).\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "itoa(i)"}
  [^Int i])

JOKER FUNC strconv.ParseBool has:
;; (defn ParseBool
;;   "ParseBool returns the boolean value represented by the string.\nIt accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\nAny other value returns an error.\nGo return type: (bool, error)\nJoker return type: [Bool Error]"
;;   {:added "1.0"
;;    :go "parseBool(str)"}
;;   [^String str])

JOKER FUNC strconv.ParseFloat has:
;; (defn ParseFloat
;;   "ParseFloat converts the string s to a floating-point number\nwith the precision specified by bitSize: 32 for float32, or 64 for float64.\nWhen bitSize=32, the result still has type float64, but it will be\nconvertible to float32 without changing its value.\n\nIf s is well-formed and near a valid floating point number,\nParseFloat returns the nearest floating point number rounded\nusing IEEE754 unbiased rounding.\n\nThe errors that ParseFloat returns have concrete type *NumError\nand include err.Num = s.\n\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but is more than 1/2 ULP\naway from the largest floating point number of the given size,\nParseFloat returns f = ±Inf, err.Err = ErrRange.\nGo return type: (float64, error)\nJoker return type: [ABEND042(cannot find typename strconv.float64) Error]"
;;   {:added "1.0"
;;    :go "parseFloat(s, bitSize)"}
;;   [^String s, ^Int bitSize])

JOKER FUNC strconv.ParseInt has:
;; (defn ParseInt
;;   "ParseInt interprets a string s in the given base (0, 2 to 36) and\nbit size (0 to 64) and returns the corresponding value i.\n\nIf base == 0, the base is implied by the string's prefix:\nbase 16 for \"0x\", base 8 for \"0\", and base 10 otherwise.\nFor bases 1, below 0 or above 36 an error is returned.\n\nThe bitSize argument specifies the integer type\nthat the result must fit into. Bit sizes 0, 8, 16, 32, and 64\ncorrespond to int, int8, int16, int32, and int64.\nFor a bitSize below 0 or above 64 an error is returned.\n\nThe errors that ParseInt returns have concrete type *NumError\nand include err.Num = s. If s is empty or contains invalid\ndigits, err.Err = ErrSyntax and the returned value is 0;\nif the value corresponding to s cannot be represented by a\nsigned integer of the given size, err.Err = ErrRange and the\nreturned value is the maximum magnitude integer of the\nappropriate bitSize and sign.\nGo return type: (i int, err error)\nJoker return type: [^Int i ^Error err]"
;;   {:added "1.0"
;;    :go "parseInt(s, base, bitSize)"}
;;   [^String s, ^Int base, ^Int bitSize])

JOKER FUNC strconv.ParseUint has:
;; (defn ParseUint
;;   "ParseUint is like ParseInt but for unsigned numbers.\nGo return type: (uint64, error)\nJoker return type: [ABEND042(cannot find typename strconv.uint64) Error]"
;;   {:added "1.0"
;;    :go "parseUint(s, base, bitSize)"}
;;   [^String s, ^Int base, ^Int bitSize])

JOKER FUNC strconv.Quote has:
(defn ^String Quote
  "Quote returns a double-quoted Go string literal representing s. The\nreturned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\ncontrol characters and non-printable characters as defined by\nIsPrint.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "quote(s)"}
  [^String s])

JOKER FUNC strconv.QuoteRune has:
(defn ^String QuoteRune
  "QuoteRune returns a single-quoted Go character literal representing the\nrune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\nfor control characters and non-printable characters as defined by IsPrint.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "quoteRune(r)"}
  [r])

JOKER FUNC strconv.QuoteRuneToASCII has:
(defn ^String QuoteRuneToASCII
  "QuoteRuneToASCII returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsPrint.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "quoteRuneToASCII(r)"}
  [r])

JOKER FUNC strconv.QuoteRuneToGraphic has:
(defn ^String QuoteRuneToGraphic
  "QuoteRuneToGraphic returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsGraphic.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "quoteRuneToGraphic(r)"}
  [r])

JOKER FUNC strconv.QuoteToASCII has:
(defn ^String QuoteToASCII
  "QuoteToASCII returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsPrint.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "quoteToASCII(s)"}
  [^String s])

JOKER FUNC strconv.QuoteToGraphic has:
(defn ^String QuoteToGraphic
  "QuoteToGraphic returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsGraphic.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "quoteToGraphic(s)"}
  [^String s])

JOKER FUNC strconv.Unquote has:
;; (defn Unquote
;;   "Unquote interprets s as a single-quoted, double-quoted,\nor backquoted Go string literal, returning the string value\nthat s quotes.  (If s is single-quoted, it would be a Go\ncharacter literal; Unquote returns the corresponding\none-character string.)\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "unquote(s)"}
;;   [^String s])

JOKER FUNC strconv.UnquoteChar has:
;; (defn UnquoteChar
;;   "UnquoteChar decodes the first character or byte in the escaped string\nor character literal represented by the string s.\nIt returns four values:\n\n\t1) value, the decoded Unicode code point or byte value;\n\t2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n\t3) tail, the remainder of the string after the character; and\n\t4) an error that will be nil if the character is syntactically valid.\n\nThe second argument, quote, specifies the type of literal being parsed\nand therefore which escaped quote character is permitted.\nIf set to a single quote, it permits the sequence \\' and disallows unescaped '.\nIf set to a double quote, it permits \\\" and disallows unescaped \".\nIf set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\nGo return type: (value rune, multibyte bool, tail string, err error)\nJoker return type: [^ABEND042(cannot find typename strconv.rune) value ^Bool multibyte ^String tail ^Error err]"
;;   {:added "1.0"
;;    :go "unquoteChar(s, quote)"}
;;   [^String s, quote])

JOKER FUNC strings.Compare has:
(defn ^Int Compare
  "Compare returns an integer comparing two strings lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n\nCompare is included only for symmetry with package bytes.\nIt is usually clearer and always faster to use the built-in\nstring comparison operators ==, <, >, and so on.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "compare(a, b)"}
  [^String a, ^String b])

JOKER FUNC strings.Contains has:
(defn ^Bool Contains
  "Contains reports whether substr is within s.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "contains(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.ContainsAny has:
(defn ^Bool ContainsAny
  "ContainsAny reports whether any Unicode code points in chars are within s.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "containsAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.ContainsRune has:
(defn ^Bool ContainsRune
  "ContainsRune reports whether the Unicode code point r is within s.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "containsRune(s, r)"}
  [^String s, r])

JOKER FUNC strings.Count has:
(defn ^Int Count
  "Count counts the number of non-overlapping instances of substr in s.\nIf substr is an empty string, Count returns 1 + the number of Unicode code points in s.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "count(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.EqualFold has:
(defn ^Bool EqualFold
  "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "equalFold(s, t)"}
  [^String s, ^String t])

JOKER FUNC strings.Fields has:
;; (defn Fields
;;   "Fields splits the string s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of substrings of s or an\nempty slice if s contains only white space.\nGo return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "fields(s)"}
;;   [^String s])

JOKER FUNC strings.FieldsFunc has:
;; (defn FieldsFunc
;;   "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\nand returns an array of slices of s. If all code points in s satisfy f(c) or the\nstring is empty, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\nGo return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "fieldsFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:378:29) f])

JOKER FUNC strings.HasPrefix has:
(defn ^Bool HasPrefix
  "HasPrefix tests whether the string s begins with prefix.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "hasPrefix(s, prefix)"}
  [^String s, ^String prefix])

JOKER FUNC strings.HasSuffix has:
(defn ^Bool HasSuffix
  "HasSuffix tests whether the string s ends with suffix.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "hasSuffix(s, suffix)"}
  [^String s, ^String suffix])

JOKER FUNC strings.Index has:
(defn ^Int Index
  "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "index(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.IndexAny has:
(defn ^Int IndexAny
  "IndexAny returns the index of the first instance of any Unicode code point\nfrom chars in s, or -1 if no Unicode code point from chars is present in s.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "indexAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.IndexByte has:
(defn ^Int IndexByte
  "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "indexByte(s, c)"}
  [^String s, c])

JOKER FUNC strings.IndexFunc has:
;; (defn ^Int IndexFunc
;;   "IndexFunc returns the index into s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "indexFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:713:28) f])

JOKER FUNC strings.IndexRune has:
(defn ^Int IndexRune
  "IndexRune returns the index of the first instance of the Unicode code point\nr, or -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "indexRune(s, r)"}
  [^String s, r])

JOKER FUNC strings.Join has:
;; (defn ^String Join
;;   "Join concatenates the elements of a to create a single string. The separator string\nsep is placed between elements in the resulting string.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "join(a, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strings/strings.go:420:13) a, ^String sep])

JOKER FUNC strings.LastIndex has:
(defn ^Int LastIndex
  "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "lastIndex(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.LastIndexAny has:
(defn ^Int LastIndexAny
  "LastIndexAny returns the index of the last instance of any Unicode code\npoint from chars in s, or -1 if no Unicode code point from chars is\npresent in s.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "lastIndexAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.LastIndexByte has:
(defn ^Int LastIndexByte
  "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "lastIndexByte(s, c)"}
  [^String s, c])

JOKER FUNC strings.LastIndexFunc has:
;; (defn ^Int LastIndexFunc
;;   "LastIndexFunc returns the index into s of the last\nUnicode code point satisfying f(c), or -1 if none do.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "lastIndexFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:719:32) f])

JOKER FUNC strings.Map has:
;; (defn ^String Map
;;   "Map returns a copy of the string s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the string with no replacement.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "map(mapping, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:462:18) mapping, ^String s])

JOKER FUNC strings.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from s.\nIt is similar to bytes.NewBufferString but more efficient and read-only.\nGo return type: *Reader\nJoker return type: {:s ^String, :i ^Int, :prevRune ^Int}"
;;   {:added "1.0"
;;    :go "newReader(s)"}
;;   [^String s])

JOKER FUNC strings.NewReplacer has:
;; (defn NewReplacer
;;   "NewReplacer returns a new Replacer from a list of old, new string\npairs. Replacements are performed in the order they appear in the\ntarget string, without overlapping matches.\nGo return type: *Replacer\nJoker return type: {:r ^ABEND042(cannot find typename strings.replacer)}"
;;   {:added "1.0"
;;    :go "newReplacer(oldnew)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/strings/replace.go:24:25) oldnew])

JOKER FUNC strings.Repeat has:
(defn ^String Repeat
  "Repeat returns a new string consisting of count copies of the string s.\n\nIt panics if count is negative or if\nthe result of (len(s) * count) overflows.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "repeat(s, count)"}
  [^String s, ^Int count])

JOKER FUNC strings.Replace has:
(defn ^String Replace
  "Replace returns a copy of the string s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the string\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune string.\nIf n < 0, there is no limit on the number of replacements.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "replace(s, old, new, n)"}
  [^String s, ^String old, ^String new, ^Int n])

JOKER FUNC strings.Split has:
;; (defn Split
;;   "Split slices s into all substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nIf s does not contain sep and sep is not empty, Split returns a\nslice of length 1 whose only element is s.\n\nIf sep is empty, Split splits after each UTF-8 sequence. If both s\nand sep are empty, Split returns an empty slice.\n\nIt is equivalent to SplitN with a count of -1.\nGo return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "split(s, sep)"}
;;   [^String s, ^String sep])

JOKER FUNC strings.SplitAfter has:
;; (defn SplitAfter
;;   "SplitAfter slices s into all substrings after each instance of sep and\nreturns a slice of those substrings.\n\nIf s does not contain sep and sep is not empty, SplitAfter returns\na slice of length 1 whose only element is s.\n\nIf sep is empty, SplitAfter splits after each UTF-8 sequence. If\nboth s and sep are empty, SplitAfter returns an empty slice.\n\nIt is equivalent to SplitAfterN with a count of -1.\nGo return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "splitAfter(s, sep)"}
;;   [^String s, ^String sep])

JOKER FUNC strings.SplitAfterN has:
;; (defn SplitAfterN
;;   "SplitAfterN slices s into substrings after each instance of sep and\nreturns a slice of those substrings.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for SplitAfter.\nGo return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "splitAfterN(s, sep, n)"}
;;   [^String s, ^String sep, ^Int n])

JOKER FUNC strings.SplitN has:
;; (defn SplitN
;;   "SplitN slices s into substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for Split.\nGo return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "splitN(s, sep, n)"}
;;   [^String s, ^String sep, ^Int n])

JOKER FUNC strings.Title has:
(defn ^String Title
  "Title returns a copy of the string s with all Unicode letters that begin words\nmapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "title(s)"}
  [^String s])

JOKER FUNC strings.ToLower has:
(defn ^String ToLower
  "ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "toLower(s)"}
  [^String s])

JOKER FUNC strings.ToLowerSpecial has:
;; (defn ^String ToLowerSpecial
;;   "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "toLowerSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/strings/strings.go:626:23) c, ^String s])

JOKER FUNC strings.ToTitle has:
(defn ^String ToTitle
  "ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "toTitle(s)"}
  [^String s])

JOKER FUNC strings.ToTitleSpecial has:
;; (defn ^String ToTitleSpecial
;;   "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "toTitleSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/strings/strings.go:632:23) c, ^String s])

JOKER FUNC strings.ToUpper has:
(defn ^String ToUpper
  "ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "toUpper(s)"}
  [^String s])

JOKER FUNC strings.ToUpperSpecial has:
;; (defn ^String ToUpperSpecial
;;   "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "toUpperSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/strings/strings.go:620:23) c, ^String s])

JOKER FUNC strings.Trim has:
(defn ^String Trim
  "Trim returns a slice of the string s with all leading and\ntrailing Unicode code points contained in cutset removed.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "trim(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimFunc has:
;; (defn ^String TrimFunc
;;   "TrimFunc returns a slice of the string s with all leading\nand trailing Unicode code points c satisfying f(c) removed.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "trimFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:707:27) f])

JOKER FUNC strings.TrimLeft has:
(defn ^String TrimLeft
  "TrimLeft returns a slice of the string s with all leading\nUnicode code points contained in cutset removed.\n\nTo remove a prefix, use TrimPrefix instead.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "trimLeft(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimLeftFunc has:
;; (defn ^String TrimLeftFunc
;;   "TrimLeftFunc returns a slice of the string s with all leading\nUnicode code points c satisfying f(c) removed.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "trimLeftFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:684:31) f])

JOKER FUNC strings.TrimPrefix has:
(defn ^String TrimPrefix
  "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "trimPrefix(s, prefix)"}
  [^String s, ^String prefix])

JOKER FUNC strings.TrimRight has:
(defn ^String TrimRight
  "TrimRight returns a slice of the string s, with all trailing\nUnicode code points contained in cutset removed.\n\nTo remove a suffix, use TrimSuffix instead.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "trimRight(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimRightFunc has:
;; (defn ^String TrimRightFunc
;;   "TrimRightFunc returns a slice of the string s with all trailing\nUnicode code points c satisfying f(c) removed.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "trimRightFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:694:32) f])

JOKER FUNC strings.TrimSpace has:
(defn ^String TrimSpace
  "TrimSpace returns a slice of the string s, with all leading\nand trailing white space removed, as defined by Unicode.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "trimSpace(s)"}
  [^String s])

JOKER FUNC strings.TrimSuffix has:
(defn ^String TrimSuffix
  "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "trimSuffix(s, suffix)"}
  [^String s, ^String suffix])

JOKER FUNC subtle.ConstantTimeByteEq has:
(defn ^Int ConstantTimeByteEq
  "ConstantTimeByteEq returns 1 if x == y and 0 otherwise.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "constantTimeByteEq(x, y)"}
  [x, y])

JOKER FUNC subtle.ConstantTimeCompare has:
;; (defn ^Int ConstantTimeCompare
;;   "ConstantTimeCompare returns 1 if and only if the two slices, x\nand y, have equal contents. The time taken is a function of the length of\nthe slices and is independent of the contents.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "constantTimeCompare(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:12:31) x, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:12:31) y])

JOKER FUNC subtle.ConstantTimeCopy has:
;; (defn ConstantTimeCopy
;;   "ConstantTimeCopy copies the contents of y into x (a slice of equal length)\nif v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v\ntakes any other value.\n"
;;   {:added "1.0"
;;    :go "constantTimeCopy(v, x, y)"}
;;   [^Int v, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:43:35) x, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:43:35) y])

JOKER FUNC subtle.ConstantTimeEq has:
(defn ^Int ConstantTimeEq
  "ConstantTimeEq returns 1 if x == y and 0 otherwise.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "constantTimeEq(x, y)"}
  [x, y])

JOKER FUNC subtle.ConstantTimeLessOrEq has:
(defn ^Int ConstantTimeLessOrEq
  "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise.\nIts behavior is undefined if x or y are negative or > 2**31 - 1.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "constantTimeLessOrEq(x, y)"}
  [^Int x, ^Int y])

JOKER FUNC subtle.ConstantTimeSelect has:
(defn ^Int ConstantTimeSelect
  "ConstantTimeSelect returns x if v is 1 and y if v is 0.\nIts behavior is undefined if v takes any other value.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "constantTimeSelect(v, x, y)"}
  [^Int v, ^Int x, ^Int y])

JOKER FUNC suffixarray.New has:
;; (defn New
;;   "New creates a new Index for data.\nIndex creation time is O(N*log(N)) for N = len(data).\nGo return type: *Index\nJoker return type: {:data ^(vector-of Int), :sa ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "new(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/index/suffixarray/suffixarray.go:35:15) data])

JOKER FUNC sync.NewCond has:
;; (defn NewCond
;;   "NewCond returns a new Cond with Locker l.\nGo return type: *Cond\nJoker return type: {:noCopy ^ABEND042(cannot find typename sync.noCopy), :L ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sync/mutex.go:31:13), :notify ^ABEND042(cannot find typename sync.notifyList), :checker ^ABEND042(cannot find typename sync.copyChecker)}"
;;   {:added "1.0"
;;    :go "newCond(l)"}
;;   [l])

JOKER FUNC syntax.Compile has:
;; (defn Compile
;;   "Compile compiles the regexp into a program to be executed.\nThe regexp should have been simplified already (returned from re.Simplify).\nGo return type: (*Prog, error)\nJoker return type: [{:Inst ^(vector-of {:Op ^ABEND042(cannot find typename syntax.uint8), :Out ^Int, :Arg ^Int, :Rune ^(vector-of ABEND042(cannot find typename syntax.rune))}), :Start ^Int, :NumCap ^Int} Error]"
;;   {:added "1.0"
;;    :go "compile(re)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/regexp/syntax/compile.go:80:17) re])

JOKER FUNC syntax.EmptyOpContext has:
;; (defn EmptyOpContext
;;   "EmptyOpContext returns the zero-width assertions\nsatisfied at the position between the runes r1 and r2.\nPassing r1 == -1 indicates that the position is\nat the beginning of the text.\nPassing r2 == -1 indicates that the position is\nat the end of the text.\nGo return type: EmptyOp\nJoker return type: ABEND042(cannot find typename syntax.uint8)"
;;   {:added "1.0"
;;    :go "emptyOpContext(r1, r2)"}
;;   [r1, r2])

JOKER FUNC syntax.IsWordChar has:
(defn ^Bool IsWordChar
  "IsWordChar reports whether r is consider a ``word character''\nduring the evaluation of the \\b and \\B zero-width assertions.\nThese assertions are ASCII-only: the word characters are [A-Za-z0-9_].\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isWordChar(r)"}
  [r])

JOKER FUNC syntax.Parse has:
;; (defn Parse
;;   "Parse parses a regular expression string s, controlled by the specified\nFlags, and returns a regular expression parse tree. The syntax is\ndescribed in the top-level comment.\nGo return type: (*Regexp, error)\nJoker return type: [{:Op ^ABEND042(cannot find typename syntax.uint8), :Flags ^Int, :Sub ^(vector-of ABEND947(recursive type reference involving syntax.Regexp)), :Sub0 ^(vector-of ABEND947(recursive type reference involving syntax.Regexp)), :Rune ^(vector-of ABEND042(cannot find typename syntax.rune)), :Rune0 ^(vector-of ABEND042(cannot find typename syntax.rune)), :Min ^Int, :Max ^Int, :Cap ^Int, :Name ^String} Error]"
;;   {:added "1.0"
;;    :go "parse(s, flags)"}
;;   [^String s, flags])

JOKER FUNC syscall.Accept has:
;; (defn Accept
;;   "Go return type: (nfd int, sa Sockaddr, err error)\nJoker return type: [^Int nfd ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/syscall/syscall_unix.go:205:15) sa ^Error err]"
;;   {:added "1.0"
;;    :go "accept(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.Access has:
;; (defn Access
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "access(path, mode)"}
;;   [^String path, mode])

JOKER FUNC syscall.Adjtime has:
;; (defn Adjtime
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "adjtime(delta, olddelta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:311:20) delta, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:311:39) olddelta])

JOKER FUNC syscall.Bind has:
;; (defn Bind
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "bind(fd, sa)"}
;;   [^Int fd, sa])

JOKER FUNC syscall.BpfBuflen has:
;; (defn BpfBuflen
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: (int, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "bpfBuflen(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.BpfDatalink has:
;; (defn BpfDatalink
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: (int, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "bpfDatalink(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.BpfHeadercmpl has:
;; (defn BpfHeadercmpl
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: (int, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "bpfHeadercmpl(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.BpfInterface has:
;; (defn BpfInterface
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "bpfInterface(fd, name)"}
;;   [^Int fd, ^String name])

JOKER FUNC syscall.BpfJump has:
;; (defn BpfJump
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: *BpfInsn\nJoker return type: {:Code ^Int, :Jt ^ABEND042(cannot find typename syscall.uint8), :Jf ^ABEND042(cannot find typename syscall.uint8), :K ^Int}"
;;   {:added "1.0"
;;    :go "bpfJump(code, k, jt, jf)"}
;;   [^Int code, ^Int k, ^Int jt, ^Int jf])

JOKER FUNC syscall.BpfStats has:
;; (defn BpfStats
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: (*BpfStat, error)\nJoker return type: [{:Recv ^Int, :Drop ^Int} Error]"
;;   {:added "1.0"
;;    :go "bpfStats(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.BpfStmt has:
;; (defn BpfStmt
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: *BpfInsn\nJoker return type: {:Code ^Int, :Jt ^ABEND042(cannot find typename syscall.uint8), :Jf ^ABEND042(cannot find typename syscall.uint8), :K ^Int}"
;;   {:added "1.0"
;;    :go "bpfStmt(code, k)"}
;;   [^Int code, ^Int k])

JOKER FUNC syscall.BpfTimeout has:
;; (defn BpfTimeout
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: (*Timeval, error)\nJoker return type: [{:Sec ^Int, :Usec ^Int, :Pad_cgo_0 ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "bpfTimeout(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.BytePtrFromString has:
;; (defn BytePtrFromString
;;   "BytePtrFromString returns a pointer to a NUL-terminated array of\nbytes containing the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\nGo return type: (*int, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "bytePtrFromString(s)"}
;;   [^String s])

JOKER FUNC syscall.ByteSliceFromString has:
;; (defn ByteSliceFromString
;;   "ByteSliceFromString returns a NUL-terminated slice of bytes\ncontaining the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "byteSliceFromString(s)"}
;;   [^String s])

JOKER FUNC syscall.Chdir has:
;; (defn Chdir
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "chdir(path)"}
;;   [^String path])

JOKER FUNC syscall.CheckBpfVersion has:
(defn ^Error CheckBpfVersion
  "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "checkBpfVersion(fd)"}
  [^Int fd])

JOKER FUNC syscall.Chflags has:
;; (defn Chflags
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "chflags(path, flags)"}
;;   [^String path, ^Int flags])

JOKER FUNC syscall.Chmod has:
;; (defn Chmod
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "chmod(path, mode)"}
;;   [^String path, mode])

JOKER FUNC syscall.Chown has:
;; (defn Chown
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "chown(path, uid, gid)"}
;;   [^String path, ^Int uid, ^Int gid])

JOKER FUNC syscall.Chroot has:
;; (defn Chroot
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "chroot(path)"}
;;   [^String path])

JOKER FUNC syscall.Clearenv has:
;; (defn Clearenv
;;   ""
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])

JOKER FUNC syscall.Close has:
;; (defn Close
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "close(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.CloseOnExec has:
;; (defn CloseOnExec
;;   ""
;;   {:added "1.0"
;;    :go "closeOnExec(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.CmsgLen has:
(defn ^Int CmsgLen
  "CmsgLen returns the value to store in the Len field of the Cmsghdr\nstructure, taking into account any necessary alignment.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "cmsgLen(datalen)"}
  [^Int datalen])

JOKER FUNC syscall.CmsgSpace has:
(defn ^Int CmsgSpace
  "CmsgSpace returns the number of bytes an ancillary element with\npayload of the passed data length occupies.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "cmsgSpace(datalen)"}
  [^Int datalen])

JOKER FUNC syscall.Connect has:
;; (defn Connect
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "connect(fd, sa)"}
;;   [^Int fd, sa])

JOKER FUNC syscall.Dup has:
;; (defn Dup
;;   "Go return type: (nfd int, err error)\nJoker return type: [^Int nfd ^Error err]"
;;   {:added "1.0"
;;    :go "dup(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.Dup2 has:
;; (defn Dup2
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "dup2(from, to)"}
;;   [^Int from, ^Int to])

JOKER FUNC syscall.Environ has:
;; (defn Environ
;;   "Go return type: []string\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "environ()"}
;;   [])

JOKER FUNC syscall.Exchangedata has:
;; (defn Exchangedata
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "exchangedata(path1, path2, options)"}
;;   [^String path1, ^String path2, ^Int options])

JOKER FUNC syscall.Exec has:
;; (defn Exec
;;   "Exec invokes the execve(2) system call.\nGo return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "exec(argv0, argv, envv)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:254:30) argv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:254:45) envv])

JOKER FUNC syscall.Exit has:
;; (defn Exit
;;   ""
;;   {:added "1.0"
;;    :go "exit(code)"}
;;   [^Int code])

JOKER FUNC syscall.Fchdir has:
;; (defn Fchdir
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "fchdir(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.Fchflags has:
;; (defn Fchflags
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "fchflags(fd, flags)"}
;;   [^Int fd, ^Int flags])

JOKER FUNC syscall.Fchmod has:
;; (defn Fchmod
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "fchmod(fd, mode)"}
;;   [^Int fd, mode])

JOKER FUNC syscall.Fchown has:
;; (defn Fchown
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "fchown(fd, uid, gid)"}
;;   [^Int fd, ^Int uid, ^Int gid])

JOKER FUNC syscall.FcntlFlock has:
;; (defn ^Error FcntlFlock
;;   "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fcntlFlock(fd, cmd, lk)"}
;;   [fd, ^Int cmd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/flock.go:16:41) lk])

JOKER FUNC syscall.Flock has:
;; (defn Flock
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "flock(fd, how)"}
;;   [^Int fd, ^Int how])

JOKER FUNC syscall.FlushBpf has:
(defn ^Error FlushBpf
  "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "flushBpf(fd)"}
  [^Int fd])

JOKER FUNC syscall.ForkExec has:
;; (defn ForkExec
;;   "Combination of fork and exec, careful to be thread safe.\nGo return type: (pid int, err error)\nJoker return type: [^Int pid ^Error err]"
;;   {:added "1.0"
;;    :go "forkExec(argv0, argv, attr)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:235:34) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/exec_unix.go:235:49) attr])

JOKER FUNC syscall.Fpathconf has:
;; (defn Fpathconf
;;   "Go return type: (val int, err error)\nJoker return type: [^Int val ^Error err]"
;;   {:added "1.0"
;;    :go "fpathconf(fd, name)"}
;;   [^Int fd, ^Int name])

JOKER FUNC syscall.Fstat has:
;; (defn Fstat
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "fstat(fd, stat)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:508:25) stat])

JOKER FUNC syscall.Fstatfs has:
;; (defn Fstatfs
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "fstatfs(fd, stat)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:518:27) stat])

JOKER FUNC syscall.Fsync has:
;; (defn Fsync
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "fsync(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.Ftruncate has:
;; (defn Ftruncate
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "ftruncate(fd, length)"}
;;   [^Int fd, length])

JOKER FUNC syscall.Futimes has:
;; (defn Futimes
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "futimes(fd, tv)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:533:25) tv])

JOKER FUNC syscall.Getdirentries has:
;; (defn Getdirentries
;;   "Go return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "getdirentries(fd, buf, basep)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:548:32) buf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:548:46) basep])

JOKER FUNC syscall.Getdtablesize has:
;; (defn Getdtablesize
;;   "Go return type: size int\nJoker return type: ^Int size"
;;   {:added "1.0"
;;    :go "getdtablesize()"}
;;   [])

JOKER FUNC syscall.Getegid has:
;; (defn Getegid
;;   "Go return type: egid int\nJoker return type: ^Int egid"
;;   {:added "1.0"
;;    :go "getegid()"}
;;   [])

JOKER FUNC syscall.Getenv has:
;; (defn Getenv
;;   "Go return type: (value string, found bool)\nJoker return type: [^String value ^Bool found]"
;;   {:added "1.0"
;;    :go "getenv(key)"}
;;   [^String key])

JOKER FUNC syscall.Geteuid has:
;; (defn Geteuid
;;   "Go return type: uid int\nJoker return type: ^Int uid"
;;   {:added "1.0"
;;    :go "geteuid()"}
;;   [])

JOKER FUNC syscall.Getfsstat has:
;; (defn Getfsstat
;;   "Go return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "getfsstat(buf, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_darwin.go:176:20) buf, ^Int flags])

JOKER FUNC syscall.Getgid has:
;; (defn Getgid
;;   "Go return type: gid int\nJoker return type: ^Int gid"
;;   {:added "1.0"
;;    :go "getgid()"}
;;   [])

JOKER FUNC syscall.Getgroups has:
;; (defn Getgroups
;;   "Go return type: (gids []int, err error)\nJoker return type: [^(vector-of Int) gids ^Error err]"
;;   {:added "1.0"
;;    :go "getgroups()"}
;;   [])

JOKER FUNC syscall.Getpagesize has:
(defn ^Int Getpagesize
  "Go return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "getpagesize()"}
  [])

JOKER FUNC syscall.Getpeername has:
;; (defn Getpeername
;;   "Go return type: (sa Sockaddr, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/syscall/syscall_unix.go:205:15) sa ^Error err]"
;;   {:added "1.0"
;;    :go "getpeername(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.Getpgid has:
;; (defn Getpgid
;;   "Go return type: (pgid int, err error)\nJoker return type: [^Int pgid ^Error err]"
;;   {:added "1.0"
;;    :go "getpgid(pid)"}
;;   [^Int pid])

JOKER FUNC syscall.Getpgrp has:
;; (defn Getpgrp
;;   "Go return type: pgrp int\nJoker return type: ^Int pgrp"
;;   {:added "1.0"
;;    :go "getpgrp()"}
;;   [])

JOKER FUNC syscall.Getpid has:
;; (defn Getpid
;;   "Go return type: pid int\nJoker return type: ^Int pid"
;;   {:added "1.0"
;;    :go "getpid()"}
;;   [])

JOKER FUNC syscall.Getppid has:
;; (defn Getppid
;;   "Go return type: ppid int\nJoker return type: ^Int ppid"
;;   {:added "1.0"
;;    :go "getppid()"}
;;   [])

JOKER FUNC syscall.Getpriority has:
;; (defn Getpriority
;;   "Go return type: (prio int, err error)\nJoker return type: [^Int prio ^Error err]"
;;   {:added "1.0"
;;    :go "getpriority(which, who)"}
;;   [^Int which, ^Int who])

JOKER FUNC syscall.Getrlimit has:
;; (defn Getrlimit
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "getrlimit(which, lim)"}
;;   [^Int which, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:643:31) lim])

JOKER FUNC syscall.Getrusage has:
;; (defn Getrusage
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "getrusage(who, rusage)"}
;;   [^Int who, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:653:32) rusage])

JOKER FUNC syscall.Getsid has:
;; (defn Getsid
;;   "Go return type: (sid int, err error)\nJoker return type: [^Int sid ^Error err]"
;;   {:added "1.0"
;;    :go "getsid(pid)"}
;;   [^Int pid])

JOKER FUNC syscall.Getsockname has:
;; (defn Getsockname
;;   "Go return type: (sa Sockaddr, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/syscall/syscall_unix.go:205:15) sa ^Error err]"
;;   {:added "1.0"
;;    :go "getsockname(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.GetsockoptByte has:
;; (defn GetsockoptByte
;;   "Go return type: (value int, err error)\nJoker return type: [^Int value ^Error err]"
;;   {:added "1.0"
;;    :go "getsockoptByte(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptICMPv6Filter has:
;; (defn GetsockoptICMPv6Filter
;;   "Go return type: (*ICMPv6Filter, error)\nJoker return type: [{:Filt ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "getsockoptICMPv6Filter(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPMreq has:
;; (defn GetsockoptIPMreq
;;   "Go return type: (*IPMreq, error)\nJoker return type: [{:Multiaddr ^(vector-of Int), :Interface ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "getsockoptIPMreq(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPv6MTUInfo has:
;; (defn GetsockoptIPv6MTUInfo
;;   "Go return type: (*IPv6MTUInfo, error)\nJoker return type: [{:Addr ^{:Len ^ABEND042(cannot find typename syscall.uint8), :Family ^ABEND042(cannot find typename syscall.uint8), :Port ^Int, :Flowinfo ^Int, :Addr ^(vector-of Int), :Scope_id ^Int}, :Mtu ^Int} Error]"
;;   {:added "1.0"
;;    :go "getsockoptIPv6MTUInfo(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPv6Mreq has:
;; (defn GetsockoptIPv6Mreq
;;   "Go return type: (*IPv6Mreq, error)\nJoker return type: [{:Multiaddr ^(vector-of Int), :Interface ^Int} Error]"
;;   {:added "1.0"
;;    :go "getsockoptIPv6Mreq(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptInet4Addr has:
;; (defn GetsockoptInet4Addr
;;   "Go return type: (value []int, err error)\nJoker return type: [^(vector-of Int) value ^Error err]"
;;   {:added "1.0"
;;    :go "getsockoptInet4Addr(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptInt has:
;; (defn GetsockoptInt
;;   "Go return type: (value int, err error)\nJoker return type: [^Int value ^Error err]"
;;   {:added "1.0"
;;    :go "getsockoptInt(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.Gettimeofday has:
;; (defn ^Error Gettimeofday
;;   "sysnb\tgettimeofday(tp *Timeval) (sec int64, usec int32, err error)\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gettimeofday(tv)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_darwin_amd64.go:18:22) tv])

JOKER FUNC syscall.Getuid has:
;; (defn Getuid
;;   "Go return type: uid int\nJoker return type: ^Int uid"
;;   {:added "1.0"
;;    :go "getuid()"}
;;   [])

JOKER FUNC syscall.Getwd has:
;; (defn Getwd
;;   "Go return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "getwd()"}
;;   [])

JOKER FUNC syscall.Issetugid has:
;; (defn Issetugid
;;   "Go return type: tainted bool\nJoker return type: ^Bool tainted"
;;   {:added "1.0"
;;    :go "issetugid()"}
;;   [])

JOKER FUNC syscall.Kevent has:
;; (defn Kevent
;;   "Go return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "kevent(kq, changes, events, timeout)"}
;;   [^Int kq, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:439:37) changes, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:439:37) events, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_bsd.go:439:57) timeout])

JOKER FUNC syscall.Kill has:
;; (defn Kill
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "kill(pid, signum)"}
;;   [^Int pid, signum])

JOKER FUNC syscall.Kqueue has:
;; (defn Kqueue
;;   "Go return type: (fd int, err error)\nJoker return type: [^Int fd ^Error err]"
;;   {:added "1.0"
;;    :go "kqueue()"}
;;   [])

JOKER FUNC syscall.Lchown has:
;; (defn Lchown
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "lchown(path, uid, gid)"}
;;   [^String path, ^Int uid, ^Int gid])

JOKER FUNC syscall.Link has:
;; (defn Link
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "link(path, link)"}
;;   [^String path, ^String link])

JOKER FUNC syscall.Listen has:
;; (defn Listen
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "listen(s, backlog)"}
;;   [^Int s, ^Int backlog])

JOKER FUNC syscall.Lstat has:
;; (defn Lstat
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "lstat(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:746:30) stat])

JOKER FUNC syscall.Mkdir has:
;; (defn Mkdir
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "mkdir(path, mode)"}
;;   [^String path, mode])

JOKER FUNC syscall.Mkfifo has:
;; (defn Mkfifo
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "mkfifo(path, mode)"}
;;   [^String path, mode])

JOKER FUNC syscall.Mknod has:
;; (defn Mknod
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "mknod(path, mode, dev)"}
;;   [^String path, mode, ^Int dev])

JOKER FUNC syscall.Mlock has:
;; (defn Mlock
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "mlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:806:14) b])

JOKER FUNC syscall.Mlockall has:
;; (defn Mlockall
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "mlockall(flags)"}
;;   [^Int flags])

JOKER FUNC syscall.Mmap has:
;; (defn Mmap
;;   "Go return type: (data []int, err error)\nJoker return type: [^(vector-of Int) data ^Error err]"
;;   {:added "1.0"
;;    :go "mmap(fd, offset, length, prot, flags)"}
;;   [^Int fd, offset, ^Int length, ^Int prot, ^Int flags])

JOKER FUNC syscall.Mprotect has:
;; (defn Mprotect
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "mprotect(b, prot)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:832:17) b, ^Int prot])

JOKER FUNC syscall.Munlock has:
;; (defn Munlock
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "munlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:848:16) b])

JOKER FUNC syscall.Munlockall has:
;; (defn Munlockall
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "munlockall()"}
;;   [])

JOKER FUNC syscall.Munmap has:
;; (defn Munmap
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "munmap(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:552:15) b])

JOKER FUNC syscall.NsecToTimespec has:
;; (defn NsecToTimespec
;;   "NsecToTimespec takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timespec value.\nGo return type: Timespec\nJoker return type: {:Sec ^Int, :Nsec ^Int}"
;;   {:added "1.0"
;;    :go "nsecToTimespec(nsec)"}
;;   [nsec])

JOKER FUNC syscall.NsecToTimeval has:
;; (defn NsecToTimeval
;;   "NsecToTimeval takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timeval value.\nGo return type: Timeval\nJoker return type: {:Sec ^Int, :Usec ^Int, :Pad_cgo_0 ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "nsecToTimeval(nsec)"}
;;   [nsec])

JOKER FUNC syscall.Open has:
;; (defn Open
;;   "Go return type: (fd int, err error)\nJoker return type: [^Int fd ^Error err]"
;;   {:added "1.0"
;;    :go "open(path, mode, perm)"}
;;   [^String path, ^Int mode, perm])

JOKER FUNC syscall.ParseDirent has:
;; (defn ParseDirent
;;   "ParseDirent parses up to max directory entries in buf,\nappending the names to names. It returns the number of\nbytes consumed from buf, the number of entries added\nto names, and the new names slice.\nGo return type: (consumed int, count int, newnames []string)\nJoker return type: [^Int consumed ^Int count ^(vector-of String) newnames]"
;;   {:added "1.0"
;;    :go "parseDirent(buf, max, names)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/dirent.go:64:22) buf, ^Int max, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/dirent.go:64:45) names])

JOKER FUNC syscall.ParseRoutingMessage has:
;; (defn ParseRoutingMessage
;;   "ParseRoutingMessage parses b as routing messages and returns the\nslice containing the RoutingMessage interfaces.\n\nDeprecated: Use golang.org/x/net/route instead.\nGo return type: (msgs []RoutingMessage, err error)\nJoker return type: [^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/syscall/route_bsd.go:201:21)) msgs ^Error err]"
;;   {:added "1.0"
;;    :go "parseRoutingMessage(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/route_bsd.go:331:28) b])

JOKER FUNC syscall.ParseRoutingSockaddr has:
;; (defn ParseRoutingSockaddr
;;   "ParseRoutingSockaddr parses msg's payload as raw sockaddrs and\nreturns the slice containing the Sockaddr interfaces.\n\nDeprecated: Use golang.org/x/net/route instead.\nGo return type: ([]Sockaddr, error)\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/syscall/syscall_unix.go:205:15)) Error]"
;;   {:added "1.0"
;;    :go "parseRoutingSockaddr(msg)"}
;;   [msg])

JOKER FUNC syscall.ParseSocketControlMessage has:
;; (defn ParseSocketControlMessage
;;   "ParseSocketControlMessage parses b as an array of socket control\nmessages.\nGo return type: ([]SocketControlMessage, error)\nJoker return type: [(vector-of {:Header ^{:Len ^Int, :Level ^Int, :Type ^Int}, :Data ^(vector-of Int)}) Error]"
;;   {:added "1.0"
;;    :go "parseSocketControlMessage(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/sockcmsg_unix.go:49:34) b])

JOKER FUNC syscall.ParseUnixRights has:
;; (defn ParseUnixRights
;;   "ParseUnixRights decodes a socket control message that contains an\ninteger array of open file descriptors from another process.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "parseUnixRights(m)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/sockcmsg_unix.go:91:24) m])

JOKER FUNC syscall.Pathconf has:
;; (defn Pathconf
;;   "Go return type: (val int, err error)\nJoker return type: [^Int val ^Error err]"
;;   {:added "1.0"
;;    :go "pathconf(path, name)"}
;;   [^String path, ^Int name])

JOKER FUNC syscall.Pipe has:
;; (defn Pipe
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "pipe(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_darwin.go:168:13) p])

JOKER FUNC syscall.Pread has:
;; (defn Pread
;;   "Go return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "pread(fd, p, offset)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:906:22) p, offset])

JOKER FUNC syscall.PtraceAttach has:
;; (defn PtraceAttach
;;   "sys   ptrace(request int, pid int, addr uintptr, data uintptr) (err error)\nGo return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "ptraceAttach(pid)"}
;;   [^Int pid])

JOKER FUNC syscall.PtraceDetach has:
;; (defn PtraceDetach
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "ptraceDetach(pid)"}
;;   [^Int pid])

JOKER FUNC syscall.Pwrite has:
;; (defn Pwrite
;;   "Go return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "pwrite(fd, p, offset)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:923:23) p, offset])

JOKER FUNC syscall.RawSyscall has:
;; (defn RawSyscall
;;   "Go return type: (r1 uintptr, r2 uintptr, err Errno)\nJoker return type: [^ABEND042(cannot find typename syscall.uintptr) r1 ^ABEND042(cannot find typename syscall.uintptr) r2 ^ABEND042(cannot find typename syscall.uintptr) err]"
;;   {:added "1.0"
;;    :go "rawSyscall(trap, a1, a2, a3)"}
;;   [trap, a1, a2, a3])

JOKER FUNC syscall.RawSyscall6 has:
;; (defn RawSyscall6
;;   "Go return type: (r1 uintptr, r2 uintptr, err Errno)\nJoker return type: [^ABEND042(cannot find typename syscall.uintptr) r1 ^ABEND042(cannot find typename syscall.uintptr) r2 ^ABEND042(cannot find typename syscall.uintptr) err]"
;;   {:added "1.0"
;;    :go "rawSyscall6(trap, a1, a2, a3, a4, a5, a6)"}
;;   [trap, a1, a2, a3, a4, a5, a6])

JOKER FUNC syscall.Read has:
;; (defn Read
;;   "Go return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "read(fd, p)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:171:21) p])

JOKER FUNC syscall.ReadDirent has:
;; (defn ReadDirent
;;   "Go return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "readDirent(fd, buf)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:65:29) buf])

JOKER FUNC syscall.Readlink has:
;; (defn Readlink
;;   "Go return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "readlink(path, buf)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:957:32) buf])

JOKER FUNC syscall.Recvfrom has:
;; (defn Recvfrom
;;   "Go return type: (n int, from Sockaddr, err error)\nJoker return type: [^Int n ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/syscall/syscall_unix.go:205:15) from ^Error err]"
;;   {:added "1.0"
;;    :go "recvfrom(fd, p, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:259:25) p, ^Int flags])

JOKER FUNC syscall.Recvmsg has:
;; (defn Recvmsg
;;   "Go return type: (n int, oobn int, recvflags int, from Sockaddr, err error)\nJoker return type: [^Int n ^Int oobn ^Int recvflags ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/syscall/syscall_unix.go:205:15) from ^Error err]"
;;   {:added "1.0"
;;    :go "recvmsg(fd, p, oob, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:358:29) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:358:29) oob, ^Int flags])

JOKER FUNC syscall.Rename has:
;; (defn Rename
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "rename(from, to)"}
;;   [^String from, ^String to])

JOKER FUNC syscall.Revoke has:
;; (defn Revoke
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "revoke(path)"}
;;   [^String path])

JOKER FUNC syscall.Rmdir has:
;; (defn Rmdir
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "rmdir(path)"}
;;   [^String path])

JOKER FUNC syscall.RouteRIB has:
;; (defn RouteRIB
;;   "RouteRIB returns routing information base, as known as RIB,\nwhich consists of network facility information, states and\nparameters.\n\nDeprecated: Use golang.org/x/net/route instead.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "routeRIB(facility, param)"}
;;   [^Int facility, ^Int param])

JOKER FUNC syscall.Seek has:
;; (defn Seek
;;   "Go return type: (newoffset int, err error)\nJoker return type: [^Int newoffset ^Error err]"
;;   {:added "1.0"
;;    :go "seek(fd, offset, whence)"}
;;   [^Int fd, offset, ^Int whence])

JOKER FUNC syscall.Select has:
;; (defn Select
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "select(n, r, w, e, timeout)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:22) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:32) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:42) e, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:58) timeout])

JOKER FUNC syscall.Sendfile has:
;; (defn Sendfile
;;   "Go return type: (written int, err error)\nJoker return type: [^Int written ^Error err]"
;;   {:added "1.0"
;;    :go "sendfile(outfd, infd, offset, count)"}
;;   [^Int outfd, ^Int infd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:334:43) offset, ^Int count])

JOKER FUNC syscall.Sendmsg has:
;; (defn Sendmsg
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "sendmsg(fd, p, oob, to, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:394:29) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:394:29) oob, to, ^Int flags])

JOKER FUNC syscall.SendmsgN has:
;; (defn SendmsgN
;;   "Go return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "sendmsgN(fd, p, oob, to, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:399:30) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:399:30) oob, to, ^Int flags])

JOKER FUNC syscall.Sendto has:
;; (defn Sendto
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "sendto(fd, p, flags, to)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:271:23) p, ^Int flags, to])

JOKER FUNC syscall.SetBpf has:
;; (defn ^Error SetBpf
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "setBpf(fd, i)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/bpf_bsd.go:146:23) i])

JOKER FUNC syscall.SetBpfBuflen has:
;; (defn SetBpfBuflen
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: (int, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "setBpfBuflen(fd, l)"}
;;   [^Int fd, ^Int l])

JOKER FUNC syscall.SetBpfDatalink has:
;; (defn SetBpfDatalink
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: (int, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "setBpfDatalink(fd, t)"}
;;   [^Int fd, ^Int t])

JOKER FUNC syscall.SetBpfHeadercmpl has:
(defn ^Error SetBpfHeadercmpl
  "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "setBpfHeadercmpl(fd, f)"}
  [^Int fd, ^Int f])

JOKER FUNC syscall.SetBpfImmediate has:
(defn ^Error SetBpfImmediate
  "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "setBpfImmediate(fd, m)"}
  [^Int fd, ^Int m])

JOKER FUNC syscall.SetBpfInterface has:
(defn ^Error SetBpfInterface
  "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "setBpfInterface(fd, name)"}
  [^Int fd, ^String name])

JOKER FUNC syscall.SetBpfPromisc has:
(defn ^Error SetBpfPromisc
  "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "setBpfPromisc(fd, m)"}
  [^Int fd, ^Int m])

JOKER FUNC syscall.SetBpfTimeout has:
;; (defn ^Error SetBpfTimeout
;;   "Deprecated: Use golang.org/x/net/bpf instead.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "setBpfTimeout(fd, tv)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/bpf_bsd.go:118:31) tv])

JOKER FUNC syscall.SetKevent has:
;; (defn SetKevent
;;   ""
;;   {:added "1.0"
;;    :go "setKevent(k, fd, mode, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_darwin_amd64.go:35:18) k, ^Int fd, ^Int mode, ^Int flags])

JOKER FUNC syscall.SetNonblock has:
;; (defn SetNonblock
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setNonblock(fd, nonblocking)"}
;;   [^Int fd, nonblocking])

JOKER FUNC syscall.Setegid has:
;; (defn Setegid
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setegid(egid)"}
;;   [^Int egid])

JOKER FUNC syscall.Setenv has:
(defn ^Error Setenv
  "Go return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "setenv(key, value)"}
  [^String key, ^String value])

JOKER FUNC syscall.Seteuid has:
;; (defn Seteuid
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "seteuid(euid)"}
;;   [^Int euid])

JOKER FUNC syscall.Setgid has:
;; (defn Setgid
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setgid(gid)"}
;;   [^Int gid])

JOKER FUNC syscall.Setgroups has:
;; (defn Setgroups
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setgroups(gids)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:53:21) gids])

JOKER FUNC syscall.Setlogin has:
;; (defn Setlogin
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setlogin(name)"}
;;   [^String name])

JOKER FUNC syscall.Setpgid has:
;; (defn Setpgid
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setpgid(pid, pgid)"}
;;   [^Int pid, ^Int pgid])

JOKER FUNC syscall.Setpriority has:
;; (defn Setpriority
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setpriority(which, who, prio)"}
;;   [^Int which, ^Int who, ^Int prio])

JOKER FUNC syscall.Setprivexec has:
;; (defn Setprivexec
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setprivexec(flag)"}
;;   [^Int flag])

JOKER FUNC syscall.Setregid has:
;; (defn Setregid
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setregid(rgid, egid)"}
;;   [^Int rgid, ^Int egid])

JOKER FUNC syscall.Setreuid has:
;; (defn Setreuid
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setreuid(ruid, euid)"}
;;   [^Int ruid, ^Int euid])

JOKER FUNC syscall.Setrlimit has:
;; (defn Setrlimit
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setrlimit(which, lim)"}
;;   [^Int which, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1145:31) lim])

JOKER FUNC syscall.Setsid has:
;; (defn Setsid
;;   "Go return type: (pid int, err error)\nJoker return type: [^Int pid ^Error err]"
;;   {:added "1.0"
;;    :go "setsid()"}
;;   [])

JOKER FUNC syscall.SetsockoptByte has:
;; (defn SetsockoptByte
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setsockoptByte(fd, level, opt, value)"}
;;   [^Int fd, ^Int level, ^Int opt, value])

JOKER FUNC syscall.SetsockoptICMPv6Filter has:
;; (defn ^Error SetsockoptICMPv6Filter
;;   "Go return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "setsockoptICMPv6Filter(fd, level, opt, filter)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:300:56) filter])

JOKER FUNC syscall.SetsockoptIPMreq has:
;; (defn SetsockoptIPMreq
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setsockoptIPMreq(fd, level, opt, mreq)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:292:48) mreq])

JOKER FUNC syscall.SetsockoptIPv6Mreq has:
;; (defn SetsockoptIPv6Mreq
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setsockoptIPv6Mreq(fd, level, opt, mreq)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:296:50) mreq])

JOKER FUNC syscall.SetsockoptInet4Addr has:
;; (defn SetsockoptInet4Addr
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setsockoptInet4Addr(fd, level, opt, value)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:288:52) value])

JOKER FUNC syscall.SetsockoptInt has:
;; (defn SetsockoptInt
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setsockoptInt(fd, level, opt, value)"}
;;   [^Int fd, ^Int level, ^Int opt, ^Int value])

JOKER FUNC syscall.SetsockoptLinger has:
;; (defn SetsockoptLinger
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setsockoptLinger(fd, level, opt, l)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:304:45) l])

JOKER FUNC syscall.SetsockoptString has:
;; (defn SetsockoptString
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setsockoptString(fd, level, opt, s)"}
;;   [^Int fd, ^Int level, ^Int opt, ^String s])

JOKER FUNC syscall.SetsockoptTimeval has:
;; (defn SetsockoptTimeval
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setsockoptTimeval(fd, level, opt, tv)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:312:47) tv])

JOKER FUNC syscall.Settimeofday has:
;; (defn Settimeofday
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "settimeofday(tp)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1166:22) tp])

JOKER FUNC syscall.Setuid has:
;; (defn Setuid
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "setuid(uid)"}
;;   [^Int uid])

JOKER FUNC syscall.Shutdown has:
;; (defn Shutdown
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "shutdown(s, how)"}
;;   [^Int s, ^Int how])

JOKER FUNC syscall.SlicePtrFromStrings has:
;; (defn SlicePtrFromStrings
;;   "SlicePtrFromStrings converts a slice of strings to a slice of\npointers to NUL-terminated byte arrays. If any string contains\na NUL byte, it returns (nil, EINVAL).\nGo return type: ([]*int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "slicePtrFromStrings(ss)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:83:29) ss])

JOKER FUNC syscall.Socket has:
;; (defn Socket
;;   "Go return type: (fd int, err error)\nJoker return type: [^Int fd ^Error err]"
;;   {:added "1.0"
;;    :go "socket(domain, typ, proto)"}
;;   [^Int domain, ^Int typ, ^Int proto])

JOKER FUNC syscall.Socketpair has:
;; (defn Socketpair
;;   "Go return type: (fd []int, err error)\nJoker return type: [^(vector-of Int) fd ^Error err]"
;;   {:added "1.0"
;;    :go "socketpair(domain, typ, proto)"}
;;   [^Int domain, ^Int typ, ^Int proto])

JOKER FUNC syscall.StartProcess has:
;; (defn StartProcess
;;   "StartProcess wraps ForkExec for package os.\nGo return type: (pid int, handle uintptr, err error)\nJoker return type: [^Int pid ^ABEND042(cannot find typename syscall.uintptr) handle ^Error err]"
;;   {:added "1.0"
;;    :go "startProcess(argv0, argv, attr)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:240:38) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/exec_unix.go:240:53) attr])

JOKER FUNC syscall.Stat has:
;; (defn Stat
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "stat(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1186:29) stat])

JOKER FUNC syscall.Statfs has:
;; (defn Statfs
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "statfs(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1201:31) stat])

JOKER FUNC syscall.StringBytePtr has:
(defn ^Int StringBytePtr
  "StringBytePtr returns a pointer to a NUL-terminated array of bytes.\nIf s contains a NUL byte this function panics instead of returning\nan error.\n\nDeprecated: Use BytePtrFromString instead.\nGo return type: *int\nJoker return type: Int"
  {:added "1.0"
   :go "stringBytePtr(s)"}
  [^String s])

JOKER FUNC syscall.StringByteSlice has:
;; (defn StringByteSlice
;;   "StringByteSlice converts a string to a NUL-terminated []byte,\nIf s contains a NUL byte this function panics instead of\nreturning an error.\n\nDeprecated: Use ByteSliceFromString instead.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "stringByteSlice(s)"}
;;   [^String s])

JOKER FUNC syscall.StringSlicePtr has:
;; (defn StringSlicePtr
;;   "StringSlicePtr converts a slice of strings to a slice of pointers\nto NUL-terminated byte arrays. If any string contains a NUL byte\nthis function panics instead of returning an error.\n\nDeprecated: Use SlicePtrFromStrings instead.\nGo return type: []*int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "stringSlicePtr(ss)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:71:24) ss])

JOKER FUNC syscall.Symlink has:
;; (defn Symlink
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "symlink(path, link)"}
;;   [^String path, ^String link])

JOKER FUNC syscall.Sync has:
;; (defn Sync
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "sync()"}
;;   [])

JOKER FUNC syscall.Syscall has:
;; (defn Syscall
;;   "Go return type: (r1 uintptr, r2 uintptr, err Errno)\nJoker return type: [^ABEND042(cannot find typename syscall.uintptr) r1 ^ABEND042(cannot find typename syscall.uintptr) r2 ^ABEND042(cannot find typename syscall.uintptr) err]"
;;   {:added "1.0"
;;    :go "syscall(trap, a1, a2, a3)"}
;;   [trap, a1, a2, a3])

JOKER FUNC syscall.Syscall6 has:
;; (defn Syscall6
;;   "Go return type: (r1 uintptr, r2 uintptr, err Errno)\nJoker return type: [^ABEND042(cannot find typename syscall.uintptr) r1 ^ABEND042(cannot find typename syscall.uintptr) r2 ^ABEND042(cannot find typename syscall.uintptr) err]"
;;   {:added "1.0"
;;    :go "syscall6(trap, a1, a2, a3, a4, a5, a6)"}
;;   [trap, a1, a2, a3, a4, a5, a6])

JOKER FUNC syscall.Syscall9 has:
;; (defn Syscall9
;;   "Go return type: (r1 uintptr, r2 uintptr, err Errno)\nJoker return type: [^ABEND042(cannot find typename syscall.uintptr) r1 ^ABEND042(cannot find typename syscall.uintptr) r2 ^ABEND042(cannot find typename syscall.uintptr) err]"
;;   {:added "1.0"
;;    :go "syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9)"}
;;   [trap, a1, a2, a3, a4, a5, a6, a7, a8, a9])

JOKER FUNC syscall.Sysctl has:
;; (defn Sysctl
;;   "Go return type: (value string, err error)\nJoker return type: [^String value ^Error err]"
;;   {:added "1.0"
;;    :go "sysctl(name)"}
;;   [^String name])

JOKER FUNC syscall.SysctlUint32 has:
;; (defn SysctlUint32
;;   "Go return type: (value int, err error)\nJoker return type: [^Int value ^Error err]"
;;   {:added "1.0"
;;    :go "sysctlUint32(name)"}
;;   [^String name])

JOKER FUNC syscall.TimespecToNsec has:
(defn ^Int TimespecToNsec
  "TimespecToNsec converts a Timespec value into a number of\nnanoseconds since the Unix epoch.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "timespecToNsec(ts)"}
  [ts])

JOKER FUNC syscall.TimevalToNsec has:
(defn ^Int TimevalToNsec
  "TimevalToNsec converts a Timeval value into a number of nanoseconds\nsince the Unix epoch.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "timevalToNsec(tv)"}
  [tv])

JOKER FUNC syscall.Truncate has:
;; (defn Truncate
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "truncate(path, length)"}
;;   [^String path, length])

JOKER FUNC syscall.Umask has:
;; (defn Umask
;;   "Go return type: oldmask int\nJoker return type: ^Int oldmask"
;;   {:added "1.0"
;;    :go "umask(newmask)"}
;;   [^Int newmask])

JOKER FUNC syscall.Undelete has:
;; (defn Undelete
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "undelete(path)"}
;;   [^String path])

JOKER FUNC syscall.UnixRights has:
;; (defn UnixRights
;;   "UnixRights encodes a set of open file descriptors into a socket\ncontrol message for sending to another process.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "unixRights(fds)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/syscall/sockcmsg_unix.go:74:21) fds])

JOKER FUNC syscall.Unlink has:
;; (defn Unlink
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "unlink(path)"}
;;   [^String path])

JOKER FUNC syscall.Unmount has:
;; (defn Unmount
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "unmount(path, flags)"}
;;   [^String path, ^Int flags])

JOKER FUNC syscall.Unsetenv has:
(defn ^Error Unsetenv
  "Go return type: error\nJoker return type: Error"
  {:added "1.0"
   :go "unsetenv(key)"}
  [^String key])

JOKER FUNC syscall.Utimes has:
;; (defn Utimes
;;   "Go return type: err error\nJoker return type: ^Error err"
;;   {:added "1.0"
;;    :go "utimes(path, tv)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:502:29) tv])

JOKER FUNC syscall.UtimesNano has:
;; (defn ^Error UtimesNano
;;   "Go return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "utimesNano(path, ts)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:509:33) ts])

JOKER FUNC syscall.Wait4 has:
;; (defn Wait4
;;   "Go return type: (wpid int, err error)\nJoker return type: [^Int wpid ^Error err]"
;;   {:added "1.0"
;;    :go "wait4(pid, wstatus, options, rusage)"}
;;   [^Int pid, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_bsd.go:127:29) wstatus, ^Int options, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_bsd.go:127:62) rusage])

JOKER FUNC syscall.Write has:
;; (defn Write
;;   "Go return type: (n int, err error)\nJoker return type: [^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "write(fd, p)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:187:22) p])

JOKER FUNC syslog.Dial has:
;; (defn Dial
;;   "Dial establishes a connection to a log daemon by connecting to\naddress raddr on the specified network. Each write to the returned\nwriter sends a log message with the facility and severity\n(from priority) and tag. If tag is empty, the os.Args[0] is used.\nIf network is empty, Dial will connect to the local syslog server.\nOtherwise, see the documentation for net.Dial for valid values\nof network and raddr.\nGo return type: (*Writer, error)\nJoker return type: [{:priority ^Int, :tag ^String, :hostname ^String, :network ^String, :raddr ^String, :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/syslog/syslog.go:83:7), :conn ^ABEND042(cannot find typename syslog.serverConn)} Error]"
;;   {:added "1.0"
;;    :go "dial(network, raddr, priority, tag)"}
;;   [^String network, ^String raddr, priority, ^String tag])

JOKER FUNC syslog.New has:
;; (defn New
;;   "New establishes a new connection to the system log daemon. Each\nwrite to the returned writer sends a log message with the given\npriority (a combination of the syslog facility and severity) and\nprefix tag. If tag is empty, the os.Args[0] is used.\nGo return type: (*Writer, error)\nJoker return type: [{:priority ^Int, :tag ^String, :hostname ^String, :network ^String, :raddr ^String, :mu ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/syslog/syslog.go:83:7), :conn ^ABEND042(cannot find typename syslog.serverConn)} Error]"
;;   {:added "1.0"
;;    :go "new(priority, tag)"}
;;   [priority, ^String tag])

JOKER FUNC syslog.NewLogger has:
;; (defn NewLogger
;;   "NewLogger creates a log.Logger whose output is written to the\nsystem log service with the specified priority, a combination of\nthe syslog facility and severity. The logFlag argument is the flag\nset passed through to log.New to create the Logger.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/syslog/syslog.go:309:43) Error]"
;;   {:added "1.0"
;;    :go "newLogger(p, logFlag)"}
;;   [p, ^Int logFlag])

JOKER FUNC tabwriter.NewWriter has:
;; (defn NewWriter
;;   "NewWriter allocates and initializes a new tabwriter.Writer.\nThe parameters are the same as for the Init function.\nGo return type: *Writer\nJoker return type: {:output ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/text/tabwriter/tabwriter.go:93:11), :minwidth ^Int, :tabwidth ^Int, :padding ^Int, :padbytes ^(vector-of Int), :flags ^Int, :buf ^(vector-of Int), :pos ^Int, :cell ^ABEND042(cannot find typename tabwriter.cell), :endChar ^Int, :lines ^(vector-of (vector-of ABEND042(cannot find typename tabwriter.cell))), :widths ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "newWriter(output, minwidth, tabwidth, padding, padchar, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/text/tabwriter/tabwriter.go:597:23) output, ^Int minwidth, ^Int tabwidth, ^Int padding, padchar, ^Int flags])

JOKER FUNC tar.FileInfoHeader has:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated Header from fi.\nIf fi describes a symlink, FileInfoHeader records link as the link target.\nIf fi describes a directory, a slash is appended to the name.\n\nSince os.FileInfo's Name method only returns the base name of\nthe file it describes, it may be necessary to modify Header.Name\nto provide the full path name of the file.\nGo return type: (*Header, error)\nJoker return type: [{:Typeflag ^Int, :Name ^String, :Linkname ^String, :Size ^Int, :Mode ^Int, :Uid ^Int, :Gid ^Int, :Uname ^String, :Gname ^String, :ModTime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:161:13), :AccessTime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:162:13), :ChangeTime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:163:13), :Devmajor ^Int, :Devminor ^Int, :Xattrs ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/archive/tar/common.go:179:9), :PAXRecords ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/archive/tar/common.go:191:13), :Format ^Int} Error]"
;;   {:added "1.0"
;;    :go "fileInfoHeader(fi, link)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:629:24) fi, ^String link])

JOKER FUNC tar.NewReader has:
;; (defn NewReader
;;   "NewReader creates a new Reader reading from r.\nGo return type: *Reader\nJoker return type: {:r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/reader.go:20:7), :pad ^Int, :curr ^ABEND042(cannot find typename tar.fileReader), :blk ^ABEND042(cannot find typename tar.block), :err ^Error}"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/reader.go:39:18) r])

JOKER FUNC tar.NewWriter has:
;; (defn NewWriter
;;   "NewWriter creates a new Writer writing to w.\nGo return type: *Writer\nJoker return type: {:w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/writer.go:20:7), :pad ^Int, :curr ^ABEND042(cannot find typename tar.fileWriter), :hdr ^{:Typeflag ^Int, :Name ^String, :Linkname ^String, :Size ^Int, :Mode ^Int, :Uid ^Int, :Gid ^Int, :Uname ^String, :Gname ^String, :ModTime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:161:13), :AccessTime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:162:13), :ChangeTime ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:163:13), :Devmajor ^Int, :Devminor ^Int, :Xattrs ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/archive/tar/common.go:179:9), :PAXRecords ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/archive/tar/common.go:191:13), :Format ^Int}, :blk ^ABEND042(cannot find typename tar.block), :err ^Error}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/writer.go:33:18) w])

JOKER FUNC testing.AllocsPerRun has:
;; (defn AllocsPerRun
;;   "AllocsPerRun returns the average number of allocations during calls to f.\nAlthough the return value has type float64, it will always be an integral value.\n\nTo compute the number of allocations, the function will first be run once as\na warm-up. The average number of allocations over the specified number of\nruns will then be measured and returned.\n\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore\nit before returning.\nGo return type: avg float64\nJoker return type: ^ABEND042(cannot find typename testing.float64) avg"
;;   {:added "1.0"
;;    :go "allocsPerRun(runs, f)"}
;;   [^Int runs, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/allocs.go:20:31) f])

JOKER FUNC testing.Benchmark has:
;; (defn Benchmark
;;   "Benchmark benchmarks a single function. Useful for creating\ncustom benchmarks that do not use the \"go test\" command.\n\nIf f calls Run, the result will be an estimate of running all its\nsubbenchmarks that don't call Run in sequence in a single benchmark.\nGo return type: BenchmarkResult\nJoker return type: {:N ^Int, :T ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/benchmark.go:298:12), :Bytes ^Int, :MemAllocs ^ABEND042(cannot find typename testing.uint64), :MemBytes ^ABEND042(cannot find typename testing.uint64)}"
;;   {:added "1.0"
;;    :go "benchmark(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/benchmark.go:649:18) f])

JOKER FUNC testing.CoverMode has:
(defn ^String CoverMode
  "CoverMode reports what the test coverage mode is set to. The\nvalues are \"set\", \"count\", or \"atomic\". The return value will be\nempty if test coverage is not enabled.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "coverMode()"}
  [])

JOKER FUNC testing.Coverage has:
;; (defn Coverage
;;   "Coverage reports the current code coverage as a fraction in the range [0, 1].\nIf coverage is not enabled, Coverage returns 0.\n\nWhen running a large set of sequential test cases, checking Coverage after each one\ncan be useful for identifying which test cases exercise new code paths.\nIt is not a replacement for the reports generated by 'go test -cover' and\n'go tool cover'.\nGo return type: float64\nJoker return type: ABEND042(cannot find typename testing.float64)"
;;   {:added "1.0"
;;    :go "coverage()"}
;;   [])

JOKER FUNC testing.Main has:
;; (defn Main
;;   "Main is an internal function, part of the implementation of the \"go test\" command.\nIt was exported because it is cross-package and predates \"internal\" packages.\nIt is no longer used by \"go test\" but preserved, as much as possible, for other\nsystems that simulate \"go test\" using Main, but Main sometimes cannot be updated as\nnew functionality is added to the testing package.\nSystems simulating \"go test\" should be updated to use MainStart.\n"
;;   {:added "1.0"
;;    :go "main(matchString, tests, benchmarks, examples)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/testing.go:961:23) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:66) tests, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:93) benchmarks, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:123) examples])

JOKER FUNC testing.MainStart has:
;; (defn MainStart
;;   "MainStart is meant for use by tests generated by 'go test'.\nIt is not meant to be called directly and is not subject to the Go 1 compatibility document.\nIt may change signature from release to release.\nGo return type: *M\nJoker return type: {:deps ^ABEND042(cannot find typename testing.testDeps), :tests ^(vector-of {:Name ^String, :F ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/testing.go:753:7)}), :benchmarks ^(vector-of {:Name ^String, :F ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/benchmark.go:32:7)}), :examples ^(vector-of {:Name ^String, :F ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/example.go:18:12), :Output ^String, :Unordered ^Bool}), :timer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/testing.go:972:13), :afterOnce ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/testing.go:973:12), :numRun ^Int}"
;;   {:added "1.0"
;;    :go "mainStart(deps, tests, benchmarks, examples)"}
;;   [deps, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:995:37) tests, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:995:64) benchmarks, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:995:94) examples])

JOKER FUNC testing.RegisterCover has:
;; (defn RegisterCover
;;   "RegisterCover records the coverage data accumulators for the tests.\nNOTE: This function is internal to the testing infrastructure and may change.\nIt is not covered (yet) by the Go 1 compatibility guidelines.\n"
;;   {:added "1.0"
;;    :go "registerCover(c)"}
;;   [c])

JOKER FUNC testing.RunBenchmarks has:
;; (defn RunBenchmarks
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n"
;;   {:added "1.0"
;;    :go "runBenchmarks(matchString, benchmarks)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/benchmark.go:377:32) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/benchmark.go:377:80) benchmarks])

JOKER FUNC testing.RunExamples has:
;; (defn RunExamples
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\nGo return type: ok bool\nJoker return type: ^Bool ok"
;;   {:added "1.0"
;;    :go "runExamples(matchString, examples)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/example.go:25:30) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/example.go:25:76) examples])

JOKER FUNC testing.RunTests has:
;; (defn RunTests
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\nGo return type: ok bool\nJoker return type: ^Bool ok"
;;   {:added "1.0"
;;    :go "runTests(matchString, tests)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/testing.go:1091:27) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:1091:70) tests])

JOKER FUNC testing.Short has:
(defn ^Bool Short
  "Short reports whether the -test.short flag is set.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "short()"}
  [])

JOKER FUNC testing.Verbose has:
(defn ^Bool Verbose
  "Verbose reports whether the -test.v flag is set.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "verbose()"}
  [])

JOKER FUNC textproto.CanonicalMIMEHeaderKey has:
(defn ^String CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "canonicalMIMEHeaderKey(s)"}
  [^String s])

JOKER FUNC textproto.Dial has:
;; (defn Dial
;;   "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\nGo return type: (*Conn, error)\nJoker return type: [{:conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/textproto/textproto.go:62:7)} Error]"
;;   {:added "1.0"
;;    :go "dial(network, addr)"}
;;   [^String network, ^String addr])

JOKER FUNC textproto.NewConn has:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\nGo return type: *Conn\nJoker return type: {:conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/textproto/textproto.go:62:7)}"
;;   {:added "1.0"
;;    :go "newConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/textproto/textproto.go:66:19) conn])

JOKER FUNC textproto.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\nGo return type: *Reader\nJoker return type: {:R ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/textproto/reader.go:19:7), :dot ^ABEND042(cannot find typename textproto.dotReader), :buf ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/textproto/reader.go:29:18) r])

JOKER FUNC textproto.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\nGo return type: *Writer\nJoker return type: {:W ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/textproto/writer.go:16:7), :dot ^ABEND042(cannot find typename textproto.dotWriter)}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/textproto/writer.go:21:18) w])

JOKER FUNC textproto.TrimBytes has:
;; (defn TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimBytes(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/textproto/textproto.go:137:18) b])

JOKER FUNC textproto.TrimString has:
(defn ^String TrimString
  "TrimString returns s without leading and trailing ASCII space.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "trimString(s)"}
  [^String s])

JOKER FUNC time.After has:
;; (defn After
;;   "After waits for the duration to elapse and then sends the current time\non the returned channel.\nIt is equivalent to NewTimer(d).C.\nThe underlying Timer is not recovered by the garbage collector\nuntil the timer fires. If efficiency is a concern, use NewTimer\ninstead and call Timer.Stop if the timer is no longer needed.\nJoker return type: ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/time/sleep.go:152:24)"
;;   {:added "1.0"
;;    :go "after(d)"}
;;   [d])

JOKER FUNC time.AfterFunc has:
;; (defn AfterFunc
;;   "AfterFunc waits for the duration to elapse and then calls f\nin its own goroutine. It returns a Timer that can\nbe used to cancel the call using its Stop method.\nGo return type: *Timer\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/time/sleep.go:50:4), :r ^ABEND042(cannot find typename time.runtimeTimer)}"
;;   {:added "1.0"
;;    :go "afterFunc(d, f)"}
;;   [d, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/time/sleep.go:159:30) f])

JOKER FUNC time.Date has:
;; (defn Date
;;   "Date returns the Time corresponding to\n\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside\ntheir usual ranges and will be normalized during the conversion.\nFor example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times.\nFor example, in the United States, March 13, 2011 2:15am never occurred,\nwhile November 6, 2011 1:15am occurred twice. In such cases, the\nchoice of time zone, and therefore the time, is not well-defined.\nDate returns a time that is correct in one of the two zones involved\nin the transition, but it does not guarantee which.\n\nDate panics if loc is nil.\nGo return type: Time\nJoker return type: {:wall ^ABEND042(cannot find typename time.uint64), :ext ^Int, :loc ^{:name ^String, :zone ^(vector-of ABEND042(cannot find typename time.zone)), :tx ^(vector-of ABEND042(cannot find typename time.zoneTrans)), :cacheStart ^Int, :cacheEnd ^Int, :cacheZone ^ABEND042(cannot find typename time.zone)}}"
;;   {:added "1.0"
;;    :go "date(year, month, day, hour, min, sec, nsec, loc)"}
;;   [^Int year, month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/time.go:1326:69) loc])

JOKER FUNC time.FixedZone has:
;; (defn FixedZone
;;   "FixedZone returns a Location that always uses\nthe given zone name and offset (seconds east of UTC).\nGo return type: *Location\nJoker return type: {:name ^String, :zone ^(vector-of ABEND042(cannot find typename time.zone)), :tx ^(vector-of ABEND042(cannot find typename time.zoneTrans)), :cacheStart ^Int, :cacheEnd ^Int, :cacheZone ^ABEND042(cannot find typename time.zone)}"
;;   {:added "1.0"
;;    :go "fixedZone(name, offset)"}
;;   [^String name, ^Int offset])

JOKER FUNC time.LoadLocation has:
;; (defn LoadLocation
;;   "LoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC.\nIf the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file\nin the IANA Time Zone database, such as \"America/New_York\".\n\nThe time zone database needed by LoadLocation may not be\npresent on all systems, especially non-Unix systems.\nLoadLocation looks in the directory or uncompressed zip file\nnamed by the ZONEINFO environment variable, if any, then looks in\nknown installation locations on Unix systems,\nand finally looks in $GOROOT/lib/time/zoneinfo.zip.\nGo return type: (*Location, error)\nJoker return type: [{:name ^String, :zone ^(vector-of ABEND042(cannot find typename time.zone)), :tx ^(vector-of ABEND042(cannot find typename time.zoneTrans)), :cacheStart ^Int, :cacheEnd ^Int, :cacheZone ^ABEND042(cannot find typename time.zone)} Error]"
;;   {:added "1.0"
;;    :go "loadLocation(name)"}
;;   [^String name])

JOKER FUNC time.LoadLocationFromTZData has:
;; (defn LoadLocationFromTZData
;;   "LoadLocationFromTZData returns a Location with the given name\ninitialized from the IANA Time Zone database-formatted data.\nThe data should be in the format of a standard IANA time zone file\n(for example, the content of /etc/localtime on Unix systems).\nGo return type: (*Location, error)\nJoker return type: [{:name ^String, :zone ^(vector-of ABEND042(cannot find typename time.zone)), :tx ^(vector-of ABEND042(cannot find typename time.zoneTrans)), :cacheStart ^Int, :cacheEnd ^Int, :cacheZone ^ABEND042(cannot find typename time.zone)} Error]"
;;   {:added "1.0"
;;    :go "loadLocationFromTZData(name, data)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/time/zoneinfo_read.go:86:47) data])

JOKER FUNC time.NewTicker has:
;; (defn NewTicker
;;   "NewTicker returns a new Ticker containing a channel that will send the\ntime with a period specified by the duration argument.\nIt adjusts the intervals or drops ticks to make up for slow receivers.\nThe duration d must be greater than zero; if not, NewTicker will panic.\nStop the ticker to release associated resources.\nGo return type: *Ticker\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/time/tick.go:12:4), :r ^ABEND042(cannot find typename time.runtimeTimer)}"
;;   {:added "1.0"
;;    :go "newTicker(d)"}
;;   [d])

JOKER FUNC time.NewTimer has:
;; (defn NewTimer
;;   "NewTimer creates a new Timer that will send\nthe current time on its channel after at least duration d.\nGo return type: *Timer\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/time/sleep.go:50:4), :r ^ABEND042(cannot find typename time.runtimeTimer)}"
;;   {:added "1.0"
;;    :go "newTimer(d)"}
;;   [d])

JOKER FUNC time.Now has:
;; (defn Now
;;   "Now returns the current local time.\nGo return type: Time\nJoker return type: {:wall ^ABEND042(cannot find typename time.uint64), :ext ^Int, :loc ^{:name ^String, :zone ^(vector-of ABEND042(cannot find typename time.zone)), :tx ^(vector-of ABEND042(cannot find typename time.zoneTrans)), :cacheStart ^Int, :cacheEnd ^Int, :cacheZone ^ABEND042(cannot find typename time.zone)}}"
;;   {:added "1.0"
;;    :go "now()"}
;;   [])

JOKER FUNC time.Parse has:
;; (defn Parse
;;   "Parse parses a formatted string and returns the time value it represents.\nThe layout defines the format by showing how the reference time,\ndefined to be\n\tMon Jan 2 15:04:05 -0700 MST 2006\nwould be interpreted if it were the value; it serves as an example of\nthe input format. The same interpretation will then be made to the\ninput string.\n\nPredefined layouts ANSIC, UnixDate, RFC3339 and others describe standard\nand convenient representations of the reference time. For more information\nabout the formats and the definition of the reference time, see the\ndocumentation for ANSIC and the other constants defined by this package.\nAlso, the executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nElements omitted from the value are assumed to be zero or, when\nzero is impossible, one, so parsing \"3:04pm\" returns the time\ncorresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is\n0, this time is before the zero Time).\nYears must be in the range 0000..9999. The day of the week is checked\nfor syntax but it is otherwise ignored.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds\nto a time zone used by the current location (Local), then Parse uses that\nlocation and zone in the returned time. Otherwise it records the time as\nbeing in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation\nhas a defined offset in the current location, then that offset is used.\nThe zone abbreviation \"UTC\" is recognized as UTC regardless of location.\nIf the zone abbreviation is unknown, Parse records the time as being\nin a fabricated location with the given zone abbreviation and a zero offset.\nThis choice means that such a time can be parsed and reformatted with the\nsame layout losslessly, but the exact instant used in the representation will\ndiffer by the actual zone offset. To avoid such problems, prefer time layouts\nthat use a numeric zone offset, or use ParseInLocation.\nGo return type: (Time, error)\nJoker return type: [{:wall ^ABEND042(cannot find typename time.uint64), :ext ^Int, :loc ^{:name ^String, :zone ^(vector-of ABEND042(cannot find typename time.zone)), :tx ^(vector-of ABEND042(cannot find typename time.zoneTrans)), :cacheStart ^Int, :cacheEnd ^Int, :cacheZone ^ABEND042(cannot find typename time.zone)}} Error]"
;;   {:added "1.0"
;;    :go "parse(layout, value)"}
;;   [^String layout, ^String value])

JOKER FUNC time.ParseDuration has:
;; (defn ParseDuration
;;   "ParseDuration parses a duration string.\nA duration string is a possibly signed sequence of\ndecimal numbers, each with optional fraction and a unit suffix,\nsuch as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".\nGo return type: (Duration, error)\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "parseDuration(s)"}
;;   [^String s])

JOKER FUNC time.ParseInLocation has:
;; (defn ParseInLocation
;;   "ParseInLocation is like Parse but differs in two important ways.\nFirst, in the absence of time zone information, Parse interprets a time as UTC;\nParseInLocation interprets the time as in the given location.\nSecond, when given a zone offset or abbreviation, Parse tries to match it\nagainst the Local location; ParseInLocation uses the given location.\nGo return type: (Time, error)\nJoker return type: [{:wall ^ABEND042(cannot find typename time.uint64), :ext ^Int, :loc ^{:name ^String, :zone ^(vector-of ABEND042(cannot find typename time.zone)), :tx ^(vector-of ABEND042(cannot find typename time.zoneTrans)), :cacheStart ^Int, :cacheEnd ^Int, :cacheZone ^ABEND042(cannot find typename time.zone)}} Error]"
;;   {:added "1.0"
;;    :go "parseInLocation(layout, value, loc)"}
;;   [^String layout, ^String value, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/format.go:782:48) loc])

JOKER FUNC time.Since has:
(defn ^Int Since
  "Since returns the time elapsed since t.\nIt is shorthand for time.Now().Sub(t).\nGo return type: Duration\nJoker return type: Int"
  {:added "1.0"
   :go "since(t)"}
  [t])

JOKER FUNC time.Sleep has:
;; (defn Sleep
;;   "Sleep pauses the current goroutine for at least the duration d.\nA negative or zero duration causes Sleep to return immediately.\n"
;;   {:added "1.0"
;;    :go "sleep(d)"}
;;   [d])

JOKER FUNC time.Tick has:
;; (defn Tick
;;   "Tick is a convenience wrapper for NewTicker providing access to the ticking\nchannel only. While Tick is useful for clients that have no need to shut down\nthe Ticker, be aware that without a way to shut it down the underlying\nTicker cannot be recovered by the garbage collector; it \"leaks\".\nUnlike NewTicker, Tick will return nil if d <= 0.\nJoker return type: ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/time/tick.go:54:23)"
;;   {:added "1.0"
;;    :go "tick(d)"}
;;   [d])

JOKER FUNC time.Unix has:
;; (defn Unix
;;   "Unix returns the local Time corresponding to the given Unix time,\nsec seconds and nsec nanoseconds since January 1, 1970 UTC.\nIt is valid to pass nsec outside the range [0, 999999999].\nNot all sec values have a corresponding time value. One such\nvalue is 1<<63-1 (the largest int64 value).\nGo return type: Time\nJoker return type: {:wall ^ABEND042(cannot find typename time.uint64), :ext ^Int, :loc ^{:name ^String, :zone ^(vector-of ABEND042(cannot find typename time.zone)), :tx ^(vector-of ABEND042(cannot find typename time.zoneTrans)), :cacheStart ^Int, :cacheEnd ^Int, :cacheZone ^ABEND042(cannot find typename time.zone)}}"
;;   {:added "1.0"
;;    :go "unix(sec, nsec)"}
;;   [sec, nsec])

JOKER FUNC time.Until has:
(defn ^Int Until
  "Until returns the duration until t.\nIt is shorthand for t.Sub(time.Now()).\nGo return type: Duration\nJoker return type: Int"
  {:added "1.0"
   :go "until(t)"}
  [t])

JOKER FUNC tls.Client has:
;; (defn Client
;;   "Client returns a new TLS client side connection\nusing conn as the underlying transport.\nThe config cannot be nil: users must set either ServerName or\nInsecureSkipVerify in the config.\nGo return type: *Conn\nJoker return type: {:conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:27:11), :isClient ^Bool, :handshakeStatus ^Int, :handshakeMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:35:17), :handshakeErr ^Error, :vers ^Int, :haveVers ^Bool, :config ^{:Rand ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:349:7), :Time ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:353:7), :Certificates ^(vector-of {:Certificate ^(vector-of (vector-of Int)), :PrivateKey ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:813:13), :OCSPStaple ^(vector-of Int), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :Leaf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:824:8)}), :NameToCertificate ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/tls/common.go:368:20), :GetCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:377:17), :GetClientCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:392:23), :GetConfigForClient ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:412:21), :VerifyPeerCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:425:24), :RootCAs ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:430:11), :NextProtos ^(vector-of String), :ServerName ^String, :ClientAuth ^Int, :ClientCAs ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:448:13), :InsecureSkipVerify ^Bool, :CipherSuites ^(vector-of Int), :PreferServerCipherSuites ^Bool, :SessionTicketsDisabled ^Bool, :SessionTicketKey ^(vector-of Int), :ClientSessionCache ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/tls/common.go:215:25), :MinVersion ^Int, :MaxVersion ^Int, :CurvePreferences ^(vector-of Int), :DynamicRecordSizingDisabled ^Bool, :Renegotiation ^Int, :KeyLogWriter ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:517:15), :serverInitOnce ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:519:17), :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:522:8), :sessionTicketKeys ^(vector-of ABEND042(cannot find typename tls.ticketKey))}, :handshakes ^Int, :didResume ^Bool, :cipherSuite ^Int, :ocspResponse ^(vector-of Int), :scts ^(vector-of (vector-of Int)), :peerCertificates ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:48:22)), :verifiedChains ^(vector-of (vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:51:22))), :serverName ^String, :secureRenegotiation ^Bool, :ekm ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/conn.go:59:6), :clientFinishedIsFirst ^Bool, :closeNotifyErr ^Error, :closeNotifySent ^Bool, :clientFinished ^(vector-of Int), :serverFinished ^(vector-of Int), :clientProtocol ^String, :clientProtocolFallback ^Bool, :in ^ABEND042(cannot find typename tls.halfConn), :out ^ABEND042(cannot find typename tls.halfConn), :rawInput ^ABEND042(cannot find typename tls.block), :input ^ABEND042(cannot find typename tls.block), :hand ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:87:12), :buffering ^Bool, :sendBuf ^(vector-of Int), :bytesSent ^Int, :packetsSent ^Int, :warnCount ^Int, :activeCall ^Int, :tmp ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "client(conn, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:39:18) conn, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:39:35) config])

JOKER FUNC tls.Dial has:
;; (defn Dial
;;   "Dial connects to the given network address using net.Dial\nand then initiates a TLS handshake, returning the resulting\nTLS connection.\nDial interprets a nil configuration as equivalent to\nthe zero configuration; see the documentation of Config\nfor the defaults.\nGo return type: (*Conn, error)\nJoker return type: [{:conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:27:11), :isClient ^Bool, :handshakeStatus ^Int, :handshakeMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:35:17), :handshakeErr ^Error, :vers ^Int, :haveVers ^Bool, :config ^{:Rand ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:349:7), :Time ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:353:7), :Certificates ^(vector-of {:Certificate ^(vector-of (vector-of Int)), :PrivateKey ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:813:13), :OCSPStaple ^(vector-of Int), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :Leaf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:824:8)}), :NameToCertificate ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/tls/common.go:368:20), :GetCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:377:17), :GetClientCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:392:23), :GetConfigForClient ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:412:21), :VerifyPeerCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:425:24), :RootCAs ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:430:11), :NextProtos ^(vector-of String), :ServerName ^String, :ClientAuth ^Int, :ClientCAs ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:448:13), :InsecureSkipVerify ^Bool, :CipherSuites ^(vector-of Int), :PreferServerCipherSuites ^Bool, :SessionTicketsDisabled ^Bool, :SessionTicketKey ^(vector-of Int), :ClientSessionCache ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/tls/common.go:215:25), :MinVersion ^Int, :MaxVersion ^Int, :CurvePreferences ^(vector-of Int), :DynamicRecordSizingDisabled ^Bool, :Renegotiation ^Int, :KeyLogWriter ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:517:15), :serverInitOnce ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:519:17), :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:522:8), :sessionTicketKeys ^(vector-of ABEND042(cannot find typename tls.ticketKey))}, :handshakes ^Int, :didResume ^Bool, :cipherSuite ^Int, :ocspResponse ^(vector-of Int), :scts ^(vector-of (vector-of Int)), :peerCertificates ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:48:22)), :verifiedChains ^(vector-of (vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:51:22))), :serverName ^String, :secureRenegotiation ^Bool, :ekm ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/conn.go:59:6), :clientFinishedIsFirst ^Bool, :closeNotifyErr ^Error, :closeNotifySent ^Bool, :clientFinished ^(vector-of Int), :serverFinished ^(vector-of Int), :clientProtocol ^String, :clientProtocolFallback ^Bool, :in ^ABEND042(cannot find typename tls.halfConn), :out ^ABEND042(cannot find typename tls.halfConn), :rawInput ^ABEND042(cannot find typename tls.block), :input ^ABEND042(cannot find typename tls.block), :hand ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:87:12), :buffering ^Bool, :sendBuf ^(vector-of Int), :bytesSent ^Int, :packetsSent ^Int, :warnCount ^Int, :activeCall ^Int, :tmp ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "dial(network, addr, config)"}
;;   [^String network, ^String addr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:169:40) config])

JOKER FUNC tls.DialWithDialer has:
;; (defn DialWithDialer
;;   "DialWithDialer connects to the given network address using dialer.Dial and\nthen initiates a TLS handshake, returning the resulting TLS connection. Any\ntimeout or deadline given in the dialer apply to connection and TLS\nhandshake as a whole.\n\nDialWithDialer interprets a nil configuration as equivalent to the zero\nconfiguration; see the documentation of Config for the defaults.\nGo return type: (*Conn, error)\nJoker return type: [{:conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:27:11), :isClient ^Bool, :handshakeStatus ^Int, :handshakeMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:35:17), :handshakeErr ^Error, :vers ^Int, :haveVers ^Bool, :config ^{:Rand ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:349:7), :Time ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:353:7), :Certificates ^(vector-of {:Certificate ^(vector-of (vector-of Int)), :PrivateKey ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:813:13), :OCSPStaple ^(vector-of Int), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :Leaf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:824:8)}), :NameToCertificate ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/tls/common.go:368:20), :GetCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:377:17), :GetClientCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:392:23), :GetConfigForClient ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:412:21), :VerifyPeerCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:425:24), :RootCAs ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:430:11), :NextProtos ^(vector-of String), :ServerName ^String, :ClientAuth ^Int, :ClientCAs ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:448:13), :InsecureSkipVerify ^Bool, :CipherSuites ^(vector-of Int), :PreferServerCipherSuites ^Bool, :SessionTicketsDisabled ^Bool, :SessionTicketKey ^(vector-of Int), :ClientSessionCache ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/tls/common.go:215:25), :MinVersion ^Int, :MaxVersion ^Int, :CurvePreferences ^(vector-of Int), :DynamicRecordSizingDisabled ^Bool, :Renegotiation ^Int, :KeyLogWriter ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:517:15), :serverInitOnce ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:519:17), :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:522:8), :sessionTicketKeys ^(vector-of ABEND042(cannot find typename tls.ticketKey))}, :handshakes ^Int, :didResume ^Bool, :cipherSuite ^Int, :ocspResponse ^(vector-of Int), :scts ^(vector-of (vector-of Int)), :peerCertificates ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:48:22)), :verifiedChains ^(vector-of (vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:51:22))), :serverName ^String, :secureRenegotiation ^Bool, :ekm ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/conn.go:59:6), :clientFinishedIsFirst ^Bool, :closeNotifyErr ^Error, :closeNotifySent ^Bool, :clientFinished ^(vector-of Int), :serverFinished ^(vector-of Int), :clientProtocol ^String, :clientProtocolFallback ^Bool, :in ^ABEND042(cannot find typename tls.halfConn), :out ^ABEND042(cannot find typename tls.halfConn), :rawInput ^ABEND042(cannot find typename tls.block), :input ^ABEND042(cannot find typename tls.block), :hand ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:87:12), :buffering ^Bool, :sendBuf ^(vector-of Int), :bytesSent ^Int, :packetsSent ^Int, :warnCount ^Int, :activeCall ^Int, :tmp ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "dialWithDialer(dialer, network, addr, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:98:28) dialer, ^String network, ^String addr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:98:70) config])

JOKER FUNC tls.Listen has:
;; (defn Listen
;;   "Listen creates a TLS listener accepting connections on the\ngiven network address using net.Listen.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:74:53) Error]"
;;   {:added "1.0"
;;    :go "listen(network, laddr, config)"}
;;   [^String network, ^String laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:74:43) config])

JOKER FUNC tls.LoadX509KeyPair has:
;; (defn LoadX509KeyPair
;;   "LoadX509KeyPair reads and parses a public/private key pair from a pair\nof files. The files must contain PEM encoded data. The certificate file\nmay contain intermediate certificates following the leaf certificate to\nform a certificate chain. On successful return, Certificate.Leaf will\nbe nil because the parsed form of the certificate is not retained.\nGo return type: (Certificate, error)\nJoker return type: [{:Certificate ^(vector-of (vector-of Int)), :PrivateKey ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:813:13), :OCSPStaple ^(vector-of Int), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :Leaf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:824:8)} Error]"
;;   {:added "1.0"
;;    :go "loadX509KeyPair(certFile, keyFile)"}
;;   [^String certFile, ^String keyFile])

JOKER FUNC tls.NewLRUClientSessionCache has:
;; (defn NewLRUClientSessionCache
;;   "NewLRUClientSessionCache returns a ClientSessionCache with the given\ncapacity that uses an LRU strategy. If capacity is < 1, a default capacity\nis used instead.\nGo return type: ClientSessionCache\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/tls/common.go:215:25)"
;;   {:added "1.0"
;;    :go "newLRUClientSessionCache(capacity)"}
;;   [^Int capacity])

JOKER FUNC tls.NewListener has:
;; (defn NewListener
;;   "NewListener creates a Listener which accepts connections from an inner\nListener and wraps each connection with Server.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\nJoker return type: ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:63:54)"
;;   {:added "1.0"
;;    :go "newListener(inner, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:63:24) inner, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:63:45) config])

JOKER FUNC tls.Server has:
;; (defn Server
;;   "Server returns a new TLS server side connection\nusing conn as the underlying transport.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\nGo return type: *Conn\nJoker return type: {:conn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:27:11), :isClient ^Bool, :handshakeStatus ^Int, :handshakeMutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:35:17), :handshakeErr ^Error, :vers ^Int, :haveVers ^Bool, :config ^{:Rand ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:349:7), :Time ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:353:7), :Certificates ^(vector-of {:Certificate ^(vector-of (vector-of Int)), :PrivateKey ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:813:13), :OCSPStaple ^(vector-of Int), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :Leaf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:824:8)}), :NameToCertificate ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/tls/common.go:368:20), :GetCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:377:17), :GetClientCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:392:23), :GetConfigForClient ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:412:21), :VerifyPeerCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/common.go:425:24), :RootCAs ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:430:11), :NextProtos ^(vector-of String), :ServerName ^String, :ClientAuth ^Int, :ClientCAs ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:448:13), :InsecureSkipVerify ^Bool, :CipherSuites ^(vector-of Int), :PreferServerCipherSuites ^Bool, :SessionTicketsDisabled ^Bool, :SessionTicketKey ^(vector-of Int), :ClientSessionCache ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/tls/common.go:215:25), :MinVersion ^Int, :MaxVersion ^Int, :CurvePreferences ^(vector-of Int), :DynamicRecordSizingDisabled ^Bool, :Renegotiation ^Int, :KeyLogWriter ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:517:15), :serverInitOnce ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:519:17), :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:522:8), :sessionTicketKeys ^(vector-of ABEND042(cannot find typename tls.ticketKey))}, :handshakes ^Int, :didResume ^Bool, :cipherSuite ^Int, :ocspResponse ^(vector-of Int), :scts ^(vector-of (vector-of Int)), :peerCertificates ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:48:22)), :verifiedChains ^(vector-of (vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:51:22))), :serverName ^String, :secureRenegotiation ^Bool, :ekm ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/conn.go:59:6), :clientFinishedIsFirst ^Bool, :closeNotifyErr ^Error, :closeNotifySent ^Bool, :clientFinished ^(vector-of Int), :serverFinished ^(vector-of Int), :clientProtocol ^String, :clientProtocolFallback ^Bool, :in ^ABEND042(cannot find typename tls.halfConn), :out ^ABEND042(cannot find typename tls.halfConn), :rawInput ^ABEND042(cannot find typename tls.block), :input ^ABEND042(cannot find typename tls.block), :hand ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:87:12), :buffering ^Bool, :sendBuf ^(vector-of Int), :bytesSent ^Int, :packetsSent ^Int, :warnCount ^Int, :activeCall ^Int, :tmp ^(vector-of Int)}"
;;   {:added "1.0"
;;    :go "server(conn, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:31:18) conn, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:31:35) config])

JOKER FUNC tls.X509KeyPair has:
;; (defn X509KeyPair
;;   "X509KeyPair parses a public/private key pair from a pair of\nPEM encoded data. On successful return, Certificate.Leaf will be nil because\nthe parsed form of the certificate is not retained.\nGo return type: (Certificate, error)\nJoker return type: [{:Certificate ^(vector-of (vector-of Int)), :PrivateKey ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:813:13), :OCSPStaple ^(vector-of Int), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :Leaf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:824:8)} Error]"
;;   {:added "1.0"
;;    :go "x509KeyPair(certPEMBlock, keyPEMBlock)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/tls.go:193:44) certPEMBlock, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/tls.go:193:44) keyPEMBlock])

JOKER FUNC token.Lookup has:
(defn ^Int Lookup
  "Lookup maps an identifier to its keyword token or IDENT (if not a keyword).\nGo return type: Token\nJoker return type: Int"
  {:added "1.0"
   :go "lookup(ident)"}
  [^String ident])

JOKER FUNC token.NewFileSet has:
;; (defn NewFileSet
;;   "NewFileSet creates a new file set.\nGo return type: *FileSet\nJoker return type: {:mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/token/position.go:353:8), :base ^Int, :files ^(vector-of {:set ^ABEND947(recursive type reference involving token.FileSet), :name ^String, :base ^Int, :size ^Int, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/token/position.go:103:8), :lines ^(vector-of Int), :infos ^(vector-of ABEND042(cannot find typename token.lineInfo))}), :last ^{:set ^ABEND947(recursive type reference involving token.FileSet), :name ^String, :base ^Int, :size ^Int, :mutex ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/token/position.go:103:8), :lines ^(vector-of Int), :infos ^(vector-of ABEND042(cannot find typename token.lineInfo))}}"
;;   {:added "1.0"
;;    :go "newFileSet()"}
;;   [])

JOKER FUNC trace.IsEnabled has:
(defn ^Bool IsEnabled
  "IsEnabled returns whether tracing is enabled.\nThe information is advisory only. The tracing status\nmay have changed by the time this function returns.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isEnabled()"}
  [])

JOKER FUNC trace.Log has:
;; (defn Log
;;   "Log emits a one-off event with the given category and message.\nCategory can be empty and the API assumes there are only a handful of\nunique categories in the system.\n"
;;   {:added "1.0"
;;    :go "log(ctx, category, message)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:91:14) ctx, ^String category, ^String message])

JOKER FUNC trace.Logf has:
;; (defn Logf
;;   "Logf is like Log, but the value is formatted using the specified format spec.\n"
;;   {:added "1.0"
;;    :go "logf(ctx, category, format, args)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:97:15) ctx, ^String category, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/runtime/trace/annotation.go:97:62) args])

JOKER FUNC trace.NewTask has:
;; (defn NewTask
;;   "NewTask creates a task instance with the type taskType and returns\nit along with a Context that carries the task.\nIf the input context contains a task, the new task is its subtask.\n\nThe taskType is used to classify task instances. Analysis tools\nlike the Go execution tracer may assume there are only a bounded\nnumber of unique task types in the system.\n\nThe returned end function is used to mark the task's end.\nThe trace tool measures task latency as the time between task creation\nand when the end function is called, and provides the latency\ndistribution per task type.\nIf the end function is called multiple times, only the first\ncall is used in the latency measurement.\n\n  ctx, task := trace.NewTask(ctx, \"awesomeTask\")\n  trace.WithRegion(ctx, \"preparation\", prepWork)\n  // preparation of the task\n  go func() {  // continue processing the task in a separate goroutine.\n      defer task.End()\n      trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n  }()\nGo return type: (ctx, task *Task)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:34:58) ctx ^{:id ^ABEND042(cannot find typename trace.uint64)} task]"
;;   {:added "1.0"
;;    :go "newTask(pctx, taskType)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:34:19) pctx, ^String taskType])

JOKER FUNC trace.Start has:
;; (defn ^Error Start
;;   "Start enables tracing for the current program.\nWhile tracing, the trace will be buffered and written to w.\nStart returns an error if tracing is already enabled.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "start(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/trace.go:120:14) w])

JOKER FUNC trace.StartRegion has:
;; (defn StartRegion
;;   "StartRegion starts a region and returns a function for marking the\nend of the region. The returned Region's End function must be called\nfrom the same goroutine where the region was started.\nWithin each goroutine, regions must nest. That is, regions started\nafter this region must be ended before this region can be ended.\nRecommended usage is\n\n    defer trace.StartRegion(ctx, \"myTracedRegion\").End()\nGo return type: *Region\nJoker return type: {:id ^ABEND042(cannot find typename trace.uint64), :regionType ^String}"
;;   {:added "1.0"
;;    :go "startRegion(ctx, regionType)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:149:22) ctx, ^String regionType])

JOKER FUNC trace.Stop has:
;; (defn Stop
;;   "Stop stops the current tracing, if any.\nStop only returns after all the writes for the trace have completed.\n"
;;   {:added "1.0"
;;    :go "stop()"}
;;   [])

JOKER FUNC trace.WithRegion has:
;; (defn WithRegion
;;   "WithRegion starts a region associated with its calling goroutine, runs fn,\nand then ends the region. If the context carries a task, the region is\nassociated with the task. Otherwise, the region is attached to the background\ntask.\n\nThe regionType is used to classify regions, so there should be only a\nhandful of unique region types.\n"
;;   {:added "1.0"
;;    :go "withRegion(ctx, regionType, fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:118:21) ctx, ^String regionType, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/trace/annotation.go:118:60) fn])

JOKER FUNC transform.Append has:
;; (defn Append
;;   "Append appends the result of converting src[:n] using t to dst, where\nn <= len(src), If err == nil, n will be len(src). It calls Reset on t.\nGo return type: (result []int, n int, err error)\nJoker return type: [^(vector-of Int) result ^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "append(t, dst, src)"}
;;   [t, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:681:37) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:681:37) src])

JOKER FUNC transform.Bytes has:
;; (defn Bytes
;;   "Bytes returns a new byte slice with the result of converting b[:n] using t,\nwhere n <= len(b). If err == nil, n will be len(b). It calls Reset on t.\nGo return type: (result []int, n int, err error)\nJoker return type: [^(vector-of Int) result ^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "bytes(t, b)"}
;;   [t, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:675:29) b])

JOKER FUNC transform.Chain has:
;; (defn Chain
;;   "Chain returns a Transformer that applies t in sequence.\nGo return type: Transformer\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:43:18)"
;;   {:added "1.0"
;;    :go "chain(t)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:380:14) t])

JOKER FUNC transform.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader that wraps r by transforming the bytes read\nvia t. It calls Reset on t.\nGo return type: *Reader\nJoker return type: {:r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:113:6), :t ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:43:18), :err ^Error, :dst ^(vector-of Int), :dst0 ^Int, :dst1 ^Int, :src ^(vector-of Int), :src0 ^Int, :src1 ^Int, :transformComplete ^Bool}"
;;   {:added "1.0"
;;    :go "newReader(r, t)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:136:18) r, t])

JOKER FUNC transform.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that wraps w by transforming the bytes written\nvia t. It calls Reset on t.\nGo return type: *Writer\nJoker return type: {:w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:212:6), :t ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:43:18), :dst ^(vector-of Int), :src ^(vector-of Int), :n ^Int}"
;;   {:added "1.0"
;;    :go "newWriter(w, t)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:223:18) w, t])

JOKER FUNC transform.RemoveFunc has:
;; (defn RemoveFunc
;;   "Deprecated: use runes.Remove instead.\nGo return type: Transformer\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:43:18)"
;;   {:added "1.0"
;;    :go "removeFunc(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:499:19) f])

JOKER FUNC transform.String has:
;; (defn String
;;   "String returns a string with the result of converting s[:n] using t, where\nn <= len(s). If err == nil, n will be len(s). It calls Reset on t.\nGo return type: (result string, n int, err error)\nJoker return type: [^String result ^Int n ^Error err]"
;;   {:added "1.0"
;;    :go "string(t, s)"}
;;   [t, ^String s])

JOKER FUNC types.AssertableTo has:
;; (defn ^Bool AssertableTo
;;   "AssertableTo reports whether a value of type V can be asserted to have type T.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "assertableTo(V, T)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/api.go:355:21) V, T])

JOKER FUNC types.AssignableTo has:
(defn ^Bool AssignableTo
  "AssignableTo reports whether a value of type V is assignable to a variable of type T.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "assignableTo(V, T)"}
  [V, T])

JOKER FUNC types.Comparable has:
(defn ^Bool Comparable
  "Comparable reports whether values of type T are comparable.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "comparable(T)"}
  [T])

JOKER FUNC types.ConvertibleTo has:
(defn ^Bool ConvertibleTo
  "ConvertibleTo reports whether a value of type V is convertible to a value of type T.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "convertibleTo(V, T)"}
  [V, T])

JOKER FUNC types.DefPredeclaredTestFuncs has:
;; (defn DefPredeclaredTestFuncs
;;   "DefPredeclaredTestFuncs defines the assert and trace built-ins.\nThese built-ins are intended for debugging and testing of this\npackage only.\n"
;;   {:added "1.0"
;;    :go "defPredeclaredTestFuncs()"}
;;   [])

JOKER FUNC types.Default has:
;; (defn Default
;;   "Default returns the default \"typed\" type for an \"untyped\" type;\nit returns the incoming type for all other types. The default type\nfor untyped nil is untyped nil.\nGo return type: Type\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11)"
;;   {:added "1.0"
;;    :go "default(typ)"}
;;   [typ])

JOKER FUNC types.Eval has:
;; (defn Eval
;;   "Eval returns the type and, if constant, the value for the\nexpression expr, evaluated at position pos of package pkg,\nwhich must have been derived from type-checking an AST with\ncomplete position information relative to the provided file\nset.\n\nIf pkg == nil, the Universe scope is used and the provided\nposition pos is ignored. If pkg != nil, and pos is invalid,\nthe package scope is used. Otherwise, pos must belong to the\npackage.\n\nAn error is returned if pos is not within the package or\nif the node cannot be evaluated.\n\nNote: Eval should not be used instead of running Check to compute\ntypes and values, but in addition to Check. Eval will re-evaluate\nits argument each time, and it also does not know about the context\nin which an expression is used (e.g., an assignment). Thus, top-\nlevel untyped constants will return an untyped type rather then the\nrespective context-specific type.\nGo return type: (_ TypeAndValue, err error)\nJoker return type: [^{:mode ^ABEND042(cannot find typename types.operandMode), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11), :Value ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/api.go:259:8)} _ ^Error err]"
;;   {:added "1.0"
;;    :go "eval(fset, pkg, pos, expr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/eval.go:34:16) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/eval.go:34:36) pkg, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/eval.go:34:50) pos, ^String expr])

JOKER FUNC types.ExprString has:
;; (defn ^String ExprString
;;   "ExprString returns the (possibly shortened) string representation for x.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "exprString(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/exprstring.go:17:19) x])

JOKER FUNC types.Id has:
;; (defn ^String Id
;;   "Id returns name if it is exported, otherwise it\nreturns the name qualified with the package path.\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "id(pkg, name)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:61:13) pkg, ^String name])

JOKER FUNC types.Identical has:
(defn ^Bool Identical
  "Identical reports whether x and y are identical types.\nReceivers of Signature types are ignored.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "identical(x, y)"}
  [x, y])

JOKER FUNC types.IdenticalIgnoreTags has:
(defn ^Bool IdenticalIgnoreTags
  "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.\nReceivers of Signature types are ignored.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "identicalIgnoreTags(x, y)"}
  [x, y])

JOKER FUNC types.Implements has:
;; (defn ^Bool Implements
;;   "Implements reports whether type V implements interface T.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "implements(V, T)"}
;;   [V, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/api.go:373:27) T])

JOKER FUNC types.IsInterface has:
(defn ^Bool IsInterface
  "IsInterface reports whether typ is an interface type.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isInterface(typ)"}
  [typ])

JOKER FUNC types.LookupFieldOrMethod has:
;; (defn LookupFieldOrMethod
;;   "LookupFieldOrMethod looks up a field or method with given package and name\nin T and returns the corresponding *Var or *Func, an index sequence, and a\nbool indicating if there were any pointer indirections on the path to the\nfield or method. If addressable is set, T is the type of an addressable\nvariable (only matters for method lookups).\n\nThe last index entry is the field or method index in the (possibly embedded)\ntype where the entry was found, either:\n\n\t1) the list of declared methods of a named type; or\n\t2) the list of all methods (method set) of an interface type; or\n\t3) the list of fields of a struct type.\n\nThe earlier index entries are the indices of the embedded struct fields\ntraversed to get to the found entry, starting at depth 0.\n\nIf no entry is found, a nil object is returned. In this case, the returned\nindex and indirect values have the following meaning:\n\n\t- If index != nil, the index sequence points to an ambiguous entry\n\t(the same name appeared more than once at the same embedding level).\n\n\t- If indirect is set, a method with a pointer receiver type was found\n     but there was no pointer on the path from the actual receiver type to\n\tthe method's formal receiver base type, nor was the receiver addressable.\nGo return type: (obj Object, index []int, indirect bool)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/object.go:19:13) obj ^(vector-of Int) index ^Bool indirect]"
;;   {:added "1.0"
;;    :go "lookupFieldOrMethod(T, addressable, pkg, name)"}
;;   [T, addressable, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/lookup.go:35:56) pkg, ^String name])

JOKER FUNC types.MissingMethod has:
;; (defn MissingMethod
;;   "MissingMethod returns (nil, false) if V implements T, otherwise it\nreturns a missing method required by T and whether it is missing or\njust has the wrong type.\n\nFor non-interface types V, or if static is set, V implements T if all\nmethods of T are present in V. Otherwise (V is an interface and static\nis not set), MissingMethod only checks that methods of T which are also\npresent in V have matching types (e.g., for a type assertion x.(T) where\nx is of interface type V).\nGo return type: (method *Func, wrongType bool)\nJoker return type: [^{} method ^Bool wrongType]"
;;   {:added "1.0"
;;    :go "missingMethod(V, T, static)"}
;;   [V, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/lookup.go:250:30) T, static])

JOKER FUNC types.NewArray has:
;; (defn NewArray
;;   "NewArray returns a new array type for the given element type and length.\nA negative length indicates an unknown length.\nGo return type: *Array\nJoker return type: {:len ^Int, :elem ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11)}"
;;   {:added "1.0"
;;    :go "newArray(elem, len)"}
;;   [elem, len])

JOKER FUNC types.NewChan has:
;; (defn NewChan
;;   "NewChan returns a new channel type for the given direction and element type.\nGo return type: *Chan\nJoker return type: {:dir ^Int, :elem ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11)}"
;;   {:added "1.0"
;;    :go "newChan(dir, elem)"}
;;   [dir, elem])

JOKER FUNC types.NewChecker has:
;; (defn NewChecker
;;   "NewChecker returns a new Checker instance for a given package.\nPackage files may be added incrementally via checker.Files.\nGo return type: *Checker\nJoker return type: {:conf ^{:IgnoreFuncBodies ^Bool, :FakeImportC ^Bool, :Error ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/types/api.go:115:8), :Importer ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/api.go:59:15), :Sizes ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/sizes.go:10:12), :DisableUnusedImportCheck ^Bool}, :fset ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/check.go:76:8), :pkg ^{:path ^String, :name ^String, :scope ^{:parent ^ABEND947(recursive type reference involving types.Scope), :children ^(vector-of ABEND947(recursive type reference involving types.Scope)), :elems ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/scope.go:28:11), :pos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11), :end ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11), :comment ^String, :isFunc ^Bool}, :complete ^Bool, :imports ^(vector-of ABEND947(recursive type reference involving types.Package)), :fake ^Bool}, :objMap ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:79:9), :impMap ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:80:9), :files ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/check.go:85:22)), :unusedDotImports ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:86:19), :firstErr ^Error, :methods ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:89:13), :interfaces ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:90:13), :untyped ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:91:13), :delayed ^(vector-of ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/types/check.go:92:15)), :objPath ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/object.go:19:13)), :indent ^Int}"
;;   {:added "1.0"
;;    :go "newChecker(conf, fset, pkg, info)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:22) conf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:36) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:56) pkg, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:71) info])

JOKER FUNC types.NewConst has:
;; (defn NewConst
;;   "NewConst returns a new constant with value val.\nThe remaining arguments set the attributes found with all Objects.\nGo return type: *Const\nJoker return type: {:val ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:200:6)}"
;;   {:added "1.0"
;;    :go "newConst(pos, pkg, name, typ, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:205:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:205:34) pkg, ^String name, typ, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:205:71) val])

JOKER FUNC types.NewField has:
;; (defn NewField
;;   "NewField returns a new variable representing a struct field.\nFor embedded fields, the name is the unqualified type name\n/ under which the field is accessible.\nGo return type: *Var\nJoker return type: {:embedded ^Bool, :isField ^Bool, :used ^Bool}"
;;   {:added "1.0"
;;    :go "newField(pos, pkg, name, typ, embedded)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:276:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:276:34) pkg, ^String name, typ, embedded])

JOKER FUNC types.NewFunc has:
;; (defn NewFunc
;;   "NewFunc returns a new function with the given signature, representing\nthe function's type.\nGo return type: *Func\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newFunc(pos, pkg, name, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:301:18) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:301:33) pkg, ^String name, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:301:60) sig])

JOKER FUNC types.NewInterface has:
;; (defn NewInterface
;;   "NewInterface returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type.\nNewInterface takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nDeprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types\nto be embedded. This is necessary for interfaces that embed alias type names referring to\nnon-defined (literal) interface types.\nGo return type: *Interface\nJoker return type: {:methods ^(vector-of {}), :embeddeds ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11)), :allMethods ^(vector-of {})}"
;;   {:added "1.0"
;;    :go "newInterface(methods, embeddeds)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:266:27) methods, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:266:46) embeddeds])

JOKER FUNC types.NewInterfaceType has:
;; (defn NewInterfaceType
;;   "NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type (this property is not\nverified for defined types, which may be in the process of being set up and which don't\nhave a valid underlying type yet).\nNewInterfaceType takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\nGo return type: *Interface\nJoker return type: {:methods ^(vector-of {}), :embeddeds ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11)), :allMethods ^(vector-of {})}"
;;   {:added "1.0"
;;    :go "newInterfaceType(methods, embeddeds)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:280:31) methods, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:280:50) embeddeds])

JOKER FUNC types.NewLabel has:
;; (defn NewLabel
;;   "NewLabel returns a new label.\nGo return type: *Label\nJoker return type: {:used ^Bool}"
;;   {:added "1.0"
;;    :go "newLabel(pos, pkg, name)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:331:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:331:34) pkg, ^String name])

JOKER FUNC types.NewMap has:
;; (defn NewMap
;;   "NewMap returns a new map for the given key and element types.\nGo return type: *Map\nJoker return type: {:key ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11), :elem ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11)}"
;;   {:added "1.0"
;;    :go "newMap(key, elem)"}
;;   [key, elem])

JOKER FUNC types.NewMethodSet has:
;; (defn NewMethodSet
;;   "NewMethodSet returns the method set for the given type T.\nIt always returns a non-nil method set, even if it is empty.\nGo return type: *MethodSet\nJoker return type: {:list ^(vector-of {:kind ^Int, :recv ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11), :obj ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/object.go:19:13), :index ^(vector-of Int), :indirect ^Bool})}"
;;   {:added "1.0"
;;    :go "newMethodSet(T)"}
;;   [T])

JOKER FUNC types.NewNamed has:
;; (defn NewNamed
;;   "NewNamed returns a new named type for the given type name, underlying type, and associated methods.\nIf the given type name obj doesn't have a type yet, its type is set to the returned named type.\nThe underlying type must not be a *Named.\nGo return type: *Named\nJoker return type: {:obj ^{}, :underlying ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11), :methods ^(vector-of {})}"
;;   {:added "1.0"
;;    :go "newNamed(obj, underlying, methods)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:433:19) obj, underlying, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:433:55) methods])

JOKER FUNC types.NewPackage has:
;; (defn NewPackage
;;   "NewPackage returns a new Package for the given package path and name.\nThe package is not complete and contains no explicit imports.\nGo return type: *Package\nJoker return type: {:path ^String, :name ^String, :scope ^{:parent ^ABEND947(recursive type reference involving types.Scope), :children ^(vector-of ABEND947(recursive type reference involving types.Scope)), :elems ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/scope.go:28:11), :pos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11), :end ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11), :comment ^String, :isFunc ^Bool}, :complete ^Bool, :imports ^(vector-of ABEND947(recursive type reference involving types.Package)), :fake ^Bool}"
;;   {:added "1.0"
;;    :go "newPackage(path, name)"}
;;   [^String path, ^String name])

JOKER FUNC types.NewParam has:
;; (defn NewParam
;;   "NewParam returns a new variable representing a function parameter.\nGo return type: *Var\nJoker return type: {:embedded ^Bool, :isField ^Bool, :used ^Bool}"
;;   {:added "1.0"
;;    :go "newParam(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:269:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:269:34) pkg, ^String name, typ])

JOKER FUNC types.NewPkgName has:
;; (defn NewPkgName
;;   "NewPkgName returns a new PkgName object representing an imported package.\nThe remaining arguments set the attributes found with all Objects.\nGo return type: *PkgName\nJoker return type: {:imported ^{:path ^String, :name ^String, :scope ^{:parent ^ABEND947(recursive type reference involving types.Scope), :children ^(vector-of ABEND947(recursive type reference involving types.Scope)), :elems ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/scope.go:28:11), :pos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11), :end ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11), :comment ^String, :isFunc ^Bool}, :complete ^Bool, :imports ^(vector-of ABEND947(recursive type reference involving types.Package)), :fake ^Bool}, :used ^Bool}"
;;   {:added "1.0"
;;    :go "newPkgName(pos, pkg, name, imported)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:189:21) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:189:36) pkg, ^String name, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:189:68) imported])

JOKER FUNC types.NewPointer has:
;; (defn NewPointer
;;   "NewPointer returns a new pointer type for the given element (base) type.\nGo return type: *Pointer\nJoker return type: {:base ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11)}"
;;   {:added "1.0"
;;    :go "newPointer(elem)"}
;;   [elem])

JOKER FUNC types.NewScope has:
;; (defn NewScope
;;   "NewScope returns a new, empty scope contained in the given parent\nscope, if any. The comment is for debugging only.\nGo return type: *Scope\nJoker return type: {:parent ^ABEND947(recursive type reference involving types.Scope), :children ^(vector-of ABEND947(recursive type reference involving types.Scope)), :elems ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/scope.go:28:11), :pos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11), :end ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11), :comment ^String, :isFunc ^Bool}"
;;   {:added "1.0"
;;    :go "newScope(parent, pos, end, comment)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/scope.go:36:22) parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:36:39) pos, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:36:39) end, ^String comment])

JOKER FUNC types.NewSignature has:
;; (defn NewSignature
;;   "NewSignature returns a new function type for the given receiver, parameters,\nand results, either of which may be nil. If variadic is set, the function\nis variadic, it must have at least one parameter, and the last parameter\nmust be of unnamed slice type.\nGo return type: *Signature\nJoker return type: {:scope ^{:parent ^ABEND947(recursive type reference involving types.Scope), :children ^(vector-of ABEND947(recursive type reference involving types.Scope)), :elems ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/scope.go:28:11), :pos ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11), :end ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11), :comment ^String, :isFunc ^Bool}, :recv ^{:embedded ^Bool, :isField ^Bool, :used ^Bool}, :params ^{:vars ^(vector-of {:embedded ^Bool, :isField ^Bool, :used ^Bool})}, :results ^{:vars ^(vector-of {:embedded ^Bool, :isField ^Bool, :used ^Bool})}, :variadic ^Bool}"
;;   {:added "1.0"
;;    :go "newSignature(recv, params, results, variadic)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:213:24) recv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:213:46) params, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:213:46) results, variadic])

JOKER FUNC types.NewSlice has:
;; (defn NewSlice
;;   "NewSlice returns a new slice type for the given element type.\nGo return type: *Slice\nJoker return type: {:elem ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11)}"
;;   {:added "1.0"
;;    :go "newSlice(elem)"}
;;   [elem])

JOKER FUNC types.NewStruct has:
;; (defn NewStruct
;;   "NewStruct returns a new struct with the given fields and corresponding field tags.\nIf a field with index i has a tag, tags[i] must be that tag, but len(tags) may be\nonly as long as required to hold the tag with the largest index i. Consequently,\nif no field has a tag, tags may be nil.\nGo return type: *Struct\nJoker return type: {:fields ^(vector-of {:embedded ^Bool, :isField ^Bool, :used ^Bool}), :tags ^(vector-of String)}"
;;   {:added "1.0"
;;    :go "newStruct(fields, tags)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:131:23) fields, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:131:36) tags])

JOKER FUNC types.NewTuple has:
;; (defn NewTuple
;;   "NewTuple returns a new tuple for the given variables.\nGo return type: *Tuple\nJoker return type: {:vars ^(vector-of {:embedded ^Bool, :isField ^Bool, :used ^Bool})}"
;;   {:added "1.0"
;;    :go "newTuple(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/go/types/type.go:177:17) x])

JOKER FUNC types.NewTypeName has:
;; (defn NewTypeName
;;   "NewTypeName returns a new type name denoting the given typ.\nThe remaining arguments set the attributes found with all Objects.\n\nThe typ argument may be a defined (Named) type or an alias type.\nIt may also be nil such that the returned TypeName can be used as\nargument for NewNamed, which will set the TypeName's type as a side-\neffect.\nGo return type: *TypeName\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newTypeName(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:226:22) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:226:37) pkg, ^String name, typ])

JOKER FUNC types.NewVar has:
;; (defn NewVar
;;   "NewVar returns a new variable.\nThe arguments set the attributes found with all Objects.\nGo return type: *Var\nJoker return type: {:embedded ^Bool, :isField ^Bool, :used ^Bool}"
;;   {:added "1.0"
;;    :go "newVar(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:264:17) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:264:32) pkg, ^String name, typ])

JOKER FUNC types.ObjectString has:
(defn ^String ObjectString
  "ObjectString returns the string form of obj.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "objectString(obj, qf)"}
  [obj, qf])

JOKER FUNC types.RelativeTo has:
;; (defn RelativeTo
;;   "RelativeTo(pkg) returns a Qualifier that fully qualifies members of\nall packages other than pkg.\nGo return type: Qualifier\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/types/typestring.go:25:16)"
;;   {:added "1.0"
;;    :go "relativeTo(pkg)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:29:21) pkg])

JOKER FUNC types.SelectionString has:
;; (defn ^String SelectionString
;;   "SelectionString returns the string form of s.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nExamples:\n\t\"field (T) f int\"\n\t\"method (T) f(X) Y\"\n\t\"method expr (T) f(X) Y\"\nGo return type: string\nJoker return type: String"
;;   {:added "1.0"
;;    :go "selectionString(s, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/selection.go:119:24) s, qf])

JOKER FUNC types.SizesFor has:
;; (defn SizesFor
;;   "SizesFor returns the Sizes used by a compiler for an architecture.\nThe result is nil if a compiler/architecture pair is not known.\n\nSupported architectures for compiler \"gc\":\n\"386\", \"arm\", \"arm64\", \"amd64\", \"amd64p32\", \"mips\", \"mipsle\",\n\"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"wasm\".\nGo return type: Sizes\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/sizes.go:10:12)"
;;   {:added "1.0"
;;    :go "sizesFor(compiler, arch)"}
;;   [^String compiler, ^String arch])

JOKER FUNC types.TypeString has:
(defn ^String TypeString
  "TypeString returns the string representation of typ.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "typeString(typ, qf)"}
  [typ, qf])

JOKER FUNC types.WriteExpr has:
;; (defn WriteExpr
;;   "WriteExpr writes the (possibly shortened) string representation for x to buf.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n"
;;   {:added "1.0"
;;    :go "writeExpr(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/exprstring.go:26:20) buf, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/exprstring.go:26:37) x])

JOKER FUNC types.WriteSignature has:
;; (defn WriteSignature
;;   "WriteSignature writes the representation of the signature sig to buf,\nwithout a leading \"func\" keyword.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n"
;;   {:added "1.0"
;;    :go "writeSignature(buf, sig, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:285:25) buf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:285:44) sig, qf])

JOKER FUNC types.WriteType has:
;; (defn WriteType
;;   "WriteType writes the string representation of typ to buf.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n"
;;   {:added "1.0"
;;    :go "writeType(buf, typ, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:74:20) buf, typ, qf])

JOKER FUNC unicode.In has:
;; (defn ^Bool In
;;   "In reports whether the rune is a member of one of the ranges.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "in(r, ranges)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/unicode/graphic.go:69:24) ranges])

JOKER FUNC unicode.Is has:
;; (defn ^Bool Is
;;   "Is reports whether the rune is in the specified table of ranges.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "is(rangeTab, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/unicode/letter.go:158:18) rangeTab, r])

JOKER FUNC unicode.IsControl has:
(defn ^Bool IsControl
  "IsControl reports whether the rune is a control character.\nThe C (Other) Unicode category includes more code points\nsuch as surrogates; use Is(C, r) to test for them.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isControl(r)"}
  [r])

JOKER FUNC unicode.IsDigit has:
(defn ^Bool IsDigit
  "IsDigit reports whether the rune is a decimal digit.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isDigit(r)"}
  [r])

JOKER FUNC unicode.IsGraphic has:
(defn ^Bool IsGraphic
  "IsGraphic reports whether the rune is defined as a Graphic by Unicode.\nSuch characters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, Zs.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isGraphic(r)"}
  [r])

JOKER FUNC unicode.IsLetter has:
(defn ^Bool IsLetter
  "IsLetter reports whether the rune is a letter (category L).\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isLetter(r)"}
  [r])

JOKER FUNC unicode.IsLower has:
(defn ^Bool IsLower
  "IsLower reports whether the rune is a lower case letter.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isLower(r)"}
  [r])

JOKER FUNC unicode.IsMark has:
(defn ^Bool IsMark
  "IsMark reports whether the rune is a mark character (category M).\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isMark(r)"}
  [r])

JOKER FUNC unicode.IsNumber has:
(defn ^Bool IsNumber
  "IsNumber reports whether the rune is a number (category N).\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isNumber(r)"}
  [r])

JOKER FUNC unicode.IsOneOf has:
;; (defn ^Bool IsOneOf
;;   "IsOneOf reports whether the rune is a member of one of the ranges.\nThe function \"In\" provides a nicer signature and should be used in preference to IsOneOf.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "isOneOf(ranges, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/graphic.go:59:21) ranges, r])

JOKER FUNC unicode.IsPrint has:
(defn ^Bool IsPrint
  "IsPrint reports whether the rune is defined as printable by Go. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and the\nASCII space character, from categories L, M, N, P, S and the ASCII space\ncharacter. This categorization is the same as IsGraphic except that the\nonly spacing character is ASCII space, U+0020.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isPrint(r)"}
  [r])

JOKER FUNC unicode.IsPunct has:
(defn ^Bool IsPunct
  "IsPunct reports whether the rune is a Unicode punctuation character\n(category P).\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isPunct(r)"}
  [r])

JOKER FUNC unicode.IsSpace has:
(defn ^Bool IsSpace
  "IsSpace reports whether the rune is a space character as defined\nby Unicode's White Space property; in the Latin-1 space\nthis is\n\t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\nOther definitions of spacing characters are set by category\nZ and property Pattern_White_Space.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isSpace(r)"}
  [r])

JOKER FUNC unicode.IsSymbol has:
(defn ^Bool IsSymbol
  "IsSymbol reports whether the rune is a symbolic character.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isSymbol(r)"}
  [r])

JOKER FUNC unicode.IsTitle has:
(defn ^Bool IsTitle
  "IsTitle reports whether the rune is a title case letter.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isTitle(r)"}
  [r])

JOKER FUNC unicode.IsUpper has:
(defn ^Bool IsUpper
  "IsUpper reports whether the rune is an upper case letter.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isUpper(r)"}
  [r])

JOKER FUNC unicode.SimpleFold has:
;; (defn SimpleFold
;;   "SimpleFold iterates over Unicode code points equivalent under\nthe Unicode-defined simple case folding. Among the code points\nequivalent to rune (including rune itself), SimpleFold returns the\nsmallest rune > r if one exists, or else the smallest rune >= 0.\nIf r is not a valid Unicode code point, SimpleFold(r) returns r.\n\nFor example:\n\tSimpleFold('A') = 'a'\n\tSimpleFold('a') = 'A'\n\n\tSimpleFold('K') = 'k'\n\tSimpleFold('k') = '\\u212A' (Kelvin symbol, K)\n\tSimpleFold('\\u212A') = 'K'\n\n\tSimpleFold('1') = '1'\n\n\tSimpleFold(-2) = -2\nGo return type: rune\nJoker return type: ABEND042(cannot find typename unicode.rune)"
;;   {:added "1.0"
;;    :go "simpleFold(r)"}
;;   [r])

JOKER FUNC unicode.To has:
;; (defn To
;;   "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.\nGo return type: rune\nJoker return type: ABEND042(cannot find typename unicode.rune)"
;;   {:added "1.0"
;;    :go "to(_case, r)"}
;;   [^Int _case, r])

JOKER FUNC unicode.ToLower has:
;; (defn ToLower
;;   "ToLower maps the rune to lower case.\nGo return type: rune\nJoker return type: ABEND042(cannot find typename unicode.rune)"
;;   {:added "1.0"
;;    :go "toLower(r)"}
;;   [r])

JOKER FUNC unicode.ToTitle has:
;; (defn ToTitle
;;   "ToTitle maps the rune to title case.\nGo return type: rune\nJoker return type: ABEND042(cannot find typename unicode.rune)"
;;   {:added "1.0"
;;    :go "toTitle(r)"}
;;   [r])

JOKER FUNC unicode.ToUpper has:
;; (defn ToUpper
;;   "ToUpper maps the rune to upper case.\nGo return type: rune\nJoker return type: ABEND042(cannot find typename unicode.rune)"
;;   {:added "1.0"
;;    :go "toUpper(r)"}
;;   [r])

JOKER FUNC unsafe.Alignof has:
;; (defn Alignof
;;   "Alignof takes an expression x of any type and returns the required alignment\nof a hypothetical variable v as if v was declared via var v = x.\nIt is the largest value m such that the address of v is always zero mod m.\nIt is the same as the value returned by reflect.TypeOf(x).Align().\nAs a special case, if a variable s is of struct type and f is a field\nwithin that struct, then Alignof(s.f) will return the required alignment\nof a field of that type within a struct. This case is the same as the\nvalue returned by reflect.TypeOf(s.f).FieldAlign().\nGo return type: uintptr\nJoker return type: ABEND042(cannot find typename unsafe.uintptr)"
;;   {:added "1.0"
;;    :go "alignof(x)"}
;;   [x])

JOKER FUNC unsafe.Offsetof has:
;; (defn Offsetof
;;   "Offsetof returns the offset within the struct of the field represented by x,\nwhich must be of the form structValue.field. In other words, it returns the\nnumber of bytes between the start of the struct and the start of the field.\nGo return type: uintptr\nJoker return type: ABEND042(cannot find typename unsafe.uintptr)"
;;   {:added "1.0"
;;    :go "offsetof(x)"}
;;   [x])

JOKER FUNC unsafe.Sizeof has:
;; (defn Sizeof
;;   "Sizeof takes an expression x of any type and returns the size in bytes\nof a hypothetical variable v as if v was declared via var v = x.\nThe size does not include any memory possibly referenced by x.\nFor instance, if x is a slice, Sizeof returns the size of the slice\ndescriptor, not the size of the memory referenced by the slice.\nGo return type: uintptr\nJoker return type: ABEND042(cannot find typename unsafe.uintptr)"
;;   {:added "1.0"
;;    :go "sizeof(x)"}
;;   [x])

JOKER FUNC url.Parse has:
;; (defn Parse
;;   "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\nGo return type: (*URL, error)\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^{:username ^String, :password ^String, :passwordSet ^Bool}, :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
;;   {:added "1.0"
;;    :go "parse(rawurl)"}
;;   [^String rawurl])

JOKER FUNC url.ParseQuery has:
;; (defn ParseQuery
;;   "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\nGo return type: (Values, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/url/url.go:804:13) Error]"
;;   {:added "1.0"
;;    :go "parseQuery(query)"}
;;   [^String query])

JOKER FUNC url.ParseRequestURI has:
;; (defn ParseRequestURI
;;   "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\nGo return type: (*URL, error)\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^{:username ^String, :password ^String, :passwordSet ^Bool}, :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
;;   {:added "1.0"
;;    :go "parseRequestURI(rawurl)"}
;;   [^String rawurl])

JOKER FUNC url.PathEscape has:
(defn ^String PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "pathEscape(s)"}
  [^String s])

JOKER FUNC url.PathUnescape has:
;; (defn PathUnescape
;;   "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "pathUnescape(s)"}
;;   [^String s])

JOKER FUNC url.QueryEscape has:
(defn ^String QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\nGo return type: string\nJoker return type: String"
  {:added "1.0"
   :go "queryEscape(s)"}
  [^String s])

JOKER FUNC url.QueryUnescape has:
;; (defn QueryUnescape
;;   "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\nGo return type: (string, error)\nJoker return type: [String Error]"
;;   {:added "1.0"
;;    :go "queryUnescape(s)"}
;;   [^String s])

JOKER FUNC url.User has:
;; (defn User
;;   "User returns a Userinfo containing the provided username\nand no password set.\nGo return type: *Userinfo\nJoker return type: {:username ^String, :password ^String, :passwordSet ^Bool}"
;;   {:added "1.0"
;;    :go "user(username)"}
;;   [^String username])

JOKER FUNC url.UserPassword has:
;; (defn UserPassword
;;   "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\nGo return type: *Userinfo\nJoker return type: {:username ^String, :password ^String, :passwordSet ^Bool}"
;;   {:added "1.0"
;;    :go "userPassword(username, password)"}
;;   [^String username, ^String password])

JOKER FUNC user.Current has:
;; (defn Current
;;   "Current returns the current user.\nGo return type: (*User, error)\nJoker return type: [{:Uid ^String, :Gid ^String, :Username ^String, :Name ^String, :HomeDir ^String} Error]"
;;   {:added "1.0"
;;    :go "current()"}
;;   [])

JOKER FUNC user.Lookup has:
;; (defn Lookup
;;   "Lookup looks up a user by username. If the user cannot be found, the\nreturned error is of type UnknownUserError.\nGo return type: (*User, error)\nJoker return type: [{:Uid ^String, :Gid ^String, :Username ^String, :Name ^String, :HomeDir ^String} Error]"
;;   {:added "1.0"
;;    :go "lookup(username)"}
;;   [^String username])

JOKER FUNC user.LookupGroup has:
;; (defn LookupGroup
;;   "LookupGroup looks up a group by name. If the group cannot be found, the\nreturned error is of type UnknownGroupError.\nGo return type: (*Group, error)\nJoker return type: [{:Gid ^String, :Name ^String} Error]"
;;   {:added "1.0"
;;    :go "lookupGroup(name)"}
;;   [^String name])

JOKER FUNC user.LookupGroupId has:
;; (defn LookupGroupId
;;   "LookupGroupId looks up a group by groupid. If the group cannot be found, the\nreturned error is of type UnknownGroupIdError.\nGo return type: (*Group, error)\nJoker return type: [{:Gid ^String, :Name ^String} Error]"
;;   {:added "1.0"
;;    :go "lookupGroupId(gid)"}
;;   [^String gid])

JOKER FUNC user.LookupId has:
;; (defn LookupId
;;   "LookupId looks up a user by userid. If the user cannot be found, the\nreturned error is of type UnknownUserIdError.\nGo return type: (*User, error)\nJoker return type: [{:Uid ^String, :Gid ^String, :Username ^String, :Name ^String, :HomeDir ^String} Error]"
;;   {:added "1.0"
;;    :go "lookupId(uid)"}
;;   [^String uid])

JOKER FUNC utf16.Decode has:
;; (defn Decode
;;   "Decode returns the Unicode code point sequence represented\nby the UTF-16 encoding s.\nGo return type: []rune\nJoker return type: (vector-of ABEND042(cannot find typename utf16.rune))"
;;   {:added "1.0"
;;    :go "decode(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf16/utf16.go:88:15) s])

JOKER FUNC utf16.DecodeRune has:
;; (defn DecodeRune
;;   "DecodeRune returns the UTF-16 decoding of a surrogate pair.\nIf the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\nthe Unicode replacement code point U+FFFD.\nGo return type: rune\nJoker return type: ABEND042(cannot find typename utf16.rune)"
;;   {:added "1.0"
;;    :go "decodeRune(r1, r2)"}
;;   [r1, r2])

JOKER FUNC utf16.Encode has:
;; (defn Encode
;;   "Encode returns the UTF-16 encoding of the Unicode code point sequence s.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "encode(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf16/utf16.go:56:15) s])

JOKER FUNC utf16.EncodeRune has:
;; (defn EncodeRune
;;   "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\nIf the rune is not a valid Unicode code point or does not need encoding,\nEncodeRune returns U+FFFD, U+FFFD.\nGo return type: (r1 rune, r2 rune)\nJoker return type: [^ABEND042(cannot find typename utf16.rune) r1 ^ABEND042(cannot find typename utf16.rune) r2]"
;;   {:added "1.0"
;;    :go "encodeRune(r)"}
;;   [r])

JOKER FUNC utf16.IsSurrogate has:
(defn ^Bool IsSurrogate
  "IsSurrogate reports whether the specified Unicode code point\ncan appear in a surrogate pair.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "isSurrogate(r)"}
  [r])

JOKER FUNC utf8.DecodeLastRune has:
;; (defn DecodeLastRune
;;   "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\nGo return type: (r rune, size int)\nJoker return type: [^ABEND042(cannot find typename utf8.rune) r ^Int size]"
;;   {:added "1.0"
;;    :go "decodeLastRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:245:23) p])

JOKER FUNC utf8.DecodeLastRuneInString has:
;; (defn DecodeLastRuneInString
;;   "DecodeLastRuneInString is like DecodeLastRune but its input is a string. If\ns is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\nit returns (RuneError, 1). Both are impossible results for correct,\nnon-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\nGo return type: (r rune, size int)\nJoker return type: [^ABEND042(cannot find typename utf8.rune) r ^Int size]"
;;   {:added "1.0"
;;    :go "decodeLastRuneInString(s)"}
;;   [^String s])

JOKER FUNC utf8.DecodeRune has:
;; (defn DecodeRune
;;   "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\nGo return type: (r rune, size int)\nJoker return type: [^ABEND042(cannot find typename utf8.rune) r ^Int size]"
;;   {:added "1.0"
;;    :go "decodeRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:149:19) p])

JOKER FUNC utf8.DecodeRuneInString has:
;; (defn DecodeRuneInString
;;   "DecodeRuneInString is like DecodeRune but its input is a string. If s is\nempty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it\nreturns (RuneError, 1). Both are impossible results for correct, non-empty\nUTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\nGo return type: (r rune, size int)\nJoker return type: [^ABEND042(cannot find typename utf8.rune) r ^Int size]"
;;   {:added "1.0"
;;    :go "decodeRuneInString(s)"}
;;   [^String s])

JOKER FUNC utf8.EncodeRune has:
;; (defn ^Int EncodeRune
;;   "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\nIt returns the number of bytes written.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "encodeRune(p, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:339:19) p, r])

JOKER FUNC utf8.FullRune has:
;; (defn ^Bool FullRune
;;   "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.\nAn invalid encoding is considered a full Rune since it will convert as a width-1 error rune.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "fullRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:102:17) p])

JOKER FUNC utf8.FullRuneInString has:
(defn ^Bool FullRuneInString
  "FullRuneInString is like FullRune but its input is a string.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "fullRuneInString(s)"}
  [^String s])

JOKER FUNC utf8.RuneCount has:
;; (defn ^Int RuneCount
;;   "RuneCount returns the number of runes in p. Erroneous and short\nencodings are treated as single runes of width 1 byte.\nGo return type: int\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runeCount(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:371:18) p])

JOKER FUNC utf8.RuneCountInString has:
;; (defn RuneCountInString
;;   "RuneCountInString is like RuneCount but its input is a string.\nGo return type: n int\nJoker return type: ^Int n"
;;   {:added "1.0"
;;    :go "runeCountInString(s)"}
;;   [^String s])

JOKER FUNC utf8.RuneLen has:
(defn ^Int RuneLen
  "RuneLen returns the number of bytes required to encode the rune.\nIt returns -1 if the rune is not a valid value to encode in UTF-8.\nGo return type: int\nJoker return type: Int"
  {:added "1.0"
   :go "runeLen(r)"}
  [r])

JOKER FUNC utf8.RuneStart has:
(defn ^Bool RuneStart
  "RuneStart reports whether the byte could be the first byte of an encoded,\npossibly invalid rune. Second and subsequent bytes always have the top two\nbits set to 10.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "runeStart(b)"}
  [b])

JOKER FUNC utf8.Valid has:
;; (defn ^Bool Valid
;;   "Valid reports whether p consists entirely of valid UTF-8-encoded runes.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "valid(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:448:14) p])

JOKER FUNC utf8.ValidRune has:
(defn ^Bool ValidRune
  "ValidRune reports whether r can be legally encoded as UTF-8.\nCode points that are out of range or a surrogate half are illegal.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "validRune(r)"}
  [r])

JOKER FUNC utf8.ValidString has:
(defn ^Bool ValidString
  "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\nGo return type: bool\nJoker return type: Bool"
  {:added "1.0"
   :go "validString(s)"}
  [^String s])

JOKER FUNC x509.CreateCertificate has:
;; (defn CreateCertificate
;;   "CreateCertificate creates a new X.509v3 certificate based on a template.\nThe following members of template are used:\n\n - AuthorityKeyId\n - BasicConstraintsValid\n - CRLDistributionPoints\n - DNSNames\n - EmailAddresses\n - ExcludedDNSDomains\n - ExcludedEmailAddresses\n - ExcludedIPRanges\n - ExcludedURIDomains\n - ExtKeyUsage\n - ExtraExtensions\n - IsCA\n - IssuingCertificateURL\n - KeyUsage\n - MaxPathLen\n - MaxPathLenZero\n - NotAfter\n - NotBefore\n - OCSPServer\n - PermittedDNSDomains\n - PermittedDNSDomainsCritical\n - PermittedEmailAddresses\n - PermittedIPRanges\n - PermittedURIDomains\n - PolicyIdentifiers\n - SerialNumber\n - SignatureAlgorithm\n - Subject\n - SubjectKeyId\n - URIs\n - UnknownExtKeyUsage\n\nThe certificate is signed by parent. If parent is equal to template then the\ncertificate is self-signed. The parameter pub is the public key of the\nsignee and priv is the private key of the signer.\n\nThe returned slice is the certificate in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nThe AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,\nunless the resulting certificate is self-signed. Otherwise the value from\ntemplate will be used.\nGo return type: (cert []int, err error)\nJoker return type: [^(vector-of Int) cert ^Error err]"
;;   {:added "1.0"
;;    :go "createCertificate(rand, template, parent, pub, priv)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2082:29) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:2082:57) template, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:2082:57) parent, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2082:81) pub, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2082:81) priv])

JOKER FUNC x509.CreateCertificateRequest has:
;; (defn CreateCertificateRequest
;;   "CreateCertificateRequest creates a new certificate request based on a\ntemplate. The following members of template are used:\n\n - Attributes\n - DNSNames\n - EmailAddresses\n - ExtraExtensions\n - IPAddresses\n - URIs\n - SignatureAlgorithm\n - Subject\n\nThe private key is the private key of the signer.\n\nThe returned slice is the certificate request in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\nGo return type: (csr []int, err error)\nJoker return type: [^(vector-of Int) csr ^Error err]"
;;   {:added "1.0"
;;    :go "createCertificateRequest(rand, template, priv)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2407:36) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:2407:56) template, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2407:82) priv])

JOKER FUNC x509.DecryptPEMBlock has:
;; (defn DecryptPEMBlock
;;   "DecryptPEMBlock takes a password encrypted PEM block and the password used to\nencrypt it and returns a slice of decrypted DER encoded bytes. It inspects\nthe DEK-Info header to determine the algorithm used for decryption. If no\nDEK-Info header is present, an error is returned. If an incorrect password\nis detected an IncorrectPasswordError is returned. Because of deficiencies\nin the encrypted-PEM format, it's not always possible to detect an incorrect\npassword. In these cases no error will be returned but the decrypted DER\nbytes will be random noise.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "decryptPEMBlock(b, password)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pem_decrypt.go:115:24) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pem_decrypt.go:115:45) password])

JOKER FUNC x509.EncryptPEMBlock has:
;; (defn EncryptPEMBlock
;;   "EncryptPEMBlock returns a PEM block of the specified type holding the\ngiven DER-encoded data encrypted with the specified algorithm and\npassword.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/pem_decrypt.go:183:96) Error]"
;;   {:added "1.0"
;;    :go "encryptPEMBlock(rand, blockType, data, password, alg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/pem_decrypt.go:183:27) rand, ^String blockType, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pem_decrypt.go:183:71) data, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pem_decrypt.go:183:71) password, alg])

JOKER FUNC x509.IsEncryptedPEMBlock has:
;; (defn ^Bool IsEncryptedPEMBlock
;;   "IsEncryptedPEMBlock returns if the PEM block is password encrypted.\nGo return type: bool\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "isEncryptedPEMBlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pem_decrypt.go:99:28) b])

JOKER FUNC x509.MarshalECPrivateKey has:
;; (defn MarshalECPrivateKey
;;   "MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalECPrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/sec1.go:37:30) key])

JOKER FUNC x509.MarshalPKCS1PrivateKey has:
;; (defn MarshalPKCS1PrivateKey
;;   "MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "marshalPKCS1PrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pkcs1.go:92:33) key])

JOKER FUNC x509.MarshalPKCS1PublicKey has:
;; (defn MarshalPKCS1PublicKey
;;   "MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.\nGo return type: []int\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "marshalPKCS1PublicKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pkcs1.go:148:32) key])

JOKER FUNC x509.MarshalPKCS8PrivateKey has:
;; (defn MarshalPKCS8PrivateKey
;;   "MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form.\nThe following key types are supported: *rsa.PrivateKey, *ecdsa.PrivateKey.\nUnsupported key types result in an error.\n\nSee RFC 5208.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalPKCS8PrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/pkcs8.go:63:33) key])

JOKER FUNC x509.MarshalPKIXPublicKey has:
;; (defn MarshalPKIXPublicKey
;;   "MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalPKIXPublicKey(pub)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:104:31) pub])

JOKER FUNC x509.NewCertPool has:
;; (defn NewCertPool
;;   "NewCertPool returns a new, empty CertPool.\nGo return type: *CertPool\nJoker return type: {:bySubjectKeyId ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/x509/cert_pool.go:15:17), :byName ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/x509/cert_pool.go:16:17), :certs ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:647:23), :Issuer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:648:22), :Subject ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:649:22), :NotBefore ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22), :NotAfter ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22), :KeyUsage ^Int, :Extensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:657:15)), :ExtraExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:663:20)), :UnhandledCriticalExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:673:32)), :ExtKeyUsage ^(vector-of Int), :UnknownExtKeyUsage ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:676:23)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:714:19)), :URIs ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:715:20)), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:721:33)), :ExcludedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:722:33)), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:731:22))})}"
;;   {:added "1.0"
;;    :go "newCertPool()"}
;;   [])

JOKER FUNC x509.ParseCRL has:
;; (defn ParseCRL
;;   "ParseCRL parses a CRL from the given bytes. It's often the case that PEM\nencoded CRLs will appear where they should be DER encoded, so this function\nwill transparently handle PEM encoding as long as there isn't any leading\ngarbage.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2179:34) Error]"
;;   {:added "1.0"
;;    :go "parseCRL(crlBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2179:24) crlBytes])

JOKER FUNC x509.ParseCertificate has:
;; (defn ParseCertificate
;;   "ParseCertificate parses a single certificate from the given ASN.1 DER data.\nGo return type: (*Certificate, error)\nJoker return type: [{:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:647:23), :Issuer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:648:22), :Subject ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:649:22), :NotBefore ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22), :NotAfter ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22), :KeyUsage ^Int, :Extensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:657:15)), :ExtraExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:663:20)), :UnhandledCriticalExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:673:32)), :ExtKeyUsage ^(vector-of Int), :UnknownExtKeyUsage ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:676:23)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:714:19)), :URIs ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:715:20)), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:721:33)), :ExcludedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:722:33)), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:731:22))} Error]"
;;   {:added "1.0"
;;    :go "parseCertificate(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:1562:32) asn1Data])

JOKER FUNC x509.ParseCertificateRequest has:
;; (defn ParseCertificateRequest
;;   "ParseCertificateRequest parses a single certificate request from the\ngiven ASN.1 DER data.\nGo return type: (*CertificateRequest, error)\nJoker return type: [{:Raw ^(vector-of Int), :RawTBSCertificateRequest ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :Version ^Int, :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2274:21), :Subject ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2276:10), :Attributes ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2279:15)), :Extensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2284:15)), :ExtraExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2293:20)), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2298:19)), :URIs ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2299:20))} Error]"
;;   {:added "1.0"
;;    :go "parseCertificateRequest(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2575:39) asn1Data])

JOKER FUNC x509.ParseCertificates has:
;; (defn ParseCertificates
;;   "ParseCertificates parses one or more certificates from the given ASN.1 DER\ndata. The certificates must be concatenated with no intermediate padding.\nGo return type: ([]*Certificate, error)\nJoker return type: [(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:647:23), :Issuer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:648:22), :Subject ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:649:22), :NotBefore ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22), :NotAfter ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22), :KeyUsage ^Int, :Extensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:657:15)), :ExtraExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:663:20)), :UnhandledCriticalExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:673:32)), :ExtKeyUsage ^(vector-of Int), :UnknownExtKeyUsage ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:676:23)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:714:19)), :URIs ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:715:20)), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:721:33)), :ExcludedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:722:33)), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:731:22))}) Error]"
;;   {:added "1.0"
;;    :go "parseCertificates(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:1577:33) asn1Data])

JOKER FUNC x509.ParseDERCRL has:
;; (defn ParseDERCRL
;;   "ParseDERCRL parses a DER encoded CRL from the given bytes.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2190:37) Error]"
;;   {:added "1.0"
;;    :go "parseDERCRL(derBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2190:27) derBytes])

JOKER FUNC x509.ParseECPrivateKey has:
;; (defn ParseECPrivateKey
;;   "ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/sec1.go:32:38) Error]"
;;   {:added "1.0"
;;    :go "parseECPrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/sec1.go:32:28) der])

JOKER FUNC x509.ParsePKCS1PrivateKey has:
;; (defn ParsePKCS1PrivateKey
;;   "ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/pkcs1.go:45:41) Error]"
;;   {:added "1.0"
;;    :go "parsePKCS1PrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pkcs1.go:45:31) der])

JOKER FUNC x509.ParsePKCS1PublicKey has:
;; (defn ParsePKCS1PublicKey
;;   "ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.\nGo return type: (*, error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/pkcs1.go:124:40) Error]"
;;   {:added "1.0"
;;    :go "parsePKCS1PublicKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pkcs1.go:124:30) der])

JOKER FUNC x509.ParsePKCS8PrivateKey has:
;; (defn ParsePKCS8PrivateKey
;;   "ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key.\nSee RFC 5208.\nGo return type: (key, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/pkcs8.go:28:44) key ^Error err]"
;;   {:added "1.0"
;;    :go "parsePKCS8PrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pkcs8.go:28:31) der])

JOKER FUNC x509.ParsePKIXPublicKey has:
;; (defn ParsePKIXPublicKey
;;   "ParsePKIXPublicKey parses a DER encoded public key. These values are\ntypically found in PEM blocks with \"BEGIN PUBLIC KEY\".\n\nSupported key types include RSA, DSA, and ECDSA. Unknown key\ntypes result in an error.\n\nOn success, pub will be of type *rsa.PublicKey, *dsa.PublicKey,\nor *ecdsa.PublicKey.\nGo return type: (pub, err error)\nJoker return type: [^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:55:47) pub ^Error err]"
;;   {:added "1.0"
;;    :go "parsePKIXPublicKey(derBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:55:34) derBytes])

JOKER FUNC x509.SystemCertPool has:
;; (defn SystemCertPool
;;   "SystemCertPool returns a copy of the system cert pool.\n\nAny mutations to the returned pool are not written to disk and do\nnot affect any other pool.\n\nNew changes in the the system cert pool might not be reflected\nin subsequent calls.\nGo return type: (*CertPool, error)\nJoker return type: [{:bySubjectKeyId ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/x509/cert_pool.go:15:17), :byName ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/x509/cert_pool.go:16:17), :certs ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:647:23), :Issuer ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:648:22), :Subject ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:649:22), :NotBefore ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22), :NotAfter ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22), :KeyUsage ^Int, :Extensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:657:15)), :ExtraExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:663:20)), :UnhandledCriticalExtensions ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:673:32)), :ExtKeyUsage ^(vector-of Int), :UnknownExtKeyUsage ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:676:23)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:714:19)), :URIs ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:715:20)), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:721:33)), :ExcludedIPRanges ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:722:33)), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:731:22))})} Error]"
;;   {:added "1.0"
;;    :go "systemCertPool()"}
;;   [])

JOKER FUNC xml.CopyToken has:
;; (defn CopyToken
;;   "CopyToken returns a copy of a Token.\nGo return type: Token\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/xml.go:55:12)"
;;   {:added "1.0"
;;    :go "copyToken(t)"}
;;   [t])

JOKER FUNC xml.Escape has:
;; (defn Escape
;;   "Escape is like EscapeText but omits the error return value.\nIt is provided for backwards compatibility with Go 1.0.\nCode targeting Go 1.1 or later should use EscapeText.\n"
;;   {:added "1.0"
;;    :go "escape(w, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:1985:15) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/xml/xml.go:1985:28) s])

JOKER FUNC xml.EscapeText has:
;; (defn ^Error EscapeText
;;   "EscapeText writes to w the properly escaped XML equivalent\nof the plain text data s.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "escapeText(w, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:1891:19) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/xml/xml.go:1891:32) s])

JOKER FUNC xml.Marshal has:
;; (defn Marshal
;;   "Marshal returns the XML encoding of v.\n\nMarshal handles an array or slice by marshaling each of the elements.\nMarshal handles a pointer by marshaling the value it points at or, if the\npointer is nil, by writing nothing. Marshal handles an interface value by\nmarshaling the value it contains or, if the interface value is nil, by\nwriting nothing. Marshal handles all other data by writing one or more XML\nelements containing the data.\n\nThe name for the XML elements is taken from, in order of preference:\n    - the tag on the XMLName field, if the data is a struct\n    - the value of the XMLName field of type Name\n    - the tag of the struct field used to obtain the data\n    - the name of the struct field used to obtain the data\n    - the name of the marshaled type\n\nThe XML element for a struct contains marshaled elements for each of the\nexported fields of the struct, with these exceptions:\n    - the XMLName field, described above, is omitted.\n    - a field with tag \"-\" is omitted.\n    - a field with tag \"name,attr\" becomes an attribute with\n      the given name in the XML element.\n    - a field with tag \",attr\" becomes an attribute with the\n      field name in the XML element.\n    - a field with tag \",chardata\" is written as character data,\n      not as an XML element.\n    - a field with tag \",cdata\" is written as character data\n      wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.\n    - a field with tag \",innerxml\" is written verbatim, not subject\n      to the usual marshaling procedure.\n    - a field with tag \",comment\" is written as an XML comment, not\n      subject to the usual marshaling procedure. It must not contain\n      the \"--\" string within it.\n    - a field with a tag including the \"omitempty\" option is omitted\n      if the field value is empty. The empty values are false, 0, any\n      nil pointer or interface value, and any array, slice, map, or\n      string of length zero.\n    - an anonymous struct field is handled as if the fields of its\n      value were part of the outer struct.\n\nIf a field uses a tag \"a>b>c\", then the element c will be nested inside\nparent elements a and b. Fields that appear next to each other that name\nthe same parent will be enclosed in one XML element.\n\nIf the XML name for a struct field is defined by both the field tag and the\nstruct's XMLName field, the names must match.\n\nSee MarshalIndent for an example.\n\nMarshal will return an error if asked to marshal a channel, function, or map.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/marshal.go:75:16) v])

JOKER FUNC xml.MarshalIndent has:
;; (defn MarshalIndent
;;   "MarshalIndent works like Marshal, but each XML element begins on a new\nindented line that starts with prefix and is followed by one or more\ncopies of indent according to the nesting depth.\nGo return type: ([]int, error)\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalIndent(v, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/marshal.go:121:22) v, ^String prefix, ^String indent])

JOKER FUNC xml.NewDecoder has:
;; (defn NewDecoder
;;   "NewDecoder creates a new XML parser reading from r.\nIf r does not implement io.ByteReader, NewDecoder will\ndo its own buffering.\nGo return type: *Decoder\nJoker return type: {:Strict ^Bool, :AutoClose ^(vector-of String), :Entity ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/xml/xml.go:195:9), :CharsetReader ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/encoding/xml/xml.go:202:16), :DefaultSpace ^String, :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:209:17), :t ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/xml.go:151:18), :buf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:211:17), :saved ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:212:18), :stk ^ABEND042(cannot find typename xml.stack), :free ^ABEND042(cannot find typename xml.stack), :needClose ^Bool, :toClose ^{:Space ^String, :Local ^String}, :nextToken ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/xml.go:55:12), :nextByte ^Int, :ns ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/xml/xml.go:219:17), :err ^Error, :line ^Int, :offset ^Int, :unmarshalDepth ^Int}"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:229:19) r])

JOKER FUNC xml.NewEncoder has:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\nGo return type: *Encoder\nJoker return type: {:p ^ABEND042(cannot find typename xml.printer)}"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/marshal.go:137:19) w])

JOKER FUNC xml.NewTokenDecoder has:
;; (defn NewTokenDecoder
;;   "NewTokenDecoder creates a new XML parser using an underlying token stream.\nGo return type: *Decoder\nJoker return type: {:Strict ^Bool, :AutoClose ^(vector-of String), :Entity ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/xml/xml.go:195:9), :CharsetReader ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/encoding/xml/xml.go:202:16), :DefaultSpace ^String, :r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:209:17), :t ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/xml.go:151:18), :buf ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:211:17), :saved ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:212:18), :stk ^ABEND042(cannot find typename xml.stack), :free ^ABEND042(cannot find typename xml.stack), :needClose ^Bool, :toClose ^{:Space ^String, :Local ^String}, :nextToken ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/xml.go:55:12), :nextByte ^Int, :ns ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/xml/xml.go:219:17), :err ^Error, :line ^Int, :offset ^Int, :unmarshalDepth ^Int}"
;;   {:added "1.0"
;;    :go "newTokenDecoder(t)"}
;;   [t])

JOKER FUNC xml.Unmarshal has:
;; (defn ^Error Unmarshal
;;   "Unmarshal parses the XML-encoded data and stores the result in\nthe value pointed to by v, which must be an arbitrary struct,\nslice, or string. Well-formed data that does not fit into v is\ndiscarded.\n\nBecause Unmarshal uses the reflect package, it can only assign\nto exported (upper case) fields. Unmarshal uses a case-sensitive\ncomparison to match XML element names to tag values and struct\nfield names.\n\nUnmarshal maps an XML element to a struct using the following rules.\nIn the rules, the tag of a field refers to the value associated with the\nkey 'xml' in the struct field's tag (see the example above).\n\n  * If the struct has a field of type []byte or string with tag\n     \",innerxml\", Unmarshal accumulates the raw XML nested inside the\n     element in that field. The rest of the rules still apply.\n\n  * If the struct has a field named XMLName of type Name,\n     Unmarshal records the element name in that field.\n\n  * If the XMLName field has an associated tag of the form\n     \"name\" or \"namespace-URL name\", the XML element must have\n     the given name (and, optionally, name space) or else Unmarshal\n     returns an error.\n\n  * If the XML element has an attribute whose name matches a\n     struct field name with an associated tag containing \",attr\" or\n     the explicit name in a struct field tag of the form \"name,attr\",\n     Unmarshal records the attribute value in that field.\n\n  * If the XML element has an attribute not handled by the previous\n     rule and the struct has a field with an associated tag containing\n     \",any,attr\", Unmarshal records the attribute value in the first\n     such field.\n\n  * If the XML element contains character data, that data is\n     accumulated in the first struct field that has tag \",chardata\".\n     The struct field may have type []byte or string.\n     If there is no such field, the character data is discarded.\n\n  * If the XML element contains comments, they are accumulated in\n     the first struct field that has tag \",comment\".  The struct\n     field may have type []byte or string. If there is no such\n     field, the comments are discarded.\n\n  * If the XML element contains a sub-element whose name matches\n     the prefix of a tag formatted as \"a\" or \"a>b>c\", unmarshal\n     will descend into the XML structure looking for elements with the\n     given names, and will map the innermost elements to that struct\n     field. A tag starting with \">\" is equivalent to one starting\n     with the field name followed by \">\".\n\n  * If the XML element contains a sub-element whose name matches\n     a struct field's XMLName tag and the struct field has no\n     explicit name tag as per the previous rule, unmarshal maps\n     the sub-element to that struct field.\n\n  * If the XML element contains a sub-element whose name matches a\n     field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal\n     maps the sub-element to that struct field.\n\n  * If the XML element contains a sub-element that hasn't matched any\n     of the above rules and the struct has a field with tag \",any\",\n     unmarshal maps the sub-element to that struct field.\n\n  * An anonymous struct field is handled as if the fields of its\n     value were part of the outer struct.\n\n  * A struct field with tag \"-\" is never unmarshaled into.\n\nUnmarshal maps an XML element to a string or []byte by saving the\nconcatenation of that element's character data in the string or\n[]byte. The saved []byte is never nil.\n\nUnmarshal maps an attribute value to a string or []byte by saving\nthe value in the string or slice.\n\nUnmarshal maps an attribute value to an Attr by saving the attribute,\nincluding its name, in the Attr.\n\nUnmarshal maps an XML element or attribute value to a slice by\nextending the length of the slice and mapping the element or attribute\nto the newly created value.\n\nUnmarshal maps an XML element or attribute value to a bool by\nsetting it to the boolean value represented by the string. Whitespace\nis trimmed and ignored.\n\nUnmarshal maps an XML element or attribute value to an integer or\nfloating-point field by setting the field to the result of\ninterpreting the string value in decimal. There is no check for\noverflow. Whitespace is trimmed and ignored.\n\nUnmarshal maps an XML element to a Name by recording the element\nname.\n\nUnmarshal maps an XML element to a pointer by setting the pointer\nto a freshly allocated value and then mapping the element to that value.\n\nA missing element or empty attribute value will be unmarshaled as a zero value.\nIf the field is a slice, a zero value will be appended to the field. Otherwise, the\nfield will be set to its zero value.\nGo return type: error\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "unmarshal(data, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/xml/read.go:127:21) data, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/read.go:127:31) v])

JOKER FUNC zip.FileInfoHeader has:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated FileHeader from an\nos.FileInfo.\nBecause os.FileInfo's Name method returns only the base name of\nthe file it describes, it may be necessary to modify the Name field\nof the returned header to provide the full path name of the file.\nIf compression is desired, callers should set the FileHeader.Method\nfield; it is unset by default.\nGo return type: (*FileHeader, error)\nJoker return type: [{:Name ^String, :Comment ^String, :NonUTF8 ^Bool, :CreatorVersion ^Int, :ReaderVersion ^Int, :Flags ^Int, :Method ^Int, :Modified ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/struct.go:127:15), :ModifiedTime ^Int, :ModifiedDate ^Int, :CRC32 ^Int, :CompressedSize ^Int, :UncompressedSize ^Int, :CompressedSize64 ^ABEND042(cannot find typename zip.uint64), :UncompressedSize64 ^ABEND042(cannot find typename zip.uint64), :Extra ^(vector-of Int), :ExternalAttrs ^Int} Error]"
;;   {:added "1.0"
;;    :go "fileInfoHeader(fi)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/struct.go:169:24) fi])

JOKER FUNC zip.NewReader has:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r, which is assumed to\nhave the given size in bytes.\nGo return type: (*Reader, error)\nJoker return type: [{:r ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/reader.go:26:16), :File ^(vector-of {:zip ^ABEND947(recursive type reference involving zip.Reader), :zipr ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/reader.go:40:15), :zipsize ^Int, :headerOffset ^Int}), :Comment ^String, :decompressors ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/archive/zip/reader.go:29:16)} Error]"
;;   {:added "1.0"
;;    :go "newReader(r, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/reader.go:71:18) r, size])

JOKER FUNC zip.NewWriter has:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing a zip file to w.\nGo return type: *Writer\nJoker return type: {:cw ^ABEND042(cannot find typename zip.countWriter), :dir ^(vector-of ABEND042(cannot find typename zip.header)), :last ^ABEND042(cannot find typename zip.fileWriter), :closed ^Bool, :compressors ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/archive/zip/writer.go:29:14), :comment ^String, :testHookCloseSizeOffset ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/archive/zip/writer.go:34:26)}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/writer.go:43:18) w])

JOKER FUNC zip.OpenReader has:
;; (defn OpenReader
;;   "OpenReader will open the Zip file specified by name and return a ReadCloser.\nGo return type: (*ReadCloser, error)\nJoker return type: [{:f ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/reader.go:33:5)} Error]"
;;   {:added "1.0"
;;    :go "openReader(name)"}
;;   [^String name])

JOKER FUNC zip.RegisterCompressor has:
;; (defn RegisterCompressor
;;   "RegisterCompressor registers custom compressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n"
;;   {:added "1.0"
;;    :go "registerCompressor(method, comp)"}
;;   [^Int method, comp])

JOKER FUNC zip.RegisterDecompressor has:
;; (defn RegisterDecompressor
;;   "RegisterDecompressor allows custom decompressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n"
;;   {:added "1.0"
;;    :go "registerDecompressor(method, dcomp)"}
;;   [^Int method, dcomp])

JOKER FUNC zlib.NewReader has:
;; (defn NewReader
;;   "NewReader creates a new ReadCloser.\nReads from the returned ReadCloser read and decompress data from r.\nIf r does not implement io.ByteReader, the decompressor may read more\ndata than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when done.\n\nThe ReadCloser returned by NewReader also implements Resetter.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/reader.go:70:30) Error]"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/reader.go:70:18) r])

JOKER FUNC zlib.NewReaderDict has:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but uses a preset dictionary.\nNewReaderDict ignores the dictionary if the compressed data does not refer to it.\nIf the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.\n\nThe ReadCloser returned by NewReaderDict also implements Resetter.\nGo return type: (error)\nJoker return type: [ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/reader.go:79:47) Error]"
;;   {:added "1.0"
;;    :go "newReaderDict(r, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/reader.go:79:22) r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/reader.go:79:38) dict])

JOKER FUNC zlib.NewWriter has:
;; (defn NewWriter
;;   "NewWriter creates a new Writer.\nWrites to the returned Writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\nGo return type: *Writer\nJoker return type: {:w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:28:14), :level ^Int, :dict ^(vector-of Int), :compressor ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:31:15), :digest ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:32:14), :err ^Error, :scratch ^(vector-of Int), :wroteHeader ^Bool}"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:43:18) w])

JOKER FUNC zlib.NewWriterLevel has:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\nGo return type: (*Writer, error)\nJoker return type: [{:w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:28:14), :level ^Int, :dict ^(vector-of Int), :compressor ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:31:15), :digest ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:32:14), :err ^Error, :scratch ^(vector-of Int), :wroteHeader ^Bool} Error]"
;;   {:added "1.0"
;;    :go "newWriterLevel(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:54:23) w, ^Int level])

JOKER FUNC zlib.NewWriterLevelDict has:
;; (defn NewWriterLevelDict
;;   "NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to\ncompress with.\n\nThe dictionary may be nil. If not, its contents should not be modified until\nthe Writer is closed.\nGo return type: (*Writer, error)\nJoker return type: [{:w ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:28:14), :level ^Int, :dict ^(vector-of Int), :compressor ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:31:15), :digest ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:32:14), :err ^Error, :scratch ^(vector-of Int), :wroteHeader ^Bool} Error]"
;;   {:added "1.0"
;;    :go "newWriterLevelDict(w, level, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:63:27) w, ^Int level, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/writer.go:63:54) dict])

GO FUNC adler32.New has:
// func new() Object {
// 	arg_1 := adler32.New()
// 	...ABEND676: TODO...
// }

GO FUNC aes.NewCipher has:
// func newCipher(key ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/aes/cipher.go:32:20)) Object {
// 	arg_1, arg_2 := aes.NewCipher(key)
// 	...ABEND676: TODO...
// }

GO FUNC ascii85.Decode has:
// func decode(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/ascii85/ascii85.go:189:22), src ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/ascii85/ascii85.go:189:22), flush Object) Object {
// 	ndst, nsrc, err := ascii85.Decode(dst, src, flush)
// 	...ABEND676: TODO...
// }

GO FUNC ascii85.NewDecoder has:
// func newDecoder(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/ascii85/ascii85.go:246:19)) Object {
// 	arg_1 := ascii85.NewDecoder(r)
// 	...ABEND676: TODO...
// }

GO FUNC ascii85.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/ascii85/ascii85.go:93:19)) Object {
// 	arg_1 := ascii85.NewEncoder(w)
// 	...ABEND676: TODO...
// }

GO FUNC asn1.Marshal has:
// func marshal(val ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/marshal.go:677:18)) Object {
// 	arg_1, arg_2 := asn1.Marshal(val)
// 	...ABEND676: TODO...
// }

GO FUNC asn1.MarshalWithParams has:
// func marshalWithParams(val ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/marshal.go:683:28), params string) Object {
// 	arg_1, arg_2 := asn1.MarshalWithParams(val, params)
// 	...ABEND676: TODO...
// }

GO FUNC asn1.Unmarshal has:
// func unmarshal(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/asn1/asn1.go:1053:18), val ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/asn1.go:1053:30)) Object {
// 	rest, err := asn1.Unmarshal(b, val)
// 	...ABEND676: TODO...
// }

GO FUNC asn1.UnmarshalWithParams has:
// func unmarshalWithParams(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/asn1/asn1.go:1059:28), val ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/asn1.go:1059:40), params string) Object {
// 	rest, err := asn1.UnmarshalWithParams(b, val, params)
// 	...ABEND676: TODO...
// }

GO FUNC ast.Inspect has:
// func inspect(node Object, f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/ast/walk.go:384:27)) Object {
// 	ast.Inspect(node, f)
// 	...ABEND676: TODO...
// }

GO FUNC ast.MergePackageFiles has:
// func mergePackageFiles(pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:344:28), mode Object) Object {
// 	arg_1 := ast.MergePackageFiles(pkg, mode)
// 	...ABEND676: TODO...
// }

GO FUNC ast.NewCommentMap has:
// func newCommentMap(fset ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/commentmap.go:143:25), node Object, comments ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/ast/commentmap.go:143:61)) Object {
// 	arg_1 := ast.NewCommentMap(fset, node, comments)
// 	...ABEND676: TODO...
// }

GO FUNC ast.NewIdent has:
// func newIdent(name string) Object {
// 	arg_1 := ast.NewIdent(name)
// 	...ABEND676: TODO...
// }

GO FUNC ast.NewObj has:
// func newObj(kind Object, name string) Object {
// 	arg_1 := ast.NewObj(kind, name)
// 	...ABEND676: TODO...
// }

GO FUNC ast.NewPackage has:
// func newPackage(fset ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/resolve.go:74:22), files ABEND882(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/resolve.go:74:44), importer Object, universe ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/resolve.go:74:90)) Object {
// 	arg_1, arg_2 := ast.NewPackage(fset, files, importer, universe)
// 	...ABEND676: TODO...
// }

GO FUNC ast.NewScope has:
// func newScope(outer ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/scope.go:25:21)) Object {
// 	arg_1 := ast.NewScope(outer)
// 	...ABEND676: TODO...
// }

GO FUNC ast.SortImports has:
// func sortImports(fset ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/import.go:15:23), f ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/import.go:15:41)) Object {
// 	ast.SortImports(fset, f)
// 	...ABEND676: TODO...
// }

GO FUNC ast.Walk has:
// func walk(v Object, node Object) Object {
// 	ast.Walk(v, node)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.AddInt32 has:
// func addInt32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:92:20), delta Object) Object {
// 	new := atomic.AddInt32(addr, delta)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.AddInt64 has:
// func addInt64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:100:20), delta Object) Object {
// 	new := atomic.AddInt64(addr, delta)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.AddUint32 has:
// func addUint32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:97:21), delta Object) Object {
// 	new := atomic.AddUint32(addr, delta)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.AddUint64 has:
// func addUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:105:21), delta Object) Object {
// 	new := atomic.AddUint64(addr, delta)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.AddUintptr has:
// func addUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:108:22), delta Object) Object {
// 	new := atomic.AddUintptr(addr, delta)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.CompareAndSwapInt32 has:
// func compareAndSwapInt32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:74:31), old Object, new Object) Object {
// 	swapped := atomic.CompareAndSwapInt32(addr, old, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.CompareAndSwapInt64 has:
// func compareAndSwapInt64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:77:31), old Object, new Object) Object {
// 	swapped := atomic.CompareAndSwapInt64(addr, old, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.CompareAndSwapPointer has:
// func compareAndSwapPointer(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:89:33), old ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:89:59), new ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:89:59)) Object {
// 	swapped := atomic.CompareAndSwapPointer(addr, old, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.CompareAndSwapUint32 has:
// func compareAndSwapUint32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:80:32), old Object, new Object) Object {
// 	swapped := atomic.CompareAndSwapUint32(addr, old, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.CompareAndSwapUint64 has:
// func compareAndSwapUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:83:32), old Object, new Object) Object {
// 	swapped := atomic.CompareAndSwapUint64(addr, old, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.CompareAndSwapUintptr has:
// func compareAndSwapUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:86:33), old Object, new Object) Object {
// 	swapped := atomic.CompareAndSwapUintptr(addr, old, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.LoadInt32 has:
// func loadInt32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:111:21)) Object {
// 	val := atomic.LoadInt32(addr)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.LoadInt64 has:
// func loadInt64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:114:21)) Object {
// 	val := atomic.LoadInt64(addr)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.LoadPointer has:
// func loadPointer(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:126:23)) Object {
// 	val := atomic.LoadPointer(addr)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.LoadUint32 has:
// func loadUint32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:117:22)) Object {
// 	val := atomic.LoadUint32(addr)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.LoadUint64 has:
// func loadUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:120:22)) Object {
// 	val := atomic.LoadUint64(addr)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.LoadUintptr has:
// func loadUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:123:23)) Object {
// 	val := atomic.LoadUintptr(addr)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.StoreInt32 has:
// func storeInt32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:129:22), val Object) Object {
// 	atomic.StoreInt32(addr, val)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.StoreInt64 has:
// func storeInt64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:132:22), val Object) Object {
// 	atomic.StoreInt64(addr, val)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.StorePointer has:
// func storePointer(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:144:24), val ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:144:45)) Object {
// 	atomic.StorePointer(addr, val)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.StoreUint32 has:
// func storeUint32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:135:23), val Object) Object {
// 	atomic.StoreUint32(addr, val)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.StoreUint64 has:
// func storeUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:138:23), val Object) Object {
// 	atomic.StoreUint64(addr, val)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.StoreUintptr has:
// func storeUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:141:24), val Object) Object {
// 	atomic.StoreUintptr(addr, val)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.SwapInt32 has:
// func swapInt32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:56:21), new Object) Object {
// 	old := atomic.SwapInt32(addr, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.SwapInt64 has:
// func swapInt64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:59:21), new Object) Object {
// 	old := atomic.SwapInt64(addr, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.SwapPointer has:
// func swapPointer(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:71:23), new ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:71:44)) Object {
// 	old := atomic.SwapPointer(addr, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.SwapUint32 has:
// func swapUint32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:62:22), new Object) Object {
// 	old := atomic.SwapUint32(addr, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.SwapUint64 has:
// func swapUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:65:22), new Object) Object {
// 	old := atomic.SwapUint64(addr, new)
// 	...ABEND676: TODO...
// }

GO FUNC atomic.SwapUintptr has:
// func swapUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:68:23), new Object) Object {
// 	old := atomic.SwapUintptr(addr, new)
// 	...ABEND676: TODO...
// }

GO FUNC base32.NewDecoder has:
// func newDecoder(enc ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base32/base32.go:530:21), r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base32/base32.go:530:34)) Object {
// 	arg_1 := base32.NewDecoder(enc, r)
// 	...ABEND676: TODO...
// }

GO FUNC base32.NewEncoder has:
// func newEncoder(enc ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base32/base32.go:259:21), w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base32/base32.go:259:34)) Object {
// 	arg_1 := base32.NewEncoder(enc, w)
// 	...ABEND676: TODO...
// }

GO FUNC base32.NewEncoding has:
// func newEncoding(encoder string) Object {
// 	arg_1 := base32.NewEncoding(encoder)
// 	...ABEND676: TODO...
// }

GO FUNC base64.NewDecoder has:
// func newDecoder(enc ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base64/base64.go:603:21), r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base64/base64.go:603:34)) Object {
// 	arg_1 := base64.NewDecoder(enc, r)
// 	...ABEND676: TODO...
// }

GO FUNC base64.NewEncoder has:
// func newEncoder(enc ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base64/base64.go:250:21), w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base64/base64.go:250:34)) Object {
// 	arg_1 := base64.NewEncoder(enc, w)
// 	...ABEND676: TODO...
// }

GO FUNC base64.NewEncoding has:
// func newEncoding(encoder string) Object {
// 	arg_1 := base64.NewEncoding(encoder)
// 	...ABEND676: TODO...
// }

GO FUNC bidi.AppendReverse has:
// func appendReverse(out ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go:189:28), in ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go:189:28)) Object {
// 	arg_1 := bidi.AppendReverse(out, in)
// 	...ABEND676: TODO...
// }

GO FUNC bidi.DefaultDirection has:
// func defaultDirection(d Object) Object {
// 	arg_1 := bidi.DefaultDirection(d)
// 	...ABEND676: TODO...
// }

GO FUNC bidi.Lookup has:
// func lookup(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/prop.go:87:15)) Object {
// 	p, sz := bidi.Lookup(s)
// 	...ABEND676: TODO...
// }

GO FUNC bidi.LookupRune has:
// func lookupRune(r Object) Object {
// 	p, size := bidi.LookupRune(r)
// 	...ABEND676: TODO...
// }

GO FUNC bidi.LookupString has:
// func lookupString(s string) Object {
// 	p, sz := bidi.LookupString(s)
// 	...ABEND676: TODO...
// }

GO FUNC bidirule.Direction has:
// func direction(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go:137:18)) Object {
// 	arg_1 := bidirule.Direction(b)
// 	...ABEND676: TODO...
// }

GO FUNC bidirule.DirectionString has:
// func directionString(s string) Object {
// 	arg_1 := bidirule.DirectionString(s)
// 	...ABEND676: TODO...
// }

GO FUNC bidirule.New has:
// func new() Object {
// 	arg_1 := bidirule.New()
// 	...ABEND676: TODO...
// }

GO FUNC big.NewFloat has:
// func newFloat(x Object) Object {
// 	arg_1 := big.NewFloat(x)
// 	...ABEND676: TODO...
// }

GO FUNC big.NewInt has:
// func newInt(x Object) Object {
// 	arg_1 := big.NewInt(x)
// 	...ABEND676: TODO...
// }

GO FUNC big.NewRat has:
// func newRat(a Object, b Object) Object {
// 	arg_1 := big.NewRat(a, b)
// 	...ABEND676: TODO...
// }

GO FUNC big.ParseFloat has:
// func parseFloat(s string, base int, prec Object, mode Object) Object {
// 	f, b, err := big.ParseFloat(s, base, prec, mode)
// 	...ABEND676: TODO...
// }

GO FUNC binary.ReadUvarint has:
// func readUvarint(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/binary/varint.go:106:20)) Object {
// 	arg_1, arg_2 := binary.ReadUvarint(r)
// 	...ABEND676: TODO...
// }

GO FUNC binary.ReadVarint has:
// func readVarint(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/binary/varint.go:126:19)) Object {
// 	arg_1, arg_2 := binary.ReadVarint(r)
// 	...ABEND676: TODO...
// }

GO FUNC binary.Uvarint has:
// func uvarint(buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/binary/varint.go:60:18)) Object {
// 	arg_1, arg_2 := binary.Uvarint(buf)
// 	...ABEND676: TODO...
// }

GO FUNC binary.Varint has:
// func varint(buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/binary/varint.go:94:17)) Object {
// 	arg_1, arg_2 := binary.Varint(buf)
// 	...ABEND676: TODO...
// }

GO FUNC bits.Len16 has:
// func len16(x Object) Object {
// 	n := bits.Len16(x)
// 	...ABEND676: TODO...
// }

GO FUNC bits.Len32 has:
// func len32(x Object) Object {
// 	n := bits.Len32(x)
// 	...ABEND676: TODO...
// }

GO FUNC bits.Len64 has:
// func len64(x Object) Object {
// 	n := bits.Len64(x)
// 	...ABEND676: TODO...
// }

GO FUNC bits.Reverse64 has:
// func reverse64(x Object) Object {
// 	arg_1 := bits.Reverse64(x)
// 	...ABEND676: TODO...
// }

GO FUNC bits.Reverse8 has:
// func reverse8(x Object) Object {
// 	arg_1 := bits.Reverse8(x)
// 	...ABEND676: TODO...
// }

GO FUNC bits.ReverseBytes64 has:
// func reverseBytes64(x Object) Object {
// 	arg_1 := bits.ReverseBytes64(x)
// 	...ABEND676: TODO...
// }

GO FUNC bits.RotateLeft64 has:
// func rotateLeft64(x Object, k int) Object {
// 	arg_1 := bits.RotateLeft64(x, k)
// 	...ABEND676: TODO...
// }

GO FUNC bits.RotateLeft8 has:
// func rotateLeft8(x Object, k int) Object {
// 	arg_1 := bits.RotateLeft8(x, k)
// 	...ABEND676: TODO...
// }

GO FUNC bits.TrailingZeros16 has:
// func trailingZeros16(x Object) Object {
// 	n := bits.TrailingZeros16(x)
// 	...ABEND676: TODO...
// }

GO FUNC bufio.NewReadWriter has:
// func newReadWriter(r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/bufio/bufio.go:743:22), w ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/bufio/bufio.go:743:33)) Object {
// 	arg_1 := bufio.NewReadWriter(r, w)
// 	...ABEND676: TODO...
// }

GO FUNC bufio.NewReader has:
// func newReader(rd ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:61:19)) Object {
// 	arg_1 := bufio.NewReader(rd)
// 	...ABEND676: TODO...
// }

GO FUNC bufio.NewReaderSize has:
// func newReaderSize(rd ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:46:23), size int) Object {
// 	arg_1 := bufio.NewReaderSize(rd, size)
// 	...ABEND676: TODO...
// }

GO FUNC bufio.NewScanner has:
// func newScanner(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/scan.go:86:19)) Object {
// 	arg_1 := bufio.NewScanner(r)
// 	...ABEND676: TODO...
// }

GO FUNC bufio.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:552:18)) Object {
// 	arg_1 := bufio.NewWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC bufio.NewWriterSize has:
// func newWriterSize(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:536:22), size int) Object {
// 	arg_1 := bufio.NewWriterSize(w, size)
// 	...ABEND676: TODO...
// }

GO FUNC bufio.ScanBytes has:
// func scanBytes(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:284:21), atEOF Object) Object {
// 	advance, token, err := bufio.ScanBytes(data, atEOF)
// 	...ABEND676: TODO...
// }

GO FUNC bufio.ScanLines has:
// func scanLines(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:345:21), atEOF Object) Object {
// 	advance, token, err := bufio.ScanLines(data, atEOF)
// 	...ABEND676: TODO...
// }

GO FUNC bufio.ScanRunes has:
// func scanRunes(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:299:21), atEOF Object) Object {
// 	advance, token, err := bufio.ScanRunes(data, atEOF)
// 	...ABEND676: TODO...
// }

GO FUNC bufio.ScanWords has:
// func scanWords(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:390:21), atEOF Object) Object {
// 	advance, token, err := bufio.ScanWords(data, atEOF)
// 	...ABEND676: TODO...
// }

GO FUNC build.ArchChar has:
// func archChar(goarch string) Object {
// 	arg_1, arg_2 := build.ArchChar(goarch)
// 	...ABEND676: TODO...
// }

GO FUNC build.Import has:
// func import(path string, srcDir string, mode Object) Object {
// 	arg_1, arg_2 := build.Import(path, srcDir, mode)
// 	...ABEND676: TODO...
// }

GO FUNC build.ImportDir has:
// func importDir(dir string, mode Object) Object {
// 	arg_1, arg_2 := build.ImportDir(dir, mode)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.Fields has:
// func fields(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:283:15)) Object {
// 	arg_1 := bytes.Fields(s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.FieldsFunc has:
// func fieldsFunc(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:339:19), f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:339:29)) Object {
// 	arg_1 := bytes.FieldsFunc(s, f)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.Join has:
// func join(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:387:13), sep ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:387:27)) Object {
// 	arg_1 := bytes.Join(s, sep)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.Map has:
// func map(mapping ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:423:18), s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:423:39)) Object {
// 	arg_1 := bytes.Map(mapping, s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.NewBuffer has:
// func newBuffer(buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/buffer.go:450:20)) Object {
// 	arg_1 := bytes.NewBuffer(buf)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.NewBufferString has:
// func newBufferString(s string) Object {
// 	arg_1 := bytes.NewBufferString(s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.NewReader has:
// func newReader(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/reader.go:156:18)) Object {
// 	arg_1 := bytes.NewReader(b)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.Repeat has:
// func repeat(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:460:15), count int) Object {
// 	arg_1 := bytes.Repeat(b, count)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.Replace has:
// func replace(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:741:26), old ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:741:26), new ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:741:26), n int) Object {
// 	arg_1 := bytes.Replace(s, old, new, n)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.Runes has:
// func runes(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:723:14)) Object {
// 	arg_1 := bytes.Runes(s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.Split has:
// func split(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:267:19), sep ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:267:19)) Object {
// 	arg_1 := bytes.Split(s, sep)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.SplitAfter has:
// func splitAfter(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:273:24), sep ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:273:24)) Object {
// 	arg_1 := bytes.SplitAfter(s, sep)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.SplitAfterN has:
// func splitAfterN(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:259:25), sep ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:259:25), n int) Object {
// 	arg_1 := bytes.SplitAfterN(s, sep, n)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.SplitN has:
// func splitN(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:250:20), sep ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:250:20), n int) Object {
// 	arg_1 := bytes.SplitN(s, sep, n)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.Title has:
// func title(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:536:14)) Object {
// 	arg_1 := bytes.Title(s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.ToLower has:
// func toLower(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:484:16)) Object {
// 	arg_1 := bytes.ToLower(s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.ToLowerSpecial has:
// func toLowerSpecial(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bytes/bytes.go:497:23), s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:497:46)) Object {
// 	arg_1 := bytes.ToLowerSpecial(c, s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.ToTitle has:
// func toTitle(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:487:16)) Object {
// 	arg_1 := bytes.ToTitle(s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.ToTitleSpecial has:
// func toTitleSpecial(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bytes/bytes.go:503:23), s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:503:46)) Object {
// 	arg_1 := bytes.ToTitleSpecial(c, s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.ToUpper has:
// func toUpper(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:481:16)) Object {
// 	arg_1 := bytes.ToUpper(s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.ToUpperSpecial has:
// func toUpperSpecial(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bytes/bytes.go:491:23), s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:491:46)) Object {
// 	arg_1 := bytes.ToUpperSpecial(c, s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.Trim has:
// func trim(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:699:13), cutset string) Object {
// 	arg_1 := bytes.Trim(s, cutset)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.TrimFunc has:
// func trimFunc(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:578:17), f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:578:27)) Object {
// 	arg_1 := bytes.TrimFunc(s, f)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.TrimLeft has:
// func trimLeft(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:705:17), cutset string) Object {
// 	arg_1 := bytes.TrimLeft(s, cutset)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.TrimLeftFunc has:
// func trimLeftFunc(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:555:21), f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:555:31)) Object {
// 	arg_1 := bytes.TrimLeftFunc(s, f)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.TrimPrefix has:
// func trimPrefix(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:584:27), prefix ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:584:27)) Object {
// 	arg_1 := bytes.TrimPrefix(s, prefix)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.TrimRight has:
// func trimRight(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:711:18), cutset string) Object {
// 	arg_1 := bytes.TrimRight(s, cutset)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.TrimRightFunc has:
// func trimRightFunc(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:565:22), f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:565:32)) Object {
// 	arg_1 := bytes.TrimRightFunc(s, f)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.TrimSpace has:
// func trimSpace(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:717:18)) Object {
// 	arg_1 := bytes.TrimSpace(s)
// 	...ABEND676: TODO...
// }

GO FUNC bytes.TrimSuffix has:
// func trimSuffix(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:593:27), suffix ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:593:27)) Object {
// 	arg_1 := bytes.TrimSuffix(s, suffix)
// 	...ABEND676: TODO...
// }

GO FUNC bzip2.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/bzip2/bzip2.go:46:18)) Object {
// 	arg_1 := bzip2.NewReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC cgi.Request has:
// func request() Object {
// 	arg_1, arg_2 := cgi.Request()
// 	...ABEND676: TODO...
// }

GO FUNC cgi.RequestFromMap has:
// func requestFromMap(params ABEND882(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/cgi/child.go:52:28)) Object {
// 	arg_1, arg_2 := cgi.RequestFromMap(params)
// 	...ABEND676: TODO...
// }

GO FUNC cgo._cgo_panic has:
// func _cgo_panic(a ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/cgo/callbacks.go:45:19), n Object) Object {
// 	cgo._cgo_panic(a, n)
// 	...ABEND676: TODO...
// }

GO FUNC cgo._runtime_cgocallback has:
// func _runtime_cgocallback() Object {
// 	cgo._runtime_cgocallback()
// 	...ABEND676: TODO...
// }

GO FUNC chacha20poly1305.New has:
// func new(key ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/chacha20poly1305/chacha20poly1305.go:26:14)) Object {
// 	arg_1, arg_2 := chacha20poly1305.New(key)
// 	...ABEND676: TODO...
// }

GO FUNC cipher.NewCBCDecrypter has:
// func newCBCDecrypter(b Object, iv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cbc.go:105:34)) Object {
// 	arg_1 := cipher.NewCBCDecrypter(b, iv)
// 	...ABEND676: TODO...
// }

GO FUNC cipher.NewCBCEncrypter has:
// func newCBCEncrypter(b Object, iv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cbc.go:45:34)) Object {
// 	arg_1 := cipher.NewCBCEncrypter(b, iv)
// 	...ABEND676: TODO...
// }

GO FUNC cipher.NewCFBDecrypter has:
// func newCFBDecrypter(block Object, iv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cfb.go:60:38)) Object {
// 	arg_1 := cipher.NewCFBDecrypter(block, iv)
// 	...ABEND676: TODO...
// }

GO FUNC cipher.NewCFBEncrypter has:
// func newCFBEncrypter(block Object, iv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cfb.go:53:38)) Object {
// 	arg_1 := cipher.NewCFBEncrypter(block, iv)
// 	...ABEND676: TODO...
// }

GO FUNC cipher.NewCTR has:
// func newCTR(block Object, iv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/ctr.go:35:29)) Object {
// 	arg_1 := cipher.NewCTR(block, iv)
// 	...ABEND676: TODO...
// }

GO FUNC cipher.NewGCM has:
// func newGCM(cipher Object) Object {
// 	arg_1, arg_2 := cipher.NewGCM(cipher)
// 	...ABEND676: TODO...
// }

GO FUNC cipher.NewGCMWithNonceSize has:
// func newGCMWithNonceSize(cipher Object, size int) Object {
// 	arg_1, arg_2 := cipher.NewGCMWithNonceSize(cipher, size)
// 	...ABEND676: TODO...
// }

GO FUNC cipher.NewGCMWithTagSize has:
// func newGCMWithTagSize(cipher Object, tagSize int) Object {
// 	arg_1, arg_2 := cipher.NewGCMWithTagSize(cipher, tagSize)
// 	...ABEND676: TODO...
// }

GO FUNC cipher.NewOFB has:
// func newOFB(b Object, iv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/ofb.go:21:25)) Object {
// 	arg_1 := cipher.NewOFB(b, iv)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Abs has:
// func abs(x Object) Object {
// 	arg_1 := cmplx.Abs(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Acos has:
// func acos(x Object) Object {
// 	arg_1 := cmplx.Acos(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Acosh has:
// func acosh(x Object) Object {
// 	arg_1 := cmplx.Acosh(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Asin has:
// func asin(x Object) Object {
// 	arg_1 := cmplx.Asin(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Asinh has:
// func asinh(x Object) Object {
// 	arg_1 := cmplx.Asinh(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Atan has:
// func atan(x Object) Object {
// 	arg_1 := cmplx.Atan(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Atanh has:
// func atanh(x Object) Object {
// 	arg_1 := cmplx.Atanh(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Conj has:
// func conj(x Object) Object {
// 	arg_1 := cmplx.Conj(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Cos has:
// func cos(x Object) Object {
// 	arg_1 := cmplx.Cos(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Cosh has:
// func cosh(x Object) Object {
// 	arg_1 := cmplx.Cosh(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Cot has:
// func cot(x Object) Object {
// 	arg_1 := cmplx.Cot(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Exp has:
// func exp(x Object) Object {
// 	arg_1 := cmplx.Exp(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Inf has:
// func inf() Object {
// 	arg_1 := cmplx.Inf()
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Log has:
// func log(x Object) Object {
// 	arg_1 := cmplx.Log(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Log10 has:
// func log10(x Object) Object {
// 	arg_1 := cmplx.Log10(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.NaN has:
// func naN() Object {
// 	arg_1 := cmplx.NaN()
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Phase has:
// func phase(x Object) Object {
// 	arg_1 := cmplx.Phase(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Polar has:
// func polar(x Object) Object {
// 	r, θ := cmplx.Polar(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Pow has:
// func pow(x Object, y Object) Object {
// 	arg_1 := cmplx.Pow(x, y)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Rect has:
// func rect(r Object, θ Object) Object {
// 	arg_1 := cmplx.Rect(r, θ)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Sin has:
// func sin(x Object) Object {
// 	arg_1 := cmplx.Sin(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Sinh has:
// func sinh(x Object) Object {
// 	arg_1 := cmplx.Sinh(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Sqrt has:
// func sqrt(x Object) Object {
// 	arg_1 := cmplx.Sqrt(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Tan has:
// func tan(x Object) Object {
// 	arg_1 := cmplx.Tan(x)
// 	...ABEND676: TODO...
// }

GO FUNC cmplx.Tanh has:
// func tanh(x Object) Object {
// 	arg_1 := cmplx.Tanh(x)
// 	...ABEND676: TODO...
// }

GO FUNC color.CMYKToRGB has:
// func cMYKToRGB(c Object, m Object, y Object, k Object) Object {
// 	arg_1, arg_2, arg_3 := color.CMYKToRGB(c, m, y, k)
// 	...ABEND676: TODO...
// }

GO FUNC color.ModelFunc has:
// func modelFunc(f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/color/color.go:147:18)) Object {
// 	arg_1 := color.ModelFunc(f)
// 	...ABEND676: TODO...
// }

GO FUNC color.RGBToCMYK has:
// func rGBToCMYK(r Object, g Object, b Object) Object {
// 	arg_1, arg_2, arg_3, arg_4 := color.RGBToCMYK(r, g, b)
// 	...ABEND676: TODO...
// }

GO FUNC color.RGBToYCbCr has:
// func rGBToYCbCr(r Object, g Object, b Object) Object {
// 	arg_1, arg_2, arg_3 := color.RGBToYCbCr(r, g, b)
// 	...ABEND676: TODO...
// }

GO FUNC color.YCbCrToRGB has:
// func yCbCrToRGB(y Object, cb Object, cr Object) Object {
// 	arg_1, arg_2, arg_3 := color.YCbCrToRGB(y, cb, cr)
// 	...ABEND676: TODO...
// }

GO FUNC constant.BinaryOp has:
// func binaryOp(x_ Object, op ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:1011:28), y_ Object) Object {
// 	arg_1 := constant.BinaryOp(x_, op, y_)
// 	...ABEND676: TODO...
// }

GO FUNC constant.Bytes has:
// func bytes(x Object) Object {
// 	arg_1 := constant.Bytes(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.Denom has:
// func denom(x Object) Object {
// 	arg_1 := constant.Denom(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.Float32Val has:
// func float32Val(x Object) Object {
// 	arg_1, arg_2 := constant.Float32Val(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.Float64Val has:
// func float64Val(x Object) Object {
// 	arg_1, arg_2 := constant.Float64Val(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.Imag has:
// func imag(x Object) Object {
// 	arg_1 := constant.Imag(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.Int64Val has:
// func int64Val(x Object) Object {
// 	arg_1, arg_2 := constant.Int64Val(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.MakeBool has:
// func makeBool(b Object) Object {
// 	arg_1 := constant.MakeBool(b)
// 	...ABEND676: TODO...
// }

GO FUNC constant.MakeFloat64 has:
// func makeFloat64(x Object) Object {
// 	arg_1 := constant.MakeFloat64(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.MakeFromBytes has:
// func makeFromBytes(bytes ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/constant/value.go:621:26)) Object {
// 	arg_1 := constant.MakeFromBytes(bytes)
// 	...ABEND676: TODO...
// }

GO FUNC constant.MakeFromLiteral has:
// func makeFromLiteral(lit string, tok ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:378:38), zero Object) Object {
// 	arg_1 := constant.MakeFromLiteral(lit, tok, zero)
// 	...ABEND676: TODO...
// }

GO FUNC constant.MakeImag has:
// func makeImag(x Object) Object {
// 	arg_1 := constant.MakeImag(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.MakeInt64 has:
// func makeInt64(x Object) Object {
// 	arg_1 := constant.MakeInt64(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.MakeString has:
// func makeString(s string) Object {
// 	arg_1 := constant.MakeString(s)
// 	...ABEND676: TODO...
// }

GO FUNC constant.MakeUint64 has:
// func makeUint64(x Object) Object {
// 	arg_1 := constant.MakeUint64(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.MakeUnknown has:
// func makeUnknown() Object {
// 	arg_1 := constant.MakeUnknown()
// 	...ABEND676: TODO...
// }

GO FUNC constant.Num has:
// func num(x Object) Object {
// 	arg_1 := constant.Num(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.Real has:
// func real(x Object) Object {
// 	arg_1 := constant.Real(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.Shift has:
// func shift(x Object, op ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:1191:24), s Object) Object {
// 	arg_1 := constant.Shift(x, op, s)
// 	...ABEND676: TODO...
// }

GO FUNC constant.ToComplex has:
// func toComplex(x Object) Object {
// 	arg_1 := constant.ToComplex(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.ToFloat has:
// func toFloat(x Object) Object {
// 	arg_1 := constant.ToFloat(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.ToInt has:
// func toInt(x Object) Object {
// 	arg_1 := constant.ToInt(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.Uint64Val has:
// func uint64Val(x Object) Object {
// 	arg_1, arg_2 := constant.Uint64Val(x)
// 	...ABEND676: TODO...
// }

GO FUNC constant.UnaryOp has:
// func unaryOp(op ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:850:17), y Object, prec Object) Object {
// 	arg_1 := constant.UnaryOp(op, y, prec)
// 	...ABEND676: TODO...
// }

GO FUNC context.Background has:
// func background() Object {
// 	arg_1 := context.Background()
// 	...ABEND676: TODO...
// }

GO FUNC context.TODO has:
// func tODO() Object {
// 	arg_1 := context.TODO()
// 	...ABEND676: TODO...
// }

GO FUNC context.WithCancel has:
// func withCancel(parent Object) Object {
// 	ctx, cancel := context.WithCancel(parent)
// 	...ABEND676: TODO...
// }

GO FUNC context.WithDeadline has:
// func withDeadline(parent Object, d ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/context/context.go:384:37)) Object {
// 	arg_1, arg_2 := context.WithDeadline(parent, d)
// 	...ABEND676: TODO...
// }

GO FUNC context.WithTimeout has:
// func withTimeout(parent Object, timeout ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/context/context.go:451:42)) Object {
// 	arg_1, arg_2 := context.WithTimeout(parent, timeout)
// 	...ABEND676: TODO...
// }

GO FUNC context.WithValue has:
// func withValue(parent Object, key ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:468:41), val ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:468:41)) Object {
// 	arg_1 := context.WithValue(parent, key, val)
// 	...ABEND676: TODO...
// }

GO FUNC cookiejar.New has:
// func new(o ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/cookiejar/jar.go:77:12)) Object {
// 	arg_1, arg_2 := cookiejar.New(o)
// 	...ABEND676: TODO...
// }

GO FUNC crc32.MakeTable has:
// func makeTable(poly Object) Object {
// 	arg_1 := crc32.MakeTable(poly)
// 	...ABEND676: TODO...
// }

GO FUNC crc32.New has:
// func new(tab ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc32/crc32.go:147:14)) Object {
// 	arg_1 := crc32.New(tab)
// 	...ABEND676: TODO...
// }

GO FUNC crc32.NewIEEE has:
// func newIEEE() Object {
// 	arg_1 := crc32.NewIEEE()
// 	...ABEND676: TODO...
// }

GO FUNC crc64.Checksum has:
// func checksum(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc64/crc64.go:199:20), tab ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc64/crc64.go:199:32)) Object {
// 	arg_1 := crc64.Checksum(data, tab)
// 	...ABEND676: TODO...
// }

GO FUNC crc64.MakeTable has:
// func makeTable(poly Object) Object {
// 	arg_1 := crc64.MakeTable(poly)
// 	...ABEND676: TODO...
// }

GO FUNC crc64.New has:
// func new(tab ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc64/crc64.go:88:14)) Object {
// 	arg_1 := crc64.New(tab)
// 	...ABEND676: TODO...
// }

GO FUNC crc64.Update has:
// func update(crc Object, tab ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc64/crc64.go:181:29), p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc64/crc64.go:181:39)) Object {
// 	arg_1 := crc64.Update(crc, tab, p)
// 	...ABEND676: TODO...
// }

GO FUNC crypto.RegisterHash has:
// func registerHash(h Object, f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/crypto.go:100:29)) Object {
// 	crypto.RegisterHash(h, f)
// 	...ABEND676: TODO...
// }

GO FUNC cryptobyte.NewBuilder has:
// func newBuilder(buffer ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:37:24)) Object {
// 	arg_1 := cryptobyte.NewBuilder(buffer)
// 	...ABEND676: TODO...
// }

GO FUNC cryptobyte.NewFixedBuilder has:
// func newFixedBuilder(buffer ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:46:29)) Object {
// 	arg_1 := cryptobyte.NewFixedBuilder(buffer)
// 	...ABEND676: TODO...
// }

GO FUNC csv.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/csv/reader.go:168:18)) Object {
// 	arg_1 := csv.NewReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC csv.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/csv/writer.go:31:18)) Object {
// 	arg_1 := csv.NewWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC curve25519.ScalarBaseMult has:
// func scalarBaseMult(dst ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:21:29), in ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:21:29)) Object {
// 	curve25519.ScalarBaseMult(dst, in)
// 	...ABEND676: TODO...
// }

GO FUNC curve25519.ScalarMult has:
// func scalarMult(dst ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31), in ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31), base ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31)) Object {
// 	curve25519.ScalarMult(dst, in, base)
// 	...ABEND676: TODO...
// }

GO FUNC debug.FreeOSMemory has:
// func freeOSMemory() Object {
// 	debug.FreeOSMemory()
// 	...ABEND676: TODO...
// }

GO FUNC debug.PrintStack has:
// func printStack() Object {
// 	debug.PrintStack()
// 	...ABEND676: TODO...
// }

GO FUNC debug.ReadGCStats has:
// func readGCStats(stats ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/debug/garbage.go:31:24)) Object {
// 	debug.ReadGCStats(stats)
// 	...ABEND676: TODO...
// }

GO FUNC debug.SetTraceback has:
// func setTraceback(level string) Object {
// 	debug.SetTraceback(level)
// 	...ABEND676: TODO...
// }

GO FUNC debug.Stack has:
// func stack() Object {
// 	arg_1 := debug.Stack()
// 	...ABEND676: TODO...
// }

GO FUNC debug.WriteHeapDump has:
// func writeHeapDump(fd Object) Object {
// 	debug.WriteHeapDump(fd)
// 	...ABEND676: TODO...
// }

GO FUNC des.NewCipher has:
// func newCipher(key ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/des/cipher.go:29:20)) Object {
// 	arg_1, arg_2 := des.NewCipher(key)
// 	...ABEND676: TODO...
// }

GO FUNC des.NewTripleDESCipher has:
// func newTripleDESCipher(key ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/des/cipher.go:73:29)) Object {
// 	arg_1, arg_2 := des.NewTripleDESCipher(key)
// 	...ABEND676: TODO...
// }

GO FUNC dnsmessage.NewBuilder has:
// func newBuilder(buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go:939:21), h Object) Object {
// 	arg_1 := dnsmessage.NewBuilder(buf, h)
// 	...ABEND676: TODO...
// }

GO FUNC dnsmessage.NewName has:
// func newName(name string) Object {
// 	arg_1, arg_2 := dnsmessage.NewName(name)
// 	...ABEND676: TODO...
// }

GO FUNC doc.Examples has:
// func examples(files ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/go/doc/example.go:47:21)) Object {
// 	arg_1 := doc.Examples(files)
// 	...ABEND676: TODO...
// }

GO FUNC doc.New has:
// func new(pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/doc/doc.go:94:14), importPath string, mode Object) Object {
// 	arg_1 := doc.New(pkg, importPath, mode)
// 	...ABEND676: TODO...
// }

GO FUNC doc.ToHTML has:
// func toHTML(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/comment.go:308:15), text string, words ABEND882(unrecognized Expr type *ast.MapType at: ../GOSRC/go/doc/comment.go:308:45)) Object {
// 	doc.ToHTML(w, text, words)
// 	...ABEND676: TODO...
// }

GO FUNC doc.ToText has:
// func toText(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/comment.go:422:15), text string, indent string, preIndent string, width int) Object {
// 	doc.ToText(w, text, indent, preIndent, width)
// 	...ABEND676: TODO...
// }

GO FUNC draw.Draw has:
// func draw(dst Object, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:24), src ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:45), sp ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:61), op Object) Object {
// 	draw.Draw(dst, r, src, sp, op)
// 	...ABEND676: TODO...
// }

GO FUNC draw.DrawMask has:
// func drawMask(dst Object, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:28), src ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:49), sp ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:65), mask ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:83), mp ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:99), op Object) Object {
// 	draw.DrawMask(dst, r, src, sp, mask, mp, op)
// 	...ABEND676: TODO...
// }

GO FUNC dsa.Sign has:
// func sign(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/dsa/dsa.go:199:16), priv ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:199:32), hash ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/dsa/dsa.go:199:50)) Object {
// 	r, s, err := dsa.Sign(rand, priv, hash)
// 	...ABEND676: TODO...
// }

GO FUNC dwarf.New has:
// func new(abbrev ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68), aranges ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68), frame ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68), info ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68), line ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68), pubnames ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68), ranges ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68), str ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68)) Object {
// 	arg_1, arg_2 := dwarf.New(abbrev, aranges, frame, info, line, pubnames, ranges, str)
// 	...ABEND676: TODO...
// }

GO FUNC ecdsa.GenerateKey has:
// func generateKey(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:105:20), rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:105:41)) Object {
// 	arg_1, arg_2 := ecdsa.GenerateKey(c, rand)
// 	...ABEND676: TODO...
// }

GO FUNC ecdsa.Sign has:
// func sign(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:16), priv ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:32), hash ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:50)) Object {
// 	r, s, err := ecdsa.Sign(rand, priv, hash)
// 	...ABEND676: TODO...
// }

GO FUNC elf.NewFile has:
// func newFile(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:235:16)) Object {
// 	arg_1, arg_2 := elf.NewFile(r)
// 	...ABEND676: TODO...
// }

GO FUNC elf.Open has:
// func open(name string) Object {
// 	arg_1, arg_2 := elf.Open(name)
// 	...ABEND676: TODO...
// }

GO FUNC elf.R_INFO has:
// func r_INFO(sym Object, typ Object) Object {
// 	arg_1 := elf.R_INFO(sym, typ)
// 	...ABEND676: TODO...
// }

GO FUNC elf.ST_INFO has:
// func sT_INFO(bind Object, typ Object) Object {
// 	arg_1 := elf.ST_INFO(bind, typ)
// 	...ABEND676: TODO...
// }

GO FUNC elliptic.GenerateKey has:
// func generateKey(curve Object, rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/elliptic/elliptic.go:276:36)) Object {
// 	priv, x, y, err := elliptic.GenerateKey(curve, rand)
// 	...ABEND676: TODO...
// }

GO FUNC elliptic.Marshal has:
// func marshal(curve Object, x ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/elliptic/elliptic.go:305:32), y ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/elliptic/elliptic.go:305:32)) Object {
// 	arg_1 := elliptic.Marshal(curve, x, y)
// 	...ABEND676: TODO...
// }

GO FUNC elliptic.P224 has:
// func p224() Object {
// 	arg_1 := elliptic.P224()
// 	...ABEND676: TODO...
// }

GO FUNC elliptic.P256 has:
// func p256() Object {
// 	arg_1 := elliptic.P256()
// 	...ABEND676: TODO...
// }

GO FUNC elliptic.P384 has:
// func p384() Object {
// 	arg_1 := elliptic.P384()
// 	...ABEND676: TODO...
// }

GO FUNC elliptic.P521 has:
// func p521() Object {
// 	arg_1 := elliptic.P521()
// 	...ABEND676: TODO...
// }

GO FUNC elliptic.Unmarshal has:
// func unmarshal(curve Object, data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/elliptic/elliptic.go:321:34)) Object {
// 	x, y := elliptic.Unmarshal(curve, data)
// 	...ABEND676: TODO...
// }

GO FUNC exec.Command has:
// func command(name string, arg ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/exec/exec.go:155:31)) Object {
// 	arg_1 := exec.Command(name, arg)
// 	...ABEND676: TODO...
// }

GO FUNC exec.CommandContext has:
// func commandContext(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:175:25), name string, arg ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/exec/exec.go:175:59)) Object {
// 	arg_1 := exec.CommandContext(ctx, name, arg)
// 	...ABEND676: TODO...
// }

GO FUNC exec.LookPath has:
// func lookPath(file string) Object {
// 	arg_1, arg_2 := exec.LookPath(file)
// 	...ABEND676: TODO...
// }

GO FUNC expvar.Do has:
// func do(f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/expvar/expvar.go:306:11)) Object {
// 	expvar.Do(f)
// 	...ABEND676: TODO...
// }

GO FUNC expvar.Get has:
// func get(name string) Object {
// 	arg_1 := expvar.Get(name)
// 	...ABEND676: TODO...
// }

GO FUNC expvar.Handler has:
// func handler() Object {
// 	arg_1 := expvar.Handler()
// 	...ABEND676: TODO...
// }

GO FUNC expvar.NewFloat has:
// func newFloat(name string) Object {
// 	arg_1 := expvar.NewFloat(name)
// 	...ABEND676: TODO...
// }

GO FUNC expvar.NewInt has:
// func newInt(name string) Object {
// 	arg_1 := expvar.NewInt(name)
// 	...ABEND676: TODO...
// }

GO FUNC expvar.NewMap has:
// func newMap(name string) Object {
// 	arg_1 := expvar.NewMap(name)
// 	...ABEND676: TODO...
// }

GO FUNC expvar.NewString has:
// func newString(name string) Object {
// 	arg_1 := expvar.NewString(name)
// 	...ABEND676: TODO...
// }

GO FUNC expvar.Publish has:
// func publish(name string, v Object) Object {
// 	expvar.Publish(name, v)
// 	...ABEND676: TODO...
// }

GO FUNC fcgi.ProcessEnv has:
// func processEnv(r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fcgi/child.go:358:19)) Object {
// 	arg_1 := fcgi.ProcessEnv(r)
// 	...ABEND676: TODO...
// }

GO FUNC filepath.Abs has:
// func abs(path string) Object {
// 	arg_1, arg_2 := filepath.Abs(path)
// 	...ABEND676: TODO...
// }

GO FUNC filepath.EvalSymlinks has:
// func evalSymlinks(path string) Object {
// 	arg_1, arg_2 := filepath.EvalSymlinks(path)
// 	...ABEND676: TODO...
// }

GO FUNC filepath.Glob has:
// func glob(pattern string) Object {
// 	matches, err := filepath.Glob(pattern)
// 	...ABEND676: TODO...
// }

GO FUNC filepath.Match has:
// func match(pattern string, name string) Object {
// 	matched, err := filepath.Match(pattern, name)
// 	...ABEND676: TODO...
// }

GO FUNC filepath.Rel has:
// func rel(basepath string, targpath string) Object {
// 	arg_1, arg_2 := filepath.Rel(basepath, targpath)
// 	...ABEND676: TODO...
// }

GO FUNC filepath.Split has:
// func split(path string) Object {
// 	dir, file := filepath.Split(path)
// 	...ABEND676: TODO...
// }

GO FUNC filepath.SplitList has:
// func splitList(path string) Object {
// 	arg_1 := filepath.SplitList(path)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Args has:
// func args() Object {
// 	arg_1 := flag.Args()
// 	...ABEND676: TODO...
// }

GO FUNC flag.BoolVar has:
// func boolVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:583:16), name string, value Object, usage string) Object {
// 	flag.BoolVar(p, name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Duration has:
// func duration(name string, value ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:783:34), usage string) Object {
// 	arg_1 := flag.Duration(name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.DurationVar has:
// func durationVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:767:20), name string, value ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:767:55), usage string) Object {
// 	flag.DurationVar(p, name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Float64 has:
// func float64(name string, value Object, usage string) Object {
// 	arg_1 := flag.Float64(name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Float64Var has:
// func float64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:739:19), name string, value Object, usage string) Object {
// 	flag.Float64Var(p, name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Int64Var has:
// func int64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:635:17), name string, value Object, usage string) Object {
// 	flag.Int64Var(p, name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.IntVar has:
// func intVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:609:15), name string, value int, usage string) Object {
// 	flag.IntVar(p, name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Lookup has:
// func lookup(name string) Object {
// 	arg_1 := flag.Lookup(name)
// 	...ABEND676: TODO...
// }

GO FUNC flag.NewFlagSet has:
// func newFlagSet(name string, errorHandling Object) Object {
// 	arg_1 := flag.NewFlagSet(name, errorHandling)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Parse has:
// func parse() Object {
// 	flag.Parse()
// 	...ABEND676: TODO...
// }

GO FUNC flag.PrintDefaults has:
// func printDefaults() Object {
// 	flag.PrintDefaults()
// 	...ABEND676: TODO...
// }

GO FUNC flag.StringVar has:
// func stringVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:713:18), name string, value string, usage string) Object {
// 	flag.StringVar(p, name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Uint64 has:
// func uint64(name string, value Object, usage string) Object {
// 	arg_1 := flag.Uint64(name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Uint64Var has:
// func uint64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:687:18), name string, value Object, usage string) Object {
// 	flag.Uint64Var(p, name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.UintVar has:
// func uintVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:661:16), name string, value Object, usage string) Object {
// 	flag.UintVar(p, name, value, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.UnquoteUsage has:
// func unquoteUsage(flag ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:422:24)) Object {
// 	name, usage := flag.UnquoteUsage(flag)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Var has:
// func var(value Object, name string, usage string) Object {
// 	flag.Var(value, name, usage)
// 	...ABEND676: TODO...
// }

GO FUNC flag.Visit has:
// func visit(fn ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/flag/flag.go:364:15)) Object {
// 	flag.Visit(fn)
// 	...ABEND676: TODO...
// }

GO FUNC flag.VisitAll has:
// func visitAll(fn ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/flag/flag.go:350:18)) Object {
// 	flag.VisitAll(fn)
// 	...ABEND676: TODO...
// }

GO FUNC flate.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/inflate.go:796:18)) Object {
// 	arg_1 := flate.NewReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC flate.NewReaderDict has:
// func newReaderDict(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/inflate.go:815:22), dict ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/flate/inflate.go:815:38)) Object {
// 	arg_1 := flate.NewReaderDict(r, dict)
// 	...ABEND676: TODO...
// }

GO FUNC flate.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/deflate.go:666:18), level int) Object {
// 	arg_1, arg_2 := flate.NewWriter(w, level)
// 	...ABEND676: TODO...
// }

GO FUNC flate.NewWriterDict has:
// func newWriterDict(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/deflate.go:680:22), level int, dict ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/flate/deflate.go:680:49)) Object {
// 	arg_1, arg_2 := flate.NewWriterDict(w, level, dict)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Fprint has:
// func fprint(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/print.go:220:15), a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:220:28)) Object {
// 	n, err := fmt.Fprint(w, a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Fprintf has:
// func fprintf(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/print.go:186:16), format string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:186:44)) Object {
// 	n, err := fmt.Fprintf(w, format, a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Fprintln has:
// func fprintln(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/print.go:252:17), a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:252:30)) Object {
// 	n, err := fmt.Fprintln(w, a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Fscan has:
// func fscan(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/scan.go:121:14), a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:121:27)) Object {
// 	n, err := fmt.Fscan(r, a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Fscanf has:
// func fscanf(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/scan.go:141:15), format string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:141:43)) Object {
// 	n, err := fmt.Fscanf(r, format, a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Fscanln has:
// func fscanln(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/scan.go:130:16), a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:130:29)) Object {
// 	n, err := fmt.Fscanln(r, a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Print has:
// func print(a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:231:14)) Object {
// 	n, err := fmt.Print(a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Printf has:
// func printf(format string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:196:30)) Object {
// 	n, err := fmt.Printf(format, a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Println has:
// func println(a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:263:16)) Object {
// 	n, err := fmt.Println(a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Scan has:
// func scan(a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:63:13)) Object {
// 	n, err := fmt.Scan(a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Scanf has:
// func scanf(format string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:80:29)) Object {
// 	n, err := fmt.Scanf(format, a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Scanln has:
// func scanln(a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:69:15)) Object {
// 	n, err := fmt.Scanln(a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Sscan has:
// func sscan(str string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:99:26)) Object {
// 	n, err := fmt.Sscan(str, a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Sscanf has:
// func sscanf(str string, format string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:113:42)) Object {
// 	n, err := fmt.Sscanf(str, format, a)
// 	...ABEND676: TODO...
// }

GO FUNC fmt.Sscanln has:
// func sscanln(str string, a ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:105:28)) Object {
// 	n, err := fmt.Sscanln(str, a)
// 	...ABEND676: TODO...
// }

GO FUNC fnv.New128 has:
// func new128() Object {
// 	arg_1 := fnv.New128()
// 	...ABEND676: TODO...
// }

GO FUNC fnv.New128a has:
// func new128a() Object {
// 	arg_1 := fnv.New128a()
// 	...ABEND676: TODO...
// }

GO FUNC fnv.New32 has:
// func new32() Object {
// 	arg_1 := fnv.New32()
// 	...ABEND676: TODO...
// }

GO FUNC fnv.New32a has:
// func new32a() Object {
// 	arg_1 := fnv.New32a()
// 	...ABEND676: TODO...
// }

GO FUNC fnv.New64 has:
// func new64() Object {
// 	arg_1 := fnv.New64()
// 	...ABEND676: TODO...
// }

GO FUNC fnv.New64a has:
// func new64a() Object {
// 	arg_1 := fnv.New64a()
// 	...ABEND676: TODO...
// }

GO FUNC format.Source has:
// func source(src ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/format/format.go:91:17)) Object {
// 	arg_1, arg_2 := format.Source(src)
// 	...ABEND676: TODO...
// }

GO FUNC gif.Decode has:
// func decode(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:561:15)) Object {
// 	arg_1, arg_2 := gif.Decode(r)
// 	...ABEND676: TODO...
// }

GO FUNC gif.DecodeAll has:
// func decodeAll(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:601:18)) Object {
// 	arg_1, arg_2 := gif.DecodeAll(r)
// 	...ABEND676: TODO...
// }

GO FUNC gif.DecodeConfig has:
// func decodeConfig(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:623:21)) Object {
// 	arg_1, arg_2 := gif.DecodeConfig(r)
// 	...ABEND676: TODO...
// }

GO FUNC gob.NewDecoder has:
// func newDecoder(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/decoder.go:41:19)) Object {
// 	arg_1 := gob.NewDecoder(r)
// 	...ABEND676: TODO...
// }

GO FUNC gob.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/encoder.go:33:19)) Object {
// 	arg_1 := gob.NewEncoder(w)
// 	...ABEND676: TODO...
// }

GO FUNC gob.Register has:
// func register(value ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/gob/type.go:836:21)) Object {
// 	gob.Register(value)
// 	...ABEND676: TODO...
// }

GO FUNC gob.RegisterName has:
// func registerName(name string, value ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/gob/type.go:807:38)) Object {
// 	gob.RegisterName(name, value)
// 	...ABEND676: TODO...
// }

GO FUNC gosym.NewLineTable has:
// func newLineTable(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/pclntab.go:124:24), text Object) Object {
// 	arg_1 := gosym.NewLineTable(data, text)
// 	...ABEND676: TODO...
// }

GO FUNC gosym.NewTable has:
// func newTable(symtab ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/symtab.go:283:22), pcln ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/debug/gosym/symtab.go:283:35)) Object {
// 	arg_1, arg_2 := gosym.NewTable(symtab, pcln)
// 	...ABEND676: TODO...
// }

GO FUNC gzip.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gunzip.go:92:18)) Object {
// 	arg_1, arg_2 := gzip.NewReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC gzip.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:49:18)) Object {
// 	arg_1 := gzip.NewWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC gzip.NewWriterLevel has:
// func newWriterLevel(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:60:23), level int) Object {
// 	arg_1, arg_2 := gzip.NewWriterLevel(w, level)
// 	...ABEND676: TODO...
// }

GO FUNC heap.Fix has:
// func fix(h Object, i int) Object {
// 	heap.Fix(h, i)
// 	...ABEND676: TODO...
// }

GO FUNC heap.Init has:
// func init(h Object) Object {
// 	heap.Init(h)
// 	...ABEND676: TODO...
// }

GO FUNC heap.Pop has:
// func pop(h Object) Object {
// 	arg_1 := heap.Pop(h)
// 	...ABEND676: TODO...
// }

GO FUNC heap.Push has:
// func push(h Object, x ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/heap/heap.go:53:26)) Object {
// 	heap.Push(h, x)
// 	...ABEND676: TODO...
// }

GO FUNC heap.Remove has:
// func remove(h Object, i int) Object {
// 	arg_1 := heap.Remove(h, i)
// 	...ABEND676: TODO...
// }

GO FUNC hex.Decode has:
// func decode(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:57:22), src ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:57:22)) Object {
// 	arg_1, arg_2 := hex.Decode(dst, src)
// 	...ABEND676: TODO...
// }

GO FUNC hex.DecodeString has:
// func decodeString(s string) Object {
// 	arg_1, arg_2 := hex.DecodeString(s)
// 	...ABEND676: TODO...
// }

GO FUNC hex.Dumper has:
// func dumper(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:204:15)) Object {
// 	arg_1 := hex.Dumper(w)
// 	...ABEND676: TODO...
// }

GO FUNC hex.NewDecoder has:
// func newDecoder(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:165:19)) Object {
// 	arg_1 := hex.NewDecoder(r)
// 	...ABEND676: TODO...
// }

GO FUNC hex.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:136:19)) Object {
// 	arg_1 := hex.NewEncoder(w)
// 	...ABEND676: TODO...
// }

GO FUNC hmac.New has:
// func new(h ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/hmac/hmac.go:70:12), key ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/hmac/hmac.go:70:34)) Object {
// 	arg_1 := hmac.New(h, key)
// 	...ABEND676: TODO...
// }

GO FUNC hpack.AppendHuffmanString has:
// func appendHuffmanString(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:160:30), s string) Object {
// 	arg_1 := hpack.AppendHuffmanString(dst, s)
// 	...ABEND676: TODO...
// }

GO FUNC hpack.HuffmanDecode has:
// func huffmanDecode(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:21:22), v ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:21:35)) Object {
// 	arg_1, arg_2 := hpack.HuffmanDecode(w, v)
// 	...ABEND676: TODO...
// }

GO FUNC hpack.HuffmanDecodeToString has:
// func huffmanDecodeToString(v ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:32:30)) Object {
// 	arg_1, arg_2 := hpack.HuffmanDecodeToString(v)
// 	...ABEND676: TODO...
// }

GO FUNC hpack.HuffmanEncodeLength has:
// func huffmanEncodeLength(s string) Object {
// 	arg_1 := hpack.HuffmanEncodeLength(s)
// 	...ABEND676: TODO...
// }

GO FUNC hpack.NewDecoder has:
// func newDecoder(maxDynamicTableSize Object, emitFunc ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go:100:54)) Object {
// 	arg_1 := hpack.NewDecoder(maxDynamicTableSize, emitFunc)
// 	...ABEND676: TODO...
// }

GO FUNC hpack.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/encode.go:35:19)) Object {
// 	arg_1 := hpack.NewEncoder(w)
// 	...ABEND676: TODO...
// }

GO FUNC http.Error has:
// func error(w Object, error string, code int) Object {
// 	http.Error(w, error, code)
// 	...ABEND676: TODO...
// }

GO FUNC http.FileServer has:
// func fileServer(root Object) Object {
// 	arg_1 := http.FileServer(root)
// 	...ABEND676: TODO...
// }

GO FUNC http.Get has:
// func get(url string) Object {
// 	resp, err := http.Get(url)
// 	...ABEND676: TODO...
// }

GO FUNC http.Handle has:
// func handle(pattern string, handler Object) Object {
// 	http.Handle(pattern, handler)
// 	...ABEND676: TODO...
// }

GO FUNC http.HandleFunc has:
// func handleFunc(pattern string, handler ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/server.go:2406:41)) Object {
// 	http.HandleFunc(pattern, handler)
// 	...ABEND676: TODO...
// }

GO FUNC http.Head has:
// func head(url string) Object {
// 	resp, err := http.Head(url)
// 	...ABEND676: TODO...
// }

GO FUNC http.MaxBytesReader has:
// func maxBytesReader(w Object, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:1056:41), n Object) Object {
// 	arg_1 := http.MaxBytesReader(w, r, n)
// 	...ABEND676: TODO...
// }

GO FUNC http.NewFileTransport has:
// func newFileTransport(fs Object) Object {
// 	arg_1 := http.NewFileTransport(fs)
// 	...ABEND676: TODO...
// }

GO FUNC http.NewRequest has:
// func newRequest(method string, url string, body ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:792:42)) Object {
// 	arg_1, arg_2 := http.NewRequest(method, url, body)
// 	...ABEND676: TODO...
// }

GO FUNC http.NewServeMux has:
// func newServeMux() Object {
// 	arg_1 := http.NewServeMux()
// 	...ABEND676: TODO...
// }

GO FUNC http.NotFound has:
// func notFound(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/server.go:1981:35)) Object {
// 	http.NotFound(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC http.NotFoundHandler has:
// func notFoundHandler() Object {
// 	arg_1 := http.NotFoundHandler()
// 	...ABEND676: TODO...
// }

GO FUNC http.ParseHTTPVersion has:
// func parseHTTPVersion(vers string) Object {
// 	major, minor, ok := http.ParseHTTPVersion(vers)
// 	...ABEND676: TODO...
// }

GO FUNC http.ParseTime has:
// func parseTime(text string) Object {
// 	t, err := http.ParseTime(text)
// 	...ABEND676: TODO...
// }

GO FUNC http.Post has:
// func post(url string, contentType string, body ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/client.go:748:41)) Object {
// 	resp, err := http.Post(url, contentType, body)
// 	...ABEND676: TODO...
// }

GO FUNC http.PostForm has:
// func postForm(url string, data ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/client.go:785:32)) Object {
// 	resp, err := http.PostForm(url, data)
// 	...ABEND676: TODO...
// }

GO FUNC http.ProxyFromEnvironment has:
// func proxyFromEnvironment(req ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/transport.go:345:31)) Object {
// 	arg_1, arg_2 := http.ProxyFromEnvironment(req)
// 	...ABEND676: TODO...
// }

GO FUNC http.ProxyURL has:
// func proxyURL(fixedURL ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/transport.go:351:24)) Object {
// 	arg_1 := http.ProxyURL(fixedURL)
// 	...ABEND676: TODO...
// }

GO FUNC http.ReadRequest has:
// func readRequest(b ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:942:20)) Object {
// 	arg_1, arg_2 := http.ReadRequest(b)
// 	...ABEND676: TODO...
// }

GO FUNC http.ReadResponse has:
// func readResponse(r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/response.go:148:21), req ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/response.go:148:40)) Object {
// 	arg_1, arg_2 := http.ReadResponse(r, req)
// 	...ABEND676: TODO...
// }

GO FUNC http.Redirect has:
// func redirect(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/server.go:2020:35), url string, code int) Object {
// 	http.Redirect(w, r, url, code)
// 	...ABEND676: TODO...
// }

GO FUNC http.RedirectHandler has:
// func redirectHandler(url string, code int) Object {
// 	arg_1 := http.RedirectHandler(url, code)
// 	...ABEND676: TODO...
// }

GO FUNC http.ServeContent has:
// func serveContent(w Object, req ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fs.go:151:41), name string, modtime ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fs.go:151:72), content ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fs.go:151:91)) Object {
// 	http.ServeContent(w, req, name, modtime, content)
// 	...ABEND676: TODO...
// }

GO FUNC http.ServeFile has:
// func serveFile(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fs.go:670:36), name string) Object {
// 	http.ServeFile(w, r, name)
// 	...ABEND676: TODO...
// }

GO FUNC http.SetCookie has:
// func setCookie(w Object, cookie ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/cookie.go:157:41)) Object {
// 	http.SetCookie(w, cookie)
// 	...ABEND676: TODO...
// }

GO FUNC http.StripPrefix has:
// func stripPrefix(prefix string, h Object) Object {
// 	arg_1 := http.StripPrefix(prefix, h)
// 	...ABEND676: TODO...
// }

GO FUNC http.TimeoutHandler has:
// func timeoutHandler(h Object, dt ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/server.go:3106:35), msg string) Object {
// 	arg_1 := http.TimeoutHandler(h, dt, msg)
// 	...ABEND676: TODO...
// }

GO FUNC httpguts.PunycodeHostPort has:
// func punycodeHostPort(v string) Object {
// 	arg_1, arg_2 := httpguts.PunycodeHostPort(v)
// 	...ABEND676: TODO...
// }

GO FUNC httpproxy.FromEnvironment has:
// func fromEnvironment() Object {
// 	arg_1 := httpproxy.FromEnvironment()
// 	...ABEND676: TODO...
// }

GO FUNC httptest.NewRecorder has:
// func newRecorder() Object {
// 	arg_1 := httptest.NewRecorder()
// 	...ABEND676: TODO...
// }

GO FUNC httptest.NewRequest has:
// func newRequest(method string, target string, body ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/httptest.go:41:45)) Object {
// 	arg_1 := httptest.NewRequest(method, target, body)
// 	...ABEND676: TODO...
// }

GO FUNC httptest.NewServer has:
// func newServer(handler ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:80:24)) Object {
// 	arg_1 := httptest.NewServer(handler)
// 	...ABEND676: TODO...
// }

GO FUNC httptest.NewTLSServer has:
// func newTLSServer(handler ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:160:27)) Object {
// 	arg_1 := httptest.NewTLSServer(handler)
// 	...ABEND676: TODO...
// }

GO FUNC httptest.NewUnstartedServer has:
// func newUnstartedServer(handler ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:92:33)) Object {
// 	arg_1 := httptest.NewUnstartedServer(handler)
// 	...ABEND676: TODO...
// }

GO FUNC httptrace.ContextClientTrace has:
// func contextClientTrace(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptrace/trace.go:24:29)) Object {
// 	arg_1 := httptrace.ContextClientTrace(ctx)
// 	...ABEND676: TODO...
// }

GO FUNC httptrace.WithClientTrace has:
// func withClientTrace(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptrace/trace.go:34:26), trace ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptrace/trace.go:34:49)) Object {
// 	arg_1 := httptrace.WithClientTrace(ctx, trace)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.DumpRequest has:
// func dumpRequest(req ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/dump.go:191:22), body Object) Object {
// 	arg_1, arg_2 := httputil.DumpRequest(req, body)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.DumpRequestOut has:
// func dumpRequestOut(req ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/dump.go:66:25), body Object) Object {
// 	arg_1, arg_2 := httputil.DumpRequestOut(req, body)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.DumpResponse has:
// func dumpResponse(resp ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/dump.go:281:24), body Object) Object {
// 	arg_1, arg_2 := httputil.DumpResponse(resp, body)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewChunkedReader has:
// func newChunkedReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/httputil.go:20:25)) Object {
// 	arg_1 := httputil.NewChunkedReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewChunkedWriter has:
// func newChunkedWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/httputil.go:35:25)) Object {
// 	arg_1 := httputil.NewChunkedWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewClientConn has:
// func newClientConn(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:248:22), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:248:34)) Object {
// 	arg_1 := httputil.NewClientConn(c, r)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewProxyClientConn has:
// func newProxyClientConn(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:265:27), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:265:39)) Object {
// 	arg_1 := httputil.NewProxyClientConn(c, r)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewServerConn has:
// func newServerConn(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:54:22), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:54:34)) Object {
// 	arg_1 := httputil.NewServerConn(c, r)
// 	...ABEND676: TODO...
// }

GO FUNC httputil.NewSingleHostReverseProxy has:
// func newSingleHostReverseProxy(target ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/reverseproxy.go:103:39)) Object {
// 	arg_1 := httputil.NewSingleHostReverseProxy(target)
// 	...ABEND676: TODO...
// }

GO FUNC idna.BidiRule has:
// func bidiRule() Object {
// 	arg_1 := idna.BidiRule()
// 	...ABEND676: TODO...
// }

GO FUNC idna.MapForLookup has:
// func mapForLookup() Object {
// 	arg_1 := idna.MapForLookup()
// 	...ABEND676: TODO...
// }

GO FUNC idna.New has:
// func new(o ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:189:12)) Object {
// 	arg_1 := idna.New(o)
// 	...ABEND676: TODO...
// }

GO FUNC idna.RemoveLeadingDots has:
// func removeLeadingDots(remove Object) Object {
// 	arg_1 := idna.RemoveLeadingDots(remove)
// 	...ABEND676: TODO...
// }

GO FUNC idna.StrictDomainName has:
// func strictDomainName(use Object) Object {
// 	arg_1 := idna.StrictDomainName(use)
// 	...ABEND676: TODO...
// }

GO FUNC idna.ToASCII has:
// func toASCII(s string) Object {
// 	arg_1, arg_2 := idna.ToASCII(s)
// 	...ABEND676: TODO...
// }

GO FUNC idna.ToUnicode has:
// func toUnicode(s string) Object {
// 	arg_1, arg_2 := idna.ToUnicode(s)
// 	...ABEND676: TODO...
// }

GO FUNC idna.Transitional has:
// func transitional(transitional Object) Object {
// 	arg_1 := idna.Transitional(transitional)
// 	...ABEND676: TODO...
// }

GO FUNC idna.ValidateForRegistration has:
// func validateForRegistration() Object {
// 	arg_1 := idna.ValidateForRegistration()
// 	...ABEND676: TODO...
// }

GO FUNC idna.ValidateLabels has:
// func validateLabels(enable Object) Object {
// 	arg_1 := idna.ValidateLabels(enable)
// 	...ABEND676: TODO...
// }

GO FUNC idna.VerifyDNSLength has:
// func verifyDNSLength(verify Object) Object {
// 	arg_1 := idna.VerifyDNSLength(verify)
// 	...ABEND676: TODO...
// }

GO FUNC image.Decode has:
// func decode(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/format.go:78:15)) Object {
// 	arg_1, arg_2, arg_3 := image.Decode(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.DecodeConfig has:
// func decodeConfig(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/format.go:92:21)) Object {
// 	arg_1, arg_2, arg_3 := image.DecodeConfig(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewAlpha has:
// func newAlpha(r Object) Object {
// 	arg_1 := image.NewAlpha(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewAlpha16 has:
// func newAlpha16(r Object) Object {
// 	arg_1 := image.NewAlpha16(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewCMYK has:
// func newCMYK(r Object) Object {
// 	arg_1 := image.NewCMYK(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewGray has:
// func newGray(r Object) Object {
// 	arg_1 := image.NewGray(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewGray16 has:
// func newGray16(r Object) Object {
// 	arg_1 := image.NewGray16(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewNRGBA has:
// func newNRGBA(r Object) Object {
// 	arg_1 := image.NewNRGBA(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewNRGBA64 has:
// func newNRGBA64(r Object) Object {
// 	arg_1 := image.NewNRGBA64(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewNYCbCrA has:
// func newNYCbCrA(r Object, subsampleRatio Object) Object {
// 	arg_1 := image.NewNYCbCrA(r, subsampleRatio)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewPaletted has:
// func newPaletted(r Object, p ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/image.go:1019:33)) Object {
// 	arg_1 := image.NewPaletted(r, p)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewRGBA has:
// func newRGBA(r Object) Object {
// 	arg_1 := image.NewRGBA(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewRGBA64 has:
// func newRGBA64(r Object) Object {
// 	arg_1 := image.NewRGBA64(r)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewUniform has:
// func newUniform(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/names.go:50:19)) Object {
// 	arg_1 := image.NewUniform(c)
// 	...ABEND676: TODO...
// }

GO FUNC image.NewYCbCr has:
// func newYCbCr(r Object, subsampleRatio Object) Object {
// 	arg_1 := image.NewYCbCr(r, subsampleRatio)
// 	...ABEND676: TODO...
// }

GO FUNC image.Pt has:
// func pt(X int, Y int) Object {
// 	arg_1 := image.Pt(X, Y)
// 	...ABEND676: TODO...
// }

GO FUNC image.Rect has:
// func rect(x0 int, y0 int, x1 int, y1 int) Object {
// 	arg_1 := image.Rect(x0, y0, x1, y1)
// 	...ABEND676: TODO...
// }

GO FUNC image.RegisterFormat has:
// func registerFormat(name string, magic string, decode ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/format.go:32:48), decodeConfig ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/format.go:32:93)) Object {
// 	image.RegisterFormat(name, magic, decode, decodeConfig)
// 	...ABEND676: TODO...
// }

GO FUNC importer.Default has:
// func default() Object {
// 	arg_1 := importer.Default()
// 	...ABEND676: TODO...
// }

GO FUNC importer.For has:
// func for(compiler string, lookup Object) Object {
// 	arg_1 := importer.For(compiler, lookup)
// 	...ABEND676: TODO...
// }

GO FUNC io.Copy has:
// func copy(dst Object, src Object) Object {
// 	written, err := io.Copy(dst, src)
// 	...ABEND676: TODO...
// }

GO FUNC io.CopyBuffer has:
// func copyBuffer(dst Object, src Object, buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/io.go:371:45)) Object {
// 	written, err := io.CopyBuffer(dst, src, buf)
// 	...ABEND676: TODO...
// }

GO FUNC io.CopyN has:
// func copyN(dst Object, src Object, n Object) Object {
// 	written, err := io.CopyN(dst, src, n)
// 	...ABEND676: TODO...
// }

GO FUNC io.LimitReader has:
// func limitReader(r Object, n Object) Object {
// 	arg_1 := io.LimitReader(r, n)
// 	...ABEND676: TODO...
// }

GO FUNC io.MultiReader has:
// func multiReader(readers ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/io/multi.go:48:26)) Object {
// 	arg_1 := io.MultiReader(readers)
// 	...ABEND676: TODO...
// }

GO FUNC io.MultiWriter has:
// func multiWriter(writers ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/io/multi.go:102:26)) Object {
// 	arg_1 := io.MultiWriter(writers)
// 	...ABEND676: TODO...
// }

GO FUNC io.NewSectionReader has:
// func newSectionReader(r Object, off Object, n Object) Object {
// 	arg_1 := io.NewSectionReader(r, off, n)
// 	...ABEND676: TODO...
// }

GO FUNC io.Pipe has:
// func pipe() Object {
// 	arg_1, arg_2 := io.Pipe()
// 	...ABEND676: TODO...
// }

GO FUNC io.ReadAtLeast has:
// func readAtLeast(r Object, buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/io.go:304:32), min int) Object {
// 	n, err := io.ReadAtLeast(r, buf, min)
// 	...ABEND676: TODO...
// }

GO FUNC io.ReadFull has:
// func readFull(r Object, buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/io.go:328:29)) Object {
// 	n, err := io.ReadFull(r, buf)
// 	...ABEND676: TODO...
// }

GO FUNC io.TeeReader has:
// func teeReader(r Object, w Object) Object {
// 	arg_1 := io.TeeReader(r, w)
// 	...ABEND676: TODO...
// }

GO FUNC io.WriteString has:
// func writeString(w Object, s string) Object {
// 	n, err := io.WriteString(w, s)
// 	...ABEND676: TODO...
// }

GO FUNC iotest.DataErrReader has:
// func dataErrReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:45:22)) Object {
// 	arg_1 := iotest.DataErrReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC iotest.HalfReader has:
// func halfReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:30:19)) Object {
// 	arg_1 := iotest.HalfReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC iotest.NewReadLogger has:
// func newReadLogger(prefix string, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/logger.go:52:37)) Object {
// 	arg_1 := iotest.NewReadLogger(prefix, r)
// 	...ABEND676: TODO...
// }

GO FUNC iotest.NewWriteLogger has:
// func newWriteLogger(prefix string, w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/logger.go:30:38)) Object {
// 	arg_1 := iotest.NewWriteLogger(prefix, w)
// 	...ABEND676: TODO...
// }

GO FUNC iotest.OneByteReader has:
// func oneByteReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:15:22)) Object {
// 	arg_1 := iotest.OneByteReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC iotest.TimeoutReader has:
// func timeoutReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:75:22)) Object {
// 	arg_1 := iotest.TimeoutReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC iotest.TruncateWriter has:
// func truncateWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/writer.go:11:23), n Object) Object {
// 	arg_1 := iotest.TruncateWriter(w, n)
// 	...ABEND676: TODO...
// }

GO FUNC ioutil.NopCloser has:
// func nopCloser(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:118:18)) Object {
// 	arg_1 := ioutil.NopCloser(r)
// 	...ABEND676: TODO...
// }

GO FUNC ioutil.ReadAll has:
// func readAll(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:44:16)) Object {
// 	arg_1, arg_2 := ioutil.ReadAll(r)
// 	...ABEND676: TODO...
// }

GO FUNC ioutil.ReadDir has:
// func readDir(dirname string) Object {
// 	arg_1, arg_2 := ioutil.ReadDir(dirname)
// 	...ABEND676: TODO...
// }

GO FUNC ioutil.ReadFile has:
// func readFile(filename string) Object {
// 	arg_1, arg_2 := ioutil.ReadFile(filename)
// 	...ABEND676: TODO...
// }

GO FUNC ioutil.TempDir has:
// func tempDir(dir string, prefix string) Object {
// 	name, err := ioutil.TempDir(dir, prefix)
// 	...ABEND676: TODO...
// }

GO FUNC ioutil.TempFile has:
// func tempFile(dir string, pattern string) Object {
// 	f, err := ioutil.TempFile(dir, pattern)
// 	...ABEND676: TODO...
// }

GO FUNC jpeg.Decode has:
// func decode(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/reader.go:777:15)) Object {
// 	arg_1, arg_2 := jpeg.Decode(r)
// 	...ABEND676: TODO...
// }

GO FUNC jpeg.DecodeConfig has:
// func decodeConfig(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/reader.go:784:21)) Object {
// 	arg_1, arg_2 := jpeg.DecodeConfig(r)
// 	...ABEND676: TODO...
// }

GO FUNC json.HTMLEscape has:
// func hTMLEscape(dst ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/json/encode.go:194:21), src ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/encode.go:194:40)) Object {
// 	json.HTMLEscape(dst, src)
// 	...ABEND676: TODO...
// }

GO FUNC json.Marshal has:
// func marshal(v ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/json/encode.go:157:16)) Object {
// 	arg_1, arg_2 := json.Marshal(v)
// 	...ABEND676: TODO...
// }

GO FUNC json.MarshalIndent has:
// func marshalIndent(v ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/json/encode.go:175:22), prefix string, indent string) Object {
// 	arg_1, arg_2 := json.MarshalIndent(v, prefix, indent)
// 	...ABEND676: TODO...
// }

GO FUNC json.NewDecoder has:
// func newDecoder(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:31:19)) Object {
// 	arg_1 := json.NewDecoder(r)
// 	...ABEND676: TODO...
// }

GO FUNC json.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:186:19)) Object {
// 	arg_1 := json.NewEncoder(w)
// 	...ABEND676: TODO...
// }

GO FUNC jsonrpc.Dial has:
// func dial(network string, address string) Object {
// 	arg_1, arg_2 := jsonrpc.Dial(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC jsonrpc.NewClient has:
// func newClient(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:113:21)) Object {
// 	arg_1 := jsonrpc.NewClient(conn)
// 	...ABEND676: TODO...
// }

GO FUNC jsonrpc.NewClientCodec has:
// func newClientCodec(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:37:26)) Object {
// 	arg_1 := jsonrpc.NewClientCodec(conn)
// 	...ABEND676: TODO...
// }

GO FUNC jsonrpc.NewServerCodec has:
// func newServerCodec(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/server.go:37:26)) Object {
// 	arg_1 := jsonrpc.NewServerCodec(conn)
// 	...ABEND676: TODO...
// }

GO FUNC jsonrpc.ServeConn has:
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/server.go:132:21)) Object {
// 	jsonrpc.ServeConn(conn)
// 	...ABEND676: TODO...
// }

GO FUNC list.New has:
// func new() Object {
// 	arg_1 := list.New()
// 	...ABEND676: TODO...
// }

GO FUNC log.Fatal has:
// func fatal(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:305:14)) Object {
// 	log.Fatal(v)
// 	...ABEND676: TODO...
// }

GO FUNC log.Fatalf has:
// func fatalf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:311:30)) Object {
// 	log.Fatalf(format, v)
// 	...ABEND676: TODO...
// }

GO FUNC log.Fatalln has:
// func fatalln(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:317:16)) Object {
// 	log.Fatalln(v)
// 	...ABEND676: TODO...
// }

GO FUNC log.New has:
// func new(out ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:62:14), prefix string, flag int) Object {
// 	arg_1 := log.New(out, prefix, flag)
// 	...ABEND676: TODO...
// }

GO FUNC log.Panic has:
// func panic(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:323:14)) Object {
// 	log.Panic(v)
// 	...ABEND676: TODO...
// }

GO FUNC log.Panicf has:
// func panicf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:330:30)) Object {
// 	log.Panicf(format, v)
// 	...ABEND676: TODO...
// }

GO FUNC log.Panicln has:
// func panicln(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:337:16)) Object {
// 	log.Panicln(v)
// 	...ABEND676: TODO...
// }

GO FUNC log.Print has:
// func print(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:288:14)) Object {
// 	log.Print(v)
// 	...ABEND676: TODO...
// }

GO FUNC log.Printf has:
// func printf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:294:30)) Object {
// 	log.Printf(format, v)
// 	...ABEND676: TODO...
// }

GO FUNC log.Println has:
// func println(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:300:16)) Object {
// 	log.Println(v)
// 	...ABEND676: TODO...
// }

GO FUNC log.SetFlags has:
// func setFlags(flag int) Object {
// 	log.SetFlags(flag)
// 	...ABEND676: TODO...
// }

GO FUNC log.SetOutput has:
// func setOutput(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:258:18)) Object {
// 	log.SetOutput(w)
// 	...ABEND676: TODO...
// }

GO FUNC log.SetPrefix has:
// func setPrefix(prefix string) Object {
// 	log.SetPrefix(prefix)
// 	...ABEND676: TODO...
// }

GO FUNC lzw.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/lzw/reader.go:239:18), order Object, litWidth int) Object {
// 	arg_1 := lzw.NewReader(r, order, litWidth)
// 	...ABEND676: TODO...
// }

GO FUNC lzw.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/lzw/writer.go:241:18), order Object, litWidth int) Object {
// 	arg_1 := lzw.NewWriter(w, order, litWidth)
// 	...ABEND676: TODO...
// }

GO FUNC macho.NewFatFile has:
// func newFatFile(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/fat.go:45:19)) Object {
// 	arg_1, arg_2 := macho.NewFatFile(r)
// 	...ABEND676: TODO...
// }

GO FUNC macho.NewFile has:
// func newFile(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:228:16)) Object {
// 	arg_1, arg_2 := macho.NewFile(r)
// 	...ABEND676: TODO...
// }

GO FUNC macho.Open has:
// func open(name string) Object {
// 	arg_1, arg_2 := macho.Open(name)
// 	...ABEND676: TODO...
// }

GO FUNC macho.OpenFat has:
// func openFat(name string) Object {
// 	arg_1, arg_2 := macho.OpenFat(name)
// 	...ABEND676: TODO...
// }

GO FUNC mail.ParseAddress has:
// func parseAddress(address string) Object {
// 	arg_1, arg_2 := mail.ParseAddress(address)
// 	...ABEND676: TODO...
// }

GO FUNC mail.ParseAddressList has:
// func parseAddressList(list string) Object {
// 	arg_1, arg_2 := mail.ParseAddressList(list)
// 	...ABEND676: TODO...
// }

GO FUNC mail.ParseDate has:
// func parseDate(date string) Object {
// 	arg_1, arg_2 := mail.ParseDate(date)
// 	...ABEND676: TODO...
// }

GO FUNC mail.ReadMessage has:
// func readMessage(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/mail/message.go:52:20)) Object {
// 	msg, err := mail.ReadMessage(r)
// 	...ABEND676: TODO...
// }

GO FUNC math.Abs has:
// func abs(x Object) Object {
// 	arg_1 := math.Abs(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Acos has:
// func acos(x Object) Object {
// 	arg_1 := math.Acos(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Acosh has:
// func acosh(x Object) Object {
// 	arg_1 := math.Acosh(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Asin has:
// func asin(x Object) Object {
// 	arg_1 := math.Asin(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Asinh has:
// func asinh(x Object) Object {
// 	arg_1 := math.Asinh(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Atan has:
// func atan(x Object) Object {
// 	arg_1 := math.Atan(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Atan2 has:
// func atan2(y Object, x Object) Object {
// 	arg_1 := math.Atan2(y, x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Atanh has:
// func atanh(x Object) Object {
// 	arg_1 := math.Atanh(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Cbrt has:
// func cbrt(x Object) Object {
// 	arg_1 := math.Cbrt(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Ceil has:
// func ceil(x Object) Object {
// 	arg_1 := math.Ceil(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Copysign has:
// func copysign(x Object, y Object) Object {
// 	arg_1 := math.Copysign(x, y)
// 	...ABEND676: TODO...
// }

GO FUNC math.Cos has:
// func cos(x Object) Object {
// 	arg_1 := math.Cos(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Cosh has:
// func cosh(x Object) Object {
// 	arg_1 := math.Cosh(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Dim has:
// func dim(x Object, y Object) Object {
// 	arg_1 := math.Dim(x, y)
// 	...ABEND676: TODO...
// }

GO FUNC math.Erf has:
// func erf(x Object) Object {
// 	arg_1 := math.Erf(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Erfc has:
// func erfc(x Object) Object {
// 	arg_1 := math.Erfc(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Erfcinv has:
// func erfcinv(x Object) Object {
// 	arg_1 := math.Erfcinv(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Erfinv has:
// func erfinv(x Object) Object {
// 	arg_1 := math.Erfinv(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Exp has:
// func exp(x Object) Object {
// 	arg_1 := math.Exp(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Exp2 has:
// func exp2(x Object) Object {
// 	arg_1 := math.Exp2(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Expm1 has:
// func expm1(x Object) Object {
// 	arg_1 := math.Expm1(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Float32frombits has:
// func float32frombits(b Object) Object {
// 	arg_1 := math.Float32frombits(b)
// 	...ABEND676: TODO...
// }

GO FUNC math.Float64bits has:
// func float64bits(f Object) Object {
// 	arg_1 := math.Float64bits(f)
// 	...ABEND676: TODO...
// }

GO FUNC math.Float64frombits has:
// func float64frombits(b Object) Object {
// 	arg_1 := math.Float64frombits(b)
// 	...ABEND676: TODO...
// }

GO FUNC math.Floor has:
// func floor(x Object) Object {
// 	arg_1 := math.Floor(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Frexp has:
// func frexp(f Object) Object {
// 	frac, exp := math.Frexp(f)
// 	...ABEND676: TODO...
// }

GO FUNC math.Gamma has:
// func gamma(x Object) Object {
// 	arg_1 := math.Gamma(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Hypot has:
// func hypot(p Object, q Object) Object {
// 	arg_1 := math.Hypot(p, q)
// 	...ABEND676: TODO...
// }

GO FUNC math.Inf has:
// func inf(sign int) Object {
// 	arg_1 := math.Inf(sign)
// 	...ABEND676: TODO...
// }

GO FUNC math.IsNaN has:
// func isNaN(f Object) Object {
// 	is := math.IsNaN(f)
// 	...ABEND676: TODO...
// }

GO FUNC math.J0 has:
// func j0(x Object) Object {
// 	arg_1 := math.J0(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.J1 has:
// func j1(x Object) Object {
// 	arg_1 := math.J1(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Jn has:
// func jn(n int, x Object) Object {
// 	arg_1 := math.Jn(n, x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Ldexp has:
// func ldexp(frac Object, exp int) Object {
// 	arg_1 := math.Ldexp(frac, exp)
// 	...ABEND676: TODO...
// }

GO FUNC math.Lgamma has:
// func lgamma(x Object) Object {
// 	lgamma, sign := math.Lgamma(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Log has:
// func log(x Object) Object {
// 	arg_1 := math.Log(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Log10 has:
// func log10(x Object) Object {
// 	arg_1 := math.Log10(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Log1p has:
// func log1p(x Object) Object {
// 	arg_1 := math.Log1p(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Log2 has:
// func log2(x Object) Object {
// 	arg_1 := math.Log2(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Logb has:
// func logb(x Object) Object {
// 	arg_1 := math.Logb(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Max has:
// func max(x Object, y Object) Object {
// 	arg_1 := math.Max(x, y)
// 	...ABEND676: TODO...
// }

GO FUNC math.Min has:
// func min(x Object, y Object) Object {
// 	arg_1 := math.Min(x, y)
// 	...ABEND676: TODO...
// }

GO FUNC math.Mod has:
// func mod(x Object, y Object) Object {
// 	arg_1 := math.Mod(x, y)
// 	...ABEND676: TODO...
// }

GO FUNC math.Modf has:
// func modf(f Object) Object {
// 	int, frac := math.Modf(f)
// 	...ABEND676: TODO...
// }

GO FUNC math.NaN has:
// func naN() Object {
// 	arg_1 := math.NaN()
// 	...ABEND676: TODO...
// }

GO FUNC math.Nextafter has:
// func nextafter(x Object, y Object) Object {
// 	r := math.Nextafter(x, y)
// 	...ABEND676: TODO...
// }

GO FUNC math.Nextafter32 has:
// func nextafter32(x Object, y Object) Object {
// 	r := math.Nextafter32(x, y)
// 	...ABEND676: TODO...
// }

GO FUNC math.Pow has:
// func pow(x Object, y Object) Object {
// 	arg_1 := math.Pow(x, y)
// 	...ABEND676: TODO...
// }

GO FUNC math.Pow10 has:
// func pow10(n int) Object {
// 	arg_1 := math.Pow10(n)
// 	...ABEND676: TODO...
// }

GO FUNC math.Remainder has:
// func remainder(x Object, y Object) Object {
// 	arg_1 := math.Remainder(x, y)
// 	...ABEND676: TODO...
// }

GO FUNC math.Round has:
// func round(x Object) Object {
// 	arg_1 := math.Round(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.RoundToEven has:
// func roundToEven(x Object) Object {
// 	arg_1 := math.RoundToEven(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Sin has:
// func sin(x Object) Object {
// 	arg_1 := math.Sin(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Sincos has:
// func sincos(x Object) Object {
// 	sin, cos := math.Sincos(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Sinh has:
// func sinh(x Object) Object {
// 	arg_1 := math.Sinh(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Sqrt has:
// func sqrt(x Object) Object {
// 	arg_1 := math.Sqrt(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Tan has:
// func tan(x Object) Object {
// 	arg_1 := math.Tan(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Tanh has:
// func tanh(x Object) Object {
// 	arg_1 := math.Tanh(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Trunc has:
// func trunc(x Object) Object {
// 	arg_1 := math.Trunc(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Y0 has:
// func y0(x Object) Object {
// 	arg_1 := math.Y0(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Y1 has:
// func y1(x Object) Object {
// 	arg_1 := math.Y1(x)
// 	...ABEND676: TODO...
// }

GO FUNC math.Yn has:
// func yn(n int, x Object) Object {
// 	arg_1 := math.Yn(n, x)
// 	...ABEND676: TODO...
// }

GO FUNC md5.New has:
// func new() Object {
// 	arg_1 := md5.New()
// 	...ABEND676: TODO...
// }

GO FUNC md5.Sum has:
// func sum(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/md5/md5.go:204:15)) Object {
// 	arg_1 := md5.Sum(data)
// 	...ABEND676: TODO...
// }

GO FUNC mime.ExtensionsByType has:
// func extensionsByType(typ string) Object {
// 	arg_1, arg_2 := mime.ExtensionsByType(typ)
// 	...ABEND676: TODO...
// }

GO FUNC mime.ParseMediaType has:
// func parseMediaType(v string) Object {
// 	mediatype, params, err := mime.ParseMediaType(v)
// 	...ABEND676: TODO...
// }

GO FUNC multipart.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/multipart.go:99:18), boundary string) Object {
// 	arg_1 := multipart.NewReader(r, boundary)
// 	...ABEND676: TODO...
// }

GO FUNC multipart.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/writer.go:27:18)) Object {
// 	arg_1 := multipart.NewWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC net.CIDRMask has:
// func cIDRMask(ones int, bits int) Object {
// 	arg_1 := net.CIDRMask(ones, bits)
// 	...ABEND676: TODO...
// }

GO FUNC net.Dial has:
// func dial(network string, address string) Object {
// 	arg_1, arg_2 := net.Dial(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.DialIP has:
// func dialIP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/iprawsock.go:211:42), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/iprawsock.go:211:42)) Object {
// 	arg_1, arg_2 := net.DialIP(network, laddr, raddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.DialTCP has:
// func dialTCP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/tcpsock.go:206:43), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/tcpsock.go:206:43)) Object {
// 	arg_1, arg_2 := net.DialTCP(network, laddr, raddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.DialTimeout has:
// func dialTimeout(network string, address string, timeout ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/dial.go:313:51)) Object {
// 	arg_1, arg_2 := net.DialTimeout(network, address, timeout)
// 	...ABEND676: TODO...
// }

GO FUNC net.DialUDP has:
// func dialUDP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:205:43), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:205:43)) Object {
// 	arg_1, arg_2 := net.DialUDP(network, laddr, raddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.DialUnix has:
// func dialUnix(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:200:44), raddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:200:44)) Object {
// 	arg_1, arg_2 := net.DialUnix(network, laddr, raddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.FileConn has:
// func fileConn(f ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/file.go:21:17)) Object {
// 	c, err := net.FileConn(f)
// 	...ABEND676: TODO...
// }

GO FUNC net.FileListener has:
// func fileListener(f ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/file.go:33:21)) Object {
// 	ln, err := net.FileListener(f)
// 	...ABEND676: TODO...
// }

GO FUNC net.FilePacketConn has:
// func filePacketConn(f ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/file.go:45:23)) Object {
// 	c, err := net.FilePacketConn(f)
// 	...ABEND676: TODO...
// }

GO FUNC net.IPv4 has:
// func iPv4(a Object, b Object, c Object, d Object) Object {
// 	arg_1 := net.IPv4(a, b, c, d)
// 	...ABEND676: TODO...
// }

GO FUNC net.IPv4Mask has:
// func iPv4Mask(a Object, b Object, c Object, d Object) Object {
// 	arg_1 := net.IPv4Mask(a, b, c, d)
// 	...ABEND676: TODO...
// }

GO FUNC net.InterfaceAddrs has:
// func interfaceAddrs() Object {
// 	arg_1, arg_2 := net.InterfaceAddrs()
// 	...ABEND676: TODO...
// }

GO FUNC net.InterfaceByIndex has:
// func interfaceByIndex(index int) Object {
// 	arg_1, arg_2 := net.InterfaceByIndex(index)
// 	...ABEND676: TODO...
// }

GO FUNC net.InterfaceByName has:
// func interfaceByName(name string) Object {
// 	arg_1, arg_2 := net.InterfaceByName(name)
// 	...ABEND676: TODO...
// }

GO FUNC net.Interfaces has:
// func interfaces() Object {
// 	arg_1, arg_2 := net.Interfaces()
// 	...ABEND676: TODO...
// }

GO FUNC net.Listen has:
// func listen(network string, address string) Object {
// 	arg_1, arg_2 := net.Listen(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenIP has:
// func listenIP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/iprawsock.go:230:37)) Object {
// 	arg_1, arg_2 := net.ListenIP(network, laddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenMulticastUDP has:
// func listenMulticastUDP(network string, ifi ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:265:45), gaddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:265:63)) Object {
// 	arg_1, arg_2 := net.ListenMulticastUDP(network, ifi, gaddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenPacket has:
// func listenPacket(network string, address string) Object {
// 	arg_1, arg_2 := net.ListenPacket(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenTCP has:
// func listenTCP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/tcpsock.go:323:38)) Object {
// 	arg_1, arg_2 := net.ListenTCP(network, laddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenUDP has:
// func listenUDP(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:231:38)) Object {
// 	arg_1, arg_2 := net.ListenUDP(network, laddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenUnix has:
// func listenUnix(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:314:39)) Object {
// 	arg_1, arg_2 := net.ListenUnix(network, laddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.ListenUnixgram has:
// func listenUnixgram(network string, laddr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:334:43)) Object {
// 	arg_1, arg_2 := net.ListenUnixgram(network, laddr)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupAddr has:
// func lookupAddr(addr string) Object {
// 	names, err := net.LookupAddr(addr)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupCNAME has:
// func lookupCNAME(host string) Object {
// 	cname, err := net.LookupCNAME(host)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupHost has:
// func lookupHost(host string) Object {
// 	addrs, err := net.LookupHost(host)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupIP has:
// func lookupIP(host string) Object {
// 	arg_1, arg_2 := net.LookupIP(host)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupMX has:
// func lookupMX(name string) Object {
// 	arg_1, arg_2 := net.LookupMX(name)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupNS has:
// func lookupNS(name string) Object {
// 	arg_1, arg_2 := net.LookupNS(name)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupPort has:
// func lookupPort(network string, service string) Object {
// 	port, err := net.LookupPort(network, service)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupSRV has:
// func lookupSRV(service string, proto string, name string) Object {
// 	cname, addrs, err := net.LookupSRV(service, proto, name)
// 	...ABEND676: TODO...
// }

GO FUNC net.LookupTXT has:
// func lookupTXT(name string) Object {
// 	arg_1, arg_2 := net.LookupTXT(name)
// 	...ABEND676: TODO...
// }

GO FUNC net.ParseCIDR has:
// func parseCIDR(s string) Object {
// 	arg_1, arg_2, arg_3 := net.ParseCIDR(s)
// 	...ABEND676: TODO...
// }

GO FUNC net.ParseIP has:
// func parseIP(s string) Object {
// 	arg_1 := net.ParseIP(s)
// 	...ABEND676: TODO...
// }

GO FUNC net.ParseMAC has:
// func parseMAC(s string) Object {
// 	hw, err := net.ParseMAC(s)
// 	...ABEND676: TODO...
// }

GO FUNC net.Pipe has:
// func pipe() Object {
// 	arg_1, arg_2 := net.Pipe()
// 	...ABEND676: TODO...
// }

GO FUNC net.ResolveIPAddr has:
// func resolveIPAddr(network string, address string) Object {
// 	arg_1, arg_2 := net.ResolveIPAddr(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.ResolveTCPAddr has:
// func resolveTCPAddr(network string, address string) Object {
// 	arg_1, arg_2 := net.ResolveTCPAddr(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.ResolveUDPAddr has:
// func resolveUDPAddr(network string, address string) Object {
// 	arg_1, arg_2 := net.ResolveUDPAddr(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.ResolveUnixAddr has:
// func resolveUnixAddr(network string, address string) Object {
// 	arg_1, arg_2 := net.ResolveUnixAddr(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC net.SplitHostPort has:
// func splitHostPort(hostport string) Object {
// 	host, port, err := net.SplitHostPort(hostport)
// 	...ABEND676: TODO...
// }

GO FUNC nettest.TestConn has:
// func testConn(t ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/net/nettest/conntest.go:37:17), mp Object) Object {
// 	nettest.TestConn(t, mp)
// 	...ABEND676: TODO...
// }

GO FUNC os.Clearenv has:
// func clearenv() Object {
// 	os.Clearenv()
// 	...ABEND676: TODO...
// }

GO FUNC os.Create has:
// func create(name string) Object {
// 	arg_1, arg_2 := os.Create(name)
// 	...ABEND676: TODO...
// }

GO FUNC os.Environ has:
// func environ() Object {
// 	arg_1 := os.Environ()
// 	...ABEND676: TODO...
// }

GO FUNC os.Executable has:
// func executable() Object {
// 	arg_1, arg_2 := os.Executable()
// 	...ABEND676: TODO...
// }

GO FUNC os.Exit has:
// func exit(code int) Object {
// 	os.Exit(code)
// 	...ABEND676: TODO...
// }

GO FUNC os.FindProcess has:
// func findProcess(pid int) Object {
// 	arg_1, arg_2 := os.FindProcess(pid)
// 	...ABEND676: TODO...
// }

GO FUNC os.Getgroups has:
// func getgroups() Object {
// 	arg_1, arg_2 := os.Getgroups()
// 	...ABEND676: TODO...
// }

GO FUNC os.Getwd has:
// func getwd() Object {
// 	dir, err := os.Getwd()
// 	...ABEND676: TODO...
// }

GO FUNC os.Hostname has:
// func hostname() Object {
// 	name, err := os.Hostname()
// 	...ABEND676: TODO...
// }

GO FUNC os.LookupEnv has:
// func lookupEnv(key string) Object {
// 	arg_1, arg_2 := os.LookupEnv(key)
// 	...ABEND676: TODO...
// }

GO FUNC os.Lstat has:
// func lstat(name string) Object {
// 	arg_1, arg_2 := os.Lstat(name)
// 	...ABEND676: TODO...
// }

GO FUNC os.NewFile has:
// func newFile(fd Object, name string) Object {
// 	arg_1 := os.NewFile(fd, name)
// 	...ABEND676: TODO...
// }

GO FUNC os.Open has:
// func open(name string) Object {
// 	arg_1, arg_2 := os.Open(name)
// 	...ABEND676: TODO...
// }

GO FUNC os.OpenFile has:
// func openFile(name string, flag int, perm Object) Object {
// 	arg_1, arg_2 := os.OpenFile(name, flag, perm)
// 	...ABEND676: TODO...
// }

GO FUNC os.Pipe has:
// func pipe() Object {
// 	r, w, err := os.Pipe()
// 	...ABEND676: TODO...
// }

GO FUNC os.Readlink has:
// func readlink(name string) Object {
// 	arg_1, arg_2 := os.Readlink(name)
// 	...ABEND676: TODO...
// }

GO FUNC os.StartProcess has:
// func startProcess(name string, argv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec.go:100:37), attr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/os/exec.go:100:52)) Object {
// 	arg_1, arg_2 := os.StartProcess(name, argv, attr)
// 	...ABEND676: TODO...
// }

GO FUNC os.Stat has:
// func stat(name string) Object {
// 	arg_1, arg_2 := os.Stat(name)
// 	...ABEND676: TODO...
// }

GO FUNC os.UserCacheDir has:
// func userCacheDir() Object {
// 	arg_1, arg_2 := os.UserCacheDir()
// 	...ABEND676: TODO...
// }

GO FUNC parse.New has:
// func new(name string, funcs ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/text/template/parse/parse.go:125:29)) Object {
// 	arg_1 := parse.New(name, funcs)
// 	...ABEND676: TODO...
// }

GO FUNC parse.NewIdentifier has:
// func newIdentifier(ident string) Object {
// 	arg_1 := parse.NewIdentifier(ident)
// 	...ABEND676: TODO...
// }

GO FUNC parse.Parse has:
// func parse(name string, text string, leftDelim string, rightDelim string, funcs ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/text/template/parse/parse.go:51:60)) Object {
// 	arg_1, arg_2 := parse.Parse(name, text, leftDelim, rightDelim, funcs)
// 	...ABEND676: TODO...
// }

GO FUNC parser.ParseDir has:
// func parseDir(fset ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/parser/interface.go:135:20), path string, filter ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/parser/interface.go:135:56), mode Object) Object {
// 	pkgs, first := parser.ParseDir(fset, path, filter, mode)
// 	...ABEND676: TODO...
// }

GO FUNC parser.ParseExpr has:
// func parseExpr(x string) Object {
// 	arg_1, arg_2 := parser.ParseExpr(x)
// 	...ABEND676: TODO...
// }

GO FUNC parser.ParseExprFrom has:
// func parseExprFrom(fset ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/parser/interface.go:176:25), filename string, src ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/parser/interface.go:176:62), mode Object) Object {
// 	arg_1, arg_2 := parser.ParseExprFrom(fset, filename, src, mode)
// 	...ABEND676: TODO...
// }

GO FUNC parser.ParseFile has:
// func parseFile(fset ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/parser/interface.go:80:21), filename string, src ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/parser/interface.go:80:58), mode Object) Object {
// 	f, err := parser.ParseFile(fset, filename, src, mode)
// 	...ABEND676: TODO...
// }

GO FUNC path.Match has:
// func match(pattern string, name string) Object {
// 	matched, err := path.Match(pattern, name)
// 	...ABEND676: TODO...
// }

GO FUNC path.Split has:
// func split(path string) Object {
// 	dir, file := path.Split(path)
// 	...ABEND676: TODO...
// }

GO FUNC pe.NewFile has:
// func newFile(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/pe/file.go:69:16)) Object {
// 	arg_1, arg_2 := pe.NewFile(r)
// 	...ABEND676: TODO...
// }

GO FUNC pe.Open has:
// func open(name string) Object {
// 	arg_1, arg_2 := pe.Open(name)
// 	...ABEND676: TODO...
// }

GO FUNC pem.Decode has:
// func decode(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/pem/pem.go:78:18)) Object {
// 	p, rest := pem.Decode(data)
// 	...ABEND676: TODO...
// }

GO FUNC pem.EncodeToMemory has:
// func encodeToMemory(b ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/pem/pem.go:326:23)) Object {
// 	arg_1 := pem.EncodeToMemory(b)
// 	...ABEND676: TODO...
// }

GO FUNC plan9obj.NewFile has:
// func newFile(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/plan9obj/file.go:135:16)) Object {
// 	arg_1, arg_2 := plan9obj.NewFile(r)
// 	...ABEND676: TODO...
// }

GO FUNC plan9obj.Open has:
// func open(name string) Object {
// 	arg_1, arg_2 := plan9obj.Open(name)
// 	...ABEND676: TODO...
// }

GO FUNC plugin.Open has:
// func open(path string) Object {
// 	arg_1, arg_2 := plugin.Open(path)
// 	...ABEND676: TODO...
// }

GO FUNC png.Decode has:
// func decode(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/reader.go:952:15)) Object {
// 	arg_1, arg_2 := png.Decode(r)
// 	...ABEND676: TODO...
// }

GO FUNC png.DecodeConfig has:
// func decodeConfig(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/reader.go:976:21)) Object {
// 	arg_1, arg_2 := png.DecodeConfig(r)
// 	...ABEND676: TODO...
// }

GO FUNC poly1305.Sum has:
// func sum(out ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:14), m ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:27), key ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:39)) Object {
// 	poly1305.Sum(out, m, key)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Cmdline has:
// func cmdline(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:83:16), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:83:39)) Object {
// 	pprof.Cmdline(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Do has:
// func do(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/runtime.go:31:13), labels Object, f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/runtime.go:31:49)) Object {
// 	pprof.Do(ctx, labels, f)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.ForLabels has:
// func forLabels(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:78:20), f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/label.go:78:39)) Object {
// 	pprof.ForLabels(ctx, f)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Handler has:
// func handler(name string) Object {
// 	arg_1 := pprof.Handler(name)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Index has:
// func index(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:264:14), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:264:37)) Object {
// 	pprof.Index(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Label has:
// func label(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:70:16), key string) Object {
// 	arg_1, arg_2 := pprof.Label(ctx, key)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Labels has:
// func labels(args ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/runtime/pprof/label.go:57:18)) Object {
// 	arg_1 := pprof.Labels(args)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Lookup has:
// func lookup(name string) Object {
// 	arg_1 := pprof.Lookup(name)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.NewProfile has:
// func newProfile(name string) Object {
// 	arg_1 := pprof.NewProfile(name)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Profile has:
// func profile(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:116:16), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:116:39)) Object {
// 	pprof.Profile(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Profiles has:
// func profiles() Object {
// 	arg_1 := pprof.Profiles()
// 	...ABEND676: TODO...
// }

GO FUNC pprof.SetGoroutineLabels has:
// func setGoroutineLabels(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/runtime.go:20:29)) Object {
// 	pprof.SetGoroutineLabels(ctx)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.StopCPUProfile has:
// func stopCPUProfile() Object {
// 	pprof.StopCPUProfile()
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Symbol has:
// func symbol(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:174:15), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:174:38)) Object {
// 	pprof.Symbol(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.Trace has:
// func trace(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:145:14), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:145:37)) Object {
// 	pprof.Trace(w, r)
// 	...ABEND676: TODO...
// }

GO FUNC pprof.WithLabels has:
// func withLabels(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:39:21), labels Object) Object {
// 	arg_1 := pprof.WithLabels(ctx, labels)
// 	...ABEND676: TODO...
// }

GO FUNC quick.Value has:
// func value(t ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/quick/quick.go:59:14), rand ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/testing/quick/quick.go:59:33)) Object {
// 	value, ok := quick.Value(t, rand)
// 	...ABEND676: TODO...
// }

GO FUNC quotedprintable.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/quotedprintable/reader.go:24:18)) Object {
// 	arg_1 := quotedprintable.NewReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC quotedprintable.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/quotedprintable/writer.go:24:18)) Object {
// 	arg_1 := quotedprintable.NewWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC rand.ExpFloat64 has:
// func expFloat64() Object {
// 	arg_1 := rand.ExpFloat64()
// 	...ABEND676: TODO...
// }

GO FUNC rand.Float32 has:
// func float32() Object {
// 	arg_1 := rand.Float32()
// 	...ABEND676: TODO...
// }

GO FUNC rand.Float64 has:
// func float64() Object {
// 	arg_1 := rand.Float64()
// 	...ABEND676: TODO...
// }

GO FUNC rand.New has:
// func new(src Object) Object {
// 	arg_1 := rand.New(src)
// 	...ABEND676: TODO...
// }

GO FUNC rand.NewSource has:
// func newSource(seed Object) Object {
// 	arg_1 := rand.NewSource(seed)
// 	...ABEND676: TODO...
// }

GO FUNC rand.NewZipf has:
// func newZipf(r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/math/rand/zipf.go:39:16), s Object, v Object, imax Object) Object {
// 	arg_1 := rand.NewZipf(r, s, v, imax)
// 	...ABEND676: TODO...
// }

GO FUNC rand.NormFloat64 has:
// func normFloat64() Object {
// 	arg_1 := rand.NormFloat64()
// 	...ABEND676: TODO...
// }

GO FUNC rand.Perm has:
// func perm(n int) Object {
// 	arg_1 := rand.Perm(n)
// 	...ABEND676: TODO...
// }

GO FUNC rand.Prime has:
// func prime(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rand/util.go:31:17), bits int) Object {
// 	p, err := rand.Prime(rand, bits)
// 	...ABEND676: TODO...
// }

GO FUNC rand.Seed has:
// func seed(seed Object) Object {
// 	rand.Seed(seed)
// 	...ABEND676: TODO...
// }

GO FUNC rand.Shuffle has:
// func shuffle(n int, swap ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/math/rand/rand.go:346:26)) Object {
// 	rand.Shuffle(n, swap)
// 	...ABEND676: TODO...
// }

GO FUNC rand.Uint64 has:
// func uint64() Object {
// 	arg_1 := rand.Uint64()
// 	...ABEND676: TODO...
// }

GO FUNC rc4.NewCipher has:
// func newCipher(key ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rc4/rc4.go:31:20)) Object {
// 	arg_1, arg_2 := rc4.NewCipher(key)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.Append has:
// func append(s Object, x ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/reflect/value.go:1890:24)) Object {
// 	arg_1 := reflect.Append(s, x)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.AppendSlice has:
// func appendSlice(s Object, t Object) Object {
// 	arg_1 := reflect.AppendSlice(s, t)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.ArrayOf has:
// func arrayOf(count int, elem Object) Object {
// 	arg_1 := reflect.ArrayOf(count, elem)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.ChanOf has:
// func chanOf(dir Object, t Object) Object {
// 	arg_1 := reflect.ChanOf(dir, t)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.FuncOf has:
// func funcOf(in ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/type.go:1924:21), out ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/type.go:1924:21), variadic Object) Object {
// 	arg_1 := reflect.FuncOf(in, out, variadic)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.Indirect has:
// func indirect(v Object) Object {
// 	arg_1 := reflect.Indirect(v)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.MakeChan has:
// func makeChan(typ Object, buffer int) Object {
// 	arg_1 := reflect.MakeChan(typ, buffer)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.MakeFunc has:
// func makeFunc(typ Object, fn ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/reflect/makefunc.go:48:28)) Object {
// 	arg_1 := reflect.MakeFunc(typ, fn)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.MakeMap has:
// func makeMap(typ Object) Object {
// 	arg_1 := reflect.MakeMap(typ)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.MakeMapWithSize has:
// func makeMapWithSize(typ Object, n int) Object {
// 	arg_1 := reflect.MakeMapWithSize(typ, n)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.MakeSlice has:
// func makeSlice(typ Object, len int, cap int) Object {
// 	arg_1 := reflect.MakeSlice(typ, len, cap)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.MapOf has:
// func mapOf(key Object, elem Object) Object {
// 	arg_1 := reflect.MapOf(key, elem)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.New has:
// func new(typ Object) Object {
// 	arg_1 := reflect.New(typ)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.NewAt has:
// func newAt(typ Object, p ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:2227:24)) Object {
// 	arg_1 := reflect.NewAt(typ, p)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.PtrTo has:
// func ptrTo(t Object) Object {
// 	arg_1 := reflect.PtrTo(t)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.Select has:
// func select(cases ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/value.go:2025:19)) Object {
// 	chosen, recv, recvOK := reflect.Select(cases)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.SliceOf has:
// func sliceOf(t Object) Object {
// 	arg_1 := reflect.SliceOf(t)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.StructOf has:
// func structOf(fields ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/type.go:2349:22)) Object {
// 	arg_1 := reflect.StructOf(fields)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.Swapper has:
// func swapper(slice ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/swapper.go:13:20)) Object {
// 	arg_1 := reflect.Swapper(slice)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.TypeOf has:
// func typeOf(i ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:1376:15)) Object {
// 	arg_1 := reflect.TypeOf(i)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.ValueOf has:
// func valueOf(i ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/value.go:2182:16)) Object {
// 	arg_1 := reflect.ValueOf(i)
// 	...ABEND676: TODO...
// }

GO FUNC reflect.Zero has:
// func zero(typ Object) Object {
// 	arg_1 := reflect.Zero(typ)
// 	...ABEND676: TODO...
// }

GO FUNC regexp.Compile has:
// func compile(expr string) Object {
// 	arg_1, arg_2 := regexp.Compile(expr)
// 	...ABEND676: TODO...
// }

GO FUNC regexp.CompilePOSIX has:
// func compilePOSIX(expr string) Object {
// 	arg_1, arg_2 := regexp.CompilePOSIX(expr)
// 	...ABEND676: TODO...
// }

GO FUNC regexp.Match has:
// func match(pattern string, b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/regexp.go:475:30)) Object {
// 	matched, err := regexp.Match(pattern, b)
// 	...ABEND676: TODO...
// }

GO FUNC regexp.MatchReader has:
// func matchReader(pattern string, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:453:36)) Object {
// 	matched, err := regexp.MatchReader(pattern, r)
// 	...ABEND676: TODO...
// }

GO FUNC regexp.MatchString has:
// func matchString(pattern string, s string) Object {
// 	matched, err := regexp.MatchString(pattern, s)
// 	...ABEND676: TODO...
// }

GO FUNC regexp.MustCompile has:
// func mustCompile(str string) Object {
// 	arg_1 := regexp.MustCompile(str)
// 	...ABEND676: TODO...
// }

GO FUNC regexp.MustCompilePOSIX has:
// func mustCompilePOSIX(str string) Object {
// 	arg_1 := regexp.MustCompilePOSIX(str)
// 	...ABEND676: TODO...
// }

GO FUNC ring.New has:
// func new(n int) Object {
// 	arg_1 := ring.New(n)
// 	...ABEND676: TODO...
// }

GO FUNC route.FetchRIB has:
// func fetchRIB(af int, typ Object, arg int) Object {
// 	arg_1, arg_2 := route.FetchRIB(af, typ, arg)
// 	...ABEND676: TODO...
// }

GO FUNC route.ParseRIB has:
// func parseRIB(typ Object, b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/route/message.go:33:30)) Object {
// 	arg_1, arg_2 := route.ParseRIB(typ, b)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.Accept has:
// func accept(lis ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:692:17)) Object {
// 	rpc.Accept(lis)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.Dial has:
// func dial(network string, address string) Object {
// 	arg_1, arg_2 := rpc.Dial(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.DialHTTP has:
// func dialHTTP(network string, address string) Object {
// 	arg_1, arg_2 := rpc.DialHTTP(network, address)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.DialHTTPPath has:
// func dialHTTPPath(network string, address string, path string) Object {
// 	arg_1, arg_2 := rpc.DialHTTPPath(network, address, path)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.HandleHTTP has:
// func handleHTTP() Object {
// 	rpc.HandleHTTP()
// 	...ABEND676: TODO...
// }

GO FUNC rpc.NewClient has:
// func newClient(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:193:21)) Object {
// 	arg_1 := rpc.NewClient(conn)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.NewClientWithCodec has:
// func newClientWithCodec(codec Object) Object {
// 	arg_1 := rpc.NewClientWithCodec(codec)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.NewServer has:
// func newServer() Object {
// 	arg_1 := rpc.NewServer()
// 	...ABEND676: TODO...
// }

GO FUNC rpc.ServeCodec has:
// func serveCodec(codec Object) Object {
// 	rpc.ServeCodec(codec)
// 	...ABEND676: TODO...
// }

GO FUNC rpc.ServeConn has:
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:673:21)) Object {
// 	rpc.ServeConn(conn)
// 	...ABEND676: TODO...
// }

GO FUNC rsa.DecryptOAEP has:
// func decryptOAEP(hash ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:569:23), random ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:569:41), priv ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/rsa.go:569:57), ciphertext ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:569:81), label ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:569:95)) Object {
// 	arg_1, arg_2 := rsa.DecryptOAEP(hash, random, priv, ciphertext, label)
// 	...ABEND676: TODO...
// }

GO FUNC rsa.DecryptPKCS1v15 has:
// func decryptPKCS1v15(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:76:27), priv ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:76:43), ciphertext ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:76:67)) Object {
// 	arg_1, arg_2 := rsa.DecryptPKCS1v15(rand, priv, ciphertext)
// 	...ABEND676: TODO...
// }

GO FUNC rsa.EncryptOAEP has:
// func encryptOAEP(hash ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:376:23), random ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:376:41), pub ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/rsa.go:376:56), msg ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:376:72), label ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:376:86)) Object {
// 	arg_1, arg_2 := rsa.EncryptOAEP(hash, random, pub, msg, label)
// 	...ABEND676: TODO...
// }

GO FUNC rsa.EncryptPKCS1v15 has:
// func encryptPKCS1v15(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:39:27), pub ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:39:42), msg ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:39:58)) Object {
// 	arg_1, arg_2 := rsa.EncryptPKCS1v15(rand, pub, msg)
// 	...ABEND676: TODO...
// }

GO FUNC rsa.GenerateKey has:
// func generateKey(random ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:207:25), bits int) Object {
// 	arg_1, arg_2 := rsa.GenerateKey(random, bits)
// 	...ABEND676: TODO...
// }

GO FUNC rsa.GenerateMultiPrimeKey has:
// func generateMultiPrimeKey(random ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:222:35), nprimes int, bits int) Object {
// 	arg_1, arg_2 := rsa.GenerateMultiPrimeKey(random, nprimes, bits)
// 	...ABEND676: TODO...
// }

GO FUNC rsa.SignPKCS1v15 has:
// func signPKCS1v15(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:24), priv ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:40), hash ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:58), hashed ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:78)) Object {
// 	arg_1, arg_2 := rsa.SignPKCS1v15(rand, priv, hash, hashed)
// 	...ABEND676: TODO...
// }

GO FUNC rsa.SignPSS has:
// func signPSS(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pss.go:249:19), priv ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pss.go:249:35), hash ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pss.go:249:53), hashed ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pss.go:249:73), opts ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pss.go:249:86)) Object {
// 	arg_1, arg_2 := rsa.SignPSS(rand, priv, hash, hashed, opts)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.BlockProfile has:
// func blockProfile(p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:634:21)) Object {
// 	n, ok := runtime.BlockProfile(p)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.Breakpoint has:
// func breakpoint() Object {
// 	runtime.Breakpoint()
// 	...ABEND676: TODO...
// }

GO FUNC runtime.CPUProfile has:
// func cPUProfile() Object {
// 	arg_1 := runtime.CPUProfile()
// 	...ABEND676: TODO...
// }

GO FUNC runtime.Caller has:
// func caller(skip int) Object {
// 	pc, file, line, ok := runtime.Caller(skip)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.CallersFrames has:
// func callersFrames(callers ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/symtab.go:91:28)) Object {
// 	arg_1 := runtime.CallersFrames(callers)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.FuncForPC has:
// func funcForPC(pc Object) Object {
// 	arg_1 := runtime.FuncForPC(pc)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.GC has:
// func gC() Object {
// 	runtime.GC()
// 	...ABEND676: TODO...
// }

GO FUNC runtime.Goexit has:
// func goexit() Object {
// 	runtime.Goexit()
// 	...ABEND676: TODO...
// }

GO FUNC runtime.GoroutineProfile has:
// func goroutineProfile(p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:720:25)) Object {
// 	n, ok := runtime.GoroutineProfile(p)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.Gosched has:
// func gosched() Object {
// 	runtime.Gosched()
// 	...ABEND676: TODO...
// }

GO FUNC runtime.KeepAlive has:
// func keepAlive(x ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:446:18)) Object {
// 	runtime.KeepAlive(x)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.LockOSThread has:
// func lockOSThread() Object {
// 	runtime.LockOSThread()
// 	...ABEND676: TODO...
// }

GO FUNC runtime.MemProfile has:
// func memProfile(p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:543:19), inuseZero Object) Object {
// 	n, ok := runtime.MemProfile(p, inuseZero)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.MutexProfile has:
// func mutexProfile(p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:669:21)) Object {
// 	n, ok := runtime.MutexProfile(p)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.ReadMemStats has:
// func readMemStats(m ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/mstats.go:457:21)) Object {
// 	runtime.ReadMemStats(m)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.ReadTrace has:
// func readTrace() Object {
// 	arg_1 := runtime.ReadTrace()
// 	...ABEND676: TODO...
// }

GO FUNC runtime.SetBlockProfileRate has:
// func setBlockProfileRate(rate int) Object {
// 	runtime.SetBlockProfileRate(rate)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.SetCPUProfileRate has:
// func setCPUProfileRate(hz int) Object {
// 	runtime.SetCPUProfileRate(hz)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.SetCgoTraceback has:
// func setCgoTraceback(version int, traceback ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66), context ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66), symbolizer ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66)) Object {
// 	runtime.SetCgoTraceback(version, traceback, context, symbolizer)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.SetFinalizer has:
// func setFinalizer(obj ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:309:23), finalizer ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:309:46)) Object {
// 	runtime.SetFinalizer(obj, finalizer)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.StopTrace has:
// func stopTrace() Object {
// 	runtime.StopTrace()
// 	...ABEND676: TODO...
// }

GO FUNC runtime.ThreadCreateProfile has:
// func threadCreateProfile(p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:698:28)) Object {
// 	n, ok := runtime.ThreadCreateProfile(p)
// 	...ABEND676: TODO...
// }

GO FUNC runtime.UnlockOSThread has:
// func unlockOSThread() Object {
// 	runtime.UnlockOSThread()
// 	...ABEND676: TODO...
// }

GO FUNC runtime._ExternalCode has:
// func _ExternalCode() Object {
// 	runtime._ExternalCode()
// 	...ABEND676: TODO...
// }

GO FUNC runtime._GC has:
// func _GC() Object {
// 	runtime._GC()
// 	...ABEND676: TODO...
// }

GO FUNC runtime._LostExternalCode has:
// func _LostExternalCode() Object {
// 	runtime._LostExternalCode()
// 	...ABEND676: TODO...
// }

GO FUNC runtime._LostSIGPROFDuringAtomic64 has:
// func _LostSIGPROFDuringAtomic64() Object {
// 	runtime._LostSIGPROFDuringAtomic64()
// 	...ABEND676: TODO...
// }

GO FUNC runtime._System has:
// func _System() Object {
// 	runtime._System()
// 	...ABEND676: TODO...
// }

GO FUNC runtime._VDSO has:
// func _VDSO() Object {
// 	runtime._VDSO()
// 	...ABEND676: TODO...
// }

GO FUNC runtime._cgo_panic_internal has:
// func _cgo_panic_internal(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/cgocallback.go:11:28)) Object {
// 	runtime._cgo_panic_internal(p)
// 	...ABEND676: TODO...
// }

GO FUNC scanner.PrintError has:
// func printError(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/scanner/errors.go:116:19), err Object) Object {
// 	scanner.PrintError(w, err)
// 	...ABEND676: TODO...
// }

GO FUNC sha1.New has:
// func new() Object {
// 	arg_1 := sha1.New()
// 	...ABEND676: TODO...
// }

GO FUNC sha1.Sum has:
// func sum(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha1/sha1.go:260:15)) Object {
// 	arg_1 := sha1.Sum(data)
// 	...ABEND676: TODO...
// }

GO FUNC sha256.New has:
// func new() Object {
// 	arg_1 := sha256.New()
// 	...ABEND676: TODO...
// }

GO FUNC sha256.New224 has:
// func new224() Object {
// 	arg_1 := sha256.New224()
// 	...ABEND676: TODO...
// }

GO FUNC sha256.Sum224 has:
// func sum224(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha256/sha256.go:281:18)) Object {
// 	sum224 := sha256.Sum224(data)
// 	...ABEND676: TODO...
// }

GO FUNC sha256.Sum256 has:
// func sum256(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha256/sha256.go:273:18)) Object {
// 	arg_1 := sha256.Sum256(data)
// 	...ABEND676: TODO...
// }

GO FUNC sha512.New has:
// func new() Object {
// 	arg_1 := sha512.New()
// 	...ABEND676: TODO...
// }

GO FUNC sha512.New384 has:
// func new384() Object {
// 	arg_1 := sha512.New384()
// 	...ABEND676: TODO...
// }

GO FUNC sha512.New512_224 has:
// func new512_224() Object {
// 	arg_1 := sha512.New512_224()
// 	...ABEND676: TODO...
// }

GO FUNC sha512.New512_256 has:
// func new512_256() Object {
// 	arg_1 := sha512.New512_256()
// 	...ABEND676: TODO...
// }

GO FUNC sha512.Sum384 has:
// func sum384(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:351:18)) Object {
// 	sum384 := sha512.Sum384(data)
// 	...ABEND676: TODO...
// }

GO FUNC sha512.Sum512 has:
// func sum512(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:343:18)) Object {
// 	arg_1 := sha512.Sum512(data)
// 	...ABEND676: TODO...
// }

GO FUNC sha512.Sum512_224 has:
// func sum512_224(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:361:22)) Object {
// 	sum224 := sha512.Sum512_224(data)
// 	...ABEND676: TODO...
// }

GO FUNC sha512.Sum512_256 has:
// func sum512_256(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:371:22)) Object {
// 	sum256 := sha512.Sum512_256(data)
// 	...ABEND676: TODO...
// }

GO FUNC signal.Ignore has:
// func ignore(sig ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:85:17)) Object {
// 	signal.Ignore(sig)
// 	...ABEND676: TODO...
// }

GO FUNC signal.Notify has:
// func notify(c ABEND882(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/signal/signal.go:111:15), sig ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:111:37)) Object {
// 	signal.Notify(c, sig)
// 	...ABEND676: TODO...
// }

GO FUNC signal.Reset has:
// func reset(sig ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:155:16)) Object {
// 	signal.Reset(sig)
// 	...ABEND676: TODO...
// }

GO FUNC signal.Stop has:
// func stop(c ABEND882(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/signal/signal.go:162:13)) Object {
// 	signal.Stop(c)
// 	...ABEND676: TODO...
// }

GO FUNC smtp.CRAMMD5Auth has:
// func cRAMMD5Auth(username string, secret string) Object {
// 	arg_1 := smtp.CRAMMD5Auth(username, secret)
// 	...ABEND676: TODO...
// }

GO FUNC smtp.Dial has:
// func dial(addr string) Object {
// 	arg_1, arg_2 := smtp.Dial(addr)
// 	...ABEND676: TODO...
// }

GO FUNC smtp.NewClient has:
// func newClient(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/smtp/smtp.go:62:21), host string) Object {
// 	arg_1, arg_2 := smtp.NewClient(conn, host)
// 	...ABEND676: TODO...
// }

GO FUNC smtp.PlainAuth has:
// func plainAuth(identity string, username string, password string, host string) Object {
// 	arg_1 := smtp.PlainAuth(identity, username, password, host)
// 	...ABEND676: TODO...
// }

GO FUNC sort.Float64s has:
// func float64s(a ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:311:17)) Object {
// 	sort.Float64s(a)
// 	...ABEND676: TODO...
// }

GO FUNC sort.Ints has:
// func ints(a ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:307:13)) Object {
// 	sort.Ints(a)
// 	...ABEND676: TODO...
// }

GO FUNC sort.Reverse has:
// func reverse(data Object) Object {
// 	arg_1 := sort.Reverse(data)
// 	...ABEND676: TODO...
// }

GO FUNC sort.Slice has:
// func slice(slice ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/slice.go:17:18), less ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/slice.go:17:36)) Object {
// 	sort.Slice(slice, less)
// 	...ABEND676: TODO...
// }

GO FUNC sort.SliceStable has:
// func sliceStable(slice ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/slice.go:28:24), less ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/slice.go:28:42)) Object {
// 	sort.SliceStable(slice, less)
// 	...ABEND676: TODO...
// }

GO FUNC sort.Sort has:
// func sort(data Object) Object {
// 	sort.Sort(data)
// 	...ABEND676: TODO...
// }

GO FUNC sort.Stable has:
// func stable(data Object) Object {
// 	sort.Stable(data)
// 	...ABEND676: TODO...
// }

GO FUNC sort.Strings has:
// func strings(a ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:314:16)) Object {
// 	sort.Strings(a)
// 	...ABEND676: TODO...
// }

GO FUNC sql.Drivers has:
// func drivers() Object {
// 	arg_1 := sql.Drivers()
// 	...ABEND676: TODO...
// }

GO FUNC sql.Named has:
// func named(name string, value ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/database/sql/sql.go:110:31)) Object {
// 	arg_1 := sql.Named(name, value)
// 	...ABEND676: TODO...
// }

GO FUNC sql.Open has:
// func open(driverName string, dataSourceName string) Object {
// 	arg_1, arg_2 := sql.Open(driverName, dataSourceName)
// 	...ABEND676: TODO...
// }

GO FUNC sql.OpenDB has:
// func openDB(c ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:660:15)) Object {
// 	arg_1 := sql.OpenDB(c)
// 	...ABEND676: TODO...
// }

GO FUNC sql.Register has:
// func register(name string, driver ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:44:35)) Object {
// 	sql.Register(name, driver)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.AppendBool has:
// func appendBool(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/atob.go:30:21), b Object) Object {
// 	arg_1 := strconv.AppendBool(dst, b)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.AppendFloat has:
// func appendFloat(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/ftoa.go:51:22), f Object, fmt Object, prec int, bitSize int) Object {
// 	arg_1 := strconv.AppendFloat(dst, f, fmt, prec, bitSize)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.AppendInt has:
// func appendInt(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/itoa.go:40:20), i Object, base int) Object {
// 	arg_1 := strconv.AppendInt(dst, i, base)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.AppendQuote has:
// func appendQuote(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:117:22), s string) Object {
// 	arg_1 := strconv.AppendQuote(dst, s)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.AppendQuoteRune has:
// func appendQuoteRune(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:156:26), r Object) Object {
// 	arg_1 := strconv.AppendQuoteRune(dst, r)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.AppendQuoteRuneToASCII has:
// func appendQuoteRuneToASCII(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:170:33), r Object) Object {
// 	arg_1 := strconv.AppendQuoteRuneToASCII(dst, r)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.AppendQuoteRuneToGraphic has:
// func appendQuoteRuneToGraphic(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:184:35), r Object) Object {
// 	arg_1 := strconv.AppendQuoteRuneToGraphic(dst, r)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.AppendQuoteToASCII has:
// func appendQuoteToASCII(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:130:29), s string) Object {
// 	arg_1 := strconv.AppendQuoteToASCII(dst, s)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.AppendQuoteToGraphic has:
// func appendQuoteToGraphic(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:143:31), s string) Object {
// 	arg_1 := strconv.AppendQuoteToGraphic(dst, s)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.AppendUint has:
// func appendUint(dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/itoa.go:50:21), i Object, base int) Object {
// 	arg_1 := strconv.AppendUint(dst, i, base)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.Atoi has:
// func atoi(s string) Object {
// 	arg_1, arg_2 := strconv.Atoi(s)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.ParseBool has:
// func parseBool(str string) Object {
// 	arg_1, arg_2 := strconv.ParseBool(str)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.ParseFloat has:
// func parseFloat(s string, bitSize int) Object {
// 	arg_1, arg_2 := strconv.ParseFloat(s, bitSize)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.ParseInt has:
// func parseInt(s string, base int, bitSize int) Object {
// 	i, err := strconv.ParseInt(s, base, bitSize)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.ParseUint has:
// func parseUint(s string, base int, bitSize int) Object {
// 	arg_1, arg_2 := strconv.ParseUint(s, base, bitSize)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.Unquote has:
// func unquote(s string) Object {
// 	arg_1, arg_2 := strconv.Unquote(s)
// 	...ABEND676: TODO...
// }

GO FUNC strconv.UnquoteChar has:
// func unquoteChar(s string, quote Object) Object {
// 	value, multibyte, tail, err := strconv.UnquoteChar(s, quote)
// 	...ABEND676: TODO...
// }

GO FUNC strings.Fields has:
// func fields(s string) Object {
// 	arg_1 := strings.Fields(s)
// 	...ABEND676: TODO...
// }

GO FUNC strings.FieldsFunc has:
// func fieldsFunc(s string, f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:378:29)) Object {
// 	arg_1 := strings.FieldsFunc(s, f)
// 	...ABEND676: TODO...
// }

GO FUNC strings.NewReader has:
// func newReader(s string) Object {
// 	arg_1 := strings.NewReader(s)
// 	...ABEND676: TODO...
// }

GO FUNC strings.NewReplacer has:
// func newReplacer(oldnew ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/strings/replace.go:24:25)) Object {
// 	arg_1 := strings.NewReplacer(oldnew)
// 	...ABEND676: TODO...
// }

GO FUNC strings.Split has:
// func split(s string, sep string) Object {
// 	arg_1 := strings.Split(s, sep)
// 	...ABEND676: TODO...
// }

GO FUNC strings.SplitAfter has:
// func splitAfter(s string, sep string) Object {
// 	arg_1 := strings.SplitAfter(s, sep)
// 	...ABEND676: TODO...
// }

GO FUNC strings.SplitAfterN has:
// func splitAfterN(s string, sep string, n int) Object {
// 	arg_1 := strings.SplitAfterN(s, sep, n)
// 	...ABEND676: TODO...
// }

GO FUNC strings.SplitN has:
// func splitN(s string, sep string, n int) Object {
// 	arg_1 := strings.SplitN(s, sep, n)
// 	...ABEND676: TODO...
// }

GO FUNC subtle.ConstantTimeCopy has:
// func constantTimeCopy(v int, x ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:43:35), y ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:43:35)) Object {
// 	subtle.ConstantTimeCopy(v, x, y)
// 	...ABEND676: TODO...
// }

GO FUNC suffixarray.New has:
// func new(data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/index/suffixarray/suffixarray.go:35:15)) Object {
// 	arg_1 := suffixarray.New(data)
// 	...ABEND676: TODO...
// }

GO FUNC sync.NewCond has:
// func newCond(l Object) Object {
// 	arg_1 := sync.NewCond(l)
// 	...ABEND676: TODO...
// }

GO FUNC syntax.Compile has:
// func compile(re ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/regexp/syntax/compile.go:80:17)) Object {
// 	arg_1, arg_2 := syntax.Compile(re)
// 	...ABEND676: TODO...
// }

GO FUNC syntax.EmptyOpContext has:
// func emptyOpContext(r1 Object, r2 Object) Object {
// 	arg_1 := syntax.EmptyOpContext(r1, r2)
// 	...ABEND676: TODO...
// }

GO FUNC syntax.Parse has:
// func parse(s string, flags Object) Object {
// 	arg_1, arg_2 := syntax.Parse(s, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Accept has:
// func accept(fd int) Object {
// 	nfd, sa, err := syscall.Accept(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Access has:
// func access(path string, mode Object) Object {
// 	err := syscall.Access(path, mode)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Adjtime has:
// func adjtime(delta ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:311:20), olddelta ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:311:39)) Object {
// 	err := syscall.Adjtime(delta, olddelta)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Bind has:
// func bind(fd int, sa Object) Object {
// 	err := syscall.Bind(fd, sa)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.BpfBuflen has:
// func bpfBuflen(fd int) Object {
// 	arg_1, arg_2 := syscall.BpfBuflen(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.BpfDatalink has:
// func bpfDatalink(fd int) Object {
// 	arg_1, arg_2 := syscall.BpfDatalink(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.BpfHeadercmpl has:
// func bpfHeadercmpl(fd int) Object {
// 	arg_1, arg_2 := syscall.BpfHeadercmpl(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.BpfInterface has:
// func bpfInterface(fd int, name string) Object {
// 	arg_1, arg_2 := syscall.BpfInterface(fd, name)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.BpfJump has:
// func bpfJump(code int, k int, jt int, jf int) Object {
// 	arg_1 := syscall.BpfJump(code, k, jt, jf)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.BpfStats has:
// func bpfStats(fd int) Object {
// 	arg_1, arg_2 := syscall.BpfStats(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.BpfStmt has:
// func bpfStmt(code int, k int) Object {
// 	arg_1 := syscall.BpfStmt(code, k)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.BpfTimeout has:
// func bpfTimeout(fd int) Object {
// 	arg_1, arg_2 := syscall.BpfTimeout(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.BytePtrFromString has:
// func bytePtrFromString(s string) Object {
// 	arg_1, arg_2 := syscall.BytePtrFromString(s)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.ByteSliceFromString has:
// func byteSliceFromString(s string) Object {
// 	arg_1, arg_2 := syscall.ByteSliceFromString(s)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Chdir has:
// func chdir(path string) Object {
// 	err := syscall.Chdir(path)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Chflags has:
// func chflags(path string, flags int) Object {
// 	err := syscall.Chflags(path, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Chmod has:
// func chmod(path string, mode Object) Object {
// 	err := syscall.Chmod(path, mode)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Chown has:
// func chown(path string, uid int, gid int) Object {
// 	err := syscall.Chown(path, uid, gid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Chroot has:
// func chroot(path string) Object {
// 	err := syscall.Chroot(path)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Clearenv has:
// func clearenv() Object {
// 	syscall.Clearenv()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Close has:
// func close(fd int) Object {
// 	err := syscall.Close(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.CloseOnExec has:
// func closeOnExec(fd int) Object {
// 	syscall.CloseOnExec(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Connect has:
// func connect(fd int, sa Object) Object {
// 	err := syscall.Connect(fd, sa)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Dup has:
// func dup(fd int) Object {
// 	nfd, err := syscall.Dup(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Dup2 has:
// func dup2(from int, to int) Object {
// 	err := syscall.Dup2(from, to)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Environ has:
// func environ() Object {
// 	arg_1 := syscall.Environ()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Exchangedata has:
// func exchangedata(path1 string, path2 string, options int) Object {
// 	err := syscall.Exchangedata(path1, path2, options)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Exec has:
// func exec(argv0 string, argv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:254:30), envv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:254:45)) Object {
// 	err := syscall.Exec(argv0, argv, envv)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Exit has:
// func exit(code int) Object {
// 	syscall.Exit(code)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Fchdir has:
// func fchdir(fd int) Object {
// 	err := syscall.Fchdir(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Fchflags has:
// func fchflags(fd int, flags int) Object {
// 	err := syscall.Fchflags(fd, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Fchmod has:
// func fchmod(fd int, mode Object) Object {
// 	err := syscall.Fchmod(fd, mode)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Fchown has:
// func fchown(fd int, uid int, gid int) Object {
// 	err := syscall.Fchown(fd, uid, gid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Flock has:
// func flock(fd int, how int) Object {
// 	err := syscall.Flock(fd, how)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.ForkExec has:
// func forkExec(argv0 string, argv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:235:34), attr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/exec_unix.go:235:49)) Object {
// 	pid, err := syscall.ForkExec(argv0, argv, attr)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Fpathconf has:
// func fpathconf(fd int, name int) Object {
// 	val, err := syscall.Fpathconf(fd, name)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Fstat has:
// func fstat(fd int, stat ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:508:25)) Object {
// 	err := syscall.Fstat(fd, stat)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Fstatfs has:
// func fstatfs(fd int, stat ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:518:27)) Object {
// 	err := syscall.Fstatfs(fd, stat)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Fsync has:
// func fsync(fd int) Object {
// 	err := syscall.Fsync(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Ftruncate has:
// func ftruncate(fd int, length Object) Object {
// 	err := syscall.Ftruncate(fd, length)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Futimes has:
// func futimes(fd int, tv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:533:25)) Object {
// 	err := syscall.Futimes(fd, tv)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getdirentries has:
// func getdirentries(fd int, buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:548:32), basep ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:548:46)) Object {
// 	n, err := syscall.Getdirentries(fd, buf, basep)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getdtablesize has:
// func getdtablesize() Object {
// 	size := syscall.Getdtablesize()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getegid has:
// func getegid() Object {
// 	egid := syscall.Getegid()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getenv has:
// func getenv(key string) Object {
// 	value, found := syscall.Getenv(key)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Geteuid has:
// func geteuid() Object {
// 	uid := syscall.Geteuid()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getfsstat has:
// func getfsstat(buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_darwin.go:176:20), flags int) Object {
// 	n, err := syscall.Getfsstat(buf, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getgid has:
// func getgid() Object {
// 	gid := syscall.Getgid()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getgroups has:
// func getgroups() Object {
// 	gids, err := syscall.Getgroups()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getpeername has:
// func getpeername(fd int) Object {
// 	sa, err := syscall.Getpeername(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getpgid has:
// func getpgid(pid int) Object {
// 	pgid, err := syscall.Getpgid(pid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getpgrp has:
// func getpgrp() Object {
// 	pgrp := syscall.Getpgrp()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getpid has:
// func getpid() Object {
// 	pid := syscall.Getpid()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getppid has:
// func getppid() Object {
// 	ppid := syscall.Getppid()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getpriority has:
// func getpriority(which int, who int) Object {
// 	prio, err := syscall.Getpriority(which, who)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getrlimit has:
// func getrlimit(which int, lim ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:643:31)) Object {
// 	err := syscall.Getrlimit(which, lim)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getrusage has:
// func getrusage(who int, rusage ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:653:32)) Object {
// 	err := syscall.Getrusage(who, rusage)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getsid has:
// func getsid(pid int) Object {
// 	sid, err := syscall.Getsid(pid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getsockname has:
// func getsockname(fd int) Object {
// 	sa, err := syscall.Getsockname(fd)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.GetsockoptByte has:
// func getsockoptByte(fd int, level int, opt int) Object {
// 	value, err := syscall.GetsockoptByte(fd, level, opt)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.GetsockoptICMPv6Filter has:
// func getsockoptICMPv6Filter(fd int, level int, opt int) Object {
// 	arg_1, arg_2 := syscall.GetsockoptICMPv6Filter(fd, level, opt)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.GetsockoptIPMreq has:
// func getsockoptIPMreq(fd int, level int, opt int) Object {
// 	arg_1, arg_2 := syscall.GetsockoptIPMreq(fd, level, opt)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.GetsockoptIPv6MTUInfo has:
// func getsockoptIPv6MTUInfo(fd int, level int, opt int) Object {
// 	arg_1, arg_2 := syscall.GetsockoptIPv6MTUInfo(fd, level, opt)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.GetsockoptIPv6Mreq has:
// func getsockoptIPv6Mreq(fd int, level int, opt int) Object {
// 	arg_1, arg_2 := syscall.GetsockoptIPv6Mreq(fd, level, opt)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.GetsockoptInet4Addr has:
// func getsockoptInet4Addr(fd int, level int, opt int) Object {
// 	value, err := syscall.GetsockoptInet4Addr(fd, level, opt)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.GetsockoptInt has:
// func getsockoptInt(fd int, level int, opt int) Object {
// 	value, err := syscall.GetsockoptInt(fd, level, opt)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getuid has:
// func getuid() Object {
// 	uid := syscall.Getuid()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Getwd has:
// func getwd() Object {
// 	arg_1, arg_2 := syscall.Getwd()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Issetugid has:
// func issetugid() Object {
// 	tainted := syscall.Issetugid()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Kevent has:
// func kevent(kq int, changes ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:439:37), events ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:439:37), timeout ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_bsd.go:439:57)) Object {
// 	n, err := syscall.Kevent(kq, changes, events, timeout)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Kill has:
// func kill(pid int, signum Object) Object {
// 	err := syscall.Kill(pid, signum)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Kqueue has:
// func kqueue() Object {
// 	fd, err := syscall.Kqueue()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Lchown has:
// func lchown(path string, uid int, gid int) Object {
// 	err := syscall.Lchown(path, uid, gid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Link has:
// func link(path string, link string) Object {
// 	err := syscall.Link(path, link)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Listen has:
// func listen(s int, backlog int) Object {
// 	err := syscall.Listen(s, backlog)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Lstat has:
// func lstat(path string, stat ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:746:30)) Object {
// 	err := syscall.Lstat(path, stat)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Mkdir has:
// func mkdir(path string, mode Object) Object {
// 	err := syscall.Mkdir(path, mode)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Mkfifo has:
// func mkfifo(path string, mode Object) Object {
// 	err := syscall.Mkfifo(path, mode)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Mknod has:
// func mknod(path string, mode Object, dev int) Object {
// 	err := syscall.Mknod(path, mode, dev)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Mlock has:
// func mlock(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:806:14)) Object {
// 	err := syscall.Mlock(b)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Mlockall has:
// func mlockall(flags int) Object {
// 	err := syscall.Mlockall(flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Mmap has:
// func mmap(fd int, offset Object, length int, prot int, flags int) Object {
// 	data, err := syscall.Mmap(fd, offset, length, prot, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Mprotect has:
// func mprotect(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:832:17), prot int) Object {
// 	err := syscall.Mprotect(b, prot)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Munlock has:
// func munlock(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:848:16)) Object {
// 	err := syscall.Munlock(b)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Munlockall has:
// func munlockall() Object {
// 	err := syscall.Munlockall()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Munmap has:
// func munmap(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:552:15)) Object {
// 	err := syscall.Munmap(b)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.NsecToTimespec has:
// func nsecToTimespec(nsec Object) Object {
// 	arg_1 := syscall.NsecToTimespec(nsec)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.NsecToTimeval has:
// func nsecToTimeval(nsec Object) Object {
// 	arg_1 := syscall.NsecToTimeval(nsec)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Open has:
// func open(path string, mode int, perm Object) Object {
// 	fd, err := syscall.Open(path, mode, perm)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.ParseDirent has:
// func parseDirent(buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/dirent.go:64:22), max int, names ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/dirent.go:64:45)) Object {
// 	consumed, count, newnames := syscall.ParseDirent(buf, max, names)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.ParseRoutingMessage has:
// func parseRoutingMessage(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/route_bsd.go:331:28)) Object {
// 	msgs, err := syscall.ParseRoutingMessage(b)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.ParseRoutingSockaddr has:
// func parseRoutingSockaddr(msg Object) Object {
// 	arg_1, arg_2 := syscall.ParseRoutingSockaddr(msg)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.ParseSocketControlMessage has:
// func parseSocketControlMessage(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/sockcmsg_unix.go:49:34)) Object {
// 	arg_1, arg_2 := syscall.ParseSocketControlMessage(b)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.ParseUnixRights has:
// func parseUnixRights(m ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/sockcmsg_unix.go:91:24)) Object {
// 	arg_1, arg_2 := syscall.ParseUnixRights(m)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Pathconf has:
// func pathconf(path string, name int) Object {
// 	val, err := syscall.Pathconf(path, name)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Pipe has:
// func pipe(p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_darwin.go:168:13)) Object {
// 	err := syscall.Pipe(p)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Pread has:
// func pread(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:906:22), offset Object) Object {
// 	n, err := syscall.Pread(fd, p, offset)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.PtraceAttach has:
// func ptraceAttach(pid int) Object {
// 	err := syscall.PtraceAttach(pid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.PtraceDetach has:
// func ptraceDetach(pid int) Object {
// 	err := syscall.PtraceDetach(pid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Pwrite has:
// func pwrite(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:923:23), offset Object) Object {
// 	n, err := syscall.Pwrite(fd, p, offset)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.RawSyscall has:
// func rawSyscall(trap Object, a1 Object, a2 Object, a3 Object) Object {
// 	r1, r2, err := syscall.RawSyscall(trap, a1, a2, a3)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.RawSyscall6 has:
// func rawSyscall6(trap Object, a1 Object, a2 Object, a3 Object, a4 Object, a5 Object, a6 Object) Object {
// 	r1, r2, err := syscall.RawSyscall6(trap, a1, a2, a3, a4, a5, a6)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Read has:
// func read(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:171:21)) Object {
// 	n, err := syscall.Read(fd, p)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.ReadDirent has:
// func readDirent(fd int, buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:65:29)) Object {
// 	n, err := syscall.ReadDirent(fd, buf)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Readlink has:
// func readlink(path string, buf ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:957:32)) Object {
// 	n, err := syscall.Readlink(path, buf)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Recvfrom has:
// func recvfrom(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:259:25), flags int) Object {
// 	n, from, err := syscall.Recvfrom(fd, p, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Recvmsg has:
// func recvmsg(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:358:29), oob ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:358:29), flags int) Object {
// 	n, oobn, recvflags, from, err := syscall.Recvmsg(fd, p, oob, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Rename has:
// func rename(from string, to string) Object {
// 	err := syscall.Rename(from, to)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Revoke has:
// func revoke(path string) Object {
// 	err := syscall.Revoke(path)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Rmdir has:
// func rmdir(path string) Object {
// 	err := syscall.Rmdir(path)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.RouteRIB has:
// func routeRIB(facility int, param int) Object {
// 	arg_1, arg_2 := syscall.RouteRIB(facility, param)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Seek has:
// func seek(fd int, offset Object, whence int) Object {
// 	newoffset, err := syscall.Seek(fd, offset, whence)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Select has:
// func select(n int, r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:22), w ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:32), e ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:42), timeout ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:58)) Object {
// 	err := syscall.Select(n, r, w, e, timeout)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Sendfile has:
// func sendfile(outfd int, infd int, offset ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:334:43), count int) Object {
// 	written, err := syscall.Sendfile(outfd, infd, offset, count)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Sendmsg has:
// func sendmsg(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:394:29), oob ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:394:29), to Object, flags int) Object {
// 	err := syscall.Sendmsg(fd, p, oob, to, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SendmsgN has:
// func sendmsgN(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:399:30), oob ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:399:30), to Object, flags int) Object {
// 	n, err := syscall.SendmsgN(fd, p, oob, to, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Sendto has:
// func sendto(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:271:23), flags int, to Object) Object {
// 	err := syscall.Sendto(fd, p, flags, to)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetBpfBuflen has:
// func setBpfBuflen(fd int, l int) Object {
// 	arg_1, arg_2 := syscall.SetBpfBuflen(fd, l)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetBpfDatalink has:
// func setBpfDatalink(fd int, t int) Object {
// 	arg_1, arg_2 := syscall.SetBpfDatalink(fd, t)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetKevent has:
// func setKevent(k ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_darwin_amd64.go:35:18), fd int, mode int, flags int) Object {
// 	syscall.SetKevent(k, fd, mode, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetNonblock has:
// func setNonblock(fd int, nonblocking Object) Object {
// 	err := syscall.SetNonblock(fd, nonblocking)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setegid has:
// func setegid(egid int) Object {
// 	err := syscall.Setegid(egid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Seteuid has:
// func seteuid(euid int) Object {
// 	err := syscall.Seteuid(euid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setgid has:
// func setgid(gid int) Object {
// 	err := syscall.Setgid(gid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setgroups has:
// func setgroups(gids ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:53:21)) Object {
// 	err := syscall.Setgroups(gids)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setlogin has:
// func setlogin(name string) Object {
// 	err := syscall.Setlogin(name)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setpgid has:
// func setpgid(pid int, pgid int) Object {
// 	err := syscall.Setpgid(pid, pgid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setpriority has:
// func setpriority(which int, who int, prio int) Object {
// 	err := syscall.Setpriority(which, who, prio)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setprivexec has:
// func setprivexec(flag int) Object {
// 	err := syscall.Setprivexec(flag)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setregid has:
// func setregid(rgid int, egid int) Object {
// 	err := syscall.Setregid(rgid, egid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setreuid has:
// func setreuid(ruid int, euid int) Object {
// 	err := syscall.Setreuid(ruid, euid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setrlimit has:
// func setrlimit(which int, lim ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1145:31)) Object {
// 	err := syscall.Setrlimit(which, lim)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setsid has:
// func setsid() Object {
// 	pid, err := syscall.Setsid()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetsockoptByte has:
// func setsockoptByte(fd int, level int, opt int, value Object) Object {
// 	err := syscall.SetsockoptByte(fd, level, opt, value)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetsockoptIPMreq has:
// func setsockoptIPMreq(fd int, level int, opt int, mreq ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:292:48)) Object {
// 	err := syscall.SetsockoptIPMreq(fd, level, opt, mreq)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetsockoptIPv6Mreq has:
// func setsockoptIPv6Mreq(fd int, level int, opt int, mreq ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:296:50)) Object {
// 	err := syscall.SetsockoptIPv6Mreq(fd, level, opt, mreq)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetsockoptInet4Addr has:
// func setsockoptInet4Addr(fd int, level int, opt int, value ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:288:52)) Object {
// 	err := syscall.SetsockoptInet4Addr(fd, level, opt, value)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetsockoptInt has:
// func setsockoptInt(fd int, level int, opt int, value int) Object {
// 	err := syscall.SetsockoptInt(fd, level, opt, value)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetsockoptLinger has:
// func setsockoptLinger(fd int, level int, opt int, l ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:304:45)) Object {
// 	err := syscall.SetsockoptLinger(fd, level, opt, l)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetsockoptString has:
// func setsockoptString(fd int, level int, opt int, s string) Object {
// 	err := syscall.SetsockoptString(fd, level, opt, s)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SetsockoptTimeval has:
// func setsockoptTimeval(fd int, level int, opt int, tv ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:312:47)) Object {
// 	err := syscall.SetsockoptTimeval(fd, level, opt, tv)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Settimeofday has:
// func settimeofday(tp ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1166:22)) Object {
// 	err := syscall.Settimeofday(tp)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Setuid has:
// func setuid(uid int) Object {
// 	err := syscall.Setuid(uid)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Shutdown has:
// func shutdown(s int, how int) Object {
// 	err := syscall.Shutdown(s, how)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SlicePtrFromStrings has:
// func slicePtrFromStrings(ss ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:83:29)) Object {
// 	arg_1, arg_2 := syscall.SlicePtrFromStrings(ss)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Socket has:
// func socket(domain int, typ int, proto int) Object {
// 	fd, err := syscall.Socket(domain, typ, proto)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Socketpair has:
// func socketpair(domain int, typ int, proto int) Object {
// 	fd, err := syscall.Socketpair(domain, typ, proto)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.StartProcess has:
// func startProcess(argv0 string, argv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:240:38), attr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/exec_unix.go:240:53)) Object {
// 	pid, handle, err := syscall.StartProcess(argv0, argv, attr)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Stat has:
// func stat(path string, stat ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1186:29)) Object {
// 	err := syscall.Stat(path, stat)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Statfs has:
// func statfs(path string, stat ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1201:31)) Object {
// 	err := syscall.Statfs(path, stat)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.StringByteSlice has:
// func stringByteSlice(s string) Object {
// 	arg_1 := syscall.StringByteSlice(s)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.StringSlicePtr has:
// func stringSlicePtr(ss ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:71:24)) Object {
// 	arg_1 := syscall.StringSlicePtr(ss)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Symlink has:
// func symlink(path string, link string) Object {
// 	err := syscall.Symlink(path, link)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Sync has:
// func sync() Object {
// 	err := syscall.Sync()
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Syscall has:
// func syscall(trap Object, a1 Object, a2 Object, a3 Object) Object {
// 	r1, r2, err := syscall.Syscall(trap, a1, a2, a3)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Syscall6 has:
// func syscall6(trap Object, a1 Object, a2 Object, a3 Object, a4 Object, a5 Object, a6 Object) Object {
// 	r1, r2, err := syscall.Syscall6(trap, a1, a2, a3, a4, a5, a6)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Syscall9 has:
// func syscall9(trap Object, a1 Object, a2 Object, a3 Object, a4 Object, a5 Object, a6 Object, a7 Object, a8 Object, a9 Object) Object {
// 	r1, r2, err := syscall.Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Sysctl has:
// func sysctl(name string) Object {
// 	value, err := syscall.Sysctl(name)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.SysctlUint32 has:
// func sysctlUint32(name string) Object {
// 	value, err := syscall.SysctlUint32(name)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Truncate has:
// func truncate(path string, length Object) Object {
// 	err := syscall.Truncate(path, length)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Umask has:
// func umask(newmask int) Object {
// 	oldmask := syscall.Umask(newmask)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Undelete has:
// func undelete(path string) Object {
// 	err := syscall.Undelete(path)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.UnixRights has:
// func unixRights(fds ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/syscall/sockcmsg_unix.go:74:21)) Object {
// 	arg_1 := syscall.UnixRights(fds)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Unlink has:
// func unlink(path string) Object {
// 	err := syscall.Unlink(path)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Unmount has:
// func unmount(path string, flags int) Object {
// 	err := syscall.Unmount(path, flags)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Utimes has:
// func utimes(path string, tv ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:502:29)) Object {
// 	err := syscall.Utimes(path, tv)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Wait4 has:
// func wait4(pid int, wstatus ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_bsd.go:127:29), options int, rusage ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_bsd.go:127:62)) Object {
// 	wpid, err := syscall.Wait4(pid, wstatus, options, rusage)
// 	...ABEND676: TODO...
// }

GO FUNC syscall.Write has:
// func write(fd int, p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:187:22)) Object {
// 	n, err := syscall.Write(fd, p)
// 	...ABEND676: TODO...
// }

GO FUNC syslog.Dial has:
// func dial(network string, raddr string, priority Object, tag string) Object {
// 	arg_1, arg_2 := syslog.Dial(network, raddr, priority, tag)
// 	...ABEND676: TODO...
// }

GO FUNC syslog.New has:
// func new(priority Object, tag string) Object {
// 	arg_1, arg_2 := syslog.New(priority, tag)
// 	...ABEND676: TODO...
// }

GO FUNC syslog.NewLogger has:
// func newLogger(p Object, logFlag int) Object {
// 	arg_1, arg_2 := syslog.NewLogger(p, logFlag)
// 	...ABEND676: TODO...
// }

GO FUNC tabwriter.NewWriter has:
// func newWriter(output ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/text/tabwriter/tabwriter.go:597:23), minwidth int, tabwidth int, padding int, padchar Object, flags Object) Object {
// 	arg_1 := tabwriter.NewWriter(output, minwidth, tabwidth, padding, padchar, flags)
// 	...ABEND676: TODO...
// }

GO FUNC tar.FileInfoHeader has:
// func fileInfoHeader(fi ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:629:24), link string) Object {
// 	arg_1, arg_2 := tar.FileInfoHeader(fi, link)
// 	...ABEND676: TODO...
// }

GO FUNC tar.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/reader.go:39:18)) Object {
// 	arg_1 := tar.NewReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC tar.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/writer.go:33:18)) Object {
// 	arg_1 := tar.NewWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC testing.AllocsPerRun has:
// func allocsPerRun(runs int, f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/allocs.go:20:31)) Object {
// 	avg := testing.AllocsPerRun(runs, f)
// 	...ABEND676: TODO...
// }

GO FUNC testing.Benchmark has:
// func benchmark(f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/benchmark.go:649:18)) Object {
// 	arg_1 := testing.Benchmark(f)
// 	...ABEND676: TODO...
// }

GO FUNC testing.Coverage has:
// func coverage() Object {
// 	arg_1 := testing.Coverage()
// 	...ABEND676: TODO...
// }

GO FUNC testing.Main has:
// func main(matchString ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/testing.go:961:23), tests ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:66), benchmarks ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:93), examples ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:123)) Object {
// 	testing.Main(matchString, tests, benchmarks, examples)
// 	...ABEND676: TODO...
// }

GO FUNC testing.MainStart has:
// func mainStart(deps Object, tests ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:995:37), benchmarks ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:995:64), examples ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:995:94)) Object {
// 	arg_1 := testing.MainStart(deps, tests, benchmarks, examples)
// 	...ABEND676: TODO...
// }

GO FUNC testing.RegisterCover has:
// func registerCover(c Object) Object {
// 	testing.RegisterCover(c)
// 	...ABEND676: TODO...
// }

GO FUNC testing.RunBenchmarks has:
// func runBenchmarks(matchString ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/benchmark.go:377:32), benchmarks ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/benchmark.go:377:80)) Object {
// 	testing.RunBenchmarks(matchString, benchmarks)
// 	...ABEND676: TODO...
// }

GO FUNC testing.RunExamples has:
// func runExamples(matchString ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/example.go:25:30), examples ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/example.go:25:76)) Object {
// 	ok := testing.RunExamples(matchString, examples)
// 	...ABEND676: TODO...
// }

GO FUNC testing.RunTests has:
// func runTests(matchString ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/testing.go:1091:27), tests ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:1091:70)) Object {
// 	ok := testing.RunTests(matchString, tests)
// 	...ABEND676: TODO...
// }

GO FUNC textproto.Dial has:
// func dial(network string, addr string) Object {
// 	arg_1, arg_2 := textproto.Dial(network, addr)
// 	...ABEND676: TODO...
// }

GO FUNC textproto.NewConn has:
// func newConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/textproto/textproto.go:66:19)) Object {
// 	arg_1 := textproto.NewConn(conn)
// 	...ABEND676: TODO...
// }

GO FUNC textproto.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/textproto/reader.go:29:18)) Object {
// 	arg_1 := textproto.NewReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC textproto.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/textproto/writer.go:21:18)) Object {
// 	arg_1 := textproto.NewWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC textproto.TrimBytes has:
// func trimBytes(b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/textproto/textproto.go:137:18)) Object {
// 	arg_1 := textproto.TrimBytes(b)
// 	...ABEND676: TODO...
// }

GO FUNC time.After has:
// func after(d Object) Object {
// 	arg_1 := time.After(d)
// 	...ABEND676: TODO...
// }

GO FUNC time.AfterFunc has:
// func afterFunc(d Object, f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/time/sleep.go:159:30)) Object {
// 	arg_1 := time.AfterFunc(d, f)
// 	...ABEND676: TODO...
// }

GO FUNC time.Date has:
// func date(year int, month Object, day int, hour int, min int, sec int, nsec int, loc ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/time.go:1326:69)) Object {
// 	arg_1 := time.Date(year, month, day, hour, min, sec, nsec, loc)
// 	...ABEND676: TODO...
// }

GO FUNC time.FixedZone has:
// func fixedZone(name string, offset int) Object {
// 	arg_1 := time.FixedZone(name, offset)
// 	...ABEND676: TODO...
// }

GO FUNC time.LoadLocation has:
// func loadLocation(name string) Object {
// 	arg_1, arg_2 := time.LoadLocation(name)
// 	...ABEND676: TODO...
// }

GO FUNC time.LoadLocationFromTZData has:
// func loadLocationFromTZData(name string, data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/time/zoneinfo_read.go:86:47)) Object {
// 	arg_1, arg_2 := time.LoadLocationFromTZData(name, data)
// 	...ABEND676: TODO...
// }

GO FUNC time.NewTicker has:
// func newTicker(d Object) Object {
// 	arg_1 := time.NewTicker(d)
// 	...ABEND676: TODO...
// }

GO FUNC time.NewTimer has:
// func newTimer(d Object) Object {
// 	arg_1 := time.NewTimer(d)
// 	...ABEND676: TODO...
// }

GO FUNC time.Now has:
// func now() Object {
// 	arg_1 := time.Now()
// 	...ABEND676: TODO...
// }

GO FUNC time.Parse has:
// func parse(layout string, value string) Object {
// 	arg_1, arg_2 := time.Parse(layout, value)
// 	...ABEND676: TODO...
// }

GO FUNC time.ParseDuration has:
// func parseDuration(s string) Object {
// 	arg_1, arg_2 := time.ParseDuration(s)
// 	...ABEND676: TODO...
// }

GO FUNC time.ParseInLocation has:
// func parseInLocation(layout string, value string, loc ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/format.go:782:48)) Object {
// 	arg_1, arg_2 := time.ParseInLocation(layout, value, loc)
// 	...ABEND676: TODO...
// }

GO FUNC time.Sleep has:
// func sleep(d Object) Object {
// 	time.Sleep(d)
// 	...ABEND676: TODO...
// }

GO FUNC time.Tick has:
// func tick(d Object) Object {
// 	arg_1 := time.Tick(d)
// 	...ABEND676: TODO...
// }

GO FUNC time.Unix has:
// func unix(sec Object, nsec Object) Object {
// 	arg_1 := time.Unix(sec, nsec)
// 	...ABEND676: TODO...
// }

GO FUNC tls.Client has:
// func client(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:39:18), config ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:39:35)) Object {
// 	arg_1 := tls.Client(conn, config)
// 	...ABEND676: TODO...
// }

GO FUNC tls.Dial has:
// func dial(network string, addr string, config ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:169:40)) Object {
// 	arg_1, arg_2 := tls.Dial(network, addr, config)
// 	...ABEND676: TODO...
// }

GO FUNC tls.DialWithDialer has:
// func dialWithDialer(dialer ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:98:28), network string, addr string, config ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:98:70)) Object {
// 	arg_1, arg_2 := tls.DialWithDialer(dialer, network, addr, config)
// 	...ABEND676: TODO...
// }

GO FUNC tls.Listen has:
// func listen(network string, laddr string, config ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:74:43)) Object {
// 	arg_1, arg_2 := tls.Listen(network, laddr, config)
// 	...ABEND676: TODO...
// }

GO FUNC tls.LoadX509KeyPair has:
// func loadX509KeyPair(certFile string, keyFile string) Object {
// 	arg_1, arg_2 := tls.LoadX509KeyPair(certFile, keyFile)
// 	...ABEND676: TODO...
// }

GO FUNC tls.NewLRUClientSessionCache has:
// func newLRUClientSessionCache(capacity int) Object {
// 	arg_1 := tls.NewLRUClientSessionCache(capacity)
// 	...ABEND676: TODO...
// }

GO FUNC tls.NewListener has:
// func newListener(inner ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:63:24), config ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:63:45)) Object {
// 	arg_1 := tls.NewListener(inner, config)
// 	...ABEND676: TODO...
// }

GO FUNC tls.Server has:
// func server(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:31:18), config ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:31:35)) Object {
// 	arg_1 := tls.Server(conn, config)
// 	...ABEND676: TODO...
// }

GO FUNC tls.X509KeyPair has:
// func x509KeyPair(certPEMBlock ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/tls.go:193:44), keyPEMBlock ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/tls.go:193:44)) Object {
// 	arg_1, arg_2 := tls.X509KeyPair(certPEMBlock, keyPEMBlock)
// 	...ABEND676: TODO...
// }

GO FUNC token.NewFileSet has:
// func newFileSet() Object {
// 	arg_1 := token.NewFileSet()
// 	...ABEND676: TODO...
// }

GO FUNC trace.Log has:
// func log(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:91:14), category string, message string) Object {
// 	trace.Log(ctx, category, message)
// 	...ABEND676: TODO...
// }

GO FUNC trace.Logf has:
// func logf(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:97:15), category string, format string, args ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/runtime/trace/annotation.go:97:62)) Object {
// 	trace.Logf(ctx, category, format, args)
// 	...ABEND676: TODO...
// }

GO FUNC trace.NewTask has:
// func newTask(pctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:34:19), taskType string) Object {
// 	ctx, task := trace.NewTask(pctx, taskType)
// 	...ABEND676: TODO...
// }

GO FUNC trace.StartRegion has:
// func startRegion(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:149:22), regionType string) Object {
// 	arg_1 := trace.StartRegion(ctx, regionType)
// 	...ABEND676: TODO...
// }

GO FUNC trace.Stop has:
// func stop() Object {
// 	trace.Stop()
// 	...ABEND676: TODO...
// }

GO FUNC trace.WithRegion has:
// func withRegion(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:118:21), regionType string, fn ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/trace/annotation.go:118:60)) Object {
// 	trace.WithRegion(ctx, regionType, fn)
// 	...ABEND676: TODO...
// }

GO FUNC transform.Append has:
// func append(t Object, dst ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:681:37), src ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:681:37)) Object {
// 	result, n, err := transform.Append(t, dst, src)
// 	...ABEND676: TODO...
// }

GO FUNC transform.Bytes has:
// func bytes(t Object, b ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:675:29)) Object {
// 	result, n, err := transform.Bytes(t, b)
// 	...ABEND676: TODO...
// }

GO FUNC transform.Chain has:
// func chain(t ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:380:14)) Object {
// 	arg_1 := transform.Chain(t)
// 	...ABEND676: TODO...
// }

GO FUNC transform.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:136:18), t Object) Object {
// 	arg_1 := transform.NewReader(r, t)
// 	...ABEND676: TODO...
// }

GO FUNC transform.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:223:18), t Object) Object {
// 	arg_1 := transform.NewWriter(w, t)
// 	...ABEND676: TODO...
// }

GO FUNC transform.RemoveFunc has:
// func removeFunc(f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:499:19)) Object {
// 	arg_1 := transform.RemoveFunc(f)
// 	...ABEND676: TODO...
// }

GO FUNC transform.String has:
// func string(t Object, s string) Object {
// 	result, n, err := transform.String(t, s)
// 	...ABEND676: TODO...
// }

GO FUNC types.DefPredeclaredTestFuncs has:
// func defPredeclaredTestFuncs() Object {
// 	types.DefPredeclaredTestFuncs()
// 	...ABEND676: TODO...
// }

GO FUNC types.Default has:
// func default(typ Object) Object {
// 	arg_1 := types.Default(typ)
// 	...ABEND676: TODO...
// }

GO FUNC types.Eval has:
// func eval(fset ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/eval.go:34:16), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/eval.go:34:36), pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/eval.go:34:50), expr string) Object {
// 	_, err := types.Eval(fset, pkg, pos, expr)
// 	...ABEND676: TODO...
// }

GO FUNC types.LookupFieldOrMethod has:
// func lookupFieldOrMethod(T Object, addressable Object, pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/lookup.go:35:56), name string) Object {
// 	obj, index, indirect := types.LookupFieldOrMethod(T, addressable, pkg, name)
// 	...ABEND676: TODO...
// }

GO FUNC types.MissingMethod has:
// func missingMethod(V Object, T ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/lookup.go:250:30), static Object) Object {
// 	method, wrongType := types.MissingMethod(V, T, static)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewArray has:
// func newArray(elem Object, len Object) Object {
// 	arg_1 := types.NewArray(elem, len)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewChan has:
// func newChan(dir Object, elem Object) Object {
// 	arg_1 := types.NewChan(dir, elem)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewChecker has:
// func newChecker(conf ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:22), fset ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:36), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:56), info ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:71)) Object {
// 	arg_1 := types.NewChecker(conf, fset, pkg, info)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewConst has:
// func newConst(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:205:19), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:205:34), name string, typ Object, val ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:205:71)) Object {
// 	arg_1 := types.NewConst(pos, pkg, name, typ, val)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewField has:
// func newField(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:276:19), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:276:34), name string, typ Object, embedded Object) Object {
// 	arg_1 := types.NewField(pos, pkg, name, typ, embedded)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewFunc has:
// func newFunc(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:301:18), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:301:33), name string, sig ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:301:60)) Object {
// 	arg_1 := types.NewFunc(pos, pkg, name, sig)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewInterface has:
// func newInterface(methods ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:266:27), embeddeds ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:266:46)) Object {
// 	arg_1 := types.NewInterface(methods, embeddeds)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewInterfaceType has:
// func newInterfaceType(methods ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:280:31), embeddeds ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:280:50)) Object {
// 	arg_1 := types.NewInterfaceType(methods, embeddeds)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewLabel has:
// func newLabel(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:331:19), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:331:34), name string) Object {
// 	arg_1 := types.NewLabel(pos, pkg, name)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewMap has:
// func newMap(key Object, elem Object) Object {
// 	arg_1 := types.NewMap(key, elem)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewMethodSet has:
// func newMethodSet(T Object) Object {
// 	arg_1 := types.NewMethodSet(T)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewNamed has:
// func newNamed(obj ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:433:19), underlying Object, methods ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:433:55)) Object {
// 	arg_1 := types.NewNamed(obj, underlying, methods)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewPackage has:
// func newPackage(path string, name string) Object {
// 	arg_1 := types.NewPackage(path, name)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewParam has:
// func newParam(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:269:19), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:269:34), name string, typ Object) Object {
// 	arg_1 := types.NewParam(pos, pkg, name, typ)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewPkgName has:
// func newPkgName(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:189:21), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:189:36), name string, imported ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:189:68)) Object {
// 	arg_1 := types.NewPkgName(pos, pkg, name, imported)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewPointer has:
// func newPointer(elem Object) Object {
// 	arg_1 := types.NewPointer(elem)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewScope has:
// func newScope(parent ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/scope.go:36:22), pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:36:39), end ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:36:39), comment string) Object {
// 	arg_1 := types.NewScope(parent, pos, end, comment)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewSignature has:
// func newSignature(recv ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:213:24), params ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:213:46), results ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:213:46), variadic Object) Object {
// 	arg_1 := types.NewSignature(recv, params, results, variadic)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewSlice has:
// func newSlice(elem Object) Object {
// 	arg_1 := types.NewSlice(elem)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewStruct has:
// func newStruct(fields ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:131:23), tags ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:131:36)) Object {
// 	arg_1 := types.NewStruct(fields, tags)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewTuple has:
// func newTuple(x ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/go/types/type.go:177:17)) Object {
// 	arg_1 := types.NewTuple(x)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewTypeName has:
// func newTypeName(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:226:22), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:226:37), name string, typ Object) Object {
// 	arg_1 := types.NewTypeName(pos, pkg, name, typ)
// 	...ABEND676: TODO...
// }

GO FUNC types.NewVar has:
// func newVar(pos ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:264:17), pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:264:32), name string, typ Object) Object {
// 	arg_1 := types.NewVar(pos, pkg, name, typ)
// 	...ABEND676: TODO...
// }

GO FUNC types.RelativeTo has:
// func relativeTo(pkg ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:29:21)) Object {
// 	arg_1 := types.RelativeTo(pkg)
// 	...ABEND676: TODO...
// }

GO FUNC types.SizesFor has:
// func sizesFor(compiler string, arch string) Object {
// 	arg_1 := types.SizesFor(compiler, arch)
// 	...ABEND676: TODO...
// }

GO FUNC types.WriteExpr has:
// func writeExpr(buf ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/exprstring.go:26:20), x ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/exprstring.go:26:37)) Object {
// 	types.WriteExpr(buf, x)
// 	...ABEND676: TODO...
// }

GO FUNC types.WriteSignature has:
// func writeSignature(buf ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:285:25), sig ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:285:44), qf Object) Object {
// 	types.WriteSignature(buf, sig, qf)
// 	...ABEND676: TODO...
// }

GO FUNC types.WriteType has:
// func writeType(buf ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:74:20), typ Object, qf Object) Object {
// 	types.WriteType(buf, typ, qf)
// 	...ABEND676: TODO...
// }

GO FUNC unicode.SimpleFold has:
// func simpleFold(r Object) Object {
// 	arg_1 := unicode.SimpleFold(r)
// 	...ABEND676: TODO...
// }

GO FUNC unicode.To has:
// func to(_case int, r Object) Object {
// 	arg_1 := unicode.To(_case, r)
// 	...ABEND676: TODO...
// }

GO FUNC unicode.ToLower has:
// func toLower(r Object) Object {
// 	arg_1 := unicode.ToLower(r)
// 	...ABEND676: TODO...
// }

GO FUNC unicode.ToTitle has:
// func toTitle(r Object) Object {
// 	arg_1 := unicode.ToTitle(r)
// 	...ABEND676: TODO...
// }

GO FUNC unicode.ToUpper has:
// func toUpper(r Object) Object {
// 	arg_1 := unicode.ToUpper(r)
// 	...ABEND676: TODO...
// }

GO FUNC unsafe.Alignof has:
// func alignof(x Object) Object {
// 	arg_1 := unsafe.Alignof(x)
// 	...ABEND676: TODO...
// }

GO FUNC unsafe.Offsetof has:
// func offsetof(x Object) Object {
// 	arg_1 := unsafe.Offsetof(x)
// 	...ABEND676: TODO...
// }

GO FUNC unsafe.Sizeof has:
// func sizeof(x Object) Object {
// 	arg_1 := unsafe.Sizeof(x)
// 	...ABEND676: TODO...
// }

GO FUNC url.Parse has:
// func parse(rawurl string) Object {
// 	arg_1, arg_2 := url.Parse(rawurl)
// 	...ABEND676: TODO...
// }

GO FUNC url.ParseQuery has:
// func parseQuery(query string) Object {
// 	arg_1, arg_2 := url.ParseQuery(query)
// 	...ABEND676: TODO...
// }

GO FUNC url.ParseRequestURI has:
// func parseRequestURI(rawurl string) Object {
// 	arg_1, arg_2 := url.ParseRequestURI(rawurl)
// 	...ABEND676: TODO...
// }

GO FUNC url.PathUnescape has:
// func pathUnescape(s string) Object {
// 	arg_1, arg_2 := url.PathUnescape(s)
// 	...ABEND676: TODO...
// }

GO FUNC url.QueryUnescape has:
// func queryUnescape(s string) Object {
// 	arg_1, arg_2 := url.QueryUnescape(s)
// 	...ABEND676: TODO...
// }

GO FUNC url.User has:
// func user(username string) Object {
// 	arg_1 := url.User(username)
// 	...ABEND676: TODO...
// }

GO FUNC url.UserPassword has:
// func userPassword(username string, password string) Object {
// 	arg_1 := url.UserPassword(username, password)
// 	...ABEND676: TODO...
// }

GO FUNC user.Current has:
// func current() Object {
// 	arg_1, arg_2 := user.Current()
// 	...ABEND676: TODO...
// }

GO FUNC user.Lookup has:
// func lookup(username string) Object {
// 	arg_1, arg_2 := user.Lookup(username)
// 	...ABEND676: TODO...
// }

GO FUNC user.LookupGroup has:
// func lookupGroup(name string) Object {
// 	arg_1, arg_2 := user.LookupGroup(name)
// 	...ABEND676: TODO...
// }

GO FUNC user.LookupGroupId has:
// func lookupGroupId(gid string) Object {
// 	arg_1, arg_2 := user.LookupGroupId(gid)
// 	...ABEND676: TODO...
// }

GO FUNC user.LookupId has:
// func lookupId(uid string) Object {
// 	arg_1, arg_2 := user.LookupId(uid)
// 	...ABEND676: TODO...
// }

GO FUNC utf16.Decode has:
// func decode(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf16/utf16.go:88:15)) Object {
// 	arg_1 := utf16.Decode(s)
// 	...ABEND676: TODO...
// }

GO FUNC utf16.DecodeRune has:
// func decodeRune(r1 Object, r2 Object) Object {
// 	arg_1 := utf16.DecodeRune(r1, r2)
// 	...ABEND676: TODO...
// }

GO FUNC utf16.Encode has:
// func encode(s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf16/utf16.go:56:15)) Object {
// 	arg_1 := utf16.Encode(s)
// 	...ABEND676: TODO...
// }

GO FUNC utf16.EncodeRune has:
// func encodeRune(r Object) Object {
// 	r1, r2 := utf16.EncodeRune(r)
// 	...ABEND676: TODO...
// }

GO FUNC utf8.DecodeLastRune has:
// func decodeLastRune(p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:245:23)) Object {
// 	r, size := utf8.DecodeLastRune(p)
// 	...ABEND676: TODO...
// }

GO FUNC utf8.DecodeLastRuneInString has:
// func decodeLastRuneInString(s string) Object {
// 	r, size := utf8.DecodeLastRuneInString(s)
// 	...ABEND676: TODO...
// }

GO FUNC utf8.DecodeRune has:
// func decodeRune(p ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:149:19)) Object {
// 	r, size := utf8.DecodeRune(p)
// 	...ABEND676: TODO...
// }

GO FUNC utf8.DecodeRuneInString has:
// func decodeRuneInString(s string) Object {
// 	r, size := utf8.DecodeRuneInString(s)
// 	...ABEND676: TODO...
// }

GO FUNC utf8.RuneCountInString has:
// func runeCountInString(s string) Object {
// 	n := utf8.RuneCountInString(s)
// 	...ABEND676: TODO...
// }

GO FUNC x509.CreateCertificate has:
// func createCertificate(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2082:29), template ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:2082:57), parent ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:2082:57), pub ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2082:81), priv ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2082:81)) Object {
// 	cert, err := x509.CreateCertificate(rand, template, parent, pub, priv)
// 	...ABEND676: TODO...
// }

GO FUNC x509.CreateCertificateRequest has:
// func createCertificateRequest(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2407:36), template ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:2407:56), priv ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2407:82)) Object {
// 	csr, err := x509.CreateCertificateRequest(rand, template, priv)
// 	...ABEND676: TODO...
// }

GO FUNC x509.DecryptPEMBlock has:
// func decryptPEMBlock(b ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pem_decrypt.go:115:24), password ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pem_decrypt.go:115:45)) Object {
// 	arg_1, arg_2 := x509.DecryptPEMBlock(b, password)
// 	...ABEND676: TODO...
// }

GO FUNC x509.EncryptPEMBlock has:
// func encryptPEMBlock(rand ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/pem_decrypt.go:183:27), blockType string, data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pem_decrypt.go:183:71), password ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pem_decrypt.go:183:71), alg Object) Object {
// 	arg_1, arg_2 := x509.EncryptPEMBlock(rand, blockType, data, password, alg)
// 	...ABEND676: TODO...
// }

GO FUNC x509.MarshalECPrivateKey has:
// func marshalECPrivateKey(key ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/sec1.go:37:30)) Object {
// 	arg_1, arg_2 := x509.MarshalECPrivateKey(key)
// 	...ABEND676: TODO...
// }

GO FUNC x509.MarshalPKCS1PrivateKey has:
// func marshalPKCS1PrivateKey(key ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pkcs1.go:92:33)) Object {
// 	arg_1 := x509.MarshalPKCS1PrivateKey(key)
// 	...ABEND676: TODO...
// }

GO FUNC x509.MarshalPKCS1PublicKey has:
// func marshalPKCS1PublicKey(key ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pkcs1.go:148:32)) Object {
// 	arg_1 := x509.MarshalPKCS1PublicKey(key)
// 	...ABEND676: TODO...
// }

GO FUNC x509.MarshalPKCS8PrivateKey has:
// func marshalPKCS8PrivateKey(key ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/pkcs8.go:63:33)) Object {
// 	arg_1, arg_2 := x509.MarshalPKCS8PrivateKey(key)
// 	...ABEND676: TODO...
// }

GO FUNC x509.MarshalPKIXPublicKey has:
// func marshalPKIXPublicKey(pub ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:104:31)) Object {
// 	arg_1, arg_2 := x509.MarshalPKIXPublicKey(pub)
// 	...ABEND676: TODO...
// }

GO FUNC x509.NewCertPool has:
// func newCertPool() Object {
// 	arg_1 := x509.NewCertPool()
// 	...ABEND676: TODO...
// }

GO FUNC x509.ParseCRL has:
// func parseCRL(crlBytes ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2179:24)) Object {
// 	arg_1, arg_2 := x509.ParseCRL(crlBytes)
// 	...ABEND676: TODO...
// }

GO FUNC x509.ParseCertificate has:
// func parseCertificate(asn1Data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:1562:32)) Object {
// 	arg_1, arg_2 := x509.ParseCertificate(asn1Data)
// 	...ABEND676: TODO...
// }

GO FUNC x509.ParseCertificateRequest has:
// func parseCertificateRequest(asn1Data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2575:39)) Object {
// 	arg_1, arg_2 := x509.ParseCertificateRequest(asn1Data)
// 	...ABEND676: TODO...
// }

GO FUNC x509.ParseCertificates has:
// func parseCertificates(asn1Data ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:1577:33)) Object {
// 	arg_1, arg_2 := x509.ParseCertificates(asn1Data)
// 	...ABEND676: TODO...
// }

GO FUNC x509.ParseDERCRL has:
// func parseDERCRL(derBytes ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2190:27)) Object {
// 	arg_1, arg_2 := x509.ParseDERCRL(derBytes)
// 	...ABEND676: TODO...
// }

GO FUNC x509.ParseECPrivateKey has:
// func parseECPrivateKey(der ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/sec1.go:32:28)) Object {
// 	arg_1, arg_2 := x509.ParseECPrivateKey(der)
// 	...ABEND676: TODO...
// }

GO FUNC x509.ParsePKCS1PrivateKey has:
// func parsePKCS1PrivateKey(der ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pkcs1.go:45:31)) Object {
// 	arg_1, arg_2 := x509.ParsePKCS1PrivateKey(der)
// 	...ABEND676: TODO...
// }

GO FUNC x509.ParsePKCS1PublicKey has:
// func parsePKCS1PublicKey(der ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pkcs1.go:124:30)) Object {
// 	arg_1, arg_2 := x509.ParsePKCS1PublicKey(der)
// 	...ABEND676: TODO...
// }

GO FUNC x509.ParsePKCS8PrivateKey has:
// func parsePKCS8PrivateKey(der ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pkcs8.go:28:31)) Object {
// 	key, err := x509.ParsePKCS8PrivateKey(der)
// 	...ABEND676: TODO...
// }

GO FUNC x509.ParsePKIXPublicKey has:
// func parsePKIXPublicKey(derBytes ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:55:34)) Object {
// 	pub, err := x509.ParsePKIXPublicKey(derBytes)
// 	...ABEND676: TODO...
// }

GO FUNC x509.SystemCertPool has:
// func systemCertPool() Object {
// 	arg_1, arg_2 := x509.SystemCertPool()
// 	...ABEND676: TODO...
// }

GO FUNC xml.CopyToken has:
// func copyToken(t Object) Object {
// 	arg_1 := xml.CopyToken(t)
// 	...ABEND676: TODO...
// }

GO FUNC xml.Escape has:
// func escape(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:1985:15), s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/xml/xml.go:1985:28)) Object {
// 	xml.Escape(w, s)
// 	...ABEND676: TODO...
// }

GO FUNC xml.Marshal has:
// func marshal(v ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/marshal.go:75:16)) Object {
// 	arg_1, arg_2 := xml.Marshal(v)
// 	...ABEND676: TODO...
// }

GO FUNC xml.MarshalIndent has:
// func marshalIndent(v ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/marshal.go:121:22), prefix string, indent string) Object {
// 	arg_1, arg_2 := xml.MarshalIndent(v, prefix, indent)
// 	...ABEND676: TODO...
// }

GO FUNC xml.NewDecoder has:
// func newDecoder(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:229:19)) Object {
// 	arg_1 := xml.NewDecoder(r)
// 	...ABEND676: TODO...
// }

GO FUNC xml.NewEncoder has:
// func newEncoder(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/marshal.go:137:19)) Object {
// 	arg_1 := xml.NewEncoder(w)
// 	...ABEND676: TODO...
// }

GO FUNC xml.NewTokenDecoder has:
// func newTokenDecoder(t Object) Object {
// 	arg_1 := xml.NewTokenDecoder(t)
// 	...ABEND676: TODO...
// }

GO FUNC zip.FileInfoHeader has:
// func fileInfoHeader(fi ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/struct.go:169:24)) Object {
// 	arg_1, arg_2 := zip.FileInfoHeader(fi)
// 	...ABEND676: TODO...
// }

GO FUNC zip.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/reader.go:71:18), size Object) Object {
// 	arg_1, arg_2 := zip.NewReader(r, size)
// 	...ABEND676: TODO...
// }

GO FUNC zip.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/writer.go:43:18)) Object {
// 	arg_1 := zip.NewWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC zip.OpenReader has:
// func openReader(name string) Object {
// 	arg_1, arg_2 := zip.OpenReader(name)
// 	...ABEND676: TODO...
// }

GO FUNC zip.RegisterCompressor has:
// func registerCompressor(method Object, comp Object) Object {
// 	zip.RegisterCompressor(method, comp)
// 	...ABEND676: TODO...
// }

GO FUNC zip.RegisterDecompressor has:
// func registerDecompressor(method Object, dcomp Object) Object {
// 	zip.RegisterDecompressor(method, dcomp)
// 	...ABEND676: TODO...
// }

GO FUNC zlib.NewReader has:
// func newReader(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/reader.go:70:18)) Object {
// 	arg_1, arg_2 := zlib.NewReader(r)
// 	...ABEND676: TODO...
// }

GO FUNC zlib.NewReaderDict has:
// func newReaderDict(r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/reader.go:79:22), dict ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/reader.go:79:38)) Object {
// 	arg_1, arg_2 := zlib.NewReaderDict(r, dict)
// 	...ABEND676: TODO...
// }

GO FUNC zlib.NewWriter has:
// func newWriter(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:43:18)) Object {
// 	arg_1 := zlib.NewWriter(w)
// 	...ABEND676: TODO...
// }

GO FUNC zlib.NewWriterLevel has:
// func newWriterLevel(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:54:23), level int) Object {
// 	arg_1, arg_2 := zlib.NewWriterLevel(w, level)
// 	...ABEND676: TODO...
// }

GO FUNC zlib.NewWriterLevelDict has:
// func newWriterLevelDict(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:63:27), level int, dict ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/writer.go:63:54)) Object {
// 	arg_1, arg_2 := zlib.NewWriterLevelDict(w, level, dict)
// 	...ABEND676: TODO...
// }

Totals: types=1034 functions=1523 receivers=6082
