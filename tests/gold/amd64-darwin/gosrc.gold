Walking from ../GOSRC to ../GOSRC/archive
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/archive/tar
Processing sourceDir=../GOSRC dump=false:
Package tar:
Processing package=tar:
Excluding ../GOSRC/archive/tar/testdata
Walking from ../GOSRC to ../GOSRC/archive/zip
Processing sourceDir=../GOSRC dump=false:
Package zip:
Processing package=zip:
Excluding ../GOSRC/archive/zip/testdata
Walking from ../GOSRC to ../GOSRC/bufio
Processing sourceDir=../GOSRC dump=false:
Package bufio:
Processing package=bufio:
Excluding ../GOSRC/builtin
Walking from ../GOSRC to ../GOSRC/bytes
Processing sourceDir=../GOSRC dump=false:
Package bytes:
Processing package=bytes:
Excluding ../GOSRC/cmd
Walking from ../GOSRC to ../GOSRC/compress
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/compress/bzip2
Processing sourceDir=../GOSRC dump=false:
Package bzip2:
Processing package=bzip2:
Excluding ../GOSRC/compress/bzip2/testdata
Walking from ../GOSRC to ../GOSRC/compress/flate
Processing sourceDir=../GOSRC dump=false:
Package flate:
Processing package=flate:
Excluding ../GOSRC/compress/flate/testdata
Walking from ../GOSRC to ../GOSRC/compress/gzip
Processing sourceDir=../GOSRC dump=false:
Package gzip:
Processing package=gzip:
Excluding ../GOSRC/compress/gzip/testdata
Walking from ../GOSRC to ../GOSRC/compress/lzw
Processing sourceDir=../GOSRC dump=false:
Package lzw:
Processing package=lzw:
Excluding ../GOSRC/compress/testdata
Walking from ../GOSRC to ../GOSRC/compress/zlib
Processing sourceDir=../GOSRC dump=false:
Package zlib:
Processing package=zlib:
Walking from ../GOSRC to ../GOSRC/container
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/container/heap
Processing sourceDir=../GOSRC dump=false:
Package heap:
Processing package=heap:
Walking from ../GOSRC to ../GOSRC/container/list
Processing sourceDir=../GOSRC dump=false:
Package list:
Processing package=list:
Walking from ../GOSRC to ../GOSRC/container/ring
Processing sourceDir=../GOSRC dump=false:
Package ring:
Processing package=ring:
Walking from ../GOSRC to ../GOSRC/context
Processing sourceDir=../GOSRC dump=false:
Package context:
Processing package=context:
Walking from ../GOSRC to ../GOSRC/crypto
Processing sourceDir=../GOSRC dump=false:
Package crypto:
Processing package=crypto:
Walking from ../GOSRC to ../GOSRC/crypto/aes
Processing sourceDir=../GOSRC dump=false:
Package aes:
Processing package=aes:
Walking from ../GOSRC to ../GOSRC/crypto/cipher
Processing sourceDir=../GOSRC dump=false:
Package cipher:
Processing package=cipher:
Walking from ../GOSRC to ../GOSRC/crypto/des
Processing sourceDir=../GOSRC dump=false:
Package des:
Processing package=des:
Walking from ../GOSRC to ../GOSRC/crypto/dsa
Processing sourceDir=../GOSRC dump=false:
Package dsa:
Processing package=dsa:
Walking from ../GOSRC to ../GOSRC/crypto/ecdsa
Processing sourceDir=../GOSRC dump=false:
Package ecdsa:
Processing package=ecdsa:
Excluding ../GOSRC/crypto/ecdsa/testdata
Walking from ../GOSRC to ../GOSRC/crypto/elliptic
Processing sourceDir=../GOSRC dump=false:
Package elliptic:
Processing package=elliptic:
Walking from ../GOSRC to ../GOSRC/crypto/hmac
Processing sourceDir=../GOSRC dump=false:
Package hmac:
Processing package=hmac:
Excluding ../GOSRC/crypto/internal
Walking from ../GOSRC to ../GOSRC/crypto/md5
Processing sourceDir=../GOSRC dump=false:
Package md5:
Processing package=md5:
Walking from ../GOSRC to ../GOSRC/crypto/rand
Processing sourceDir=../GOSRC dump=false:
Package rand:
Processing package=rand:
Walking from ../GOSRC to ../GOSRC/crypto/rc4
Processing sourceDir=../GOSRC dump=false:
Package rc4:
Processing package=rc4:
Walking from ../GOSRC to ../GOSRC/crypto/rsa
Processing sourceDir=../GOSRC dump=false:
Package rsa:
Processing package=rsa:
Excluding ../GOSRC/crypto/rsa/testdata
Walking from ../GOSRC to ../GOSRC/crypto/sha1
Processing sourceDir=../GOSRC dump=false:
Package sha1:
Processing package=sha1:
Walking from ../GOSRC to ../GOSRC/crypto/sha256
Processing sourceDir=../GOSRC dump=false:
Package sha256:
Processing package=sha256:
Walking from ../GOSRC to ../GOSRC/crypto/sha512
Processing sourceDir=../GOSRC dump=false:
Package sha512:
Processing package=sha512:
Walking from ../GOSRC to ../GOSRC/crypto/subtle
Processing sourceDir=../GOSRC dump=false:
Package subtle:
Processing package=subtle:
Walking from ../GOSRC to ../GOSRC/crypto/tls
Processing sourceDir=../GOSRC dump=false:
Package tls:
Processing package=tls:
Excluding ../GOSRC/crypto/tls/testdata
Walking from ../GOSRC to ../GOSRC/crypto/x509
Processing sourceDir=../GOSRC dump=false:
Package x509:
Processing package=x509:
Walking from ../GOSRC to ../GOSRC/crypto/x509/pkix
Processing sourceDir=../GOSRC dump=false:
Package pkix:
Processing package=pkix:
Excluding ../GOSRC/crypto/x509/testdata
Walking from ../GOSRC to ../GOSRC/database
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/database/sql
Processing sourceDir=../GOSRC dump=false:
Package sql:
Processing package=sql:
Walking from ../GOSRC to ../GOSRC/database/sql/driver
Processing sourceDir=../GOSRC dump=false:
Package driver:
Processing package=driver:
Walking from ../GOSRC to ../GOSRC/debug
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/debug/dwarf
Processing sourceDir=../GOSRC dump=false:
Package dwarf:
Processing package=dwarf:
Excluding ../GOSRC/debug/dwarf/testdata
Walking from ../GOSRC to ../GOSRC/debug/elf
Processing sourceDir=../GOSRC dump=false:
Package elf:
Processing package=elf:
Excluding ../GOSRC/debug/elf/testdata
Walking from ../GOSRC to ../GOSRC/debug/gosym
Processing sourceDir=../GOSRC dump=false:
Package gosym:
Processing package=gosym:
Walking from ../GOSRC to ../GOSRC/debug/macho
Processing sourceDir=../GOSRC dump=false:
Package macho:
Processing package=macho:
Excluding ../GOSRC/debug/macho/testdata
Walking from ../GOSRC to ../GOSRC/debug/pe
Processing sourceDir=../GOSRC dump=false:
Package pe:
Processing package=pe:
Excluding ../GOSRC/debug/pe/testdata
Walking from ../GOSRC to ../GOSRC/debug/plan9obj
Processing sourceDir=../GOSRC dump=false:
Package plan9obj:
Processing package=plan9obj:
Excluding ../GOSRC/debug/plan9obj/testdata
Walking from ../GOSRC to ../GOSRC/encoding
Processing sourceDir=../GOSRC dump=false:
Package encoding:
Processing package=encoding:
Walking from ../GOSRC to ../GOSRC/encoding/ascii85
Processing sourceDir=../GOSRC dump=false:
Package ascii85:
Processing package=ascii85:
Walking from ../GOSRC to ../GOSRC/encoding/asn1
Processing sourceDir=../GOSRC dump=false:
Package asn1:
Processing package=asn1:
Walking from ../GOSRC to ../GOSRC/encoding/base32
Processing sourceDir=../GOSRC dump=false:
Package base32:
Processing package=base32:
Walking from ../GOSRC to ../GOSRC/encoding/base64
Processing sourceDir=../GOSRC dump=false:
Package base64:
Processing package=base64:
Walking from ../GOSRC to ../GOSRC/encoding/binary
Processing sourceDir=../GOSRC dump=false:
Package binary:
Processing package=binary:
Walking from ../GOSRC to ../GOSRC/encoding/csv
Processing sourceDir=../GOSRC dump=false:
Package csv:
Processing package=csv:
Walking from ../GOSRC to ../GOSRC/encoding/gob
Processing sourceDir=../GOSRC dump=false:
Package gob:
Processing package=gob:
Walking from ../GOSRC to ../GOSRC/encoding/hex
Processing sourceDir=../GOSRC dump=false:
Package hex:
Processing package=hex:
Walking from ../GOSRC to ../GOSRC/encoding/json
Processing sourceDir=../GOSRC dump=false:
Package json:
Processing package=json:
Excluding ../GOSRC/encoding/json/testdata
Walking from ../GOSRC to ../GOSRC/encoding/pem
Processing sourceDir=../GOSRC dump=false:
Package pem:
Processing package=pem:
Walking from ../GOSRC to ../GOSRC/encoding/xml
Processing sourceDir=../GOSRC dump=false:
Package xml:
Processing package=xml:
Walking from ../GOSRC to ../GOSRC/errors
Processing sourceDir=../GOSRC dump=false:
Package errors:
Processing package=errors:
Walking from ../GOSRC to ../GOSRC/expvar
Processing sourceDir=../GOSRC dump=false:
Package expvar:
Processing package=expvar:
Walking from ../GOSRC to ../GOSRC/flag
Processing sourceDir=../GOSRC dump=false:
Package flag:
Processing package=flag:
Walking from ../GOSRC to ../GOSRC/fmt
Processing sourceDir=../GOSRC dump=false:
Package fmt:
Processing package=fmt:
Walking from ../GOSRC to ../GOSRC/go
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/go/ast
Processing sourceDir=../GOSRC dump=false:
Package ast:
Processing package=ast:
Walking from ../GOSRC to ../GOSRC/go/build
Processing sourceDir=../GOSRC dump=false:
Package build:
Processing package=build:
Excluding ../GOSRC/go/build/testdata
Walking from ../GOSRC to ../GOSRC/go/constant
Processing sourceDir=../GOSRC dump=false:
Package constant:
Processing package=constant:
Walking from ../GOSRC to ../GOSRC/go/doc
Processing sourceDir=../GOSRC dump=false:
Package doc:
Processing package=doc:
Excluding ../GOSRC/go/doc/testdata
Walking from ../GOSRC to ../GOSRC/go/format
Processing sourceDir=../GOSRC dump=false:
Package format:
Processing package=format:
Walking from ../GOSRC to ../GOSRC/go/importer
Processing sourceDir=../GOSRC dump=false:
Package importer:
Processing package=importer:
Excluding ../GOSRC/go/internal
Walking from ../GOSRC to ../GOSRC/go/parser
Processing sourceDir=../GOSRC dump=false:
Package parser:
Processing package=parser:
Excluding ../GOSRC/go/parser/testdata
Walking from ../GOSRC to ../GOSRC/go/printer
Processing sourceDir=../GOSRC dump=false:
Package printer:
Processing package=printer:
Excluding ../GOSRC/go/printer/testdata
Walking from ../GOSRC to ../GOSRC/go/scanner
Processing sourceDir=../GOSRC dump=false:
Package scanner:
Processing package=scanner:
Walking from ../GOSRC to ../GOSRC/go/token
Processing sourceDir=../GOSRC dump=false:
Package token:
Processing package=token:
Walking from ../GOSRC to ../GOSRC/go/types
Processing sourceDir=../GOSRC dump=false:
Package types:
Processing package=types:
Excluding ../GOSRC/go/types/testdata
Walking from ../GOSRC to ../GOSRC/hash
Processing sourceDir=../GOSRC dump=false:
Package hash:
Processing package=hash:
Walking from ../GOSRC to ../GOSRC/hash/adler32
Processing sourceDir=../GOSRC dump=false:
Package adler32:
Processing package=adler32:
Walking from ../GOSRC to ../GOSRC/hash/crc32
Processing sourceDir=../GOSRC dump=false:
Package crc32:
Processing package=crc32:
Walking from ../GOSRC to ../GOSRC/hash/crc64
Processing sourceDir=../GOSRC dump=false:
Package crc64:
Processing package=crc64:
Walking from ../GOSRC to ../GOSRC/hash/fnv
Processing sourceDir=../GOSRC dump=false:
Package fnv:
Processing package=fnv:
Walking from ../GOSRC to ../GOSRC/html
Processing sourceDir=../GOSRC dump=false:
Package html:
Processing package=html:
Walking from ../GOSRC to ../GOSRC/html/template
Processing sourceDir=../GOSRC dump=false:
Package template:
Processing package=template:
Walking from ../GOSRC to ../GOSRC/image
Processing sourceDir=../GOSRC dump=false:
Package image:
Processing package=image:
Walking from ../GOSRC to ../GOSRC/image/color
Processing sourceDir=../GOSRC dump=false:
Package color:
Processing package=color:
Walking from ../GOSRC to ../GOSRC/image/color/palette
Processing sourceDir=../GOSRC dump=false:
Package palette:
Processing package=palette:
Walking from ../GOSRC to ../GOSRC/image/draw
Processing sourceDir=../GOSRC dump=false:
Package draw:
Processing package=draw:
Walking from ../GOSRC to ../GOSRC/image/gif
Processing sourceDir=../GOSRC dump=false:
Package gif:
Processing package=gif:
Excluding ../GOSRC/image/internal
Walking from ../GOSRC to ../GOSRC/image/jpeg
Processing sourceDir=../GOSRC dump=false:
Package jpeg:
Processing package=jpeg:
Walking from ../GOSRC to ../GOSRC/image/png
Processing sourceDir=../GOSRC dump=false:
Package png:
Processing package=png:
Excluding ../GOSRC/image/png/testdata
Excluding ../GOSRC/image/testdata
Walking from ../GOSRC to ../GOSRC/index
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/index/suffixarray
Processing sourceDir=../GOSRC dump=false:
Package suffixarray:
Processing package=suffixarray:
Excluding ../GOSRC/internal
Walking from ../GOSRC to ../GOSRC/io
Processing sourceDir=../GOSRC dump=false:
Package io:
Processing package=io:
Walking from ../GOSRC to ../GOSRC/io/ioutil
Processing sourceDir=../GOSRC dump=false:
Package ioutil:
Processing package=ioutil:
Excluding ../GOSRC/io/ioutil/testdata
Walking from ../GOSRC to ../GOSRC/log
Processing sourceDir=../GOSRC dump=false:
Package log:
Processing package=log:
Walking from ../GOSRC to ../GOSRC/log/syslog
Processing sourceDir=../GOSRC dump=false:
Package syslog:
Processing package=syslog:
Walking from ../GOSRC to ../GOSRC/math
Processing sourceDir=../GOSRC dump=false:
Package math:
Processing package=math:
Walking from ../GOSRC to ../GOSRC/math/big
Processing sourceDir=../GOSRC dump=false:
Package big:
Processing package=big:
Walking from ../GOSRC to ../GOSRC/math/bits
Processing sourceDir=../GOSRC dump=false:
Package bits:
Processing package=bits:
Walking from ../GOSRC to ../GOSRC/math/cmplx
Processing sourceDir=../GOSRC dump=false:
Package cmplx:
Processing package=cmplx:
Walking from ../GOSRC to ../GOSRC/math/rand
Processing sourceDir=../GOSRC dump=false:
Package rand:
Processing package=rand:
Walking from ../GOSRC to ../GOSRC/mime
Processing sourceDir=../GOSRC dump=false:
Package mime:
Processing package=mime:
Walking from ../GOSRC to ../GOSRC/mime/multipart
Processing sourceDir=../GOSRC dump=false:
Package multipart:
Processing package=multipart:
Excluding ../GOSRC/mime/multipart/testdata
Walking from ../GOSRC to ../GOSRC/mime/quotedprintable
Processing sourceDir=../GOSRC dump=false:
Package quotedprintable:
Processing package=quotedprintable:
Excluding ../GOSRC/mime/testdata
Walking from ../GOSRC to ../GOSRC/net
Processing sourceDir=../GOSRC dump=false:
Package net:
Processing package=net:
Walking from ../GOSRC to ../GOSRC/net/http
Processing sourceDir=../GOSRC dump=false:
Package http:
Processing package=http:
Walking from ../GOSRC to ../GOSRC/net/http/cgi
Processing sourceDir=../GOSRC dump=false:
Package cgi:
Processing package=cgi:
Excluding ../GOSRC/net/http/cgi/testdata
Walking from ../GOSRC to ../GOSRC/net/http/cookiejar
Processing sourceDir=../GOSRC dump=false:
Package cookiejar:
Processing package=cookiejar:
Walking from ../GOSRC to ../GOSRC/net/http/fcgi
Processing sourceDir=../GOSRC dump=false:
Package fcgi:
Processing package=fcgi:
Walking from ../GOSRC to ../GOSRC/net/http/httptest
Processing sourceDir=../GOSRC dump=false:
Package httptest:
Processing package=httptest:
Walking from ../GOSRC to ../GOSRC/net/http/httptrace
Processing sourceDir=../GOSRC dump=false:
Package httptrace:
Processing package=httptrace:
Walking from ../GOSRC to ../GOSRC/net/http/httputil
Processing sourceDir=../GOSRC dump=false:
Package httputil:
Processing package=httputil:
Excluding ../GOSRC/net/http/internal
Walking from ../GOSRC to ../GOSRC/net/http/pprof
Processing sourceDir=../GOSRC dump=false:
Package pprof:
Processing package=pprof:
Excluding ../GOSRC/net/http/testdata
Excluding ../GOSRC/net/internal
Walking from ../GOSRC to ../GOSRC/net/mail
Processing sourceDir=../GOSRC dump=false:
Package mail:
Processing package=mail:
Walking from ../GOSRC to ../GOSRC/net/rpc
Processing sourceDir=../GOSRC dump=false:
Package rpc:
Processing package=rpc:
Walking from ../GOSRC to ../GOSRC/net/rpc/jsonrpc
Processing sourceDir=../GOSRC dump=false:
Package jsonrpc:
Processing package=jsonrpc:
Walking from ../GOSRC to ../GOSRC/net/smtp
Processing sourceDir=../GOSRC dump=false:
Package smtp:
Processing package=smtp:
Excluding ../GOSRC/net/testdata
Walking from ../GOSRC to ../GOSRC/net/textproto
Processing sourceDir=../GOSRC dump=false:
Package textproto:
Processing package=textproto:
Walking from ../GOSRC to ../GOSRC/net/url
Processing sourceDir=../GOSRC dump=false:
Package url:
Processing package=url:
Walking from ../GOSRC to ../GOSRC/os
Processing sourceDir=../GOSRC dump=false:
Package os:
Processing package=os:
Walking from ../GOSRC to ../GOSRC/os/exec
Processing sourceDir=../GOSRC dump=false:
Package exec:
Processing package=exec:
Walking from ../GOSRC to ../GOSRC/os/signal
Processing sourceDir=../GOSRC dump=false:
Package signal:
Processing package=signal:
Excluding ../GOSRC/os/signal/internal
Walking from ../GOSRC to ../GOSRC/os/user
Processing sourceDir=../GOSRC dump=false:
Package user:
Processing package=user:
Walking from ../GOSRC to ../GOSRC/path
Processing sourceDir=../GOSRC dump=false:
Package path:
Processing package=path:
Walking from ../GOSRC to ../GOSRC/path/filepath
Processing sourceDir=../GOSRC dump=false:
Package filepath:
Processing package=filepath:
Walking from ../GOSRC to ../GOSRC/plugin
Processing sourceDir=../GOSRC dump=false:
Package plugin:
Processing package=plugin:
Walking from ../GOSRC to ../GOSRC/reflect
Processing sourceDir=../GOSRC dump=false:
Package reflect:
Processing package=reflect:
Walking from ../GOSRC to ../GOSRC/regexp
Processing sourceDir=../GOSRC dump=false:
Package regexp:
Processing package=regexp:
Walking from ../GOSRC to ../GOSRC/regexp/syntax
Processing sourceDir=../GOSRC dump=false:
Package syntax:
Processing package=syntax:
Excluding ../GOSRC/regexp/testdata
Walking from ../GOSRC to ../GOSRC/runtime
Processing sourceDir=../GOSRC dump=false:
Package runtime:
Processing package=runtime:
Walking from ../GOSRC to ../GOSRC/runtime/cgo
Processing sourceDir=../GOSRC dump=false:
Package cgo:
Processing package=cgo:
Walking from ../GOSRC to ../GOSRC/runtime/debug
Processing sourceDir=../GOSRC dump=false:
Package debug:
Processing package=debug:
Excluding ../GOSRC/runtime/internal
Walking from ../GOSRC to ../GOSRC/runtime/msan
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/runtime/pprof
Processing sourceDir=../GOSRC dump=false:
Package pprof:
Processing package=pprof:
Excluding ../GOSRC/runtime/pprof/internal
Excluding ../GOSRC/runtime/pprof/testdata
Walking from ../GOSRC to ../GOSRC/runtime/race
Processing sourceDir=../GOSRC dump=false:
Package race:
Processing package=race:
Excluding ../GOSRC/runtime/race/testdata
Excluding ../GOSRC/runtime/testdata
Walking from ../GOSRC to ../GOSRC/runtime/trace
Processing sourceDir=../GOSRC dump=false:
Package trace:
Processing package=trace:
Walking from ../GOSRC to ../GOSRC/sort
Processing sourceDir=../GOSRC dump=false:
Package sort:
Processing package=sort:
Walking from ../GOSRC to ../GOSRC/strconv
Processing sourceDir=../GOSRC dump=false:
Package strconv:
Processing package=strconv:
Excluding ../GOSRC/strconv/testdata
Walking from ../GOSRC to ../GOSRC/strings
Processing sourceDir=../GOSRC dump=false:
Package strings:
Processing package=strings:
Walking from ../GOSRC to ../GOSRC/sync
Processing sourceDir=../GOSRC dump=false:
Package sync:
Processing package=sync:
Walking from ../GOSRC to ../GOSRC/sync/atomic
Processing sourceDir=../GOSRC dump=false:
Package atomic:
Processing package=atomic:
Walking from ../GOSRC to ../GOSRC/syscall
Processing sourceDir=../GOSRC dump=false:
Package syscall:
Processing package=syscall:
Walking from ../GOSRC to ../GOSRC/syscall/js
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/testing
Processing sourceDir=../GOSRC dump=false:
Package testing:
Processing package=testing:
Excluding ../GOSRC/testing/internal
Walking from ../GOSRC to ../GOSRC/testing/iotest
Processing sourceDir=../GOSRC dump=false:
Package iotest:
Processing package=iotest:
Walking from ../GOSRC to ../GOSRC/testing/quick
Processing sourceDir=../GOSRC dump=false:
Package quick:
Processing package=quick:
Walking from ../GOSRC to ../GOSRC/text
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/text/scanner
Processing sourceDir=../GOSRC dump=false:
Package scanner:
Processing package=scanner:
Walking from ../GOSRC to ../GOSRC/text/tabwriter
Processing sourceDir=../GOSRC dump=false:
Package tabwriter:
Processing package=tabwriter:
Walking from ../GOSRC to ../GOSRC/text/template
Processing sourceDir=../GOSRC dump=false:
Package template:
Processing package=template:
Walking from ../GOSRC to ../GOSRC/text/template/parse
Processing sourceDir=../GOSRC dump=false:
Package parse:
Processing package=parse:
Excluding ../GOSRC/text/template/testdata
Walking from ../GOSRC to ../GOSRC/time
Processing sourceDir=../GOSRC dump=false:
Package time:
Processing package=time:
Walking from ../GOSRC to ../GOSRC/unicode
Processing sourceDir=../GOSRC dump=false:
Package unicode:
Processing package=unicode:
Walking from ../GOSRC to ../GOSRC/unicode/utf16
Processing sourceDir=../GOSRC dump=false:
Package utf16:
Processing package=utf16:
Walking from ../GOSRC to ../GOSRC/unicode/utf8
Processing sourceDir=../GOSRC dump=false:
Package utf8:
Processing package=utf8:
Walking from ../GOSRC to ../GOSRC/unsafe
Processing sourceDir=../GOSRC dump=false:
Package unsafe:
Processing package=unsafe:
Walking from ../GOSRC to ../GOSRC/vendor
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto/chacha20poly1305
Processing sourceDir=../GOSRC dump=false:
Package chacha20poly1305:
Processing package=chacha20poly1305:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto/cryptobyte
Processing sourceDir=../GOSRC dump=false:
Package cryptobyte:
Processing package=cryptobyte:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/asn1
Processing sourceDir=../GOSRC dump=false:
Package asn1:
Processing package=asn1:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto/curve25519
Processing sourceDir=../GOSRC dump=false:
Package curve25519:
Processing package=curve25519:
Excluding ../GOSRC/vendor/golang_org/x/crypto/internal
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/crypto/poly1305
Processing sourceDir=../GOSRC dump=false:
Package poly1305:
Processing package=poly1305:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/dns
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage
Processing sourceDir=../GOSRC dump=false:
Package dnsmessage:
Processing package=dnsmessage:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/http
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/http/httpguts
Processing sourceDir=../GOSRC dump=false:
Package httpguts:
Processing package=httpguts:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/http/httpproxy
Processing sourceDir=../GOSRC dump=false:
Package httpproxy:
Processing package=httpproxy:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/http2
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/http2/hpack
Processing sourceDir=../GOSRC dump=false:
Package hpack:
Processing package=hpack:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/idna
Processing sourceDir=../GOSRC dump=false:
Package idna:
Processing package=idna:
Excluding ../GOSRC/vendor/golang_org/x/net/internal
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/lif
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/nettest
Processing sourceDir=../GOSRC dump=false:
Package nettest:
Processing package=nettest:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/net/route
Processing sourceDir=../GOSRC dump=false:
Package route:
Processing package=route:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text
Processing sourceDir=../GOSRC dump=false:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/secure
Processing sourceDir=../GOSRC dump=false:
Package secure:
Processing package=secure:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/secure/bidirule
Processing sourceDir=../GOSRC dump=false:
Package bidirule:
Processing package=bidirule:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/transform
Processing sourceDir=../GOSRC dump=false:
Package transform:
Processing package=transform:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/unicode
Processing sourceDir=../GOSRC dump=false:
Package unicode:
Processing package=unicode:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/unicode/bidi
Processing sourceDir=../GOSRC dump=false:
Package bidi:
Processing package=bidi:
Walking from ../GOSRC to ../GOSRC/vendor/golang_org/x/text/unicode/norm
Processing sourceDir=../GOSRC dump=false:
Package norm:
Processing package=norm:
NOTE: Already seen function rand.Int in ../GOSRC/crypto/rand/util.go, yet again in ../GOSRC/math/rand/rand.go
NOTE: Already seen function rand.Read in ../GOSRC/crypto/rand/rand.go, yet again in ../GOSRC/math/rand/rand.go
NOTE: Already seen function template.HTMLEscape in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.HTMLEscapeString in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.HTMLEscaper in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.IsTrue in ../GOSRC/html/template/template.go, yet again in ../GOSRC/text/template/exec.go
NOTE: Already seen function template.JSEscape in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.JSEscapeString in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.JSEscaper in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
NOTE: Already seen function template.Must in ../GOSRC/html/template/template.go, yet again in ../GOSRC/text/template/helper.go
NOTE: Already seen function template.New in ../GOSRC/html/template/template.go, yet again in ../GOSRC/text/template/template.go
NOTE: Already seen function template.ParseFiles in ../GOSRC/html/template/template.go, yet again in ../GOSRC/text/template/helper.go
NOTE: Already seen function template.ParseGlob in ../GOSRC/html/template/template.go, yet again in ../GOSRC/text/template/helper.go
NOTE: Already seen function template.URLQueryEscaper in ../GOSRC/html/template/escape.go, yet again in ../GOSRC/text/template/funcs.go
TYPE aes.KeySizeError:
  ../GOSRC/crypto/aes/cipher.go
TYPE ascii85.CorruptInputError:
  ../GOSRC/encoding/ascii85/ascii85.go
TYPE asn1.BitString:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.Enumerated:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.Flag:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.ObjectIdentifier:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.RawContent:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.RawValue:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.StructuralError:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.SyntaxError:
  ../GOSRC/encoding/asn1/asn1.go
TYPE asn1.Tag:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/asn1/asn1.go
TYPE ast.ArrayType:
  ../GOSRC/go/ast/ast.go
TYPE ast.AssignStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.BadDecl:
  ../GOSRC/go/ast/ast.go
TYPE ast.BadExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.BadStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.BasicLit:
  ../GOSRC/go/ast/ast.go
TYPE ast.BinaryExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.BlockStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.BranchStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.CallExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.CaseClause:
  ../GOSRC/go/ast/ast.go
TYPE ast.ChanDir:
  ../GOSRC/go/ast/ast.go
TYPE ast.ChanType:
  ../GOSRC/go/ast/ast.go
TYPE ast.CommClause:
  ../GOSRC/go/ast/ast.go
TYPE ast.Comment:
  ../GOSRC/go/ast/ast.go
TYPE ast.CommentGroup:
  ../GOSRC/go/ast/ast.go
TYPE ast.CommentMap:
  ../GOSRC/go/ast/commentmap.go
TYPE ast.CompositeLit:
  ../GOSRC/go/ast/ast.go
TYPE ast.Decl:
  ../GOSRC/go/ast/ast.go
TYPE ast.DeclStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.DeferStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.Ellipsis:
  ../GOSRC/go/ast/ast.go
TYPE ast.EmptyStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.Expr:
  ../GOSRC/go/ast/ast.go
TYPE ast.ExprStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.Field:
  ../GOSRC/go/ast/ast.go
TYPE ast.FieldFilter:
  ../GOSRC/go/ast/print.go
TYPE ast.FieldList:
  ../GOSRC/go/ast/ast.go
TYPE ast.File:
  ../GOSRC/go/ast/ast.go
TYPE ast.Filter:
  ../GOSRC/go/ast/filter.go
TYPE ast.ForStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.FuncDecl:
  ../GOSRC/go/ast/ast.go
TYPE ast.FuncLit:
  ../GOSRC/go/ast/ast.go
TYPE ast.FuncType:
  ../GOSRC/go/ast/ast.go
TYPE ast.GenDecl:
  ../GOSRC/go/ast/ast.go
TYPE ast.GoStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.Ident:
  ../GOSRC/go/ast/ast.go
TYPE ast.IfStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.ImportSpec:
  ../GOSRC/go/ast/ast.go
TYPE ast.Importer:
  ../GOSRC/go/ast/resolve.go
TYPE ast.IncDecStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.IndexExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.InterfaceType:
  ../GOSRC/go/ast/ast.go
TYPE ast.KeyValueExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.LabeledStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.MapType:
  ../GOSRC/go/ast/ast.go
TYPE ast.MergeMode:
  ../GOSRC/go/ast/filter.go
TYPE ast.Node:
  ../GOSRC/go/ast/ast.go
TYPE ast.ObjKind:
  ../GOSRC/go/ast/scope.go
TYPE ast.Object:
  ../GOSRC/go/ast/scope.go
TYPE ast.Package:
  ../GOSRC/go/ast/ast.go
TYPE ast.ParenExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.RangeStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.ReturnStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.Scope:
  ../GOSRC/go/ast/scope.go
TYPE ast.SelectStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.SelectorExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.SendStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.SliceExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.Spec:
  ../GOSRC/go/ast/ast.go
TYPE ast.StarExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.Stmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.StructType:
  ../GOSRC/go/ast/ast.go
TYPE ast.SwitchStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.TypeAssertExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.TypeSpec:
  ../GOSRC/go/ast/ast.go
TYPE ast.TypeSwitchStmt:
  ../GOSRC/go/ast/ast.go
TYPE ast.UnaryExpr:
  ../GOSRC/go/ast/ast.go
TYPE ast.ValueSpec:
  ../GOSRC/go/ast/ast.go
TYPE ast.Visitor:
  ../GOSRC/go/ast/walk.go
TYPE atomic.Value:
  ../GOSRC/sync/atomic/value.go
TYPE base32.CorruptInputError:
  ../GOSRC/encoding/base32/base32.go
TYPE base32.Encoding:
  ../GOSRC/encoding/base32/base32.go
TYPE base64.CorruptInputError:
  ../GOSRC/encoding/base64/base64.go
TYPE base64.Encoding:
  ../GOSRC/encoding/base64/base64.go
TYPE bidi.Class:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/trieval.go
TYPE bidi.Direction:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Option:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Ordering:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Paragraph:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Properties:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/prop.go
TYPE bidi.Run:
  ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidirule.Transformer:
  ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go
TYPE big.Accuracy:
  ../GOSRC/math/big/float.go
TYPE big.ErrNaN:
  ../GOSRC/math/big/float.go
TYPE big.Float:
  ../GOSRC/math/big/float.go
TYPE big.Int:
  ../GOSRC/math/big/int.go
TYPE big.Rat:
  ../GOSRC/math/big/rat.go
TYPE big.RoundingMode:
  ../GOSRC/math/big/float.go
TYPE big.Word:
  ../GOSRC/math/big/arith.go
TYPE binary.ByteOrder:
  ../GOSRC/encoding/binary/binary.go
TYPE bufio.ReadWriter:
  ../GOSRC/bufio/bufio.go
TYPE bufio.Reader:
  ../GOSRC/bufio/bufio.go
TYPE bufio.Scanner:
  ../GOSRC/bufio/scan.go
TYPE bufio.SplitFunc:
  ../GOSRC/bufio/scan.go
TYPE bufio.Writer:
  ../GOSRC/bufio/bufio.go
TYPE build.Context:
  ../GOSRC/go/build/build.go
TYPE build.ImportMode:
  ../GOSRC/go/build/build.go
TYPE build.MultiplePackageError:
  ../GOSRC/go/build/build.go
TYPE build.NoGoError:
  ../GOSRC/go/build/build.go
TYPE build.Package:
  ../GOSRC/go/build/build.go
TYPE bytes.Buffer:
  ../GOSRC/bytes/buffer.go
TYPE bytes.Reader:
  ../GOSRC/bytes/reader.go
TYPE bzip2.StructuralError:
  ../GOSRC/compress/bzip2/bzip2.go
TYPE cgi.Handler:
  ../GOSRC/net/http/cgi/host.go
TYPE cipher.AEAD:
  ../GOSRC/crypto/cipher/gcm.go
TYPE cipher.Block:
  ../GOSRC/crypto/cipher/cipher.go
TYPE cipher.BlockMode:
  ../GOSRC/crypto/cipher/cipher.go
TYPE cipher.Stream:
  ../GOSRC/crypto/cipher/cipher.go
TYPE cipher.StreamReader:
  ../GOSRC/crypto/cipher/io.go
TYPE cipher.StreamWriter:
  ../GOSRC/crypto/cipher/io.go
TYPE color.Alpha:
  ../GOSRC/image/color/color.go
TYPE color.Alpha16:
  ../GOSRC/image/color/color.go
TYPE color.CMYK:
  ../GOSRC/image/color/ycbcr.go
TYPE color.Color:
  ../GOSRC/image/color/color.go
TYPE color.Gray:
  ../GOSRC/image/color/color.go
TYPE color.Gray16:
  ../GOSRC/image/color/color.go
TYPE color.Model:
  ../GOSRC/image/color/color.go
TYPE color.NRGBA:
  ../GOSRC/image/color/color.go
TYPE color.NRGBA64:
  ../GOSRC/image/color/color.go
TYPE color.NYCbCrA:
  ../GOSRC/image/color/ycbcr.go
TYPE color.Palette:
  ../GOSRC/image/color/color.go
TYPE color.RGBA:
  ../GOSRC/image/color/color.go
TYPE color.RGBA64:
  ../GOSRC/image/color/color.go
TYPE color.YCbCr:
  ../GOSRC/image/color/ycbcr.go
TYPE constant.Kind:
  ../GOSRC/go/constant/value.go
TYPE constant.Value:
  ../GOSRC/go/constant/value.go
TYPE context.CancelFunc:
  ../GOSRC/context/context.go
TYPE context.Context:
  ../GOSRC/context/context.go
TYPE cookiejar.Jar:
  ../GOSRC/net/http/cookiejar/jar.go
TYPE cookiejar.Options:
  ../GOSRC/net/http/cookiejar/jar.go
TYPE cookiejar.PublicSuffixList:
  ../GOSRC/net/http/cookiejar/jar.go
TYPE crc32.Table:
  ../GOSRC/hash/crc32/crc32.go
TYPE crc64.Table:
  ../GOSRC/hash/crc64/crc64.go
TYPE crypto.Decrypter:
  ../GOSRC/crypto/crypto.go
TYPE crypto.DecrypterOpts:
  ../GOSRC/crypto/crypto.go
TYPE crypto.Hash:
  ../GOSRC/crypto/crypto.go
TYPE crypto.PrivateKey:
  ../GOSRC/crypto/crypto.go
TYPE crypto.PublicKey:
  ../GOSRC/crypto/crypto.go
TYPE crypto.Signer:
  ../GOSRC/crypto/crypto.go
TYPE crypto.SignerOpts:
  ../GOSRC/crypto/crypto.go
TYPE cryptobyte.BuildError:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.Builder:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.BuilderContinuation:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.MarshalingValue:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.String:
  ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/string.go
TYPE csv.ParseError:
  ../GOSRC/encoding/csv/reader.go
TYPE csv.Reader:
  ../GOSRC/encoding/csv/reader.go
TYPE csv.Writer:
  ../GOSRC/encoding/csv/writer.go
TYPE debug.GCStats:
  ../GOSRC/runtime/debug/garbage.go
TYPE des.KeySizeError:
  ../GOSRC/crypto/des/cipher.go
TYPE dnsmessage.AAAAResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.AResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Builder:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.CNAMEResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Class:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Header:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.MXResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Message:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.NSResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Name:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.OpCode:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.PTRResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Parser:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Question:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.RCode:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Resource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.ResourceBody:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.ResourceHeader:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.SOAResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.SRVResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.TXTResource:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Type:
  ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE doc.Example:
  ../GOSRC/go/doc/example.go
TYPE doc.Filter:
  ../GOSRC/go/doc/filter.go
TYPE doc.Func:
  ../GOSRC/go/doc/doc.go
TYPE doc.Mode:
  ../GOSRC/go/doc/doc.go
TYPE doc.Note:
  ../GOSRC/go/doc/doc.go
TYPE doc.Package:
  ../GOSRC/go/doc/doc.go
TYPE doc.Type:
  ../GOSRC/go/doc/doc.go
TYPE doc.Value:
  ../GOSRC/go/doc/doc.go
TYPE draw.Drawer:
  ../GOSRC/image/draw/draw.go
TYPE draw.Image:
  ../GOSRC/image/draw/draw.go
TYPE draw.Op:
  ../GOSRC/image/draw/draw.go
TYPE draw.Quantizer:
  ../GOSRC/image/draw/draw.go
TYPE driver.ColumnConverter:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Conn:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.ConnBeginTx:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.ConnPrepareContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Connector:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Driver:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.DriverContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Execer:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.ExecerContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.IsolationLevel:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.NamedValue:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.NamedValueChecker:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.NotNull:
  ../GOSRC/database/sql/driver/types.go
TYPE driver.Null:
  ../GOSRC/database/sql/driver/types.go
TYPE driver.Pinger:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Queryer:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.QueryerContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Result:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Rows:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsAffected:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeDatabaseTypeName:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeLength:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeNullable:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsColumnTypePrecisionScale:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeScanType:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.RowsNextResultSet:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.SessionResetter:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Stmt:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.StmtExecContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.StmtQueryContext:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Tx:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.TxOptions:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.Value:
  ../GOSRC/database/sql/driver/driver.go
TYPE driver.ValueConverter:
  ../GOSRC/database/sql/driver/types.go
TYPE driver.Valuer:
  ../GOSRC/database/sql/driver/types.go
TYPE dsa.ParameterSizes:
  ../GOSRC/crypto/dsa/dsa.go
TYPE dsa.Parameters:
  ../GOSRC/crypto/dsa/dsa.go
TYPE dsa.PrivateKey:
  ../GOSRC/crypto/dsa/dsa.go
TYPE dsa.PublicKey:
  ../GOSRC/crypto/dsa/dsa.go
TYPE dwarf.AddrType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.ArrayType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Attr:
  ../GOSRC/debug/dwarf/const.go
TYPE dwarf.BasicType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.BoolType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.CharType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Class:
  ../GOSRC/debug/dwarf/entry.go
TYPE dwarf.CommonType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.ComplexType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Data:
  ../GOSRC/debug/dwarf/open.go
TYPE dwarf.DecodeError:
  ../GOSRC/debug/dwarf/buf.go
TYPE dwarf.DotDotDotType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Entry:
  ../GOSRC/debug/dwarf/entry.go
TYPE dwarf.EnumType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.EnumValue:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Field:
  ../GOSRC/debug/dwarf/entry.go
TYPE dwarf.FloatType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.FuncType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.IntType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.LineEntry:
  ../GOSRC/debug/dwarf/line.go
TYPE dwarf.LineFile:
  ../GOSRC/debug/dwarf/line.go
TYPE dwarf.LineReader:
  ../GOSRC/debug/dwarf/line.go
TYPE dwarf.LineReaderPos:
  ../GOSRC/debug/dwarf/line.go
TYPE dwarf.Offset:
  ../GOSRC/debug/dwarf/entry.go
TYPE dwarf.PtrType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.QualType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Reader:
  ../GOSRC/debug/dwarf/entry.go
TYPE dwarf.StructField:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.StructType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.Tag:
  ../GOSRC/debug/dwarf/const.go
TYPE dwarf.Type:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.TypedefType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.UcharType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.UintType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.UnspecifiedType:
  ../GOSRC/debug/dwarf/type.go
TYPE dwarf.VoidType:
  ../GOSRC/debug/dwarf/type.go
TYPE ecdsa.PrivateKey:
  ../GOSRC/crypto/ecdsa/ecdsa.go
TYPE ecdsa.PublicKey:
  ../GOSRC/crypto/ecdsa/ecdsa.go
TYPE elf.Chdr32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Chdr64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Class:
  ../GOSRC/debug/elf/elf.go
TYPE elf.CompressionType:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Data:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Dyn32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Dyn64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.DynFlag:
  ../GOSRC/debug/elf/elf.go
TYPE elf.DynTag:
  ../GOSRC/debug/elf/elf.go
TYPE elf.File:
  ../GOSRC/debug/elf/file.go
TYPE elf.FileHeader:
  ../GOSRC/debug/elf/file.go
TYPE elf.FormatError:
  ../GOSRC/debug/elf/file.go
TYPE elf.Header32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Header64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.ImportedSymbol:
  ../GOSRC/debug/elf/file.go
TYPE elf.Machine:
  ../GOSRC/debug/elf/elf.go
TYPE elf.NType:
  ../GOSRC/debug/elf/elf.go
TYPE elf.OSABI:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Prog:
  ../GOSRC/debug/elf/file.go
TYPE elf.Prog32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Prog64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.ProgFlag:
  ../GOSRC/debug/elf/elf.go
TYPE elf.ProgHeader:
  ../GOSRC/debug/elf/file.go
TYPE elf.ProgType:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_386:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_390:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_AARCH64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_ALPHA:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_ARM:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_MIPS:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_PPC:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_PPC64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_RISCV:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_SPARC:
  ../GOSRC/debug/elf/elf.go
TYPE elf.R_X86_64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Rel32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Rel64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Rela32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Rela64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Section:
  ../GOSRC/debug/elf/file.go
TYPE elf.Section32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Section64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SectionFlag:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SectionHeader:
  ../GOSRC/debug/elf/file.go
TYPE elf.SectionIndex:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SectionType:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Sym32:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Sym64:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SymBind:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SymType:
  ../GOSRC/debug/elf/elf.go
TYPE elf.SymVis:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Symbol:
  ../GOSRC/debug/elf/file.go
TYPE elf.Type:
  ../GOSRC/debug/elf/elf.go
TYPE elf.Version:
  ../GOSRC/debug/elf/elf.go
TYPE elliptic.Curve:
  ../GOSRC/crypto/elliptic/elliptic.go
TYPE elliptic.CurveParams:
  ../GOSRC/crypto/elliptic/elliptic.go
TYPE encoding.BinaryMarshaler:
  ../GOSRC/encoding/encoding.go
TYPE encoding.BinaryUnmarshaler:
  ../GOSRC/encoding/encoding.go
TYPE encoding.TextMarshaler:
  ../GOSRC/encoding/encoding.go
TYPE encoding.TextUnmarshaler:
  ../GOSRC/encoding/encoding.go
TYPE exec.Cmd:
  ../GOSRC/os/exec/exec.go
TYPE exec.Error:
  ../GOSRC/os/exec/exec.go
TYPE exec.ExitError:
  ../GOSRC/os/exec/exec.go
TYPE expvar.Float:
  ../GOSRC/expvar/expvar.go
TYPE expvar.Func:
  ../GOSRC/expvar/expvar.go
TYPE expvar.Int:
  ../GOSRC/expvar/expvar.go
TYPE expvar.KeyValue:
  ../GOSRC/expvar/expvar.go
TYPE expvar.Map:
  ../GOSRC/expvar/expvar.go
TYPE expvar.String:
  ../GOSRC/expvar/expvar.go
TYPE expvar.Var:
  ../GOSRC/expvar/expvar.go
TYPE filepath.WalkFunc:
  ../GOSRC/path/filepath/path.go
TYPE flag.ErrorHandling:
  ../GOSRC/flag/flag.go
TYPE flag.Flag:
  ../GOSRC/flag/flag.go
TYPE flag.FlagSet:
  ../GOSRC/flag/flag.go
TYPE flag.Getter:
  ../GOSRC/flag/flag.go
TYPE flag.Value:
  ../GOSRC/flag/flag.go
TYPE flate.CorruptInputError:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.InternalError:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.ReadError:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.Reader:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.Resetter:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.WriteError:
  ../GOSRC/compress/flate/inflate.go
TYPE flate.Writer:
  ../GOSRC/compress/flate/deflate.go
TYPE fmt.Formatter:
  ../GOSRC/fmt/print.go
TYPE fmt.GoStringer:
  ../GOSRC/fmt/print.go
TYPE fmt.ScanState:
  ../GOSRC/fmt/scan.go
TYPE fmt.Scanner:
  ../GOSRC/fmt/scan.go
TYPE fmt.State:
  ../GOSRC/fmt/print.go
TYPE fmt.Stringer:
  ../GOSRC/fmt/print.go
TYPE gif.GIF:
  ../GOSRC/image/gif/reader.go
TYPE gif.Options:
  ../GOSRC/image/gif/writer.go
TYPE gob.CommonType:
  ../GOSRC/encoding/gob/type.go
TYPE gob.Decoder:
  ../GOSRC/encoding/gob/decoder.go
TYPE gob.Encoder:
  ../GOSRC/encoding/gob/encoder.go
TYPE gob.GobDecoder:
  ../GOSRC/encoding/gob/type.go
TYPE gob.GobEncoder:
  ../GOSRC/encoding/gob/type.go
TYPE gosym.DecodingError:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.Func:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.LineTable:
  ../GOSRC/debug/gosym/pclntab.go
TYPE gosym.Obj:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.Sym:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.Table:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.UnknownFileError:
  ../GOSRC/debug/gosym/symtab.go
TYPE gosym.UnknownLineError:
  ../GOSRC/debug/gosym/symtab.go
TYPE gzip.Header:
  ../GOSRC/compress/gzip/gunzip.go
TYPE gzip.Reader:
  ../GOSRC/compress/gzip/gunzip.go
TYPE gzip.Writer:
  ../GOSRC/compress/gzip/gzip.go
TYPE hash.Hash:
  ../GOSRC/hash/hash.go
TYPE hash.Hash32:
  ../GOSRC/hash/hash.go
TYPE hash.Hash64:
  ../GOSRC/hash/hash.go
TYPE heap.Interface:
  ../GOSRC/container/heap/heap.go
TYPE hex.InvalidByteError:
  ../GOSRC/encoding/hex/hex.go
TYPE hpack.Decoder:
  ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE hpack.DecodingError:
  ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE hpack.Encoder:
  ../GOSRC/vendor/golang_org/x/net/http2/hpack/encode.go
TYPE hpack.HeaderField:
  ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE hpack.InvalidIndexError:
  ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE http.Client:
  ../GOSRC/net/http/client.go
TYPE http.CloseNotifier:
  ../GOSRC/net/http/server.go
TYPE http.ConnState:
  ../GOSRC/net/http/server.go
TYPE http.Cookie:
  ../GOSRC/net/http/cookie.go
TYPE http.CookieJar:
  ../GOSRC/net/http/jar.go
TYPE http.Dir:
  ../GOSRC/net/http/fs.go
TYPE http.File:
  ../GOSRC/net/http/fs.go
TYPE http.FileSystem:
  ../GOSRC/net/http/fs.go
TYPE http.Flusher:
  ../GOSRC/net/http/server.go
TYPE http.Handler:
  ../GOSRC/net/http/server.go
TYPE http.HandlerFunc:
  ../GOSRC/net/http/server.go
TYPE http.Header:
  ../GOSRC/net/http/header.go
TYPE http.Hijacker:
  ../GOSRC/net/http/server.go
TYPE http.ProtocolError:
  ../GOSRC/net/http/request.go
TYPE http.PushOptions:
  ../GOSRC/net/http/http.go
TYPE http.Pusher:
  ../GOSRC/net/http/http.go
TYPE http.Request:
  ../GOSRC/net/http/request.go
TYPE http.Response:
  ../GOSRC/net/http/response.go
TYPE http.ResponseWriter:
  ../GOSRC/net/http/server.go
TYPE http.RoundTripper:
  ../GOSRC/net/http/client.go
TYPE http.SameSite:
  ../GOSRC/net/http/cookie.go
TYPE http.ServeMux:
  ../GOSRC/net/http/server.go
TYPE http.Server:
  ../GOSRC/net/http/server.go
TYPE http.Transport:
  ../GOSRC/net/http/transport.go
TYPE httpproxy.Config:
  ../GOSRC/vendor/golang_org/x/net/http/httpproxy/proxy.go
TYPE httptest.ResponseRecorder:
  ../GOSRC/net/http/httptest/recorder.go
TYPE httptest.Server:
  ../GOSRC/net/http/httptest/server.go
TYPE httptrace.ClientTrace:
  ../GOSRC/net/http/httptrace/trace.go
TYPE httptrace.DNSDoneInfo:
  ../GOSRC/net/http/httptrace/trace.go
TYPE httptrace.DNSStartInfo:
  ../GOSRC/net/http/httptrace/trace.go
TYPE httptrace.GotConnInfo:
  ../GOSRC/net/http/httptrace/trace.go
TYPE httptrace.WroteRequestInfo:
  ../GOSRC/net/http/httptrace/trace.go
TYPE httputil.BufferPool:
  ../GOSRC/net/http/httputil/reverseproxy.go
TYPE httputil.ClientConn:
  ../GOSRC/net/http/httputil/persist.go
TYPE httputil.ReverseProxy:
  ../GOSRC/net/http/httputil/reverseproxy.go
TYPE httputil.ServerConn:
  ../GOSRC/net/http/httputil/persist.go
TYPE idna.Option:
  ../GOSRC/vendor/golang_org/x/net/idna/idna.go
TYPE idna.Profile:
  ../GOSRC/vendor/golang_org/x/net/idna/idna.go
TYPE image.Alpha:
  ../GOSRC/image/image.go
TYPE image.Alpha16:
  ../GOSRC/image/image.go
TYPE image.CMYK:
  ../GOSRC/image/image.go
TYPE image.Config:
  ../GOSRC/image/image.go
TYPE image.Gray:
  ../GOSRC/image/image.go
TYPE image.Gray16:
  ../GOSRC/image/image.go
TYPE image.Image:
  ../GOSRC/image/image.go
TYPE image.NRGBA:
  ../GOSRC/image/image.go
TYPE image.NRGBA64:
  ../GOSRC/image/image.go
TYPE image.NYCbCrA:
  ../GOSRC/image/ycbcr.go
TYPE image.Paletted:
  ../GOSRC/image/image.go
TYPE image.PalettedImage:
  ../GOSRC/image/image.go
TYPE image.Point:
  ../GOSRC/image/geom.go
TYPE image.RGBA:
  ../GOSRC/image/image.go
TYPE image.RGBA64:
  ../GOSRC/image/image.go
TYPE image.Rectangle:
  ../GOSRC/image/geom.go
TYPE image.Uniform:
  ../GOSRC/image/names.go
TYPE image.YCbCr:
  ../GOSRC/image/ycbcr.go
TYPE image.YCbCrSubsampleRatio:
  ../GOSRC/image/ycbcr.go
TYPE importer.Lookup:
  ../GOSRC/go/importer/importer.go
TYPE io.ByteReader:
  ../GOSRC/io/io.go
TYPE io.ByteScanner:
  ../GOSRC/io/io.go
TYPE io.ByteWriter:
  ../GOSRC/io/io.go
TYPE io.Closer:
  ../GOSRC/io/io.go
TYPE io.LimitedReader:
  ../GOSRC/io/io.go
TYPE io.PipeReader:
  ../GOSRC/io/pipe.go
TYPE io.PipeWriter:
  ../GOSRC/io/pipe.go
TYPE io.ReadCloser:
  ../GOSRC/io/io.go
TYPE io.ReadSeeker:
  ../GOSRC/io/io.go
TYPE io.ReadWriteCloser:
  ../GOSRC/io/io.go
TYPE io.ReadWriteSeeker:
  ../GOSRC/io/io.go
TYPE io.ReadWriter:
  ../GOSRC/io/io.go
TYPE io.Reader:
  ../GOSRC/io/io.go
TYPE io.ReaderAt:
  ../GOSRC/io/io.go
TYPE io.ReaderFrom:
  ../GOSRC/io/io.go
TYPE io.RuneReader:
  ../GOSRC/io/io.go
TYPE io.RuneScanner:
  ../GOSRC/io/io.go
TYPE io.SectionReader:
  ../GOSRC/io/io.go
TYPE io.Seeker:
  ../GOSRC/io/io.go
TYPE io.WriteCloser:
  ../GOSRC/io/io.go
TYPE io.WriteSeeker:
  ../GOSRC/io/io.go
TYPE io.Writer:
  ../GOSRC/io/io.go
TYPE io.WriterAt:
  ../GOSRC/io/io.go
TYPE io.WriterTo:
  ../GOSRC/io/io.go
TYPE jpeg.FormatError:
  ../GOSRC/image/jpeg/reader.go
TYPE jpeg.Options:
  ../GOSRC/image/jpeg/writer.go
TYPE jpeg.Reader:
  ../GOSRC/image/jpeg/reader.go
TYPE jpeg.UnsupportedError:
  ../GOSRC/image/jpeg/reader.go
TYPE json.Decoder:
  ../GOSRC/encoding/json/stream.go
TYPE json.Delim:
  ../GOSRC/encoding/json/stream.go
TYPE json.Encoder:
  ../GOSRC/encoding/json/stream.go
TYPE json.InvalidUTF8Error:
  ../GOSRC/encoding/json/encode.go
TYPE json.InvalidUnmarshalError:
  ../GOSRC/encoding/json/decode.go
TYPE json.Marshaler:
  ../GOSRC/encoding/json/encode.go
TYPE json.MarshalerError:
  ../GOSRC/encoding/json/encode.go
TYPE json.Number:
  ../GOSRC/encoding/json/decode.go
TYPE json.RawMessage:
  ../GOSRC/encoding/json/stream.go
TYPE json.SyntaxError:
  ../GOSRC/encoding/json/scanner.go
TYPE json.Token:
  ../GOSRC/encoding/json/stream.go
TYPE json.UnmarshalFieldError:
  ../GOSRC/encoding/json/decode.go
TYPE json.UnmarshalTypeError:
  ../GOSRC/encoding/json/decode.go
TYPE json.Unmarshaler:
  ../GOSRC/encoding/json/decode.go
TYPE json.UnsupportedTypeError:
  ../GOSRC/encoding/json/encode.go
TYPE json.UnsupportedValueError:
  ../GOSRC/encoding/json/encode.go
TYPE list.Element:
  ../GOSRC/container/list/list.go
TYPE list.List:
  ../GOSRC/container/list/list.go
TYPE log.Logger:
  ../GOSRC/log/log.go
TYPE lzw.Order:
  ../GOSRC/compress/lzw/reader.go
TYPE macho.Cpu:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Dylib:
  ../GOSRC/debug/macho/file.go
TYPE macho.DylibCmd:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Dysymtab:
  ../GOSRC/debug/macho/file.go
TYPE macho.DysymtabCmd:
  ../GOSRC/debug/macho/macho.go
TYPE macho.FatArch:
  ../GOSRC/debug/macho/fat.go
TYPE macho.FatArchHeader:
  ../GOSRC/debug/macho/fat.go
TYPE macho.FatFile:
  ../GOSRC/debug/macho/fat.go
TYPE macho.File:
  ../GOSRC/debug/macho/file.go
TYPE macho.FileHeader:
  ../GOSRC/debug/macho/macho.go
TYPE macho.FormatError:
  ../GOSRC/debug/macho/file.go
TYPE macho.Load:
  ../GOSRC/debug/macho/file.go
TYPE macho.LoadBytes:
  ../GOSRC/debug/macho/file.go
TYPE macho.LoadCmd:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Nlist32:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Nlist64:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Regs386:
  ../GOSRC/debug/macho/macho.go
TYPE macho.RegsAMD64:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Reloc:
  ../GOSRC/debug/macho/file.go
TYPE macho.RelocTypeARM:
  ../GOSRC/debug/macho/reloctype.go
TYPE macho.RelocTypeARM64:
  ../GOSRC/debug/macho/reloctype.go
TYPE macho.RelocTypeGeneric:
  ../GOSRC/debug/macho/reloctype.go
TYPE macho.RelocTypeX86_64:
  ../GOSRC/debug/macho/reloctype.go
TYPE macho.Rpath:
  ../GOSRC/debug/macho/file.go
TYPE macho.RpathCmd:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Section:
  ../GOSRC/debug/macho/file.go
TYPE macho.Section32:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Section64:
  ../GOSRC/debug/macho/macho.go
TYPE macho.SectionHeader:
  ../GOSRC/debug/macho/file.go
TYPE macho.Segment:
  ../GOSRC/debug/macho/file.go
TYPE macho.Segment32:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Segment64:
  ../GOSRC/debug/macho/macho.go
TYPE macho.SegmentHeader:
  ../GOSRC/debug/macho/file.go
TYPE macho.Symbol:
  ../GOSRC/debug/macho/file.go
TYPE macho.Symtab:
  ../GOSRC/debug/macho/file.go
TYPE macho.SymtabCmd:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Thread:
  ../GOSRC/debug/macho/macho.go
TYPE macho.Type:
  ../GOSRC/debug/macho/macho.go
TYPE mail.Address:
  ../GOSRC/net/mail/message.go
TYPE mail.AddressParser:
  ../GOSRC/net/mail/message.go
TYPE mail.Header:
  ../GOSRC/net/mail/message.go
TYPE mail.Message:
  ../GOSRC/net/mail/message.go
TYPE mime.WordDecoder:
  ../GOSRC/mime/encodedword.go
TYPE mime.WordEncoder:
  ../GOSRC/mime/encodedword.go
TYPE multipart.File:
  ../GOSRC/mime/multipart/formdata.go
TYPE multipart.FileHeader:
  ../GOSRC/mime/multipart/formdata.go
TYPE multipart.Form:
  ../GOSRC/mime/multipart/formdata.go
TYPE multipart.Part:
  ../GOSRC/mime/multipart/multipart.go
TYPE multipart.Reader:
  ../GOSRC/mime/multipart/multipart.go
TYPE multipart.Writer:
  ../GOSRC/mime/multipart/writer.go
TYPE net.Addr:
  ../GOSRC/net/net.go
TYPE net.AddrError:
  ../GOSRC/net/net.go
TYPE net.Buffers:
  ../GOSRC/net/net.go
TYPE net.Conn:
  ../GOSRC/net/net.go
TYPE net.DNSConfigError:
  ../GOSRC/net/net.go
TYPE net.DNSError:
  ../GOSRC/net/net.go
TYPE net.Dialer:
  ../GOSRC/net/dial.go
TYPE net.Error:
  ../GOSRC/net/net.go
TYPE net.Flags:
  ../GOSRC/net/interface.go
TYPE net.HardwareAddr:
  ../GOSRC/net/mac.go
TYPE net.IP:
  ../GOSRC/net/ip.go
TYPE net.IPAddr:
  ../GOSRC/net/iprawsock.go
TYPE net.IPConn:
  ../GOSRC/net/iprawsock.go
TYPE net.IPMask:
  ../GOSRC/net/ip.go
TYPE net.IPNet:
  ../GOSRC/net/ip.go
TYPE net.Interface:
  ../GOSRC/net/interface.go
TYPE net.InvalidAddrError:
  ../GOSRC/net/net.go
TYPE net.ListenConfig:
  ../GOSRC/net/dial.go
TYPE net.Listener:
  ../GOSRC/net/net.go
TYPE net.MX:
  ../GOSRC/net/dnsclient.go
TYPE net.NS:
  ../GOSRC/net/dnsclient.go
TYPE net.OpError:
  ../GOSRC/net/net.go
TYPE net.PacketConn:
  ../GOSRC/net/net.go
TYPE net.ParseError:
  ../GOSRC/net/net.go
TYPE net.Resolver:
  ../GOSRC/net/lookup.go
TYPE net.SRV:
  ../GOSRC/net/dnsclient.go
TYPE net.TCPAddr:
  ../GOSRC/net/tcpsock.go
TYPE net.TCPConn:
  ../GOSRC/net/tcpsock.go
TYPE net.TCPListener:
  ../GOSRC/net/tcpsock.go
TYPE net.UDPAddr:
  ../GOSRC/net/udpsock.go
TYPE net.UDPConn:
  ../GOSRC/net/udpsock.go
TYPE net.UnixAddr:
  ../GOSRC/net/unixsock.go
TYPE net.UnixConn:
  ../GOSRC/net/unixsock.go
TYPE net.UnixListener:
  ../GOSRC/net/unixsock.go
TYPE net.UnknownNetworkError:
  ../GOSRC/net/net.go
TYPE nettest.MakePipe:
  ../GOSRC/vendor/golang_org/x/net/nettest/conntest.go
TYPE norm.Form:
  ../GOSRC/vendor/golang_org/x/text/unicode/norm/normalize.go
TYPE norm.Iter:
  ../GOSRC/vendor/golang_org/x/text/unicode/norm/iter.go
TYPE norm.Properties:
  ../GOSRC/vendor/golang_org/x/text/unicode/norm/forminfo.go
TYPE os.File:
  ../GOSRC/os/types.go
TYPE os.FileInfo:
  ../GOSRC/os/types.go
TYPE os.FileMode:
  ../GOSRC/os/types.go
TYPE os.LinkError:
  ../GOSRC/os/file.go
TYPE os.PathError:
  ../GOSRC/os/error.go
TYPE os.ProcAttr:
  ../GOSRC/os/exec.go
TYPE os.Process:
  ../GOSRC/os/exec.go
TYPE os.ProcessState:
  ../GOSRC/os/exec_posix.go
TYPE os.Signal:
  ../GOSRC/os/exec.go
TYPE os.SyscallError:
  ../GOSRC/os/error.go
TYPE parse.ActionNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.BoolNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.BranchNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.ChainNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.CommandNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.DotNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.FieldNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.IdentifierNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.IfNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.ListNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.NilNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.Node:
  ../GOSRC/text/template/parse/node.go
TYPE parse.NodeType:
  ../GOSRC/text/template/parse/node.go
TYPE parse.NumberNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.PipeNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.Pos:
  ../GOSRC/text/template/parse/node.go
TYPE parse.RangeNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.StringNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.TemplateNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.TextNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.Tree:
  ../GOSRC/text/template/parse/parse.go
TYPE parse.VariableNode:
  ../GOSRC/text/template/parse/node.go
TYPE parse.WithNode:
  ../GOSRC/text/template/parse/node.go
TYPE parser.Mode:
  ../GOSRC/go/parser/interface.go
TYPE pe.COFFSymbol:
  ../GOSRC/debug/pe/symbol.go
TYPE pe.DataDirectory:
  ../GOSRC/debug/pe/pe.go
TYPE pe.File:
  ../GOSRC/debug/pe/file.go
TYPE pe.FileHeader:
  ../GOSRC/debug/pe/pe.go
TYPE pe.FormatError:
  ../GOSRC/debug/pe/file.go
TYPE pe.ImportDirectory:
  ../GOSRC/debug/pe/file.go
TYPE pe.OptionalHeader32:
  ../GOSRC/debug/pe/pe.go
TYPE pe.OptionalHeader64:
  ../GOSRC/debug/pe/pe.go
TYPE pe.Reloc:
  ../GOSRC/debug/pe/section.go
TYPE pe.Section:
  ../GOSRC/debug/pe/section.go
TYPE pe.SectionHeader:
  ../GOSRC/debug/pe/section.go
TYPE pe.SectionHeader32:
  ../GOSRC/debug/pe/section.go
TYPE pe.StringTable:
  ../GOSRC/debug/pe/string.go
TYPE pe.Symbol:
  ../GOSRC/debug/pe/symbol.go
TYPE pem.Block:
  ../GOSRC/encoding/pem/pem.go
TYPE pkix.AlgorithmIdentifier:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.AttributeTypeAndValue:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.AttributeTypeAndValueSET:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.CertificateList:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.Extension:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.Name:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.RDNSequence:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.RelativeDistinguishedNameSET:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.RevokedCertificate:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE pkix.TBSCertificateList:
  ../GOSRC/crypto/x509/pkix/pkix.go
TYPE plan9obj.File:
  ../GOSRC/debug/plan9obj/file.go
TYPE plan9obj.FileHeader:
  ../GOSRC/debug/plan9obj/file.go
TYPE plan9obj.Section:
  ../GOSRC/debug/plan9obj/file.go
TYPE plan9obj.SectionHeader:
  ../GOSRC/debug/plan9obj/file.go
TYPE plan9obj.Sym:
  ../GOSRC/debug/plan9obj/file.go
TYPE plugin.Plugin:
  ../GOSRC/plugin/plugin.go
TYPE plugin.Symbol:
  ../GOSRC/plugin/plugin.go
TYPE png.CompressionLevel:
  ../GOSRC/image/png/writer.go
TYPE png.Encoder:
  ../GOSRC/image/png/writer.go
TYPE png.EncoderBuffer:
  ../GOSRC/image/png/writer.go
TYPE png.EncoderBufferPool:
  ../GOSRC/image/png/writer.go
TYPE png.FormatError:
  ../GOSRC/image/png/reader.go
TYPE png.UnsupportedError:
  ../GOSRC/image/png/reader.go
TYPE pprof.LabelSet:
  ../GOSRC/runtime/pprof/label.go
TYPE pprof.Profile:
  ../GOSRC/runtime/pprof/pprof.go
TYPE printer.CommentedNode:
  ../GOSRC/go/printer/printer.go
TYPE printer.Config:
  ../GOSRC/go/printer/printer.go
TYPE printer.Mode:
  ../GOSRC/go/printer/printer.go
TYPE quick.CheckEqualError:
  ../GOSRC/testing/quick/quick.go
TYPE quick.CheckError:
  ../GOSRC/testing/quick/quick.go
TYPE quick.Config:
  ../GOSRC/testing/quick/quick.go
TYPE quick.Generator:
  ../GOSRC/testing/quick/quick.go
TYPE quick.SetupError:
  ../GOSRC/testing/quick/quick.go
TYPE quotedprintable.Reader:
  ../GOSRC/mime/quotedprintable/reader.go
TYPE quotedprintable.Writer:
  ../GOSRC/mime/quotedprintable/writer.go
TYPE rand.Rand:
  ../GOSRC/math/rand/rand.go
TYPE rand.Source:
  ../GOSRC/math/rand/rand.go
TYPE rand.Source64:
  ../GOSRC/math/rand/rand.go
TYPE rand.Zipf:
  ../GOSRC/math/rand/zipf.go
TYPE rc4.Cipher:
  ../GOSRC/crypto/rc4/rc4.go
TYPE rc4.KeySizeError:
  ../GOSRC/crypto/rc4/rc4.go
TYPE reflect.ChanDir:
  ../GOSRC/reflect/type.go
TYPE reflect.Kind:
  ../GOSRC/reflect/type.go
TYPE reflect.Method:
  ../GOSRC/reflect/type.go
TYPE reflect.SelectCase:
  ../GOSRC/reflect/value.go
TYPE reflect.SelectDir:
  ../GOSRC/reflect/value.go
TYPE reflect.SliceHeader:
  ../GOSRC/reflect/value.go
TYPE reflect.StringHeader:
  ../GOSRC/reflect/value.go
TYPE reflect.StructField:
  ../GOSRC/reflect/type.go
TYPE reflect.StructTag:
  ../GOSRC/reflect/type.go
TYPE reflect.Type:
  ../GOSRC/reflect/type.go
TYPE reflect.Value:
  ../GOSRC/reflect/value.go
TYPE reflect.ValueError:
  ../GOSRC/reflect/value.go
TYPE regexp.Regexp:
  ../GOSRC/regexp/regexp.go
TYPE ring.Ring:
  ../GOSRC/container/ring/ring.go
TYPE route.Addr:
  ../GOSRC/vendor/golang_org/x/net/route/address.go
TYPE route.DefaultAddr:
  ../GOSRC/vendor/golang_org/x/net/route/address.go
TYPE route.Inet4Addr:
  ../GOSRC/vendor/golang_org/x/net/route/address.go
TYPE route.Inet6Addr:
  ../GOSRC/vendor/golang_org/x/net/route/address.go
TYPE route.InterfaceAddrMessage:
  ../GOSRC/vendor/golang_org/x/net/route/interface.go
TYPE route.InterfaceAnnounceMessage:
  ../GOSRC/vendor/golang_org/x/net/route/interface.go
TYPE route.InterfaceMessage:
  ../GOSRC/vendor/golang_org/x/net/route/interface.go
TYPE route.InterfaceMetrics:
  ../GOSRC/vendor/golang_org/x/net/route/sys_darwin.go
TYPE route.InterfaceMulticastAddrMessage:
  ../GOSRC/vendor/golang_org/x/net/route/interface.go
TYPE route.LinkAddr:
  ../GOSRC/vendor/golang_org/x/net/route/address.go
TYPE route.Message:
  ../GOSRC/vendor/golang_org/x/net/route/message.go
TYPE route.RIBType:
  ../GOSRC/vendor/golang_org/x/net/route/route.go
TYPE route.RouteMessage:
  ../GOSRC/vendor/golang_org/x/net/route/route.go
TYPE route.RouteMetrics:
  ../GOSRC/vendor/golang_org/x/net/route/sys_darwin.go
TYPE route.Sys:
  ../GOSRC/vendor/golang_org/x/net/route/message.go
TYPE route.SysType:
  ../GOSRC/vendor/golang_org/x/net/route/message.go
TYPE rpc.Call:
  ../GOSRC/net/rpc/client.go
TYPE rpc.Client:
  ../GOSRC/net/rpc/client.go
TYPE rpc.ClientCodec:
  ../GOSRC/net/rpc/client.go
TYPE rpc.Request:
  ../GOSRC/net/rpc/server.go
TYPE rpc.Response:
  ../GOSRC/net/rpc/server.go
TYPE rpc.Server:
  ../GOSRC/net/rpc/server.go
TYPE rpc.ServerCodec:
  ../GOSRC/net/rpc/server.go
TYPE rpc.ServerError:
  ../GOSRC/net/rpc/client.go
TYPE rsa.CRTValue:
  ../GOSRC/crypto/rsa/rsa.go
TYPE rsa.OAEPOptions:
  ../GOSRC/crypto/rsa/rsa.go
TYPE rsa.PKCS1v15DecryptOptions:
  ../GOSRC/crypto/rsa/pkcs1v15.go
TYPE rsa.PSSOptions:
  ../GOSRC/crypto/rsa/pss.go
TYPE rsa.PrecomputedValues:
  ../GOSRC/crypto/rsa/rsa.go
TYPE rsa.PrivateKey:
  ../GOSRC/crypto/rsa/rsa.go
TYPE rsa.PublicKey:
  ../GOSRC/crypto/rsa/rsa.go
TYPE runtime.BlockProfileRecord:
  ../GOSRC/runtime/mprof.go
TYPE runtime.Error:
  ../GOSRC/runtime/error.go
TYPE runtime.Frame:
  ../GOSRC/runtime/symtab.go
TYPE runtime.Frames:
  ../GOSRC/runtime/symtab.go
TYPE runtime.Func:
  ../GOSRC/runtime/symtab.go
TYPE runtime.MemProfileRecord:
  ../GOSRC/runtime/mprof.go
TYPE runtime.MemStats:
  ../GOSRC/runtime/mstats.go
TYPE runtime.StackRecord:
  ../GOSRC/runtime/mprof.go
TYPE runtime.TypeAssertionError:
  ../GOSRC/runtime/error.go
TYPE runtime._defer:
  ../GOSRC/runtime/runtime2.go
TYPE runtime._func:
  ../GOSRC/runtime/runtime2.go
TYPE runtime._panic:
  ../GOSRC/runtime/runtime2.go
TYPE runtime._type:
  ../GOSRC/runtime/type.go
TYPE runtime._typePair:
  ../GOSRC/runtime/type.go
TYPE scanner.Error:
  ../GOSRC/go/scanner/errors.go
TYPE scanner.ErrorHandler:
  ../GOSRC/go/scanner/scanner.go
TYPE scanner.ErrorList:
  ../GOSRC/go/scanner/errors.go
TYPE scanner.Mode:
  ../GOSRC/go/scanner/scanner.go
TYPE scanner.Position:
  ../GOSRC/text/scanner/scanner.go
TYPE scanner.Scanner:
  ../GOSRC/text/scanner/scanner.go
TYPE smtp.Auth:
  ../GOSRC/net/smtp/auth.go
TYPE smtp.Client:
  ../GOSRC/net/smtp/smtp.go
TYPE smtp.ServerInfo:
  ../GOSRC/net/smtp/auth.go
TYPE sort.Float64Slice:
  ../GOSRC/sort/sort.go
TYPE sort.IntSlice:
  ../GOSRC/sort/sort.go
TYPE sort.Interface:
  ../GOSRC/sort/sort.go
TYPE sort.StringSlice:
  ../GOSRC/sort/sort.go
TYPE sql.ColumnType:
  ../GOSRC/database/sql/sql.go
TYPE sql.Conn:
  ../GOSRC/database/sql/sql.go
TYPE sql.DB:
  ../GOSRC/database/sql/sql.go
TYPE sql.DBStats:
  ../GOSRC/database/sql/sql.go
TYPE sql.IsolationLevel:
  ../GOSRC/database/sql/sql.go
TYPE sql.NamedArg:
  ../GOSRC/database/sql/sql.go
TYPE sql.NullBool:
  ../GOSRC/database/sql/sql.go
TYPE sql.NullFloat64:
  ../GOSRC/database/sql/sql.go
TYPE sql.NullInt64:
  ../GOSRC/database/sql/sql.go
TYPE sql.NullString:
  ../GOSRC/database/sql/sql.go
TYPE sql.Out:
  ../GOSRC/database/sql/sql.go
TYPE sql.RawBytes:
  ../GOSRC/database/sql/sql.go
TYPE sql.Result:
  ../GOSRC/database/sql/sql.go
TYPE sql.Row:
  ../GOSRC/database/sql/sql.go
TYPE sql.Rows:
  ../GOSRC/database/sql/sql.go
TYPE sql.Scanner:
  ../GOSRC/database/sql/sql.go
TYPE sql.Stmt:
  ../GOSRC/database/sql/sql.go
TYPE sql.Tx:
  ../GOSRC/database/sql/sql.go
TYPE sql.TxOptions:
  ../GOSRC/database/sql/sql.go
TYPE strconv.NumError:
  ../GOSRC/strconv/atoi.go
TYPE strings.Builder:
  ../GOSRC/strings/builder.go
TYPE strings.Reader:
  ../GOSRC/strings/reader.go
TYPE strings.Replacer:
  ../GOSRC/strings/replace.go
TYPE suffixarray.Index:
  ../GOSRC/index/suffixarray/suffixarray.go
TYPE sync.Cond:
  ../GOSRC/sync/cond.go
TYPE sync.Locker:
  ../GOSRC/sync/mutex.go
TYPE sync.Map:
  ../GOSRC/sync/map.go
TYPE sync.Mutex:
  ../GOSRC/sync/mutex.go
TYPE sync.Once:
  ../GOSRC/sync/once.go
TYPE sync.Pool:
  ../GOSRC/sync/pool.go
TYPE sync.RWMutex:
  ../GOSRC/sync/rwmutex.go
TYPE sync.WaitGroup:
  ../GOSRC/sync/waitgroup.go
TYPE syntax.EmptyOp:
  ../GOSRC/regexp/syntax/prog.go
TYPE syntax.Error:
  ../GOSRC/regexp/syntax/parse.go
TYPE syntax.ErrorCode:
  ../GOSRC/regexp/syntax/parse.go
TYPE syntax.Flags:
  ../GOSRC/regexp/syntax/parse.go
TYPE syntax.Inst:
  ../GOSRC/regexp/syntax/prog.go
TYPE syntax.InstOp:
  ../GOSRC/regexp/syntax/prog.go
TYPE syntax.Op:
  ../GOSRC/regexp/syntax/regexp.go
TYPE syntax.Prog:
  ../GOSRC/regexp/syntax/prog.go
TYPE syntax.Regexp:
  ../GOSRC/regexp/syntax/regexp.go
TYPE syscall.BpfHdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfInsn:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfProgram:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfStat:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfVersion:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Cmsghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Conn:
  ../GOSRC/syscall/net.go
TYPE syscall.Credential:
  ../GOSRC/syscall/exec_unix.go
TYPE syscall.Dirent:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Errno:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.Fbootstraptransfer_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.FdSet:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Flock_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Fsid:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Fstore_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.ICMPv6Filter:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPMreq:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPv6MTUInfo:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPv6Mreq:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfData:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfMsghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfaMsghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfmaMsghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfmaMsghdr2:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Inet4Pktinfo:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Inet6Pktinfo:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.InterfaceAddrMessage:
  ../GOSRC/syscall/route_bsd.go
TYPE syscall.InterfaceMessage:
  ../GOSRC/syscall/route_bsd.go
TYPE syscall.InterfaceMulticastAddrMessage:
  ../GOSRC/syscall/route_darwin.go
TYPE syscall.Iovec:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Kevent_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Linger:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Log2phys_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Msghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.ProcAttr:
  ../GOSRC/syscall/exec_unix.go
TYPE syscall.Radvisory_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawConn:
  ../GOSRC/syscall/net.go
TYPE syscall.RawSockaddr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrAny:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrDatalink:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrInet4:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrInet6:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrUnix:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Rlimit:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RouteMessage:
  ../GOSRC/syscall/route_bsd.go
TYPE syscall.RoutingMessage:
  ../GOSRC/syscall/route_bsd.go
TYPE syscall.RtMetrics:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.RtMsghdr:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Rusage:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Signal:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.Sockaddr:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.SockaddrDatalink:
  ../GOSRC/syscall/syscall_darwin.go
TYPE syscall.SockaddrInet4:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.SockaddrInet6:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.SockaddrUnix:
  ../GOSRC/syscall/syscall_unix.go
TYPE syscall.SocketControlMessage:
  ../GOSRC/syscall/sockcmsg_unix.go
TYPE syscall.Stat_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Statfs_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.SysProcAttr:
  ../GOSRC/syscall/exec_bsd.go
TYPE syscall.Termios:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timespec:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timeval:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timeval32:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall.WaitStatus:
  ../GOSRC/syscall/syscall_bsd.go
TYPE syscall._C_int:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall._C_long:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall._C_long_long:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall._C_short:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall._Gid_t:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syscall._Socklen:
  ../GOSRC/syscall/ztypes_darwin_amd64.go
TYPE syslog.Priority:
  ../GOSRC/log/syslog/syslog.go
TYPE syslog.Writer:
  ../GOSRC/log/syslog/syslog.go
TYPE tabwriter.Writer:
  ../GOSRC/text/tabwriter/tabwriter.go
TYPE tar.Format:
  ../GOSRC/archive/tar/format.go
TYPE tar.Header:
  ../GOSRC/archive/tar/common.go
TYPE tar.Reader:
  ../GOSRC/archive/tar/reader.go
TYPE tar.Writer:
  ../GOSRC/archive/tar/writer.go
TYPE template.CSS:
  ../GOSRC/html/template/content.go
TYPE template.Error:
  ../GOSRC/html/template/error.go
TYPE template.ErrorCode:
  ../GOSRC/html/template/error.go
TYPE template.ExecError:
  ../GOSRC/text/template/exec.go
TYPE template.FuncMap:
  ../GOSRC/text/template/funcs.go
TYPE template.HTML:
  ../GOSRC/html/template/content.go
TYPE template.HTMLAttr:
  ../GOSRC/html/template/content.go
TYPE template.JS:
  ../GOSRC/html/template/content.go
TYPE template.JSStr:
  ../GOSRC/html/template/content.go
TYPE template.Srcset:
  ../GOSRC/html/template/content.go
TYPE template.Template:
  ../GOSRC/text/template/template.go
TYPE template.URL:
  ../GOSRC/html/template/content.go
TYPE testing.B:
  ../GOSRC/testing/benchmark.go
TYPE testing.BenchmarkResult:
  ../GOSRC/testing/benchmark.go
TYPE testing.Cover:
  ../GOSRC/testing/cover.go
TYPE testing.CoverBlock:
  ../GOSRC/testing/cover.go
TYPE testing.InternalBenchmark:
  ../GOSRC/testing/benchmark.go
TYPE testing.InternalExample:
  ../GOSRC/testing/example.go
TYPE testing.InternalTest:
  ../GOSRC/testing/testing.go
TYPE testing.M:
  ../GOSRC/testing/testing.go
TYPE testing.PB:
  ../GOSRC/testing/benchmark.go
TYPE testing.T:
  ../GOSRC/testing/testing.go
TYPE testing.TB:
  ../GOSRC/testing/testing.go
TYPE textproto.Conn:
  ../GOSRC/net/textproto/textproto.go
TYPE textproto.Error:
  ../GOSRC/net/textproto/textproto.go
TYPE textproto.MIMEHeader:
  ../GOSRC/net/textproto/header.go
TYPE textproto.Pipeline:
  ../GOSRC/net/textproto/pipeline.go
TYPE textproto.ProtocolError:
  ../GOSRC/net/textproto/textproto.go
TYPE textproto.Reader:
  ../GOSRC/net/textproto/reader.go
TYPE textproto.Writer:
  ../GOSRC/net/textproto/writer.go
TYPE time.Duration:
  ../GOSRC/time/time.go
TYPE time.Location:
  ../GOSRC/time/zoneinfo.go
TYPE time.Month:
  ../GOSRC/time/time.go
TYPE time.ParseError:
  ../GOSRC/time/format.go
TYPE time.Ticker:
  ../GOSRC/time/tick.go
TYPE time.Time:
  ../GOSRC/time/time.go
TYPE time.Timer:
  ../GOSRC/time/sleep.go
TYPE time.Weekday:
  ../GOSRC/time/time.go
TYPE tls.Certificate:
  ../GOSRC/crypto/tls/common.go
TYPE tls.CertificateRequestInfo:
  ../GOSRC/crypto/tls/common.go
TYPE tls.ClientAuthType:
  ../GOSRC/crypto/tls/common.go
TYPE tls.ClientHelloInfo:
  ../GOSRC/crypto/tls/common.go
TYPE tls.ClientSessionCache:
  ../GOSRC/crypto/tls/common.go
TYPE tls.ClientSessionState:
  ../GOSRC/crypto/tls/common.go
TYPE tls.Config:
  ../GOSRC/crypto/tls/common.go
TYPE tls.Conn:
  ../GOSRC/crypto/tls/conn.go
TYPE tls.ConnectionState:
  ../GOSRC/crypto/tls/common.go
TYPE tls.CurveID:
  ../GOSRC/crypto/tls/common.go
TYPE tls.RecordHeaderError:
  ../GOSRC/crypto/tls/conn.go
TYPE tls.RenegotiationSupport:
  ../GOSRC/crypto/tls/common.go
TYPE tls.SignatureScheme:
  ../GOSRC/crypto/tls/common.go
TYPE token.File:
  ../GOSRC/go/token/position.go
TYPE token.FileSet:
  ../GOSRC/go/token/position.go
TYPE token.Pos:
  ../GOSRC/go/token/position.go
TYPE token.Position:
  ../GOSRC/go/token/position.go
TYPE token.Token:
  ../GOSRC/go/token/token.go
TYPE trace.Region:
  ../GOSRC/runtime/trace/annotation.go
TYPE trace.Task:
  ../GOSRC/runtime/trace/annotation.go
TYPE transform.NopResetter:
  ../GOSRC/vendor/golang_org/x/text/transform/transform.go
TYPE transform.Reader:
  ../GOSRC/vendor/golang_org/x/text/transform/transform.go
TYPE transform.SpanningTransformer:
  ../GOSRC/vendor/golang_org/x/text/transform/transform.go
TYPE transform.Transformer:
  ../GOSRC/vendor/golang_org/x/text/transform/transform.go
TYPE transform.Writer:
  ../GOSRC/vendor/golang_org/x/text/transform/transform.go
TYPE types.Array:
  ../GOSRC/go/types/type.go
TYPE types.Basic:
  ../GOSRC/go/types/type.go
TYPE types.BasicInfo:
  ../GOSRC/go/types/type.go
TYPE types.BasicKind:
  ../GOSRC/go/types/type.go
TYPE types.Builtin:
  ../GOSRC/go/types/object.go
TYPE types.Chan:
  ../GOSRC/go/types/type.go
TYPE types.ChanDir:
  ../GOSRC/go/types/type.go
TYPE types.Checker:
  ../GOSRC/go/types/check.go
TYPE types.Config:
  ../GOSRC/go/types/api.go
TYPE types.Const:
  ../GOSRC/go/types/object.go
TYPE types.Error:
  ../GOSRC/go/types/api.go
TYPE types.Func:
  ../GOSRC/go/types/object.go
TYPE types.ImportMode:
  ../GOSRC/go/types/api.go
TYPE types.Importer:
  ../GOSRC/go/types/api.go
TYPE types.ImporterFrom:
  ../GOSRC/go/types/api.go
TYPE types.Info:
  ../GOSRC/go/types/api.go
TYPE types.Initializer:
  ../GOSRC/go/types/api.go
TYPE types.Interface:
  ../GOSRC/go/types/type.go
TYPE types.Label:
  ../GOSRC/go/types/object.go
TYPE types.Map:
  ../GOSRC/go/types/type.go
TYPE types.MethodSet:
  ../GOSRC/go/types/methodset.go
TYPE types.Named:
  ../GOSRC/go/types/type.go
TYPE types.Nil:
  ../GOSRC/go/types/object.go
TYPE types.Object:
  ../GOSRC/go/types/object.go
TYPE types.Package:
  ../GOSRC/go/types/package.go
TYPE types.PkgName:
  ../GOSRC/go/types/object.go
TYPE types.Pointer:
  ../GOSRC/go/types/type.go
TYPE types.Qualifier:
  ../GOSRC/go/types/typestring.go
TYPE types.Scope:
  ../GOSRC/go/types/scope.go
TYPE types.Selection:
  ../GOSRC/go/types/selection.go
TYPE types.SelectionKind:
  ../GOSRC/go/types/selection.go
TYPE types.Signature:
  ../GOSRC/go/types/type.go
TYPE types.Sizes:
  ../GOSRC/go/types/sizes.go
TYPE types.Slice:
  ../GOSRC/go/types/type.go
TYPE types.StdSizes:
  ../GOSRC/go/types/sizes.go
TYPE types.Struct:
  ../GOSRC/go/types/type.go
TYPE types.Tuple:
  ../GOSRC/go/types/type.go
TYPE types.Type:
  ../GOSRC/go/types/type.go
TYPE types.TypeAndValue:
  ../GOSRC/go/types/api.go
TYPE types.TypeName:
  ../GOSRC/go/types/object.go
TYPE types.Var:
  ../GOSRC/go/types/object.go
TYPE unicode.CaseRange:
  ../GOSRC/unicode/letter.go
TYPE unicode.Range16:
  ../GOSRC/unicode/letter.go
TYPE unicode.Range32:
  ../GOSRC/unicode/letter.go
TYPE unicode.RangeTable:
  ../GOSRC/unicode/letter.go
TYPE unicode.SpecialCase:
  ../GOSRC/unicode/letter.go
TYPE unsafe.ArbitraryType:
  ../GOSRC/unsafe/unsafe.go
TYPE unsafe.Pointer:
  ../GOSRC/unsafe/unsafe.go
TYPE url.Error:
  ../GOSRC/net/url/url.go
TYPE url.EscapeError:
  ../GOSRC/net/url/url.go
TYPE url.InvalidHostError:
  ../GOSRC/net/url/url.go
TYPE url.URL:
  ../GOSRC/net/url/url.go
TYPE url.Userinfo:
  ../GOSRC/net/url/url.go
TYPE url.Values:
  ../GOSRC/net/url/url.go
TYPE user.Group:
  ../GOSRC/os/user/user.go
TYPE user.UnknownGroupError:
  ../GOSRC/os/user/user.go
TYPE user.UnknownGroupIdError:
  ../GOSRC/os/user/user.go
TYPE user.UnknownUserError:
  ../GOSRC/os/user/user.go
TYPE user.UnknownUserIdError:
  ../GOSRC/os/user/user.go
TYPE user.User:
  ../GOSRC/os/user/user.go
TYPE x509.CertPool:
  ../GOSRC/crypto/x509/cert_pool.go
TYPE x509.Certificate:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.CertificateInvalidError:
  ../GOSRC/crypto/x509/verify.go
TYPE x509.CertificateRequest:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.ConstraintViolationError:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.ExtKeyUsage:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.HostnameError:
  ../GOSRC/crypto/x509/verify.go
TYPE x509.InsecureAlgorithmError:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.InvalidReason:
  ../GOSRC/crypto/x509/verify.go
TYPE x509.KeyUsage:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.PEMCipher:
  ../GOSRC/crypto/x509/pem_decrypt.go
TYPE x509.PublicKeyAlgorithm:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.SignatureAlgorithm:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.SystemRootsError:
  ../GOSRC/crypto/x509/verify.go
TYPE x509.UnhandledCriticalExtension:
  ../GOSRC/crypto/x509/x509.go
TYPE x509.UnknownAuthorityError:
  ../GOSRC/crypto/x509/verify.go
TYPE x509.VerifyOptions:
  ../GOSRC/crypto/x509/verify.go
TYPE xml.Attr:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.CharData:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.Comment:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.Decoder:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.Directive:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.Encoder:
  ../GOSRC/encoding/xml/marshal.go
TYPE xml.EndElement:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.Marshaler:
  ../GOSRC/encoding/xml/marshal.go
TYPE xml.MarshalerAttr:
  ../GOSRC/encoding/xml/marshal.go
TYPE xml.Name:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.ProcInst:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.StartElement:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.SyntaxError:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.TagPathError:
  ../GOSRC/encoding/xml/typeinfo.go
TYPE xml.Token:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.TokenReader:
  ../GOSRC/encoding/xml/xml.go
TYPE xml.UnmarshalError:
  ../GOSRC/encoding/xml/read.go
TYPE xml.Unmarshaler:
  ../GOSRC/encoding/xml/read.go
TYPE xml.UnmarshalerAttr:
  ../GOSRC/encoding/xml/read.go
TYPE xml.UnsupportedTypeError:
  ../GOSRC/encoding/xml/marshal.go
TYPE zip.Compressor:
  ../GOSRC/archive/zip/register.go
TYPE zip.Decompressor:
  ../GOSRC/archive/zip/register.go
TYPE zip.File:
  ../GOSRC/archive/zip/reader.go
TYPE zip.FileHeader:
  ../GOSRC/archive/zip/struct.go
TYPE zip.ReadCloser:
  ../GOSRC/archive/zip/reader.go
TYPE zip.Reader:
  ../GOSRC/archive/zip/reader.go
TYPE zip.Writer:
  ../GOSRC/archive/zip/writer.go
TYPE zlib.Resetter:
  ../GOSRC/compress/zlib/reader.go
TYPE zlib.Writer:
  ../GOSRC/compress/zlib/writer.go
JOKER FUNC adler32.Checksum has:
;; (defn ^ABEND042(cannot find typename adler32.uint32) Checksum
;;   "Checksum returns the Adler-32 checksum of data.\n"
;;   {:added "1.0"
;;    :go "checksum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/adler32/adler32.go:134:20) data])

JOKER FUNC adler32.New has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/adler32/adler32.go:43:12) New
;;   "New returns a new hash.Hash32 computing the Adler-32 checksum. Its\nSum method will lay the value out in big-endian byte order. The\nreturned Hash32 also implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC aes.NewCipher has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/aes/cipher.go:32:29) Error] NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\nThe key argument should be the AES key,\neither 16, 24, or 32 bytes to select\nAES-128, AES-192, or AES-256.\n"
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/aes/cipher.go:32:20) key])

JOKER FUNC ascii85.Decode has:
;; (defn ^[ndst nsrc err] Decode
;;   "Decode decodes src into dst, returning both the number\nof bytes written to dst and the number consumed from src.\nIf src contains invalid ascii85 data, Decode will return the\nnumber of bytes successfully written and a CorruptInputError.\nDecode ignores space and control characters in src.\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nDecode expects these to have been stripped by the caller.\n\nIf flush is true, Decode assumes that src represents the\nend of the input stream and processes it completely rather\nthan wait for the completion of another 32-bit block.\n\nNewDecoder wraps an io.Reader interface around Decode.\n"
;;   {:added "1.0"
;;    :go "decode(dst, src, flush)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/ascii85/ascii85.go:189:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/ascii85/ascii85.go:189:22) src, flush])

JOKER FUNC ascii85.Encode has:
;; (defn ^Int Encode
;;   "Encode encodes src into at most MaxEncodedLen(len(src))\nbytes of dst, returning the actual number of bytes written.\n\nThe encoding handles 4-byte chunks, using a special encoding\nfor the last fragment, so Encode is not appropriate for use on\nindividual blocks of a large data stream. Use NewEncoder() instead.\n\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nEncode does not add these.\n"
;;   {:added "1.0"
;;    :go "encode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/ascii85/ascii85.go:27:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/ascii85/ascii85.go:27:22) src])

JOKER FUNC ascii85.MaxEncodedLen has:
(defn ^Int MaxEncodedLen
  "MaxEncodedLen returns the maximum length of an encoding of n source bytes.\n"
  {:added "1.0"
   :go "maxEncodedLen(n)"}
  [^Int n])

JOKER FUNC ascii85.NewDecoder has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/ascii85/ascii85.go:246:30) NewDecoder
;;   "NewDecoder constructs a new ascii85 stream decoder.\n"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/ascii85/ascii85.go:246:19) r])

JOKER FUNC ascii85.NewEncoder has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/ascii85/ascii85.go:93:30) NewEncoder
;;   "NewEncoder returns a new ascii85 stream encoder. Data written to\nthe returned writer will be encoded and then written to w.\nAscii85 encodings operate in 32-bit blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\ntrailing partial block.\n"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/ascii85/ascii85.go:93:19) w])

JOKER FUNC asn1.Marshal has:
;; (defn ^[[ABEND042(cannot find typename asn1.byte)] Error] Marshal
;;   "Marshal returns the ASN.1 encoding of val.\n\nIn addition to the struct tags recognised by Unmarshal, the following can be\nused:\n\n\tia5:         causes strings to be marshaled as ASN.1, IA5String values\n\tomitempty:   causes empty slices to be skipped\n\tprintable:   causes strings to be marshaled as ASN.1, PrintableString values\n\tutf8:        causes strings to be marshaled as ASN.1, UTF8String values\n\tutc:         causes time.Time to be marshaled as ASN.1, UTCTime values\n\tgeneralized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values\n"
;;   {:added "1.0"
;;    :go "marshal(val)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/marshal.go:677:18) val])

JOKER FUNC asn1.MarshalWithParams has:
;; (defn ^[[ABEND042(cannot find typename asn1.byte)] Error] MarshalWithParams
;;   "MarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n"
;;   {:added "1.0"
;;    :go "marshalWithParams(val, params)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/marshal.go:683:28) val, ^String params])

JOKER FUNC asn1.Unmarshal has:
;; (defn ^[rest err] Unmarshal
;;   "Unmarshal parses the DER-encoded ASN.1 data structure b\nand uses the reflect package to fill in an arbitrary value pointed at by val.\nBecause Unmarshal uses the reflect package, the structs\nbeing written to must use upper case field names.\n\nAn ASN.1 INTEGER can be written to an int, int32, int64,\nor *big.Int (from the math/big package).\nIf the encoded value does not fit in the Go type,\nUnmarshal returns a parse error.\n\nAn ASN.1 BIT STRING can be written to a BitString.\n\nAn ASN.1 OCTET STRING can be written to a []byte.\n\nAn ASN.1 OBJECT IDENTIFIER can be written to an\nObjectIdentifier.\n\nAn ASN.1 ENUMERATED can be written to an Enumerated.\n\nAn ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.\n\nAn ASN.1 PrintableString, IA5String, or NumericString can be written to a string.\n\nAny of the above ASN.1 values can be written to an interface{}.\nThe value stored in the interface has the corresponding Go type.\nFor integers, that type is int64.\n\nAn ASN.1 SEQUENCE OF x or SET OF x can be written\nto a slice if an x can be written to the slice's element type.\n\nAn ASN.1 SEQUENCE or SET can be written to a struct\nif each of the elements in the sequence can be\nwritten to the corresponding element in the struct.\n\nThe following tags on struct fields have special meaning to Unmarshal:\n\n\tapplication specifies that an APPLICATION tag is used\n\tprivate     specifies that a PRIVATE tag is used\n\tdefault:x   sets the default value for optional integer fields (only used if optional is also present)\n\texplicit    specifies that an additional, explicit tag wraps the implicit one\n\toptional    marks the field as ASN.1 OPTIONAL\n\tset         causes a SET, rather than a SEQUENCE type to be expected\n\ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n\nIf the type of the first field of a structure is RawContent then the raw\nASN1 contents of the struct will be stored in it.\n\nIf the type name of a slice element ends with \"SET\" then it's treated as if\nthe \"set\" tag was set on it. This can be used with nested slices where a\nstruct tag cannot be given.\n\nOther ASN.1 types are not supported; if it encounters them,\nUnmarshal returns a parse error.\n"
;;   {:added "1.0"
;;    :go "unmarshal(b, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/asn1/asn1.go:1053:18) b, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/asn1.go:1053:30) val])

JOKER FUNC asn1.UnmarshalWithParams has:
;; (defn ^[rest err] UnmarshalWithParams
;;   "UnmarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n"
;;   {:added "1.0"
;;    :go "unmarshalWithParams(b, val, params)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/asn1/asn1.go:1059:28) b, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/asn1/asn1.go:1059:40) val, ^String params])

JOKER FUNC ast.FileExports has:
;; (defn ^ABEND042(cannot find typename ast.bool) FileExports
;;   "FileExports trims the AST for a Go source file in place such that\nonly exported nodes remain: all top-level identifiers which are not exported\nand their associated information (such as type, initial value, or function\nbody) are removed. Non-exported fields and methods of exported types are\nstripped. The File.Comments list is not changed.\n\nFileExports reports whether there are exported declarations.\n"
;;   {:added "1.0"
;;    :go "fileExports(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:28:22) src])

JOKER FUNC ast.FilterDecl has:
;; (defn ^ABEND042(cannot find typename ast.bool) FilterDecl
;;   "FilterDecl trims the AST for a Go declaration in place by removing\nall names (including struct field and interface method names, but\nnot from parameter lists) that don't pass through the filter f.\n\nFilterDecl reports whether there are any declared names left after\nfiltering.\n"
;;   {:added "1.0"
;;    :go "filterDecl(decl, f)"}
;;   [decl, f])

JOKER FUNC ast.FilterFile has:
;; (defn ^ABEND042(cannot find typename ast.bool) FilterFile
;;   "FilterFile trims the AST for a Go file in place by removing all\nnames from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. Import declarations are\nalways removed. The File.Comments list is not changed.\n\nFilterFile reports whether there are any top-level declarations\nleft after filtering.\n"
;;   {:added "1.0"
;;    :go "filterFile(src, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:258:21) src, f])

JOKER FUNC ast.FilterPackage has:
;; (defn ^ABEND042(cannot find typename ast.bool) FilterPackage
;;   "FilterPackage trims the AST for a Go package in place by removing\nall names from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. The pkg.Files list is not\nchanged, so that file names and top-level package comments don't get\nlost.\n\nFilterPackage reports whether there are any top-level declarations\nleft after filtering.\n"
;;   {:added "1.0"
;;    :go "filterPackage(pkg, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:285:24) pkg, f])

JOKER FUNC ast.Fprint has:
;; (defn ^Error Fprint
;;   "Fprint prints the (sub-)tree starting at AST node x to w.\nIf fset != nil, position information is interpreted relative\nto that file set. Otherwise positions are printed as integer\nvalues (file set specific offsets).\n\nA non-nil FieldFilter f may be provided to control the output:\nstruct fields for which f(fieldname, fieldvalue) is true are\nprinted; all others are filtered from the output. Unexported\nstruct fields are never printed.\n"
;;   {:added "1.0"
;;    :go "fprint(w, fset, x, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/print.go:39:15) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/print.go:39:31) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/print.go:39:49) x, f])

JOKER FUNC ast.Inspect has:
;; (defn Inspect
;;   "Inspect traverses an AST in depth-first order: It starts by calling\nf(node); node must not be nil. If f returns true, Inspect invokes f\nrecursively for each of the non-nil children of node, followed by a\ncall of f(nil).\n"
;;   {:added "1.0"
;;    :go "inspect(node, f)"}
;;   [node, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/ast/walk.go:384:27) f])

JOKER FUNC ast.IsExported has:
;; (defn ^ABEND042(cannot find typename ast.bool) IsExported
;;   "IsExported reports whether name is an exported Go symbol\n(that is, whether it begins with an upper-case letter).\n"
;;   {:added "1.0"
;;    :go "isExported(name)"}
;;   [^String name])

JOKER FUNC ast.MergePackageFiles has:
;; (defn ^{:doc ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/ast.go:987:13) Doc, :package ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:988:13) Package, :name ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/ast.go:989:13) Name, :decls ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/ast/ast.go:990:13) Decls, :scope ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/ast.go:991:13) Scope, :imports ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/ast/ast.go:992:13) Imports, :unresolved ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/ast/ast.go:993:13) Unresolved, :comments ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/ast/ast.go:994:13) Comments} MergePackageFiles
;;   "MergePackageFiles creates a file AST by merging the ASTs of the\nfiles belonging to a package. The mode flags control merging behavior.\n"
;;   {:added "1.0"
;;    :go "mergePackageFiles(pkg, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:344:28) pkg, mode])

JOKER FUNC ast.NewCommentMap has:
;; (defn ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/commentmap.go:35:17) NewCommentMap
;;   "NewCommentMap creates a new comment map by associating comment groups\nof the comments list with the nodes of the AST specified by node.\n\nA comment group g is associated with a node n if:\n\n  - g starts on the same line as n ends\n  - g starts on the line immediately following n, and there is\n    at least one empty line after g and before the next node\n  - g starts before n and is not associated to the node before n\n    via the previous rules\n\nNewCommentMap tries to associate a comment group to the \"largest\"\nnode possible: For instance, if the comment is a line comment\ntrailing an assignment, the comment is associated with the entire\nassignment rather than just the last operand in the assignment.\n"
;;   {:added "1.0"
;;    :go "newCommentMap(fset, node, comments)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/commentmap.go:143:25) fset, node, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/ast/commentmap.go:143:61) comments])

JOKER FUNC ast.NewIdent has:
;; (defn ^{:namepos ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/ast.go:241:11) NamePos, :name ^String Name, :obj ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/ast.go:243:11) Obj} NewIdent
;;   "NewIdent creates a new Ident without position.\nUseful for ASTs generated by code other than the Go parser.\n"
;;   {:added "1.0"
;;    :go "newIdent(name)"}
;;   [^String name])

JOKER FUNC ast.NewObj has:
;; (defn ^{:kind Kind, :name ^String Name, :decl ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:79:7) Decl, :data ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:80:7) Data, :type ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/scope.go:81:7) Type} NewObj
;;   "NewObj creates a new object of a given kind and name.\n"
;;   {:added "1.0"
;;    :go "newObj(kind, name)"}
;;   [kind, ^String name])

JOKER FUNC ast.NewPackage has:
;; (defn ^[{:name ^String Name, :scope ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/ast.go:1010:10) Scope, :imports ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/ast.go:1011:10) Imports, :files ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/ast.go:1012:10) Files} Error] NewPackage
;;   "NewPackage creates a new Package node from a set of File nodes. It resolves\nunresolved identifiers across files and updates each file's Unresolved list\naccordingly. If a non-nil importer and universe scope are provided, they are\nused to resolve identifiers not declared in any of the package files. Any\nremaining unresolved identifiers are reported as undeclared. If the files\nbelong to different packages, one package name is selected and files with\ndifferent package names are reported and then ignored.\nThe result is a package node and a scanner.ErrorList if there were errors.\n"
;;   {:added "1.0"
;;    :go "newPackage(fset, files, importer, universe)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/resolve.go:74:22) fset, ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/resolve.go:74:44) files, importer, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/resolve.go:74:90) universe])

JOKER FUNC ast.NewScope has:
;; (defn ^{:outer ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/scope.go:20:10) Outer, :objects ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/ast/scope.go:21:10) Objects} NewScope
;;   "NewScope creates a new scope nested in the outer scope.\n"
;;   {:added "1.0"
;;    :go "newScope(outer)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/scope.go:25:21) outer])

JOKER FUNC ast.NotNilFilter has:
;; (defn ^ABEND042(cannot find typename ast.bool) NotNilFilter
;;   "NotNilFilter returns true for field values that are not nil;\nit returns false otherwise.\n"
;;   {:added "1.0"
;;    :go "notNilFilter(_, v)"}
;;   [^String _, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/ast/print.go:22:31) v])

JOKER FUNC ast.PackageExports has:
;; (defn ^ABEND042(cannot find typename ast.bool) PackageExports
;;   "PackageExports trims the AST for a Go package in place such that\nonly exported nodes remain. The pkg.Files list is not changed, so that\nfile names and top-level package comments don't get lost.\n\nPackageExports reports whether there are exported declarations;\nit returns false otherwise.\n"
;;   {:added "1.0"
;;    :go "packageExports(pkg)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/filter.go:39:25) pkg])

JOKER FUNC ast.Print has:
;; (defn ^Error Print
;;   "Print prints x to standard output, skipping nil fields.\nPrint(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n"
;;   {:added "1.0"
;;    :go "print(fset, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/print.go:73:17) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/ast/print.go:73:35) x])

JOKER FUNC ast.SortImports has:
;; (defn SortImports
;;   "SortImports sorts runs of consecutive import lines in import blocks in f.\nIt also removes duplicate imports when it is possible to do so without data loss.\n"
;;   {:added "1.0"
;;    :go "sortImports(fset, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/import.go:15:23) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/import.go:15:41) f])

JOKER FUNC ast.Walk has:
;; (defn Walk
;;   "Walk traverses an AST in depth-first order: It starts by calling\nv.Visit(node); node must not be nil. If the visitor w returned by\nv.Visit(node) is not nil, Walk is invoked recursively with visitor\nw for each of the non-nil children of node, followed by a call of\nw.Visit(nil).\n"
;;   {:added "1.0"
;;    :go "walk(v, node)"}
;;   [v, node])

JOKER FUNC atomic.AddInt32 has:
;; (defn ^new AddInt32
;;   "AddInt32 atomically adds delta to *addr and returns the new value.\n"
;;   {:added "1.0"
;;    :go "addInt32(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:92:20) addr, delta])

JOKER FUNC atomic.AddInt64 has:
;; (defn ^new AddInt64
;;   "AddInt64 atomically adds delta to *addr and returns the new value.\n"
;;   {:added "1.0"
;;    :go "addInt64(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:100:20) addr, delta])

JOKER FUNC atomic.AddUint32 has:
;; (defn ^new AddUint32
;;   "AddUint32 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)).\nIn particular, to decrement x, do AddUint32(&x, ^uint32(0)).\n"
;;   {:added "1.0"
;;    :go "addUint32(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:97:21) addr, delta])

JOKER FUNC atomic.AddUint64 has:
;; (defn ^new AddUint64
;;   "AddUint64 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)).\nIn particular, to decrement x, do AddUint64(&x, ^uint64(0)).\n"
;;   {:added "1.0"
;;    :go "addUint64(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:105:21) addr, delta])

JOKER FUNC atomic.AddUintptr has:
;; (defn ^new AddUintptr
;;   "AddUintptr atomically adds delta to *addr and returns the new value.\n"
;;   {:added "1.0"
;;    :go "addUintptr(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:108:22) addr, delta])

JOKER FUNC atomic.CompareAndSwapInt32 has:
;; (defn ^swapped CompareAndSwapInt32
;;   "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.\n"
;;   {:added "1.0"
;;    :go "compareAndSwapInt32(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:74:31) addr, old, new])

JOKER FUNC atomic.CompareAndSwapInt64 has:
;; (defn ^swapped CompareAndSwapInt64
;;   "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.\n"
;;   {:added "1.0"
;;    :go "compareAndSwapInt64(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:77:31) addr, old, new])

JOKER FUNC atomic.CompareAndSwapPointer has:
;; (defn ^swapped CompareAndSwapPointer
;;   "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.\n"
;;   {:added "1.0"
;;    :go "compareAndSwapPointer(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:89:33) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:89:59) old, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:89:59) new])

JOKER FUNC atomic.CompareAndSwapUint32 has:
;; (defn ^swapped CompareAndSwapUint32
;;   "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.\n"
;;   {:added "1.0"
;;    :go "compareAndSwapUint32(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:80:32) addr, old, new])

JOKER FUNC atomic.CompareAndSwapUint64 has:
;; (defn ^swapped CompareAndSwapUint64
;;   "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.\n"
;;   {:added "1.0"
;;    :go "compareAndSwapUint64(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:83:32) addr, old, new])

JOKER FUNC atomic.CompareAndSwapUintptr has:
;; (defn ^swapped CompareAndSwapUintptr
;;   "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.\n"
;;   {:added "1.0"
;;    :go "compareAndSwapUintptr(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:86:33) addr, old, new])

JOKER FUNC atomic.LoadInt32 has:
;; (defn ^val LoadInt32
;;   "LoadInt32 atomically loads *addr.\n"
;;   {:added "1.0"
;;    :go "loadInt32(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:111:21) addr])

JOKER FUNC atomic.LoadInt64 has:
;; (defn ^val LoadInt64
;;   "LoadInt64 atomically loads *addr.\n"
;;   {:added "1.0"
;;    :go "loadInt64(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:114:21) addr])

JOKER FUNC atomic.LoadPointer has:
;; (defn ^val LoadPointer
;;   "LoadPointer atomically loads *addr.\n"
;;   {:added "1.0"
;;    :go "loadPointer(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:126:23) addr])

JOKER FUNC atomic.LoadUint32 has:
;; (defn ^val LoadUint32
;;   "LoadUint32 atomically loads *addr.\n"
;;   {:added "1.0"
;;    :go "loadUint32(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:117:22) addr])

JOKER FUNC atomic.LoadUint64 has:
;; (defn ^val LoadUint64
;;   "LoadUint64 atomically loads *addr.\n"
;;   {:added "1.0"
;;    :go "loadUint64(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:120:22) addr])

JOKER FUNC atomic.LoadUintptr has:
;; (defn ^val LoadUintptr
;;   "LoadUintptr atomically loads *addr.\n"
;;   {:added "1.0"
;;    :go "loadUintptr(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:123:23) addr])

JOKER FUNC atomic.StoreInt32 has:
;; (defn StoreInt32
;;   "StoreInt32 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeInt32(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:129:22) addr, val])

JOKER FUNC atomic.StoreInt64 has:
;; (defn StoreInt64
;;   "StoreInt64 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeInt64(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:132:22) addr, val])

JOKER FUNC atomic.StorePointer has:
;; (defn StorePointer
;;   "StorePointer atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storePointer(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:144:24) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:144:45) val])

JOKER FUNC atomic.StoreUint32 has:
;; (defn StoreUint32
;;   "StoreUint32 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeUint32(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:135:23) addr, val])

JOKER FUNC atomic.StoreUint64 has:
;; (defn StoreUint64
;;   "StoreUint64 atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeUint64(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:138:23) addr, val])

JOKER FUNC atomic.StoreUintptr has:
;; (defn StoreUintptr
;;   "StoreUintptr atomically stores val into *addr.\n"
;;   {:added "1.0"
;;    :go "storeUintptr(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:141:24) addr, val])

JOKER FUNC atomic.SwapInt32 has:
;; (defn ^old SwapInt32
;;   "SwapInt32 atomically stores new into *addr and returns the previous *addr value.\n"
;;   {:added "1.0"
;;    :go "swapInt32(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:56:21) addr, new])

JOKER FUNC atomic.SwapInt64 has:
;; (defn ^old SwapInt64
;;   "SwapInt64 atomically stores new into *addr and returns the previous *addr value.\n"
;;   {:added "1.0"
;;    :go "swapInt64(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:59:21) addr, new])

JOKER FUNC atomic.SwapPointer has:
;; (defn ^old SwapPointer
;;   "SwapPointer atomically stores new into *addr and returns the previous *addr value.\n"
;;   {:added "1.0"
;;    :go "swapPointer(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:71:23) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:71:44) new])

JOKER FUNC atomic.SwapUint32 has:
;; (defn ^old SwapUint32
;;   "SwapUint32 atomically stores new into *addr and returns the previous *addr value.\n"
;;   {:added "1.0"
;;    :go "swapUint32(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:62:22) addr, new])

JOKER FUNC atomic.SwapUint64 has:
;; (defn ^old SwapUint64
;;   "SwapUint64 atomically stores new into *addr and returns the previous *addr value.\n"
;;   {:added "1.0"
;;    :go "swapUint64(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:65:22) addr, new])

JOKER FUNC atomic.SwapUintptr has:
;; (defn ^old SwapUintptr
;;   "SwapUintptr atomically stores new into *addr and returns the previous *addr value.\n"
;;   {:added "1.0"
;;    :go "swapUintptr(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:68:23) addr, new])

JOKER FUNC base32.NewDecoder has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base32/base32.go:530:45) NewDecoder
;;   "NewDecoder constructs a new base32 stream decoder.\n"
;;   {:added "1.0"
;;    :go "newDecoder(enc, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base32/base32.go:530:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base32/base32.go:530:34) r])

JOKER FUNC base32.NewEncoder has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base32/base32.go:259:45) NewEncoder
;;   "NewEncoder returns a new base32 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase32 encodings operate in 5-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n"
;;   {:added "1.0"
;;    :go "newEncoder(enc, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base32/base32.go:259:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base32/base32.go:259:34) w])

JOKER FUNC base32.NewEncoding has:
;; (defn ^{:encode ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/base32/base32.go:24:12) encode, :decodemap ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/base32/base32.go:25:12) decodeMap, :padchar padChar} NewEncoding
;;   "NewEncoding returns a new Encoding defined by the given alphabet,\nwhich must be a 32-byte string.\n"
;;   {:added "1.0"
;;    :go "newEncoding(encoder)"}
;;   [^String encoder])

JOKER FUNC base64.NewDecoder has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base64/base64.go:603:45) NewDecoder
;;   "NewDecoder constructs a new base64 stream decoder.\n"
;;   {:added "1.0"
;;    :go "newDecoder(enc, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base64/base64.go:603:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base64/base64.go:603:34) r])

JOKER FUNC base64.NewEncoder has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base64/base64.go:250:45) NewEncoder
;;   "NewEncoder returns a new base64 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase64 encodings operate in 4-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n"
;;   {:added "1.0"
;;    :go "newEncoder(enc, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/base64/base64.go:250:21) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/base64/base64.go:250:34) w])

JOKER FUNC base64.NewEncoding has:
;; (defn ^{:encode ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/base64/base64.go:24:12) encode, :decodemap ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/base64/base64.go:25:12) decodeMap, :padchar padChar, :strict strict} NewEncoding
;;   "NewEncoding returns a new padded Encoding defined by the given alphabet,\nwhich must be a 64-byte string that does not contain the padding character\nor CR / LF ('\\r', '\\n').\nThe resulting Encoding uses the default padding character ('='),\nwhich may be changed or disabled via WithPadding.\n"
;;   {:added "1.0"
;;    :go "newEncoding(encoder)"}
;;   [^String encoder])

JOKER FUNC bidi.AppendReverse has:
;; (defn ^[ABEND042(cannot find typename bidi.byte)] AppendReverse
;;   "AppendReverse reverses the order of characters of in, appends them to out,\nand returns the result. Modifiers will still follow the runes they modify.\nBrackets are replaced with their counterparts.\n"
;;   {:added "1.0"
;;    :go "appendReverse(out, in)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go:189:28) out, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go:189:28) in])

JOKER FUNC bidi.DefaultDirection has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/bidi.go:55:13) DefaultDirection
;;   "DefaultDirection sets the default direction for a Paragraph. The direction is\noverridden if the text contains directional characters.\n"
;;   {:added "1.0"
;;    :go "defaultDirection(d)"}
;;   [d])

JOKER FUNC bidi.Lookup has:
;; (defn ^[p sz] Lookup
;;   "Lookup returns properties for the first rune in s and the width in bytes of\nits encoding. The size will be 0 if s does not hold enough bytes to complete\nthe encoding.\n"
;;   {:added "1.0"
;;    :go "lookup(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/unicode/bidi/prop.go:87:15) s])

JOKER FUNC bidi.LookupRune has:
(defn ^[p size] LookupRune
  "LookupRune returns properties for r.\n"
  {:added "1.0"
   :go "lookupRune(r)"}
  [r])

JOKER FUNC bidi.LookupString has:
(defn ^[p sz] LookupString
  "LookupString returns properties for the first rune in s and the width in\nbytes of its encoding. The size will be 0 if s does not hold enough bytes to\ncomplete the encoding.\n"
  {:added "1.0"
   :go "lookupString(s)"}
  [^String s])

JOKER FUNC bidi.ReverseString has:
(defn ^String ReverseString
  "ReverseString reverses the order of characters in s and returns a new string.\nModifiers will still follow the runes they modify. Brackets are replaced with\ntheir counterparts.\n"
  {:added "1.0"
   :go "reverseString(s)"}
  [^String s])

JOKER FUNC bidirule.Direction has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go:137:26) Direction
;;   "Direction reports the direction of the given label as defined by RFC 5893.\nThe Bidi Rule does not have to be applied to labels of the category\nLeftToRight.\n"
;;   {:added "1.0"
;;    :go "direction(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go:137:18) b])

JOKER FUNC bidirule.DirectionString has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go:155:32) DirectionString
;;   "DirectionString reports the direction of the given label as defined by RFC\n5893. The Bidi Rule does not have to be applied to labels of the category\nLeftToRight.\n"
;;   {:added "1.0"
;;    :go "directionString(s)"}
;;   [^String s])

JOKER FUNC bidirule.New has:
(defn ^{:state state, :hasrtl hasRTL, :seen ^Int seen} New
  "New returns a Transformer that verifies that input adheres to the Bidi Rule.\n"
  {:added "1.0"
   :go "new()"}
  [])

JOKER FUNC bidirule.Valid has:
;; (defn ^ABEND042(cannot find typename bidirule.bool) Valid
;;   "Valid reports whether b conforms to the BiDi rule.\n"
;;   {:added "1.0"
;;    :go "valid(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/secure/bidirule/bidirule.go:172:14) b])

JOKER FUNC bidirule.ValidString has:
;; (defn ^ABEND042(cannot find typename bidirule.bool) ValidString
;;   "ValidString reports whether s conforms to the BiDi rule.\n"
;;   {:added "1.0"
;;    :go "validString(s)"}
;;   [^String s])

JOKER FUNC big.Jacobi has:
;; (defn ^Int Jacobi
;;   "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.\nThe y argument must be an odd integer.\n"
;;   {:added "1.0"
;;    :go "jacobi(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/math/big/int.go:760:18) x, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/math/big/int.go:760:18) y])

JOKER FUNC big.NewFloat has:
(defn ^{:prec prec, :mode mode, :acc acc, :form form, :neg neg, :mant mant, :exp exp} NewFloat
  "NewFloat allocates and returns a new Float set to x,\nwith precision 53 and rounding mode ToNearestEven.\nNewFloat panics with ErrNaN if x is a NaN.\n"
  {:added "1.0"
   :go "newFloat(x)"}
  [x])

JOKER FUNC big.NewInt has:
(defn ^{:neg neg, :abs abs} NewInt
  "NewInt allocates and returns a new Int set to x.\n"
  {:added "1.0"
   :go "newInt(x)"}
  [x])

JOKER FUNC big.NewRat has:
(defn ^{:a a, :b b} NewRat
  "NewRat creates a new Rat with numerator a and denominator b.\n"
  {:added "1.0"
   :go "newRat(a, b)"}
  [a, b])

JOKER FUNC big.ParseFloat has:
(defn ^[f b err] ParseFloat
  "ParseFloat is like f.Parse(s, base) with f set to the given precision\nand rounding mode.\n"
  {:added "1.0"
   :go "parseFloat(s, base, prec, mode)"}
  [^String s, ^Int base, ^Int prec, mode])

JOKER FUNC binary.PutUvarint has:
;; (defn ^Int PutUvarint
;;   "PutUvarint encodes a uint64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutUvarint will panic.\n"
;;   {:added "1.0"
;;    :go "putUvarint(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/binary/varint.go:41:21) buf, x])

JOKER FUNC binary.PutVarint has:
;; (defn ^Int PutVarint
;;   "PutVarint encodes an int64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutVarint will panic.\n"
;;   {:added "1.0"
;;    :go "putVarint(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/binary/varint.go:78:20) buf, x])

JOKER FUNC binary.Read has:
;; (defn ^Error Read
;;   "Read reads structured binary data from r into data.\nData must be a pointer to a fixed-size value or a slice\nof fixed-size values.\nBytes read from r are decoded using the specified byte order\nand written to successive fields of the data.\nWhen decoding boolean values, a zero byte is decoded as false, and\nany other non-zero byte is decoded as true.\nWhen reading into structs, the field data for fields with\nblank (_) field names is skipped; i.e., blank field names\nmay be used for padding.\nWhen reading into a struct, all non-blank fields must be exported\nor Read may panic.\n\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nRead returns ErrUnexpectedEOF.\n"
;;   {:added "1.0"
;;    :go "read(r, order, data)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/binary/binary.go:161:13) r, order, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/binary/binary.go:161:46) data])

JOKER FUNC binary.ReadUvarint has:
;; (defn ^[ABEND042(cannot find typename binary.uint64) Error] ReadUvarint
;;   "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\n"
;;   {:added "1.0"
;;    :go "readUvarint(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/binary/varint.go:106:20) r])

JOKER FUNC binary.ReadVarint has:
;; (defn ^[ABEND042(cannot find typename binary.int64) Error] ReadVarint
;;   "ReadVarint reads an encoded signed integer from r and returns it as an int64.\n"
;;   {:added "1.0"
;;    :go "readVarint(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/binary/varint.go:126:19) r])

JOKER FUNC binary.Size has:
;; (defn ^Int Size
;;   "Size returns how many bytes Write would generate to encode the value v, which\nmust be a fixed-size value or a slice of fixed-size values, or a pointer to such data.\nIf v is neither of these, Size returns -1.\n"
;;   {:added "1.0"
;;    :go "size(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/binary/binary.go:374:13) v])

JOKER FUNC binary.Uvarint has:
;; (defn ^[ABEND042(cannot find typename binary.uint64) Int] Uvarint
;;   "Uvarint decodes a uint64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n"
;;   {:added "1.0"
;;    :go "uvarint(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/binary/varint.go:60:18) buf])

JOKER FUNC binary.Varint has:
;; (defn ^[ABEND042(cannot find typename binary.int64) Int] Varint
;;   "Varint decodes an int64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 with the following meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n"
;;   {:added "1.0"
;;    :go "varint(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/binary/varint.go:94:17) buf])

JOKER FUNC binary.Write has:
;; (defn ^Error Write
;;   "Write writes the binary representation of data into w.\nData must be a fixed-size value or a slice of fixed-size\nvalues, or a pointer to such data.\nBoolean values encode as one byte: 1 for true, and 0 for false.\nBytes written to w are encoded using the specified byte order\nand read from successive fields of the data.\nWhen writing structs, zero values are written for fields\nwith blank (_) field names.\n"
;;   {:added "1.0"
;;    :go "write(w, order, data)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/binary/binary.go:260:14) w, order, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/binary/binary.go:260:47) data])

JOKER FUNC bits.LeadingZeros has:
(defn ^Int LeadingZeros
  "LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.\n"
  {:added "1.0"
   :go "leadingZeros(x)"}
  [^Int x])

JOKER FUNC bits.LeadingZeros16 has:
(defn ^Int LeadingZeros16
  "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.\n"
  {:added "1.0"
   :go "leadingZeros16(x)"}
  [^Int x])

JOKER FUNC bits.LeadingZeros32 has:
(defn ^Int LeadingZeros32
  "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.\n"
  {:added "1.0"
   :go "leadingZeros32(x)"}
  [x])

JOKER FUNC bits.LeadingZeros64 has:
(defn ^Int LeadingZeros64
  "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.\n"
  {:added "1.0"
   :go "leadingZeros64(x)"}
  [x])

JOKER FUNC bits.LeadingZeros8 has:
(defn ^Int LeadingZeros8
  "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.\n"
  {:added "1.0"
   :go "leadingZeros8(x)"}
  [x])

JOKER FUNC bits.Len has:
(defn ^Int Len
  "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n"
  {:added "1.0"
   :go "len(x)"}
  [^Int x])

JOKER FUNC bits.Len16 has:
(defn ^n Len16
  "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n"
  {:added "1.0"
   :go "len16(x)"}
  [^Int x])

JOKER FUNC bits.Len32 has:
(defn ^n Len32
  "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n"
  {:added "1.0"
   :go "len32(x)"}
  [x])

JOKER FUNC bits.Len64 has:
(defn ^n Len64
  "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n"
  {:added "1.0"
   :go "len64(x)"}
  [x])

JOKER FUNC bits.Len8 has:
(defn ^Int Len8
  "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n"
  {:added "1.0"
   :go "len8(x)"}
  [x])

JOKER FUNC bits.OnesCount has:
(defn ^Int OnesCount
  "OnesCount returns the number of one bits (\"population count\") in x.\n"
  {:added "1.0"
   :go "onesCount(x)"}
  [^Int x])

JOKER FUNC bits.OnesCount16 has:
(defn ^Int OnesCount16
  "OnesCount16 returns the number of one bits (\"population count\") in x.\n"
  {:added "1.0"
   :go "onesCount16(x)"}
  [^Int x])

JOKER FUNC bits.OnesCount32 has:
(defn ^Int OnesCount32
  "OnesCount32 returns the number of one bits (\"population count\") in x.\n"
  {:added "1.0"
   :go "onesCount32(x)"}
  [x])

JOKER FUNC bits.OnesCount64 has:
(defn ^Int OnesCount64
  "OnesCount64 returns the number of one bits (\"population count\") in x.\n"
  {:added "1.0"
   :go "onesCount64(x)"}
  [x])

JOKER FUNC bits.OnesCount8 has:
(defn ^Int OnesCount8
  "OnesCount8 returns the number of one bits (\"population count\") in x.\n"
  {:added "1.0"
   :go "onesCount8(x)"}
  [x])

JOKER FUNC bits.Reverse has:
(defn ^Int Reverse
  "Reverse returns the value of x with its bits in reversed order.\n"
  {:added "1.0"
   :go "reverse(x)"}
  [^Int x])

JOKER FUNC bits.Reverse16 has:
(defn ^Int Reverse16
  "Reverse16 returns the value of x with its bits in reversed order.\n"
  {:added "1.0"
   :go "reverse16(x)"}
  [^Int x])

JOKER FUNC bits.Reverse32 has:
;; (defn ^ABEND042(cannot find typename bits.uint32) Reverse32
;;   "Reverse32 returns the value of x with its bits in reversed order.\n"
;;   {:added "1.0"
;;    :go "reverse32(x)"}
;;   [x])

JOKER FUNC bits.Reverse64 has:
;; (defn ^ABEND042(cannot find typename bits.uint64) Reverse64
;;   "Reverse64 returns the value of x with its bits in reversed order.\n"
;;   {:added "1.0"
;;    :go "reverse64(x)"}
;;   [x])

JOKER FUNC bits.Reverse8 has:
;; (defn ^ABEND042(cannot find typename bits.uint8) Reverse8
;;   "Reverse8 returns the value of x with its bits in reversed order.\n"
;;   {:added "1.0"
;;    :go "reverse8(x)"}
;;   [x])

JOKER FUNC bits.ReverseBytes has:
(defn ^Int ReverseBytes
  "ReverseBytes returns the value of x with its bytes in reversed order.\n"
  {:added "1.0"
   :go "reverseBytes(x)"}
  [^Int x])

JOKER FUNC bits.ReverseBytes16 has:
(defn ^Int ReverseBytes16
  "ReverseBytes16 returns the value of x with its bytes in reversed order.\n"
  {:added "1.0"
   :go "reverseBytes16(x)"}
  [^Int x])

JOKER FUNC bits.ReverseBytes32 has:
;; (defn ^ABEND042(cannot find typename bits.uint32) ReverseBytes32
;;   "ReverseBytes32 returns the value of x with its bytes in reversed order.\n"
;;   {:added "1.0"
;;    :go "reverseBytes32(x)"}
;;   [x])

JOKER FUNC bits.ReverseBytes64 has:
;; (defn ^ABEND042(cannot find typename bits.uint64) ReverseBytes64
;;   "ReverseBytes64 returns the value of x with its bytes in reversed order.\n"
;;   {:added "1.0"
;;    :go "reverseBytes64(x)"}
;;   [x])

JOKER FUNC bits.RotateLeft has:
(defn ^Int RotateLeft
  "RotateLeft returns the value of x rotated left by (k mod UintSize) bits.\nTo rotate x right by k bits, call RotateLeft(x, -k).\n"
  {:added "1.0"
   :go "rotateLeft(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC bits.RotateLeft16 has:
(defn ^Int RotateLeft16
  "RotateLeft16 returns the value of x rotated left by (k mod 16) bits.\nTo rotate x right by k bits, call RotateLeft16(x, -k).\n"
  {:added "1.0"
   :go "rotateLeft16(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC bits.RotateLeft32 has:
;; (defn ^ABEND042(cannot find typename bits.uint32) RotateLeft32
;;   "RotateLeft32 returns the value of x rotated left by (k mod 32) bits.\nTo rotate x right by k bits, call RotateLeft32(x, -k).\n"
;;   {:added "1.0"
;;    :go "rotateLeft32(x, k)"}
;;   [x, ^Int k])

JOKER FUNC bits.RotateLeft64 has:
;; (defn ^ABEND042(cannot find typename bits.uint64) RotateLeft64
;;   "RotateLeft64 returns the value of x rotated left by (k mod 64) bits.\nTo rotate x right by k bits, call RotateLeft64(x, -k).\n"
;;   {:added "1.0"
;;    :go "rotateLeft64(x, k)"}
;;   [x, ^Int k])

JOKER FUNC bits.RotateLeft8 has:
;; (defn ^ABEND042(cannot find typename bits.uint8) RotateLeft8
;;   "RotateLeft8 returns the value of x rotated left by (k mod 8) bits.\nTo rotate x right by k bits, call RotateLeft8(x, -k).\n"
;;   {:added "1.0"
;;    :go "rotateLeft8(x, k)"}
;;   [x, ^Int k])

JOKER FUNC bits.TrailingZeros has:
(defn ^Int TrailingZeros
  "TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.\n"
  {:added "1.0"
   :go "trailingZeros(x)"}
  [^Int x])

JOKER FUNC bits.TrailingZeros16 has:
(defn ^n TrailingZeros16
  "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.\n"
  {:added "1.0"
   :go "trailingZeros16(x)"}
  [^Int x])

JOKER FUNC bits.TrailingZeros32 has:
(defn ^Int TrailingZeros32
  "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.\n"
  {:added "1.0"
   :go "trailingZeros32(x)"}
  [x])

JOKER FUNC bits.TrailingZeros64 has:
(defn ^Int TrailingZeros64
  "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.\n"
  {:added "1.0"
   :go "trailingZeros64(x)"}
  [x])

JOKER FUNC bits.TrailingZeros8 has:
(defn ^Int TrailingZeros8
  "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.\n"
  {:added "1.0"
   :go "trailingZeros8(x)"}
  [x])

JOKER FUNC bufio.NewReadWriter has:
;; (defn ^{} NewReadWriter
;;   "NewReadWriter allocates a new ReadWriter that dispatches to r and w.\n"
;;   {:added "1.0"
;;    :go "newReadWriter(r, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/bufio/bufio.go:743:22) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/bufio/bufio.go:743:33) w])

JOKER FUNC bufio.NewReader has:
;; (defn ^{:buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/bufio.go:32:15) buf, :rd ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:33:15) rd, :r ^Int r, :w ^Int w, :err err, :lastbyte ^Int lastByte, :lastrunesize ^Int lastRuneSize} NewReader
;;   "NewReader returns a new Reader whose buffer has the default size.\n"
;;   {:added "1.0"
;;    :go "newReader(rd)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:61:19) rd])

JOKER FUNC bufio.NewReaderSize has:
;; (defn ^{:buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/bufio.go:32:15) buf, :rd ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:33:15) rd, :r ^Int r, :w ^Int w, :err err, :lastbyte ^Int lastByte, :lastrunesize ^Int lastRuneSize} NewReaderSize
;;   "NewReaderSize returns a new Reader whose buffer has at least the specified\nsize. If the argument io.Reader is already a Reader with large enough\nsize, it returns the underlying Reader.\n"
;;   {:added "1.0"
;;    :go "newReaderSize(rd, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:46:23) rd, ^Int size])

JOKER FUNC bufio.NewScanner has:
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/scan.go:31:15) r, :split split, :maxtokensize ^Int maxTokenSize, :token ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:34:15) token, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:35:15) buf, :start ^Int start, :end ^Int end, :err err, :empties ^Int empties, :scancalled scanCalled, :done done} NewScanner
;;   "NewScanner returns a new Scanner to read from r.\nThe split function defaults to ScanLines.\n"
;;   {:added "1.0"
;;    :go "newScanner(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/scan.go:86:19) r])

JOKER FUNC bufio.NewWriter has:
;; (defn ^{:err err, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/bufio.go:528:6) buf, :n ^Int n, :wr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:530:6) wr} NewWriter
;;   "NewWriter returns a new Writer whose buffer has the default size.\n"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:552:18) w])

JOKER FUNC bufio.NewWriterSize has:
;; (defn ^{:err err, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/bufio.go:528:6) buf, :n ^Int n, :wr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:530:6) wr} NewWriterSize
;;   "NewWriterSize returns a new Writer whose buffer has at least the specified\nsize. If the argument io.Writer is already a Writer with large enough\nsize, it returns the underlying Writer.\n"
;;   {:added "1.0"
;;    :go "newWriterSize(w, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bufio/bufio.go:536:22) w, ^Int size])

JOKER FUNC bufio.ScanBytes has:
;; (defn ^[advance token err] ScanBytes
;;   "ScanBytes is a split function for a Scanner that returns each byte as a token.\n"
;;   {:added "1.0"
;;    :go "scanBytes(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:284:21) data, atEOF])

JOKER FUNC bufio.ScanLines has:
;; (defn ^[advance token err] ScanLines
;;   "ScanLines is a split function for a Scanner that returns each line of\ntext, stripped of any trailing end-of-line marker. The returned line may\nbe empty. The end-of-line marker is one optional carriage return followed\nby one mandatory newline. In regular expression notation, it is `\\r?\\n`.\nThe last non-empty line of input will be returned even if it has no\nnewline.\n"
;;   {:added "1.0"
;;    :go "scanLines(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:345:21) data, atEOF])

JOKER FUNC bufio.ScanRunes has:
;; (defn ^[advance token err] ScanRunes
;;   "ScanRunes is a split function for a Scanner that returns each\nUTF-8-encoded rune as a token. The sequence of runes returned is\nequivalent to that from a range loop over the input as a string, which\nmeans that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\".\nBecause of the Scan interface, this makes it impossible for the client to\ndistinguish correctly encoded replacement runes from encoding errors.\n"
;;   {:added "1.0"
;;    :go "scanRunes(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:299:21) data, atEOF])

JOKER FUNC bufio.ScanWords has:
;; (defn ^[advance token err] ScanWords
;;   "ScanWords is a split function for a Scanner that returns each\nspace-separated word of text, with surrounding spaces deleted. It will\nnever return an empty string. The definition of space is set by\nunicode.IsSpace.\n"
;;   {:added "1.0"
;;    :go "scanWords(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bufio/scan.go:390:21) data, atEOF])

JOKER FUNC build.ArchChar has:
(defn ^[String Error] ArchChar
  "ArchChar returns \"?\" and an error.\nIn earlier versions of Go, the returned string was used to derive\nthe compiler and linker tool names, the default object file suffix,\nand the default linker output name. As of Go 1.5, those strings\nno longer vary by architecture; they are compile, link, .o, and a.out, respectively.\n"
  {:added "1.0"
   :go "archChar(goarch)"}
  [^String goarch])

JOKER FUNC build.Import has:
;; (defn ^[{:dir ^String Dir, :name ^String Name, :importcomment ^String ImportComment, :doc ^String Doc, :importpath ^String ImportPath, :root ^String Root, :srcroot ^String SrcRoot, :pkgroot ^String PkgRoot, :pkgtargetroot ^String PkgTargetRoot, :bindir ^String BinDir, :goroot Goroot, :pkgobj ^String PkgObj, :alltags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:395:16) AllTags, :conflictdir ^String ConflictDir, :binaryonly BinaryOnly, :gofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:400:17) GoFiles, :cgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:401:17) CgoFiles, :ignoredgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:402:17) IgnoredGoFiles, :invalidgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:403:17) InvalidGoFiles, :cfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:404:17) CFiles, :cxxfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:405:17) CXXFiles, :mfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:406:17) MFiles, :hfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:407:17) HFiles, :ffiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:408:17) FFiles, :sfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:409:17) SFiles, :swigfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:410:17) SwigFiles, :swigcxxfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:411:17) SwigCXXFiles, :sysofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:412:17) SysoFiles, :cgocflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:415:15) CgoCFLAGS, :cgocppflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:416:15) CgoCPPFLAGS, :cgocxxflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:417:15) CgoCXXFLAGS, :cgofflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:418:15) CgoFFLAGS, :cgoldflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:419:15) CgoLDFLAGS, :cgopkgconfig ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:420:15) CgoPkgConfig, :imports ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:423:12) Imports, :importpos ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:424:12) ImportPos, :testgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:427:17) TestGoFiles, :testimports ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:428:17) TestImports, :testimportpos ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:429:17) TestImportPos, :xtestgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:430:17) XTestGoFiles, :xtestimports ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:431:17) XTestImports, :xtestimportpos ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:432:17) XTestImportPos} Error] Import
;;   "Import is shorthand for Default.Import.\n"
;;   {:added "1.0"
;;    :go "import(path, srcDir, mode)"}
;;   [^String path, ^String srcDir, mode])

JOKER FUNC build.ImportDir has:
;; (defn ^[{:dir ^String Dir, :name ^String Name, :importcomment ^String ImportComment, :doc ^String Doc, :importpath ^String ImportPath, :root ^String Root, :srcroot ^String SrcRoot, :pkgroot ^String PkgRoot, :pkgtargetroot ^String PkgTargetRoot, :bindir ^String BinDir, :goroot Goroot, :pkgobj ^String PkgObj, :alltags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:395:16) AllTags, :conflictdir ^String ConflictDir, :binaryonly BinaryOnly, :gofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:400:17) GoFiles, :cgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:401:17) CgoFiles, :ignoredgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:402:17) IgnoredGoFiles, :invalidgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:403:17) InvalidGoFiles, :cfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:404:17) CFiles, :cxxfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:405:17) CXXFiles, :mfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:406:17) MFiles, :hfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:407:17) HFiles, :ffiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:408:17) FFiles, :sfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:409:17) SFiles, :swigfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:410:17) SwigFiles, :swigcxxfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:411:17) SwigCXXFiles, :sysofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:412:17) SysoFiles, :cgocflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:415:15) CgoCFLAGS, :cgocppflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:416:15) CgoCPPFLAGS, :cgocxxflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:417:15) CgoCXXFLAGS, :cgofflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:418:15) CgoFFLAGS, :cgoldflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:419:15) CgoLDFLAGS, :cgopkgconfig ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:420:15) CgoPkgConfig, :imports ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:423:12) Imports, :importpos ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:424:12) ImportPos, :testgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:427:17) TestGoFiles, :testimports ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:428:17) TestImports, :testimportpos ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:429:17) TestImportPos, :xtestgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:430:17) XTestGoFiles, :xtestimports ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/build/build.go:431:17) XTestImports, :xtestimportpos ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/build/build.go:432:17) XTestImportPos} Error] ImportDir
;;   "ImportDir is shorthand for Default.ImportDir.\n"
;;   {:added "1.0"
;;    :go "importDir(dir, mode)"}
;;   [^String dir, mode])

JOKER FUNC build.IsLocalImport has:
;; (defn ^ABEND042(cannot find typename build.bool) IsLocalImport
;;   "IsLocalImport reports whether the import path is\na local import path, like \".\", \"..\", \"./foo\", or \"../foo\".\n"
;;   {:added "1.0"
;;    :go "isLocalImport(path)"}
;;   [^String path])

JOKER FUNC bytes.Compare has:
;; (defn ^Int Compare
;;   "Compare returns an integer comparing two byte slices lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\nA nil argument is equivalent to an empty slice.\n"
;;   {:added "1.0"
;;    :go "compare(a, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes_decl.go:24:19) a, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes_decl.go:24:19) b])

JOKER FUNC bytes.Contains has:
;; (defn ^ABEND042(cannot find typename bytes.bool) Contains
;;   "Contains reports whether subslice is within b.\n"
;;   {:added "1.0"
;;    :go "contains(b, subslice)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:72:27) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:72:27) subslice])

JOKER FUNC bytes.ContainsAny has:
;; (defn ^ABEND042(cannot find typename bytes.bool) ContainsAny
;;   "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.\n"
;;   {:added "1.0"
;;    :go "containsAny(b, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:77:20) b, ^String chars])

JOKER FUNC bytes.ContainsRune has:
;; (defn ^ABEND042(cannot find typename bytes.bool) ContainsRune
;;   "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.\n"
;;   {:added "1.0"
;;    :go "containsRune(b, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:82:21) b, r])

JOKER FUNC bytes.Count has:
;; (defn ^Int Count
;;   "Count counts the number of non-overlapping instances of sep in s.\nIf sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n"
;;   {:added "1.0"
;;    :go "count(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:52:19) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:52:19) sep])

JOKER FUNC bytes.Equal has:
;; (defn ^ABEND042(cannot find typename bytes.bool) Equal
;;   "Equal returns a boolean reporting whether a and b\nare the same length and contain the same bytes.\nA nil argument is equivalent to an empty slice.\n"
;;   {:added "1.0"
;;    :go "equal(a, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes_decl.go:17:17) a, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes_decl.go:17:17) b])

JOKER FUNC bytes.EqualFold has:
;; (defn ^ABEND042(cannot find typename bytes.bool) EqualFold
;;   "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n"
;;   {:added "1.0"
;;    :go "equalFold(s, t)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:779:21) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:779:21) t])

JOKER FUNC bytes.Fields has:
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] Fields
;;   "Fields interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of subslices of s or an\nempty slice if s contains only white space.\n"
;;   {:added "1.0"
;;    :go "fields(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:283:15) s])

JOKER FUNC bytes.FieldsFunc has:
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] FieldsFunc
;;   "FieldsFunc interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s at each run of code points c satisfying f(c) and\nreturns a slice of subslices of s. If all code points in s satisfy f(c), or\nlen(s) == 0, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n"
;;   {:added "1.0"
;;    :go "fieldsFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:339:19) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:339:29) f])

JOKER FUNC bytes.HasPrefix has:
;; (defn ^ABEND042(cannot find typename bytes.bool) HasPrefix
;;   "HasPrefix tests whether the byte slice s begins with prefix.\n"
;;   {:added "1.0"
;;    :go "hasPrefix(s, prefix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:410:26) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:410:26) prefix])

JOKER FUNC bytes.HasSuffix has:
;; (defn ^ABEND042(cannot find typename bytes.bool) HasSuffix
;;   "HasSuffix tests whether the byte slice s ends with suffix.\n"
;;   {:added "1.0"
;;    :go "hasSuffix(s, suffix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:415:26) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:415:26) suffix])

JOKER FUNC bytes.Index has:
;; (defn ^Int Index
;;   "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n"
;;   {:added "1.0"
;;    :go "index(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:833:19) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:833:19) sep])

JOKER FUNC bytes.IndexAny has:
;; (defn ^Int IndexAny
;;   "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\nIt returns the byte index of the first occurrence in s of any of the Unicode\ncode points in chars. It returns -1 if chars is empty or if there is no code\npoint in common.\n"
;;   {:added "1.0"
;;    :go "indexAny(s, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:151:17) s, ^String chars])

JOKER FUNC bytes.IndexByte has:
;; (defn ^Int IndexByte
;;   "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\n"
;;   {:added "1.0"
;;    :go "indexByte(b, c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes_decl.go:10:18) b, c])

JOKER FUNC bytes.IndexFunc has:
;; (defn ^Int IndexFunc
;;   "IndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n"
;;   {:added "1.0"
;;    :go "indexFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:603:18) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:603:28) f])

JOKER FUNC bytes.IndexRune has:
;; (defn ^Int IndexRune
;;   "IndexRune interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index of the first occurrence in s of the given rune.\nIt returns -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n"
;;   {:added "1.0"
;;    :go "indexRune(s, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:125:18) s, r])

JOKER FUNC bytes.Join has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Join
;;   "Join concatenates the elements of s to create a new byte slice. The separator\nsep is placed between elements in the resulting slice.\n"
;;   {:added "1.0"
;;    :go "join(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:387:13) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:387:27) sep])

JOKER FUNC bytes.LastIndex has:
;; (defn ^Int LastIndex
;;   "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\n"
;;   {:added "1.0"
;;    :go "lastIndex(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:96:23) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:96:23) sep])

JOKER FUNC bytes.LastIndexAny has:
;; (defn ^Int LastIndexAny
;;   "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\npoints. It returns the byte index of the last occurrence in s of any of\nthe Unicode code points in chars. It returns -1 if chars is empty or if\nthere is no code point in common.\n"
;;   {:added "1.0"
;;    :go "lastIndexAny(s, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:187:21) s, ^String chars])

JOKER FUNC bytes.LastIndexByte has:
;; (defn ^Int LastIndexByte
;;   "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n"
;;   {:added "1.0"
;;    :go "lastIndexByte(s, c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:111:22) s, c])

JOKER FUNC bytes.LastIndexFunc has:
;; (defn ^Int LastIndexFunc
;;   "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the last Unicode\ncode point satisfying f(c), or -1 if none do.\n"
;;   {:added "1.0"
;;    :go "lastIndexFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:610:22) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:610:32) f])

JOKER FUNC bytes.Map has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Map
;;   "Map returns a copy of the byte slice s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the byte slice with no replacement. The characters in s and the\noutput are interpreted as UTF-8-encoded code points.\n"
;;   {:added "1.0"
;;    :go "map(mapping, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:423:18) mapping, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:423:39) s])

JOKER FUNC bytes.NewBuffer has:
;; (defn ^{:buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/buffer.go:18:12) buf, :off ^Int off, :bootstrap ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/buffer.go:20:12) bootstrap, :lastread lastRead} NewBuffer
;;   "NewBuffer creates and initializes a new Buffer using buf as its\ninitial contents. The new Buffer takes ownership of buf, and the\ncaller should not use buf after this call. NewBuffer is intended to\nprepare a Buffer to read existing data. It can also be used to size\nthe internal buffer for writing. To do that, buf should have the\ndesired capacity but a length of zero.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n"
;;   {:added "1.0"
;;    :go "newBuffer(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/buffer.go:450:20) buf])

JOKER FUNC bytes.NewBufferString has:
;; (defn ^{:buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/buffer.go:18:12) buf, :off ^Int off, :bootstrap ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/buffer.go:20:12) bootstrap, :lastread lastRead} NewBufferString
;;   "NewBufferString creates and initializes a new Buffer using string s as its\ninitial contents. It is intended to prepare a buffer to read an existing\nstring.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n"
;;   {:added "1.0"
;;    :go "newBufferString(s)"}
;;   [^String s])

JOKER FUNC bytes.NewReader has:
;; (defn ^{:s ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/reader.go:18:11) s, :i i, :prevrune ^Int prevRune} NewReader
;;   "NewReader returns a new Reader reading from b.\n"
;;   {:added "1.0"
;;    :go "newReader(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/reader.go:156:18) b])

JOKER FUNC bytes.Repeat has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Repeat
;;   "Repeat returns a new byte slice consisting of count copies of b.\n\nIt panics if count is negative or if\nthe result of (len(b) * count) overflows.\n"
;;   {:added "1.0"
;;    :go "repeat(b, count)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:460:15) b, ^Int count])

JOKER FUNC bytes.Replace has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Replace
;;   "Replace returns a copy of the slice s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the slice\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune slice.\nIf n < 0, there is no limit on the number of replacements.\n"
;;   {:added "1.0"
;;    :go "replace(s, old, new, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:741:26) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:741:26) old, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:741:26) new, ^Int n])

JOKER FUNC bytes.Runes has:
;; (defn ^[ABEND042(cannot find typename bytes.rune)] Runes
;;   "Runes interprets s as a sequence of UTF-8-encoded code points.\nIt returns a slice of runes (Unicode code points) equivalent to s.\n"
;;   {:added "1.0"
;;    :go "runes(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:723:14) s])

JOKER FUNC bytes.Split has:
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] Split
;;   "Split slices s into all subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, Split splits after each UTF-8 sequence.\nIt is equivalent to SplitN with a count of -1.\n"
;;   {:added "1.0"
;;    :go "split(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:267:19) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:267:19) sep])

JOKER FUNC bytes.SplitAfter has:
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] SplitAfter
;;   "SplitAfter slices s into all subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfter splits after each UTF-8 sequence.\nIt is equivalent to SplitAfterN with a count of -1.\n"
;;   {:added "1.0"
;;    :go "splitAfter(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:273:24) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:273:24) sep])

JOKER FUNC bytes.SplitAfterN has:
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] SplitAfterN
;;   "SplitAfterN slices s into subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfterN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n"
;;   {:added "1.0"
;;    :go "splitAfterN(s, sep, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:259:25) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:259:25) sep, ^Int n])

JOKER FUNC bytes.SplitN has:
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] SplitN
;;   "SplitN slices s into subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, SplitN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n"
;;   {:added "1.0"
;;    :go "splitN(s, sep, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:250:20) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:250:20) sep, ^Int n])

JOKER FUNC bytes.Title has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Title
;;   "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin\nwords mapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n"
;;   {:added "1.0"
;;    :go "title(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:536:14) s])

JOKER FUNC bytes.ToLower has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToLower
;;   "ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.\n"
;;   {:added "1.0"
;;    :go "toLower(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:484:16) s])

JOKER FUNC bytes.ToLowerSpecial has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToLowerSpecial
;;   "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n"
;;   {:added "1.0"
;;    :go "toLowerSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bytes/bytes.go:497:23) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:497:46) s])

JOKER FUNC bytes.ToTitle has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToTitle
;;   "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.\n"
;;   {:added "1.0"
;;    :go "toTitle(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:487:16) s])

JOKER FUNC bytes.ToTitleSpecial has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToTitleSpecial
;;   "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n"
;;   {:added "1.0"
;;    :go "toTitleSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bytes/bytes.go:503:23) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:503:46) s])

JOKER FUNC bytes.ToUpper has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToUpper
;;   "ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.\n"
;;   {:added "1.0"
;;    :go "toUpper(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:481:16) s])

JOKER FUNC bytes.ToUpperSpecial has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToUpperSpecial
;;   "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n"
;;   {:added "1.0"
;;    :go "toUpperSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/bytes/bytes.go:491:23) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:491:46) s])

JOKER FUNC bytes.Trim has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Trim
;;   "Trim returns a subslice of s by slicing off all leading and\ntrailing UTF-8-encoded code points contained in cutset.\n"
;;   {:added "1.0"
;;    :go "trim(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:699:13) s, ^String cutset])

JOKER FUNC bytes.TrimFunc has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimFunc
;;   "TrimFunc returns a subslice of s by slicing off all leading and trailing\nUTF-8-encoded code points c that satisfy f(c).\n"
;;   {:added "1.0"
;;    :go "trimFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:578:17) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:578:27) f])

JOKER FUNC bytes.TrimLeft has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimLeft
;;   "TrimLeft returns a subslice of s by slicing off all leading\nUTF-8-encoded code points contained in cutset.\n"
;;   {:added "1.0"
;;    :go "trimLeft(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:705:17) s, ^String cutset])

JOKER FUNC bytes.TrimLeftFunc has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimLeftFunc
;;   "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off\nall leading UTF-8-encoded code points c that satisfy f(c).\n"
;;   {:added "1.0"
;;    :go "trimLeftFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:555:21) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:555:31) f])

JOKER FUNC bytes.TrimPrefix has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimPrefix
;;   "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n"
;;   {:added "1.0"
;;    :go "trimPrefix(s, prefix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:584:27) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:584:27) prefix])

JOKER FUNC bytes.TrimRight has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimRight
;;   "TrimRight returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points that are contained in cutset.\n"
;;   {:added "1.0"
;;    :go "trimRight(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:711:18) s, ^String cutset])

JOKER FUNC bytes.TrimRightFunc has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimRightFunc
;;   "TrimRightFunc returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points c that satisfy f(c).\n"
;;   {:added "1.0"
;;    :go "trimRightFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:565:22) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/bytes/bytes.go:565:32) f])

JOKER FUNC bytes.TrimSpace has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimSpace
;;   "TrimSpace returns a subslice of s by slicing off all leading and\ntrailing white space, as defined by Unicode.\n"
;;   {:added "1.0"
;;    :go "trimSpace(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:717:18) s])

JOKER FUNC bytes.TrimSuffix has:
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimSuffix
;;   "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n"
;;   {:added "1.0"
;;    :go "trimSuffix(s, suffix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:593:27) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/bytes/bytes.go:593:27) suffix])

JOKER FUNC bzip2.NewReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/bzip2/bzip2.go:46:29) NewReader
;;   "NewReader returns an io.Reader which decompresses bzip2 data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/bzip2/bzip2.go:46:18) r])

JOKER FUNC cgi.Request has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/cgi/child.go:29:18) Error] Request
;;   "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n"
;;   {:added "1.0"
;;    :go "request()"}
;;   [])

JOKER FUNC cgi.RequestFromMap has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/cgi/child.go:52:49) Error] RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n"
;;   {:added "1.0"
;;    :go "requestFromMap(params)"}
;;   [^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/cgi/child.go:52:28) params])

JOKER FUNC cgi.Serve has:
;; (defn ^Error Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n"
;;   {:added "1.0"
;;    :go "serve(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/cgi/child.go:146:20) handler])

JOKER FUNC cgo._cgo_panic has:
;; (defn _cgo_panic
;;   "go:linkname _cgo_panic _cgo_panic\ngo:cgo_export_static _cgo_panic\ngo:cgo_export_dynamic _cgo_panic\ngo:nosplit\ngo:norace\n"
;;   {:added "1.0"
;;    :go "_cgo_panic(a, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/cgo/callbacks.go:45:19) a, n])

JOKER FUNC cgo._runtime_cgocallback has:
;; (defn _runtime_cgocallback
;;   "cgocallback is defined in runtime\ngo:linkname _runtime_cgocallback runtime.cgocallback\n"
;;   {:added "1.0"
;;    :go "_runtime_cgocallback()"}
;;   [])

JOKER FUNC chacha20poly1305.New has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/crypto/chacha20poly1305/chacha20poly1305.go:26:23) Error] New
;;   "New returns a ChaCha20-Poly1305 AEAD that uses the given, 256-bit key.\n"
;;   {:added "1.0"
;;    :go "new(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/chacha20poly1305/chacha20poly1305.go:26:14) key])

JOKER FUNC cipher.NewCBCDecrypter has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:45:16) NewCBCDecrypter
;;   "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size and must match the iv used to encrypt the data.\n"
;;   {:added "1.0"
;;    :go "newCBCDecrypter(b, iv)"}
;;   [b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cbc.go:105:34) iv])

JOKER FUNC cipher.NewCBCEncrypter has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:45:16) NewCBCEncrypter
;;   "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size.\n"
;;   {:added "1.0"
;;    :go "newCBCEncrypter(b, iv)"}
;;   [b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cbc.go:45:34) iv])

JOKER FUNC cipher.NewCFBDecrypter has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:29:13) NewCFBDecrypter
;;   "NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n"
;;   {:added "1.0"
;;    :go "newCFBDecrypter(block, iv)"}
;;   [block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cfb.go:60:38) iv])

JOKER FUNC cipher.NewCFBEncrypter has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:29:13) NewCFBEncrypter
;;   "NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n"
;;   {:added "1.0"
;;    :go "newCFBEncrypter(block, iv)"}
;;   [block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/cfb.go:53:38) iv])

JOKER FUNC cipher.NewCTR has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:29:13) NewCTR
;;   "NewCTR returns a Stream which encrypts/decrypts using the given Block in\ncounter mode. The length of iv must be the same as the Block's block size.\n"
;;   {:added "1.0"
;;    :go "newCTR(block, iv)"}
;;   [block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/ctr.go:35:29) iv])

JOKER FUNC cipher.NewGCM has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/gcm.go:16:11) Error] NewGCM
;;   "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode\nwith the standard nonce length.\n\nIn general, the GHASH operation performed by this implementation of GCM is not constant-time.\nAn exception is when the underlying Block was created by aes.NewCipher\non systems with hardware support for AES. See the crypto/aes package documentation for details.\n"
;;   {:added "1.0"
;;    :go "newGCM(cipher)"}
;;   [cipher])

JOKER FUNC cipher.NewGCMWithNonceSize has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/gcm.go:16:11) Error] NewGCMWithNonceSize
;;   "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which accepts nonces of the given length.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard nonce lengths. All other users should use\nNewGCM, which is faster and more resistant to misuse.\n"
;;   {:added "1.0"
;;    :go "newGCMWithNonceSize(cipher, size)"}
;;   [cipher, ^Int size])

JOKER FUNC cipher.NewGCMWithTagSize has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/gcm.go:16:11) Error] NewGCMWithTagSize
;;   "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which generates tags with the given length.\n\nTag sizes between 12 and 16 bytes are allowed.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard tag lengths. All other users should use\nNewGCM, which is more resistant to misuse.\n"
;;   {:added "1.0"
;;    :go "newGCMWithTagSize(cipher, tagSize)"}
;;   [cipher, ^Int tagSize])

JOKER FUNC cipher.NewOFB has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/cipher/cipher.go:29:13) NewOFB
;;   "NewOFB returns a Stream that encrypts or decrypts using the block cipher b\nin output feedback mode. The initialization vector iv's length must be equal\nto b's block size.\n"
;;   {:added "1.0"
;;    :go "newOFB(b, iv)"}
;;   [b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/cipher/ofb.go:21:25) iv])

JOKER FUNC cmplx.Abs has:
;; (defn ^ABEND042(cannot find typename cmplx.float64) Abs
;;   "Abs returns the absolute value (also called the modulus) of x.\n"
;;   {:added "1.0"
;;    :go "abs(x)"}
;;   [x])

JOKER FUNC cmplx.Acos has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Acos
;;   "Acos returns the inverse cosine of x.\n"
;;   {:added "1.0"
;;    :go "acos(x)"}
;;   [x])

JOKER FUNC cmplx.Acosh has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n"
;;   {:added "1.0"
;;    :go "acosh(x)"}
;;   [x])

JOKER FUNC cmplx.Asin has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Asin
;;   "Asin returns the inverse sine of x.\n"
;;   {:added "1.0"
;;    :go "asin(x)"}
;;   [x])

JOKER FUNC cmplx.Asinh has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n"
;;   {:added "1.0"
;;    :go "asinh(x)"}
;;   [x])

JOKER FUNC cmplx.Atan has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Atan
;;   "Atan returns the inverse tangent of x.\n"
;;   {:added "1.0"
;;    :go "atan(x)"}
;;   [x])

JOKER FUNC cmplx.Atanh has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n"
;;   {:added "1.0"
;;    :go "atanh(x)"}
;;   [x])

JOKER FUNC cmplx.Conj has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Conj
;;   "Conj returns the complex conjugate of x.\n"
;;   {:added "1.0"
;;    :go "conj(x)"}
;;   [x])

JOKER FUNC cmplx.Cos has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Cos
;;   "Cos returns the cosine of x.\n"
;;   {:added "1.0"
;;    :go "cos(x)"}
;;   [x])

JOKER FUNC cmplx.Cosh has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n"
;;   {:added "1.0"
;;    :go "cosh(x)"}
;;   [x])

JOKER FUNC cmplx.Cot has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Cot
;;   "Cot returns the cotangent of x.\n"
;;   {:added "1.0"
;;    :go "cot(x)"}
;;   [x])

JOKER FUNC cmplx.Exp has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Exp
;;   "Exp returns e**x, the base-e exponential of x.\n"
;;   {:added "1.0"
;;    :go "exp(x)"}
;;   [x])

JOKER FUNC cmplx.Inf has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Inf
;;   "Inf returns a complex infinity, complex(+Inf, +Inf).\n"
;;   {:added "1.0"
;;    :go "inf()"}
;;   [])

JOKER FUNC cmplx.IsInf has:
;; (defn ^ABEND042(cannot find typename cmplx.bool) IsInf
;;   "IsInf returns true if either real(x) or imag(x) is an infinity.\n"
;;   {:added "1.0"
;;    :go "isInf(x)"}
;;   [x])

JOKER FUNC cmplx.IsNaN has:
;; (defn ^ABEND042(cannot find typename cmplx.bool) IsNaN
;;   "IsNaN returns true if either real(x) or imag(x) is NaN\nand neither is an infinity.\n"
;;   {:added "1.0"
;;    :go "isNaN(x)"}
;;   [x])

JOKER FUNC cmplx.Log has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Log
;;   "Log returns the natural logarithm of x.\n"
;;   {:added "1.0"
;;    :go "log(x)"}
;;   [x])

JOKER FUNC cmplx.Log10 has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Log10
;;   "Log10 returns the decimal logarithm of x.\n"
;;   {:added "1.0"
;;    :go "log10(x)"}
;;   [x])

JOKER FUNC cmplx.NaN has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) NaN
;;   "NaN returns a complex ``not-a-number'' value.\n"
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])

JOKER FUNC cmplx.Phase has:
;; (defn ^ABEND042(cannot find typename cmplx.float64) Phase
;;   "Phase returns the phase (also called the argument) of x.\nThe returned value is in the range [-Pi, Pi].\n"
;;   {:added "1.0"
;;    :go "phase(x)"}
;;   [x])

JOKER FUNC cmplx.Polar has:
(defn ^[r ] Polar
  "Polar returns the absolute value r and phase  of x,\nsuch that x = r * e**i.\nThe phase is in the range [-Pi, Pi].\n"
  {:added "1.0"
   :go "polar(x)"}
  [x])

JOKER FUNC cmplx.Pow has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Pow
;;   "Pow returns x**y, the base-x exponential of y.\nFor generalized compatibility with math.Pow:\n\tPow(0, 0) returns 1+0i\n\tPow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.\n"
;;   {:added "1.0"
;;    :go "pow(x, y)"}
;;   [x, y])

JOKER FUNC cmplx.Rect has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Rect
;;   "Rect returns the complex number x with polar coordinates r, .\n"
;;   {:added "1.0"
;;    :go "rect(r, )"}
;;   [r, ])

JOKER FUNC cmplx.Sin has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Sin
;;   "Sin returns the sine of x.\n"
;;   {:added "1.0"
;;    :go "sin(x)"}
;;   [x])

JOKER FUNC cmplx.Sinh has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Sinh
;;   "Sinh returns the hyperbolic sine of x.\n"
;;   {:added "1.0"
;;    :go "sinh(x)"}
;;   [x])

JOKER FUNC cmplx.Sqrt has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Sqrt
;;   "Sqrt returns the square root of x.\nThe result r is chosen so that real(r)  0 and imag(r) has the same sign as imag(x).\n"
;;   {:added "1.0"
;;    :go "sqrt(x)"}
;;   [x])

JOKER FUNC cmplx.Tan has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Tan
;;   "Tan returns the tangent of x.\n"
;;   {:added "1.0"
;;    :go "tan(x)"}
;;   [x])

JOKER FUNC cmplx.Tanh has:
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n"
;;   {:added "1.0"
;;    :go "tanh(x)"}
;;   [x])

JOKER FUNC color.CMYKToRGB has:
;; (defn ^[ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)] CMYKToRGB
;;   "CMYKToRGB converts a CMYK quadruple to an RGB triple.\n"
;;   {:added "1.0"
;;    :go "cMYKToRGB(c, m, y, k)"}
;;   [c, m, y, k])

JOKER FUNC color.ModelFunc has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/image/color/color.go:142:12) ModelFunc
;;   "ModelFunc returns a Model that invokes f to implement the conversion.\n"
;;   {:added "1.0"
;;    :go "modelFunc(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/color/color.go:147:18) f])

JOKER FUNC color.RGBToCMYK has:
;; (defn ^[ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)] RGBToCMYK
;;   "RGBToCMYK converts an RGB triple to a CMYK quadruple.\n"
;;   {:added "1.0"
;;    :go "rGBToCMYK(r, g, b)"}
;;   [r, g, b])

JOKER FUNC color.RGBToYCbCr has:
;; (defn ^[ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)] RGBToYCbCr
;;   "RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\n"
;;   {:added "1.0"
;;    :go "rGBToYCbCr(r, g, b)"}
;;   [r, g, b])

JOKER FUNC color.YCbCrToRGB has:
;; (defn ^[ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)] YCbCrToRGB
;;   "YCbCrToRGB converts a Y'CbCr triple to an RGB triple.\n"
;;   {:added "1.0"
;;    :go "yCbCrToRGB(y, cb, cr)"}
;;   [y, cb, cr])

JOKER FUNC constant.BinaryOp has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) BinaryOp
;;   "BinaryOp returns the result of the binary expression x op y.\nThe operation must be defined for the operands. If one of the\noperands is Unknown, the result is Unknown.\nBinaryOp doesn't handle comparisons or shifts; use Compare\nor Shift instead.\n\nTo force integer division of Int operands, use op == token.QUO_ASSIGN\ninstead of token.QUO; the result is guaranteed to be Int in this case.\nDivision by zero leads to a run-time panic.\n"
;;   {:added "1.0"
;;    :go "binaryOp(x_, op, y_)"}
;;   [x_, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:1011:28) op, y_])

JOKER FUNC constant.BitLen has:
(defn ^Int BitLen
  "BitLen returns the number of bits required to represent\nthe absolute value x in binary representation; x must be an Int or an Unknown.\nIf x is Unknown, the result is 0.\n"
  {:added "1.0"
   :go "bitLen(x)"}
  [x])

JOKER FUNC constant.BoolVal has:
;; (defn ^ABEND042(cannot find typename constant.bool) BoolVal
;;   "BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown.\nIf x is Unknown, the result is false.\n"
;;   {:added "1.0"
;;    :go "boolVal(x)"}
;;   [x])

JOKER FUNC constant.Bytes has:
;; (defn ^[ABEND042(cannot find typename constant.byte)] Bytes
;;   "Bytes returns the bytes for the absolute value of x in little-\nendian binary representation; x must be an Int.\n"
;;   {:added "1.0"
;;    :go "bytes(x)"}
;;   [x])

JOKER FUNC constant.Compare has:
;; (defn ^ABEND042(cannot find typename constant.bool) Compare
;;   "Compare returns the result of the comparison x op y.\nThe comparison must be defined for the operands.\nIf one of the operands is Unknown, the result is\nfalse.\n"
;;   {:added "1.0"
;;    :go "compare(x_, op, y_)"}
;;   [x_, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:1247:27) op, y_])

JOKER FUNC constant.Denom has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) Denom
;;   "Denom returns the denominator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int >= 1.\n"
;;   {:added "1.0"
;;    :go "denom(x)"}
;;   [x])

JOKER FUNC constant.Float32Val has:
;; (defn ^[ABEND042(cannot find typename constant.float32) ABEND042(cannot find typename constant.bool)] Float32Val
;;   "Float32Val is like Float64Val but for float32 instead of float64.\n"
;;   {:added "1.0"
;;    :go "float32Val(x)"}
;;   [x])

JOKER FUNC constant.Float64Val has:
;; (defn ^[ABEND042(cannot find typename constant.float64) ABEND042(cannot find typename constant.bool)] Float64Val
;;   "Float64Val returns the nearest Go float64 value of x and whether the result is exact;\nx must be numeric or an Unknown, but not Complex. For values too small (too close to 0)\nto represent as float64, Float64Val silently underflows to 0. The result sign always\nmatches the sign of x, even for 0.\nIf x is Unknown, the result is (0, false).\n"
;;   {:added "1.0"
;;    :go "float64Val(x)"}
;;   [x])

JOKER FUNC constant.Imag has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) Imag
;;   "Imag returns the imaginary part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n"
;;   {:added "1.0"
;;    :go "imag(x)"}
;;   [x])

JOKER FUNC constant.Int64Val has:
;; (defn ^[ABEND042(cannot find typename constant.int64) ABEND042(cannot find typename constant.bool)] Int64Val
;;   "Int64Val returns the Go int64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n"
;;   {:added "1.0"
;;    :go "int64Val(x)"}
;;   [x])

JOKER FUNC constant.MakeBool has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) MakeBool
;;   "MakeBool returns the Bool value for b.\n"
;;   {:added "1.0"
;;    :go "makeBool(b)"}
;;   [b])

JOKER FUNC constant.MakeFloat64 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) MakeFloat64
;;   "MakeFloat64 returns the Float value for x.\nIf x is not finite, the result is an Unknown.\n"
;;   {:added "1.0"
;;    :go "makeFloat64(x)"}
;;   [x])

JOKER FUNC constant.MakeFromBytes has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) MakeFromBytes
;;   "MakeFromBytes returns the Int value given the bytes of its little-endian\nbinary representation. An empty byte slice argument represents 0.\n"
;;   {:added "1.0"
;;    :go "makeFromBytes(bytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/constant/value.go:621:26) bytes])

JOKER FUNC constant.MakeFromLiteral has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) MakeFromLiteral
;;   "MakeFromLiteral returns the corresponding integer, floating-point,\nimaginary, character, or string value for a Go literal string. The\ntok value must be one of token.INT, token.FLOAT, token.IMAG,\ntoken.CHAR, or token.STRING. The final argument must be zero.\nIf the literal string syntax is invalid, the result is an Unknown.\n"
;;   {:added "1.0"
;;    :go "makeFromLiteral(lit, tok, zero)"}
;;   [^String lit, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:378:38) tok, ^Int zero])

JOKER FUNC constant.MakeImag has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) MakeImag
;;   "MakeImag returns the Complex value x*i;\nx must be Int, Float, or Unknown.\nIf x is Unknown, the result is Unknown.\n"
;;   {:added "1.0"
;;    :go "makeImag(x)"}
;;   [x])

JOKER FUNC constant.MakeInt64 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) MakeInt64
;;   "MakeInt64 returns the Int value for x.\n"
;;   {:added "1.0"
;;    :go "makeInt64(x)"}
;;   [x])

JOKER FUNC constant.MakeString has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) MakeString
;;   "MakeString returns the String value for s.\n"
;;   {:added "1.0"
;;    :go "makeString(s)"}
;;   [^String s])

JOKER FUNC constant.MakeUint64 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) MakeUint64
;;   "MakeUint64 returns the Int value for x.\n"
;;   {:added "1.0"
;;    :go "makeUint64(x)"}
;;   [x])

JOKER FUNC constant.MakeUnknown has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) MakeUnknown
;;   "MakeUnknown returns the Unknown value.\n"
;;   {:added "1.0"
;;    :go "makeUnknown()"}
;;   [])

JOKER FUNC constant.Num has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) Num
;;   "Num returns the numerator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int\nwith the same sign as x.\n"
;;   {:added "1.0"
;;    :go "num(x)"}
;;   [x])

JOKER FUNC constant.Real has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) Real
;;   "Real returns the real part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n"
;;   {:added "1.0"
;;    :go "real(x)"}
;;   [x])

JOKER FUNC constant.Shift has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) Shift
;;   "Shift returns the result of the shift expression x op s\nwith op == token.SHL or token.SHR (<< or >>). x must be\nan Int or an Unknown. If x is Unknown, the result is x.\n"
;;   {:added "1.0"
;;    :go "shift(x, op, s)"}
;;   [x, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:1191:24) op, ^Int s])

JOKER FUNC constant.Sign has:
(defn ^Int Sign
  "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0;\nx must be numeric or Unknown. For complex values x, the sign is 0 if x == 0,\notherwise it is != 0. If x is Unknown, the result is 1.\n"
  {:added "1.0"
   :go "sign(x)"}
  [x])

JOKER FUNC constant.StringVal has:
(defn ^String StringVal
  "StringVal returns the Go string value of x, which must be a String or an Unknown.\nIf x is Unknown, the result is \"\".\n"
  {:added "1.0"
   :go "stringVal(x)"}
  [x])

JOKER FUNC constant.ToComplex has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) ToComplex
;;   "ToComplex converts x to a Complex value if x is representable as a Complex.\nOtherwise it returns an Unknown.\n"
;;   {:added "1.0"
;;    :go "toComplex(x)"}
;;   [x])

JOKER FUNC constant.ToFloat has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) ToFloat
;;   "ToFloat converts x to a Float value if x is representable as a Float.\nOtherwise it returns an Unknown.\n"
;;   {:added "1.0"
;;    :go "toFloat(x)"}
;;   [x])

JOKER FUNC constant.ToInt has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) ToInt
;;   "ToInt converts x to an Int value if x is representable as an Int.\nOtherwise it returns an Unknown.\n"
;;   {:added "1.0"
;;    :go "toInt(x)"}
;;   [x])

JOKER FUNC constant.Uint64Val has:
;; (defn ^[ABEND042(cannot find typename constant.uint64) ABEND042(cannot find typename constant.bool)] Uint64Val
;;   "Uint64Val returns the Go uint64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n"
;;   {:added "1.0"
;;    :go "uint64Val(x)"}
;;   [x])

JOKER FUNC constant.UnaryOp has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/constant/value.go:44:12) UnaryOp
;;   "UnaryOp returns the result of the unary expression op y.\nThe operation must be defined for the operand.\nIf prec > 0 it specifies the ^ (xor) result size in bits.\nIf y is Unknown, the result is Unknown.\n"
;;   {:added "1.0"
;;    :go "unaryOp(op, y, prec)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/constant/value.go:850:17) op, y, ^Int prec])

JOKER FUNC context.Background has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14) Background
;;   "Background returns a non-nil, empty Context. It is never canceled, has no\nvalues, and has no deadline. It is typically used by the main function,\ninitialization, and tests, and as the top-level Context for incoming\nrequests.\n"
;;   {:added "1.0"
;;    :go "background()"}
;;   [])

JOKER FUNC context.TODO has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14) TODO
;;   "TODO returns a non-nil, empty Context. Code should use context.TODO when\nit's unclear which Context to use or it is not yet available (because the\nsurrounding function has not yet been extended to accept a Context\nparameter). TODO is recognized by static analysis tools that determine\nwhether Contexts are propagated correctly in a program.\n"
;;   {:added "1.0"
;;    :go "tODO()"}
;;   [])

JOKER FUNC context.WithCancel has:
(defn ^[ctx cancel] WithCancel
  "WithCancel returns a copy of parent with a new Done channel. The returned\ncontext's Done channel is closed when the returned cancel function is called\nor when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n"
  {:added "1.0"
   :go "withCancel(parent)"}
  [parent])

JOKER FUNC context.WithDeadline has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14) ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/context/context.go:222:17)] WithDeadline
;;   "WithDeadline returns a copy of the parent context with the deadline adjusted\nto be no later than d. If the parent's deadline is already earlier than d,\nWithDeadline(parent, d) is semantically equivalent to parent. The returned\ncontext's Done channel is closed when the deadline expires, when the returned\ncancel function is called, or when the parent context's Done channel is\nclosed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n"
;;   {:added "1.0"
;;    :go "withDeadline(parent, d)"}
;;   [parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/context/context.go:384:37) d])

JOKER FUNC context.WithTimeout has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14) ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/context/context.go:222:17)] WithTimeout
;;   "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete:\n\n\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n\t\treturn slowOperation(ctx)\n\t}\n"
;;   {:added "1.0"
;;    :go "withTimeout(parent, timeout)"}
;;   [parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/context/context.go:451:42) timeout])

JOKER FUNC context.WithValue has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:62:14) WithValue
;;   "WithValue returns a copy of parent in which the value associated with key is\nval.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type\nstring or any other built-in type to avoid collisions between\npackages using context. Users of WithValue should define their own\ntypes for keys. To avoid allocating when assigning to an\ninterface{}, context keys often have concrete type\nstruct{}. Alternatively, exported context key variables' static\ntype should be a pointer or interface.\n"
;;   {:added "1.0"
;;    :go "withValue(parent, key, val)"}
;;   [parent, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:468:41) key, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/context/context.go:468:41) val])

JOKER FUNC cookiejar.New has:
;; (defn ^[{:pslist psList, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/cookiejar/jar.go:64:5) mu, :entries ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/cookiejar/jar.go:68:10) entries, :nextseqnum nextSeqNum} Error] New
;;   "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n"
;;   {:added "1.0"
;;    :go "new(o)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/cookiejar/jar.go:77:12) o])

JOKER FUNC crc32.Checksum has:
;; (defn ^ABEND042(cannot find typename crc32.uint32) Checksum
;;   "Checksum returns the CRC-32 checksum of data\nusing the polynomial represented by the Table.\n"
;;   {:added "1.0"
;;    :go "checksum(data, tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc32/crc32.go:247:20) data, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc32/crc32.go:247:32) tab])

JOKER FUNC crc32.ChecksumIEEE has:
;; (defn ^ABEND042(cannot find typename crc32.uint32) ChecksumIEEE
;;   "ChecksumIEEE returns the CRC-32 checksum of data\nusing the IEEE polynomial.\n"
;;   {:added "1.0"
;;    :go "checksumIEEE(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc32/crc32.go:251:24) data])

JOKER FUNC crc32.MakeTable has:
;; (defn ^[ABEND042(cannot find typename crc32.uint32)] MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n"
;;   {:added "1.0"
;;    :go "makeTable(poly)"}
;;   [poly])

JOKER FUNC crc32.New has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/crc32/crc32.go:147:22) New
;;   "New creates a new hash.Hash32 computing the CRC-32 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash32 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n"
;;   {:added "1.0"
;;    :go "new(tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc32/crc32.go:147:14) tab])

JOKER FUNC crc32.NewIEEE has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/crc32/crc32.go:159:16) NewIEEE
;;   "NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using\nthe IEEE polynomial. Its Sum method will lay the value out in\nbig-endian byte order. The returned Hash32 also implements\nencoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal\nand unmarshal the internal state of the hash.\n"
;;   {:added "1.0"
;;    :go "newIEEE()"}
;;   [])

JOKER FUNC crc32.Update has:
;; (defn ^ABEND042(cannot find typename crc32.uint32) Update
;;   "Update returns the result of adding the bytes in p to the crc.\n"
;;   {:added "1.0"
;;    :go "update(crc, tab, p)"}
;;   [crc, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc32/crc32.go:210:29) tab, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc32/crc32.go:210:39) p])

JOKER FUNC crc64.Checksum has:
;; (defn ^ABEND042(cannot find typename crc64.uint64) Checksum
;;   "Checksum returns the CRC-64 checksum of data\nusing the polynomial represented by the Table.\n"
;;   {:added "1.0"
;;    :go "checksum(data, tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc64/crc64.go:199:20) data, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc64/crc64.go:199:32) tab])

JOKER FUNC crc64.MakeTable has:
;; (defn ^[ABEND042(cannot find typename crc64.uint64)] MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n"
;;   {:added "1.0"
;;    :go "makeTable(poly)"}
;;   [poly])

JOKER FUNC crc64.New has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/crc64/crc64.go:88:22) New
;;   "New creates a new hash.Hash64 computing the CRC-64 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash64 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n"
;;   {:added "1.0"
;;    :go "new(tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc64/crc64.go:88:14) tab])

JOKER FUNC crc64.Update has:
;; (defn ^ABEND042(cannot find typename crc64.uint64) Update
;;   "Update returns the result of adding the bytes in p to the crc.\n"
;;   {:added "1.0"
;;    :go "update(crc, tab, p)"}
;;   [crc, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/hash/crc64/crc64.go:181:29) tab, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/hash/crc64/crc64.go:181:39) p])

JOKER FUNC crypto.RegisterHash has:
;; (defn RegisterHash
;;   "RegisterHash registers a function that returns a new instance of the given\nhash function. This is intended to be called from the init function in\npackages that implement hash functions.\n"
;;   {:added "1.0"
;;    :go "registerHash(h, f)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/crypto.go:100:29) f])

JOKER FUNC cryptobyte.NewBuilder has:
;; (defn ^{:err err, :result ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:25:17) result, :fixedsize fixedSize, :child ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:27:17) child, :offset ^Int offset, :pendinglenlen ^Int pendingLenLen, :pendingisasn1 pendingIsASN1, :incontinuation ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:31:17) inContinuation} NewBuilder
;;   "NewBuilder creates a Builder that appends its output to the given buffer.\nLike append(), the slice will be reallocated if its capacity is exceeded.\nUse Bytes to get the final buffer.\n"
;;   {:added "1.0"
;;    :go "newBuilder(buffer)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:37:24) buffer])

JOKER FUNC cryptobyte.NewFixedBuilder has:
;; (defn ^{:err err, :result ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:25:17) result, :fixedsize fixedSize, :child ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:27:17) child, :offset ^Int offset, :pendinglenlen ^Int pendingLenLen, :pendingisasn1 pendingIsASN1, :incontinuation ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:31:17) inContinuation} NewFixedBuilder
;;   "NewFixedBuilder creates a Builder that appends its output into the given\nbuffer. This builder does not reallocate the output buffer. Writes that\nwould exceed the buffer's capacity are treated as an error.\n"
;;   {:added "1.0"
;;    :go "newFixedBuilder(buffer)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/cryptobyte/builder.go:46:29) buffer])

JOKER FUNC csv.NewReader has:
;; (defn ^{:comma Comma, :comment Comment, :fieldsperrecord ^Int FieldsPerRecord, :lazyquotes LazyQuotes, :trimleadingspace TrimLeadingSpace, :reuserecord ReuseRecord, :trailingcomma TrailingComma, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/csv/reader.go:145:4) r, :numline ^Int numLine, :rawbuffer ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/csv/reader.go:151:12) rawBuffer, :recordbuffer ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/csv/reader.go:157:15) recordBuffer, :fieldindexes ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/csv/reader.go:161:15) fieldIndexes, :lastrecord ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/csv/reader.go:164:13) lastRecord} NewReader
;;   "NewReader returns a new Reader that reads from r.\n"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/csv/reader.go:168:18) r])

JOKER FUNC csv.NewWriter has:
;; (defn ^{:comma Comma, :usecrlf UseCRLF, :w ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/csv/writer.go:27:10) w} NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/csv/writer.go:31:18) w])

JOKER FUNC curve25519.ScalarBaseMult has:
;; (defn ScalarBaseMult
;;   "ScalarBaseMult sets dst to the product in*base where dst and base are the x\ncoordinates of group points, base is the standard generator and all values\nare in little-endian form.\n"
;;   {:added "1.0"
;;    :go "scalarBaseMult(dst, in)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:21:29) dst, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:21:29) in])

JOKER FUNC curve25519.ScalarMult has:
;; (defn ScalarMult
;;   "ScalarMult sets dst to the product in*base where dst and base are the x\ncoordinates of group points and all values are in little-endian form.\n"
;;   {:added "1.0"
;;    :go "scalarMult(dst, in, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31) dst, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31) in, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31) base])

JOKER FUNC debug.FreeOSMemory has:
;; (defn FreeOSMemory
;;   "FreeOSMemory forces a garbage collection followed by an\nattempt to return as much memory to the operating system\nas possible. (Even if this is not called, the runtime gradually\nreturns memory to the operating system in a background task.)\n"
;;   {:added "1.0"
;;    :go "freeOSMemory()"}
;;   [])

JOKER FUNC debug.PrintStack has:
;; (defn PrintStack
;;   "PrintStack prints to standard error the stack trace returned by runtime.Stack.\n"
;;   {:added "1.0"
;;    :go "printStack()"}
;;   [])

JOKER FUNC debug.ReadGCStats has:
;; (defn ReadGCStats
;;   "ReadGCStats reads statistics about garbage collection into stats.\nThe number of entries in the pause history is system-dependent;\nstats.Pause slice will be reused if large enough, reallocated otherwise.\nReadGCStats may use the full capacity of the stats.Pause slice.\nIf stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles\nsummarizing the distribution of pause time. For example, if\nlen(stats.PauseQuantiles) is 5, it will be filled with the minimum,\n25%, 50%, 75%, and maximum pause times.\n"
;;   {:added "1.0"
;;    :go "readGCStats(stats)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/debug/garbage.go:31:24) stats])

JOKER FUNC debug.SetGCPercent has:
(defn ^Int SetGCPercent
  "SetGCPercent sets the garbage collection target percentage:\na collection is triggered when the ratio of freshly allocated data\nto live data remaining after the previous collection reaches this percentage.\nSetGCPercent returns the previous setting.\nThe initial setting is the value of the GOGC environment variable\nat startup, or 100 if the variable is not set.\nA negative percentage disables garbage collection.\n"
  {:added "1.0"
   :go "setGCPercent(percent)"}
  [^Int percent])

JOKER FUNC debug.SetMaxStack has:
(defn ^Int SetMaxStack
  "SetMaxStack sets the maximum amount of memory that\ncan be used by a single goroutine stack.\nIf any goroutine exceeds this limit while growing its stack,\nthe program crashes.\nSetMaxStack returns the previous setting.\nThe initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.\n\nSetMaxStack is useful mainly for limiting the damage done by\ngoroutines that enter an infinite recursion. It only limits future\nstack growth.\n"
  {:added "1.0"
   :go "setMaxStack(bytes)"}
  [^Int bytes])

JOKER FUNC debug.SetMaxThreads has:
(defn ^Int SetMaxThreads
  "SetMaxThreads sets the maximum number of operating system\nthreads that the Go program can use. If it attempts to use more than\nthis many, the program crashes.\nSetMaxThreads returns the previous setting.\nThe initial setting is 10,000 threads.\n\nThe limit controls the number of operating system threads, not the number\nof goroutines. A Go program creates a new thread only when a goroutine\nis ready to run but all the existing threads are blocked in system calls, cgo calls,\nor are locked to other goroutines due to use of runtime.LockOSThread.\n\nSetMaxThreads is useful mainly for limiting the damage done by\nprograms that create an unbounded number of threads. The idea is\nto take down the program before it takes down the operating system.\n"
  {:added "1.0"
   :go "setMaxThreads(threads)"}
  [^Int threads])

JOKER FUNC debug.SetPanicOnFault has:
;; (defn ^ABEND042(cannot find typename debug.bool) SetPanicOnFault
;;   "SetPanicOnFault controls the runtime's behavior when a program faults\nat an unexpected (non-nil) address. Such faults are typically caused by\nbugs such as runtime memory corruption, so the default response is to crash\nthe program. Programs working with memory-mapped files or unsafe\nmanipulation of memory may cause faults at non-nil addresses in less\ndramatic situations; SetPanicOnFault allows such programs to request\nthat the runtime trigger only a panic, not a crash.\nSetPanicOnFault applies only to the current goroutine.\nIt returns the previous setting.\n"
;;   {:added "1.0"
;;    :go "setPanicOnFault(enabled)"}
;;   [enabled])

JOKER FUNC debug.SetTraceback has:
;; (defn SetTraceback
;;   "SetTraceback sets the amount of detail printed by the runtime in\nthe traceback it prints before exiting due to an unrecovered panic\nor an internal runtime error.\nThe level argument takes the same values as the GOTRACEBACK\nenvironment variable. For example, SetTraceback(\"all\") ensure\nthat the program prints all goroutines when it crashes.\nSee the package runtime documentation for details.\nIf SetTraceback is called with a level lower than that of the\nenvironment variable, the call is ignored.\n"
;;   {:added "1.0"
;;    :go "setTraceback(level)"}
;;   [^String level])

JOKER FUNC debug.Stack has:
;; (defn ^[ABEND042(cannot find typename debug.byte)] Stack
;;   "Stack returns a formatted stack trace of the goroutine that calls it.\nIt calls runtime.Stack with a large enough buffer to capture the entire trace.\n"
;;   {:added "1.0"
;;    :go "stack()"}
;;   [])

JOKER FUNC debug.WriteHeapDump has:
;; (defn WriteHeapDump
;;   "WriteHeapDump writes a description of the heap and the objects in\nit to the given file descriptor.\n\nWriteHeapDump suspends the execution of all goroutines until the heap\ndump is completely written.  Thus, the file descriptor must not be\nconnected to a pipe or socket whose other end is in the same Go\nprocess; instead, use a temporary file or network socket.\n\nThe heap dump format is defined at https://golang.org/s/go15heapdump.\n"
;;   {:added "1.0"
;;    :go "writeHeapDump(fd)"}
;;   [fd])

JOKER FUNC des.NewCipher has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/des/cipher.go:29:29) Error] NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\n"
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/des/cipher.go:29:20) key])

JOKER FUNC des.NewTripleDESCipher has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/des/cipher.go:73:38) Error] NewTripleDESCipher
;;   "NewTripleDESCipher creates and returns a new cipher.Block.\n"
;;   {:added "1.0"
;;    :go "newTripleDESCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/des/cipher.go:73:29) key])

JOKER FUNC dnsmessage.NewBuilder has:
;; (defn ^{:msg ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go:912:6) msg, :section section, :header header, :start ^Int start, :compression ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go:926:14) compression} NewBuilder
;;   "NewBuilder creates a new builder with compression disabled.\n\nNote: Most users will want to immediately enable compression with the\nEnableCompression method. See that method's comment for why you may or may\nnot want to enable compression.\n\nThe DNS message is appended to the provided initial buffer buf (which may be\nnil) as it is built. The final message is returned by the (*Builder).Finish\nmethod, which may return the same underlying array if there was sufficient\ncapacity in the slice.\n"
;;   {:added "1.0"
;;    :go "newBuilder(buf, h)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go:939:21) buf, h])

JOKER FUNC dnsmessage.NewName has:
;; (defn ^[{:data ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/dns/dnsmessage/message.go:1528:9) Data, :length Length} Error] NewName
;;   "NewName creates a new Name from a string.\n"
;;   {:added "1.0"
;;    :go "newName(name)"}
;;   [^String name])

JOKER FUNC doc.Examples has:
;; (defn ^[{:name ^String Name, :doc ^String Doc, :code ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/example.go:25:14) Code, :play ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/doc/example.go:26:14) Play, :comments ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/doc/example.go:27:14) Comments, :output ^String Output, :unordered Unordered, :emptyoutput EmptyOutput, :order ^Int Order}] Examples
;;   "Examples returns the examples found in the files, sorted by Name field.\nThe Order fields record the order in which the examples were encountered.\n\nPlayable Examples must be in a package whose name ends in \"_test\".\nAn Example is \"playable\" (the Play field is non-nil) in either of these\ncircumstances:\n  - The example function is self-contained: the function references only\n    identifiers from other packages (or predeclared identifiers, such as\n    \"int\") and the test file does not include a dot import.\n  - The entire test file is the example: the file contains exactly one\n    example function, zero test or benchmark functions, and at least one\n    top-level function, type, variable, or constant declaration other\n    than the example function.\n"
;;   {:added "1.0"
;;    :go "examples(files)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/go/doc/example.go:47:21) files])

JOKER FUNC doc.IsPredeclared has:
;; (defn ^ABEND042(cannot find typename doc.bool) IsPredeclared
;;   "IsPredeclared reports whether s is a predeclared identifier.\n"
;;   {:added "1.0"
;;    :go "isPredeclared(s)"}
;;   [^String s])

JOKER FUNC doc.New has:
;; (defn ^{:doc ^String Doc, :name ^String Name, :importpath ^String ImportPath, :imports ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/doc/doc.go:18:13) Imports, :filenames ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/doc/doc.go:19:13) Filenames, :notes ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/doc/doc.go:20:13) Notes, :bugs ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/doc/doc.go:24:7) Bugs, :consts ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/doc/doc.go:27:9) Consts, :types ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/doc/doc.go:28:9) Types, :vars ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/doc/doc.go:29:9) Vars, :funcs ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/doc/doc.go:30:9) Funcs} New
;;   "New computes the package documentation for the given package AST.\nNew takes ownership of the AST pkg and may edit or overwrite it.\n"
;;   {:added "1.0"
;;    :go "new(pkg, importPath, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/doc/doc.go:94:14) pkg, ^String importPath, mode])

JOKER FUNC doc.Synopsis has:
(defn ^String Synopsis
  "Synopsis returns a cleaned version of the first sentence in s.\nThat sentence ends after the first period followed by space and\nnot preceded by exactly one uppercase letter. The result string\nhas no \\n, \\r, or \\t characters and uses only single spaces between\nwords. If s starts with any of the IllegalPrefixes, the result\nis the empty string.\n"
  {:added "1.0"
   :go "synopsis(s)"}
  [^String s])

JOKER FUNC doc.ToHTML has:
;; (defn ToHTML
;;   "ToHTML converts comment text to formatted HTML.\nThe comment was prepared by DocReader,\nso it is known not to have leading, trailing blank lines\nnor to have trailing spaces at the end of lines.\nThe comment markers have already been removed.\n\nEach span of unindented non-blank lines is converted into\na single paragraph. There is one exception to the rule: a span that\nconsists of a single line, is followed by another paragraph span,\nbegins with a capital letter, and contains no punctuation\nother than parentheses and commas is formatted as a heading.\n\nA span of indented lines is converted into a <pre> block,\nwith the common indent prefix removed.\n\nURLs in the comment text are converted into links; if the URL also appears\nin the words map, the link is taken from the map (if the corresponding map\nvalue is the empty string, the URL is not converted into a link).\n\nGo identifiers that appear in the words map are italicized; if the corresponding\nmap value is not the empty string, it is considered a URL and the word is converted\ninto a link.\n"
;;   {:added "1.0"
;;    :go "toHTML(w, text, words)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/comment.go:308:15) w, ^String text, ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/doc/comment.go:308:45) words])

JOKER FUNC doc.ToText has:
;; (defn ToText
;;   "ToText prepares comment text for presentation in textual output.\nIt wraps paragraphs of text to width or fewer Unicode code points\nand then prefixes each line with the indent. In preformatted sections\n(such as program text), it prefixes each non-blank line with preIndent.\n"
;;   {:added "1.0"
;;    :go "toText(w, text, indent, preIndent, width)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/comment.go:422:15) w, ^String text, ^String indent, ^String preIndent, ^Int width])

JOKER FUNC draw.Draw has:
;; (defn Draw
;;   "Draw calls DrawMask with a nil mask.\n"
;;   {:added "1.0"
;;    :go "draw(dst, r, src, sp, op)"}
;;   [dst, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:24) r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:45) src, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:61) sp, op])

JOKER FUNC draw.DrawMask has:
;; (defn DrawMask
;;   "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r\nin dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.\n"
;;   {:added "1.0"
;;    :go "drawMask(dst, r, src, sp, mask, mp, op)"}
;;   [dst, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:28) r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:49) src, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:65) sp, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:83) mask, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:99) mp, op])

JOKER FUNC driver.IsScanValue has:
;; (defn ^ABEND042(cannot find typename driver.bool) IsScanValue
;;   "IsScanValue is equivalent to IsValue.\nIt exists for compatibility.\n"
;;   {:added "1.0"
;;    :go "isScanValue(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/database/sql/driver/types.go:188:20) v])

JOKER FUNC driver.IsValue has:
;; (defn ^ABEND042(cannot find typename driver.bool) IsValue
;;   "IsValue reports whether v is a valid Value parameter type.\n"
;;   {:added "1.0"
;;    :go "isValue(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/database/sql/driver/types.go:175:16) v])

JOKER FUNC dsa.GenerateKey has:
;; (defn ^Error GenerateKey
;;   "GenerateKey generates a public&private key pair. The Parameters of the\nPrivateKey must already be valid (see GenerateParameters).\n"
;;   {:added "1.0"
;;    :go "generateKey(priv, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:153:23) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/dsa/dsa.go:153:41) rand])

JOKER FUNC dsa.GenerateParameters has:
;; (defn ^Error GenerateParameters
;;   "GenerateParameters puts a random, valid set of DSA parameters into params.\nThis function can take many seconds, even on fast machines.\n"
;;   {:added "1.0"
;;    :go "generateParameters(params, rand, sizes)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:59:32) params, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/dsa/dsa.go:59:50) rand, sizes])

JOKER FUNC dsa.Sign has:
;; (defn ^[r s err] Sign
;;   "Sign signs an arbitrary length hash (which should be the result of hashing a\nlarger message) using the private key, priv. It returns the signature as a\npair of integers. The security of the private key depends on the entropy of\nrand.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nBe aware that calling Sign with an attacker-controlled PrivateKey may\nrequire an arbitrary amount of CPU.\n"
;;   {:added "1.0"
;;    :go "sign(rand, priv, hash)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/dsa/dsa.go:199:16) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:199:32) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/dsa/dsa.go:199:50) hash])

JOKER FUNC dsa.Verify has:
;; (defn ^ABEND042(cannot find typename dsa.bool) Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. It\nreports whether the signature is valid.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n"
;;   {:added "1.0"
;;    :go "verify(pub, hash, r, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:267:17) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/dsa/dsa.go:267:34) hash, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:267:47) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/dsa/dsa.go:267:47) s])

JOKER FUNC dwarf.New has:
;; (defn ^[{:abbrev ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:16:11) abbrev, :aranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:17:11) aranges, :frame ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:18:11) frame, :info ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:19:11) info, :line ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:20:11) line, :pubnames ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:21:11) pubnames, :ranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:22:11) ranges, :str ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:23:11) str, :abbrevcache ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/dwarf/open.go:26:14) abbrevCache, :order ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/dwarf/open.go:27:14) order, :typecache ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/dwarf/open.go:28:14) typeCache, :typesigs ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/dwarf/open.go:29:14) typeSigs, :unit ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:30:14) unit} Error] New
;;   "New returns a new Data object initialized from the given parameters.\nRather than calling this function directly, clients should typically use\nthe DWARF method of the File type of the appropriate package debug/elf,\ndebug/macho, or debug/pe.\n\nThe []byte arguments are the data from the corresponding debug section\nin the object file; for example, for an ELF object, abbrev is the contents of\nthe \".debug_abbrev\" section.\n"
;;   {:added "1.0"
;;    :go "new(abbrev, aranges, frame, info, line, pubnames, ranges, str)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) abbrev, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) aranges, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) frame, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) info, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) line, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) pubnames, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) ranges, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/dwarf/open.go:41:68) str])

JOKER FUNC ecdsa.GenerateKey has:
;; (defn ^[{:d ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:57:4) D} Error] GenerateKey
;;   "GenerateKey generates a public and private key pair.\n"
;;   {:added "1.0"
;;    :go "generateKey(c, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:105:20) c, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:105:41) rand])

JOKER FUNC ecdsa.Sign has:
;; (defn ^[r s err] Sign
;;   "Sign signs a hash (which should be the result of hashing a larger message)\nusing the private key, priv. If the hash is longer than the bit-length of the\nprivate key's curve order, the hash will be truncated to that length.  It\nreturns the signature as a pair of integers. The security of the private key\ndepends on the entropy of rand.\n"
;;   {:added "1.0"
;;    :go "sign(rand, priv, hash)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:16) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:32) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/ecdsa/ecdsa.go:156:50) hash])

JOKER FUNC ecdsa.Verify has:
;; (defn ^ABEND042(cannot find typename ecdsa.bool) Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. Its\nreturn value records whether the signature is valid.\n"
;;   {:added "1.0"
;;    :go "verify(pub, hash, r, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:234:17) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/ecdsa/ecdsa.go:234:34) hash, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:234:47) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/ecdsa/ecdsa.go:234:47) s])

JOKER FUNC elf.NewFile has:
;; (defn ^[{:sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/elf/file.go:53:12) Sections, :progs ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/elf/file.go:54:12) Progs, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:55:12) closer, :gnuneed ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/elf/file.go:56:12) gnuNeed, :gnuversym ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/elf/file.go:57:12) gnuVersym} Error] NewFile
;;   "NewFile creates a new File for accessing an ELF binary in an underlying reader.\nThe ELF binary is expected to start at position 0 in the ReaderAt.\n"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:235:16) r])

JOKER FUNC elf.Open has:
;; (defn ^[{:sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/elf/file.go:53:12) Sections, :progs ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/elf/file.go:54:12) Progs, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/elf/file.go:55:12) closer, :gnuneed ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/elf/file.go:56:12) gnuNeed, :gnuversym ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/elf/file.go:57:12) gnuVersym} Error] Open
;;   "Open opens the named file using os.Open and prepares it for use as an ELF binary.\n"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC elf.R_INFO has:
;; (defn ^ABEND042(cannot find typename elf.uint64) R_INFO
;;   {:added "1.0"
;;    :go "r_INFO(sym, typ)"}
;;   [sym, typ])

JOKER FUNC elf.R_INFO32 has:
;; (defn ^ABEND042(cannot find typename elf.uint32) R_INFO32
;;   {:added "1.0"
;;    :go "r_INFO32(sym, typ)"}
;;   [sym, typ])

JOKER FUNC elf.R_SYM32 has:
;; (defn ^ABEND042(cannot find typename elf.uint32) R_SYM32
;;   {:added "1.0"
;;    :go "r_SYM32(info)"}
;;   [info])

JOKER FUNC elf.R_SYM64 has:
;; (defn ^ABEND042(cannot find typename elf.uint32) R_SYM64
;;   {:added "1.0"
;;    :go "r_SYM64(info)"}
;;   [info])

JOKER FUNC elf.R_TYPE32 has:
;; (defn ^ABEND042(cannot find typename elf.uint32) R_TYPE32
;;   {:added "1.0"
;;    :go "r_TYPE32(info)"}
;;   [info])

JOKER FUNC elf.R_TYPE64 has:
;; (defn ^ABEND042(cannot find typename elf.uint32) R_TYPE64
;;   {:added "1.0"
;;    :go "r_TYPE64(info)"}
;;   [info])

JOKER FUNC elf.ST_BIND has:
(defn ^Int ST_BIND
  {:added "1.0"
   :go "sT_BIND(info)"}
  [info])

JOKER FUNC elf.ST_INFO has:
;; (defn ^ABEND042(cannot find typename elf.uint8) ST_INFO
;;   {:added "1.0"
;;    :go "sT_INFO(bind, typ)"}
;;   [bind, typ])

JOKER FUNC elf.ST_TYPE has:
(defn ^Int ST_TYPE
  {:added "1.0"
   :go "sT_TYPE(info)"}
  [info])

JOKER FUNC elf.ST_VISIBILITY has:
(defn ^Int ST_VISIBILITY
  {:added "1.0"
   :go "sT_VISIBILITY(other)"}
  [other])

JOKER FUNC elliptic.GenerateKey has:
;; (defn ^[priv x y err] GenerateKey
;;   "GenerateKey returns a public/private key pair. The private key is\ngenerated using the given reader, which must return random data.\n"
;;   {:added "1.0"
;;    :go "generateKey(curve, rand)"}
;;   [curve, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/elliptic/elliptic.go:276:36) rand])

JOKER FUNC elliptic.Marshal has:
;; (defn ^[ABEND042(cannot find typename elliptic.byte)] Marshal
;;   "Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.\n"
;;   {:added "1.0"
;;    :go "marshal(curve, x, y)"}
;;   [curve, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/elliptic/elliptic.go:305:32) x, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/elliptic/elliptic.go:305:32) y])

JOKER FUNC elliptic.P224 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/elliptic/elliptic.go:24:12) P224
;;   "P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n\nThe cryptographic operations are implemented using constant-time algorithms.\n"
;;   {:added "1.0"
;;    :go "p224()"}
;;   [])

JOKER FUNC elliptic.P256 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/elliptic/elliptic.go:24:12) P256
;;   "P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n\nThe cryptographic operations are implemented using constant-time algorithms.\n"
;;   {:added "1.0"
;;    :go "p256()"}
;;   [])

JOKER FUNC elliptic.P384 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/elliptic/elliptic.go:24:12) P384
;;   "P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n\nThe cryptographic operations do not use constant-time algorithms.\n"
;;   {:added "1.0"
;;    :go "p384()"}
;;   [])

JOKER FUNC elliptic.P521 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/elliptic/elliptic.go:24:12) P521
;;   "P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n\nThe cryptographic operations do not use constant-time algorithms.\n"
;;   {:added "1.0"
;;    :go "p521()"}
;;   [])

JOKER FUNC elliptic.Unmarshal has:
;; (defn ^[x y] Unmarshal
;;   "Unmarshal converts a point, serialized by Marshal, into an x, y pair.\nIt is an error if the point is not in uncompressed form or is not on the curve.\nOn error, x = nil.\n"
;;   {:added "1.0"
;;    :go "unmarshal(curve, data)"}
;;   [curve, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/elliptic/elliptic.go:321:34) data])

JOKER FUNC errors.New has:
(defn ^Error New
  "New returns an error that formats as the given text.\n"
  {:added "1.0"
   :go "new(text)"}
  [^String text])

JOKER FUNC exec.Command has:
;; (defn ^{:path ^String Path, :args ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:66:7) Args, :env ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:74:6) Env, :dir ^String Dir, :stdin ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:93:8) Stdin, :stdout ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:110:9) Stdout, :stderr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:111:9) Stderr, :extrafiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:118:13) ExtraFiles, :sysprocattr ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/os/exec/exec.go:122:14) SysProcAttr, :process ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/os/exec/exec.go:125:10) Process, :processstate ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/os/exec/exec.go:129:15) ProcessState, :ctx ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:131:18) ctx, :lookpatherr lookPathErr, :finished finished, :childfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:134:18) childFiles, :closeafterstart ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:135:18) closeAfterStart, :closeafterwait ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:136:18) closeAfterWait, :goroutine ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:137:18) goroutine, :errch ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/exec/exec.go:138:18) errch, :waitdone ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/exec/exec.go:139:18) waitDone} Command
;;   "Command returns the Cmd struct to execute the named program with\nthe given arguments.\n\nIt sets only the Path and Args in the returned structure.\n\nIf name contains no path separators, Command uses LookPath to\nresolve name to a complete path if possible. Otherwise it uses name\ndirectly as Path.\n\nThe returned Cmd's Args field is constructed from the command name\nfollowed by the elements of arg, so arg should not include the\ncommand name itself. For example, Command(\"echo\", \"hello\").\nArgs[0] is always name, not the possibly resolved Path.\n"
;;   {:added "1.0"
;;    :go "command(name, arg)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/exec/exec.go:155:31) arg])

JOKER FUNC exec.CommandContext has:
;; (defn ^{:path ^String Path, :args ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:66:7) Args, :env ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:74:6) Env, :dir ^String Dir, :stdin ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:93:8) Stdin, :stdout ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:110:9) Stdout, :stderr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:111:9) Stderr, :extrafiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:118:13) ExtraFiles, :sysprocattr ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/os/exec/exec.go:122:14) SysProcAttr, :process ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/os/exec/exec.go:125:10) Process, :processstate ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/os/exec/exec.go:129:15) ProcessState, :ctx ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:131:18) ctx, :lookpatherr lookPathErr, :finished finished, :childfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:134:18) childFiles, :closeafterstart ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:135:18) closeAfterStart, :closeafterwait ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:136:18) closeAfterWait, :goroutine ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec/exec.go:137:18) goroutine, :errch ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/exec/exec.go:138:18) errch, :waitdone ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/exec/exec.go:139:18) waitDone} CommandContext
;;   "CommandContext is like Command but includes a context.\n\nThe provided context is used to kill the process (by calling\nos.Process.Kill) if the context becomes done before the command\ncompletes on its own.\n"
;;   {:added "1.0"
;;    :go "commandContext(ctx, name, arg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec/exec.go:175:25) ctx, ^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/exec/exec.go:175:59) arg])

JOKER FUNC exec.LookPath has:
(defn ^[String Error] LookPath
  "LookPath searches for an executable named file in the\ndirectories named by the PATH environment variable.\nIf file contains a slash, it is tried directly and the PATH is not consulted.\nThe result may be an absolute path or a path relative to the current directory.\n"
  {:added "1.0"
   :go "lookPath(file)"}
  [^String file])

JOKER FUNC expvar.Do has:
;; (defn Do
;;   "Do calls f for each exported variable.\nThe global variable map is locked during the iteration,\nbut existing entries may be concurrently updated.\n"
;;   {:added "1.0"
;;    :go "do(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/expvar/expvar.go:306:11) f])

JOKER FUNC expvar.Get has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/expvar/expvar.go:40:10) Get
;;   "Get retrieves a named exported variable. It returns nil if the name has\nnot been registered.\n"
;;   {:added "1.0"
;;    :go "get(name)"}
;;   [^String name])

JOKER FUNC expvar.Handler has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/expvar/expvar.go:332:16) Handler
;;   "Handler returns the expvar HTTP Handler.\n\nThis is only needed to install the handler in a non-standard location.\n"
;;   {:added "1.0"
;;    :go "handler()"}
;;   [])

JOKER FUNC expvar.NewFloat has:
(defn ^{:f f} NewFloat
  {:added "1.0"
   :go "newFloat(name)"}
  [^String name])

JOKER FUNC expvar.NewInt has:
(defn ^{:i i} NewInt
  {:added "1.0"
   :go "newInt(name)"}
  [^String name])

JOKER FUNC expvar.NewMap has:
;; (defn ^{:m ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/expvar/expvar.go:102:9) m, :keysmu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/expvar/expvar.go:103:9) keysMu, :keys ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/expvar/expvar.go:104:9) keys} NewMap
;;   {:added "1.0"
;;    :go "newMap(name)"}
;;   [^String name])

JOKER FUNC expvar.NewString has:
;; (defn ^{:s ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/expvar/expvar.go:216:4) s} NewString
;;   {:added "1.0"
;;    :go "newString(name)"}
;;   [^String name])

JOKER FUNC expvar.Publish has:
;; (defn Publish
;;   "Publish declares a named exported variable. This should be called from a\npackage's init function when it creates its Vars. If the name is already\nregistered then this will log.Panic.\n"
;;   {:added "1.0"
;;    :go "publish(name, v)"}
;;   [^String name, v])

JOKER FUNC fcgi.ProcessEnv has:
;; (defn ^ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/fcgi/child.go:358:34) ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n"
;;   {:added "1.0"
;;    :go "processEnv(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fcgi/child.go:358:19) r])

JOKER FUNC fcgi.Serve has:
;; (defn ^Error Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n"
;;   {:added "1.0"
;;    :go "serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fcgi/child.go:331:14) l, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fcgi/child.go:331:36) handler])

JOKER FUNC filepath.Abs has:
(defn ^[String Error] Abs
  "Abs returns an absolute representation of path.\nIf the path is not absolute it will be joined with the current\nworking directory to turn it into an absolute path. The absolute\npath name for a given file is not guaranteed to be unique.\nAbs calls Clean on the result.\n"
  {:added "1.0"
   :go "abs(path)"}
  [^String path])

JOKER FUNC filepath.Base has:
(defn ^String Base
  "Base returns the last element of path.\nTrailing path separators are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of separators, Base returns a single separator.\n"
  {:added "1.0"
   :go "base(path)"}
  [^String path])

JOKER FUNC filepath.Clean has:
(defn ^String Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple Separator elements with a single one.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path,\n\t   assuming Separator is '/'.\n\nThe returned path ends in a slash only if it represents a root directory,\nsuch as \"/\" on Unix or `C:\\` on Windows.\n\nFinally, any occurrences of slash are replaced by Separator.\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n"
  {:added "1.0"
   :go "clean(path)"}
  [^String path])

JOKER FUNC filepath.Dir has:
(defn ^String Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element, Dir calls Clean on the path and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of separators, Dir returns a single separator.\nThe returned path does not end in a separator unless it is the root directory.\n"
  {:added "1.0"
   :go "dir(path)"}
  [^String path])

JOKER FUNC filepath.EvalSymlinks has:
(defn ^[String Error] EvalSymlinks
  "EvalSymlinks returns the path name after the evaluation of any symbolic\nlinks.\nIf path is relative the result will be relative to the current directory,\nunless one of the components is an absolute symbolic link.\nEvalSymlinks calls Clean on the result.\n"
  {:added "1.0"
   :go "evalSymlinks(path)"}
  [^String path])

JOKER FUNC filepath.Ext has:
(defn ^String Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final element of path; it is empty if there is\nno dot.\n"
  {:added "1.0"
   :go "ext(path)"}
  [^String path])

JOKER FUNC filepath.FromSlash has:
(defn ^String FromSlash
  "FromSlash returns the result of replacing each slash ('/') character\nin path with a separator character. Multiple slashes are replaced\nby multiple separators.\n"
  {:added "1.0"
   :go "fromSlash(path)"}
  [^String path])

JOKER FUNC filepath.Glob has:
(defn ^[matches err] Glob
  "Glob returns the names of all files matching pattern or nil\nif there is no matching file. The syntax of patterns is the same\nas in Match. The pattern may describe hierarchical names such as\n/usr/*/bin/ed (assuming the Separator is '/').\n\nGlob ignores file system errors such as I/O errors reading directories.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n"
  {:added "1.0"
   :go "glob(pattern)"}
  [^String pattern])

JOKER FUNC filepath.HasPrefix has:
;; (defn ^ABEND042(cannot find typename filepath.bool) HasPrefix
;;   "HasPrefix exists for historical compatibility and should not be used.\n\nDeprecated: HasPrefix does not respect path boundaries and\ndoes not ignore case when required.\n"
;;   {:added "1.0"
;;    :go "hasPrefix(p, prefix)"}
;;   [^String p, ^String prefix])

JOKER FUNC filepath.IsAbs has:
;; (defn ^ABEND042(cannot find typename filepath.bool) IsAbs
;;   "IsAbs reports whether the path is absolute.\n"
;;   {:added "1.0"
;;    :go "isAbs(path)"}
;;   [^String path])

JOKER FUNC filepath.Join has:
;; (defn ^String Join
;;   "Join joins any number of path elements into a single path, adding\na Separator if necessary. Join calls Clean on the result; in particular,\nall empty strings are ignored.\nOn Windows, the result is a UNC path if and only if the first path\nelement is a UNC path.\n"
;;   {:added "1.0"
;;    :go "join(elem)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/path/filepath/path.go:209:16) elem])

JOKER FUNC filepath.Match has:
(defn ^[matched err] Match
  "Match reports whether name matches the shell file name pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-Separator characters\n\t\t'?'         matches any single non-Separator character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nOn Windows, escaping is disabled. Instead, '\\\\' is treated as\npath separator.\n"
  {:added "1.0"
   :go "match(pattern, name)"}
  [^String pattern, ^String name])

JOKER FUNC filepath.Rel has:
(defn ^[String Error] Rel
  "Rel returns a relative path that is lexically equivalent to targpath when\njoined to basepath with an intervening separator. That is,\nJoin(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.\nOn success, the returned path will always be relative to basepath,\neven if basepath and targpath share no elements.\nAn error is returned if targpath can't be made relative to basepath or if\nknowing the current working directory would be necessary to compute it.\nRel calls Clean on the result.\n"
  {:added "1.0"
   :go "rel(basepath, targpath)"}
  [^String basepath, ^String targpath])

JOKER FUNC filepath.Split has:
(defn ^[dir file] Split
  "Split splits path immediately following the final Separator,\nseparating it into a directory and file name component.\nIf there is no Separator in path, Split returns an empty dir\nand file set to path.\nThe returned values have the property that path = dir+file.\n"
  {:added "1.0"
   :go "split(path)"}
  [^String path])

JOKER FUNC filepath.SplitList has:
(defn ^[String] SplitList
  "SplitList splits a list of paths joined by the OS-specific ListSeparator,\nusually found in PATH or GOPATH environment variables.\nUnlike strings.Split, SplitList returns an empty slice when passed an empty\nstring.\n"
  {:added "1.0"
   :go "splitList(path)"}
  [^String path])

JOKER FUNC filepath.ToSlash has:
(defn ^String ToSlash
  "ToSlash returns the result of replacing each separator character\nin path with a slash ('/') character. Multiple separators are\nreplaced by multiple slashes.\n"
  {:added "1.0"
   :go "toSlash(path)"}
  [^String path])

JOKER FUNC filepath.VolumeName has:
(defn ^String VolumeName
  "VolumeName returns leading volume name.\nGiven \"C:\\foo\\bar\" it returns \"C:\" on Windows.\nGiven \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\".\nOn other platforms it returns \"\".\n"
  {:added "1.0"
   :go "volumeName(path)"}
  [^String path])

JOKER FUNC filepath.Walk has:
(defn ^Error Walk
  "Walk walks the file tree rooted at root, calling walkFn for each file or\ndirectory in the tree, including root. All errors that arise visiting files\nand directories are filtered by walkFn. The files are walked in lexical\norder, which makes the output deterministic but means that for very\nlarge directories Walk can be inefficient.\nWalk does not follow symbolic links.\n"
  {:added "1.0"
   :go "walk(root, walkFn)"}
  [^String root, walkFn])

JOKER FUNC flag.Arg has:
(defn ^String Arg
  "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument\nafter flags have been processed. Arg returns an empty string if the\nrequested element does not exist.\n"
  {:added "1.0"
   :go "arg(i)"}
  [^Int i])

JOKER FUNC flag.Args has:
(defn ^[String] Args
  "Args returns the non-flag command-line arguments.\n"
  {:added "1.0"
   :go "args()"}
  [])

JOKER FUNC flag.Bool has:
;; (defn ^ABEND042(cannot find typename flag.bool) Bool
;;   "Bool defines a bool flag with specified name, default value, and usage string.\nThe return value is the address of a bool variable that stores the value of the flag.\n"
;;   {:added "1.0"
;;    :go "bool(name, value, usage)"}
;;   [^String name, value, ^String usage])

JOKER FUNC flag.BoolVar has:
;; (defn BoolVar
;;   "BoolVar defines a bool flag with specified name, default value, and usage string.\nThe argument p points to a bool variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "boolVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:583:16) p, ^String name, value, ^String usage])

JOKER FUNC flag.Duration has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:783:64) Duration
;;   "Duration defines a time.Duration flag with specified name, default value, and usage string.\nThe return value is the address of a time.Duration variable that stores the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n"
;;   {:added "1.0"
;;    :go "duration(name, value, usage)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:783:34) value, ^String usage])

JOKER FUNC flag.DurationVar has:
;; (defn DurationVar
;;   "DurationVar defines a time.Duration flag with specified name, default value, and usage string.\nThe argument p points to a time.Duration variable in which to store the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n"
;;   {:added "1.0"
;;    :go "durationVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:767:20) p, ^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:767:55) value, ^String usage])

JOKER FUNC flag.Float64 has:
;; (defn ^ABEND042(cannot find typename flag.float64) Float64
;;   "Float64 defines a float64 flag with specified name, default value, and usage string.\nThe return value is the address of a float64 variable that stores the value of the flag.\n"
;;   {:added "1.0"
;;    :go "float64(name, value, usage)"}
;;   [^String name, value, ^String usage])

JOKER FUNC flag.Float64Var has:
;; (defn Float64Var
;;   "Float64Var defines a float64 flag with specified name, default value, and usage string.\nThe argument p points to a float64 variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "float64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:739:19) p, ^String name, value, ^String usage])

JOKER FUNC flag.Int has:
(defn ^Int Int
  "Int defines an int flag with specified name, default value, and usage string.\nThe return value is the address of an int variable that stores the value of the flag.\n"
  {:added "1.0"
   :go "int(name, value, usage)"}
  [^String name, ^Int value, ^String usage])

JOKER FUNC flag.Int64 has:
;; (defn ^ABEND042(cannot find typename flag.int64) Int64
;;   "Int64 defines an int64 flag with specified name, default value, and usage string.\nThe return value is the address of an int64 variable that stores the value of the flag.\n"
;;   {:added "1.0"
;;    :go "int64(name, value, usage)"}
;;   [^String name, value, ^String usage])

JOKER FUNC flag.Int64Var has:
;; (defn Int64Var
;;   "Int64Var defines an int64 flag with specified name, default value, and usage string.\nThe argument p points to an int64 variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "int64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:635:17) p, ^String name, value, ^String usage])

JOKER FUNC flag.IntVar has:
;; (defn IntVar
;;   "IntVar defines an int flag with specified name, default value, and usage string.\nThe argument p points to an int variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "intVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:609:15) p, ^String name, ^Int value, ^String usage])

JOKER FUNC flag.Lookup has:
(defn ^{:name ^String Name, :usage ^String Usage, :value Value, :defvalue ^String DefValue} Lookup
  "Lookup returns the Flag structure of the named command-line flag,\nreturning nil if none exists.\n"
  {:added "1.0"
   :go "lookup(name)"}
  [^String name])

JOKER FUNC flag.NArg has:
(defn ^Int NArg
  "NArg is the number of arguments remaining after flags have been processed.\n"
  {:added "1.0"
   :go "nArg()"}
  [])

JOKER FUNC flag.NFlag has:
(defn ^Int NFlag
  "NFlag returns the number of command-line flags that have been set.\n"
  {:added "1.0"
   :go "nFlag()"}
  [])

JOKER FUNC flag.NewFlagSet has:
;; (defn ^{:usage ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/flag/flag.go:280:8) Usage, :name ^String name, :parsed parsed, :actual ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/flag/flag.go:284:16) actual, :formal ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/flag/flag.go:285:16) formal, :args ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/flag/flag.go:286:16) args, :errorhandling errorHandling, :output ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:288:16) output} NewFlagSet
;;   "NewFlagSet returns a new, empty flag set with the specified name and\nerror handling property. If the name is not empty, it will be printed\nin the default usage message and in error messages.\n"
;;   {:added "1.0"
;;    :go "newFlagSet(name, errorHandling)"}
;;   [^String name, errorHandling])

JOKER FUNC flag.Parse has:
;; (defn Parse
;;   "Parse parses the command-line flags from os.Args[1:]. Must be called\nafter all flags are defined and before flags are accessed by the program.\n"
;;   {:added "1.0"
;;    :go "parse()"}
;;   [])

JOKER FUNC flag.Parsed has:
;; (defn ^ABEND042(cannot find typename flag.bool) Parsed
;;   "Parsed reports whether the command-line flags have been parsed.\n"
;;   {:added "1.0"
;;    :go "parsed()"}
;;   [])

JOKER FUNC flag.PrintDefaults has:
;; (defn PrintDefaults
;;   "PrintDefaults prints, to standard error unless configured otherwise,\na usage message showing the default settings of all defined\ncommand-line flags.\nFor an integer valued flag x, the default output has the form\n\t-x int\n\t\tusage-message-for-x (default 7)\nThe usage message will appear on a separate line for anything but\na bool flag with a one-byte name. For bool flags, the type is\nomitted and if the flag name is one byte the usage message appears\non the same line. The parenthetical default is omitted if the\ndefault is the zero value for the type. The listed type, here int,\ncan be changed by placing a back-quoted name in the flag's usage\nstring; the first such item in the message is taken to be a parameter\nname to show in the message and the back quotes are stripped from\nthe message when displayed. For instance, given\n\tflag.String(\"I\", \"\", \"search `directory` for include files\")\nthe output will be\n\t-I directory\n\t\tsearch directory for include files.\n"
;;   {:added "1.0"
;;    :go "printDefaults()"}
;;   [])

JOKER FUNC flag.Set has:
(defn ^Error Set
  "Set sets the value of the named command-line flag.\n"
  {:added "1.0"
   :go "set(name, value)"}
  [^String name, ^String value])

JOKER FUNC flag.String has:
(defn ^String String
  "String defines a string flag with specified name, default value, and usage string.\nThe return value is the address of a string variable that stores the value of the flag.\n"
  {:added "1.0"
   :go "string(name, value, usage)"}
  [^String name, ^String value, ^String usage])

JOKER FUNC flag.StringVar has:
;; (defn StringVar
;;   "StringVar defines a string flag with specified name, default value, and usage string.\nThe argument p points to a string variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "stringVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:713:18) p, ^String name, ^String value, ^String usage])

JOKER FUNC flag.Uint has:
(defn ^Int Uint
  "Uint defines a uint flag with specified name, default value, and usage string.\nThe return value is the address of a uint variable that stores the value of the flag.\n"
  {:added "1.0"
   :go "uint(name, value, usage)"}
  [^String name, ^Int value, ^String usage])

JOKER FUNC flag.Uint64 has:
;; (defn ^ABEND042(cannot find typename flag.uint64) Uint64
;;   "Uint64 defines a uint64 flag with specified name, default value, and usage string.\nThe return value is the address of a uint64 variable that stores the value of the flag.\n"
;;   {:added "1.0"
;;    :go "uint64(name, value, usage)"}
;;   [^String name, value, ^String usage])

JOKER FUNC flag.Uint64Var has:
;; (defn Uint64Var
;;   "Uint64Var defines a uint64 flag with specified name, default value, and usage string.\nThe argument p points to a uint64 variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "uint64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:687:18) p, ^String name, value, ^String usage])

JOKER FUNC flag.UintVar has:
;; (defn UintVar
;;   "UintVar defines a uint flag with specified name, default value, and usage string.\nThe argument p points to a uint variable in which to store the value of the flag.\n"
;;   {:added "1.0"
;;    :go "uintVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:661:16) p, ^String name, ^Int value, ^String usage])

JOKER FUNC flag.UnquoteUsage has:
;; (defn ^[name usage] UnquoteUsage
;;   "UnquoteUsage extracts a back-quoted name from the usage\nstring for a flag and returns it and the un-quoted usage.\nGiven \"a `name` to show\" it returns (\"name\", \"a name to show\").\nIf there are no back quotes, the name is an educated guess of the\ntype of the flag's value, or the empty string if the flag is boolean.\n"
;;   {:added "1.0"
;;    :go "unquoteUsage(flag)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:422:24) flag])

JOKER FUNC flag.Var has:
;; (defn Var
;;   "Var defines a flag with the specified name and usage string. The type and\nvalue of the flag are represented by the first argument, of type Value, which\ntypically holds a user-defined implementation of Value. For instance, the\ncaller could create a flag that turns a comma-separated string into a slice\nof strings by giving the slice the methods of Value; in particular, Set would\ndecompose the comma-separated string into the slice.\n"
;;   {:added "1.0"
;;    :go "var(value, name, usage)"}
;;   [value, ^String name, ^String usage])

JOKER FUNC flag.Visit has:
;; (defn Visit
;;   "Visit visits the command-line flags in lexicographical order, calling fn\nfor each. It visits only those flags that have been set.\n"
;;   {:added "1.0"
;;    :go "visit(fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/flag/flag.go:364:15) fn])

JOKER FUNC flag.VisitAll has:
;; (defn VisitAll
;;   "VisitAll visits the command-line flags in lexicographical order, calling\nfn for each. It visits all flags, even those not set.\n"
;;   {:added "1.0"
;;    :go "visitAll(fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/flag/flag.go:350:18) fn])

JOKER FUNC flate.NewReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/inflate.go:796:29) NewReader
;;   "NewReader returns a new ReadCloser that can be used\nto read the uncompressed version of r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser\nwhen finished reading.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/inflate.go:796:18) r])

JOKER FUNC flate.NewReaderDict has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/inflate.go:815:46) NewReaderDict
;;   "NewReaderDict is like NewReader but initializes the reader\nwith a preset dictionary. The returned Reader behaves as if\nthe uncompressed data stream started with the given dictionary,\nwhich has already been read. NewReaderDict is typically used\nto read data compressed by NewWriterDict.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n"
;;   {:added "1.0"
;;    :go "newReaderDict(r, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/inflate.go:815:22) r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/flate/inflate.go:815:38) dict])

JOKER FUNC flate.NewWriter has:
;; (defn ^[{:d d, :dict ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/flate/deflate.go:703:7) dict} Error] NewWriter
;;   "NewWriter returns a new Writer compressing data at the given level.\nFollowing zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\nhigher levels typically run slower but compress more. Level 0\n(NoCompression) does not attempt any compression; it only adds the\nnecessary DEFLATE framing.\nLevel -1 (DefaultCompression) uses the default compression level.\nLevel -2 (HuffmanOnly) will use Huffman compression only, giving\na very fast compression for all types of input, but sacrificing considerable\ncompression efficiency.\n\nIf level is in the range [-2, 9] then the error returned will be nil.\nOtherwise the error returned will be non-nil.\n"
;;   {:added "1.0"
;;    :go "newWriter(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/deflate.go:666:18) w, ^Int level])

JOKER FUNC flate.NewWriterDict has:
;; (defn ^[{:d d, :dict ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/flate/deflate.go:703:7) dict} Error] NewWriterDict
;;   "NewWriterDict is like NewWriter but initializes the new\nWriter with a preset dictionary. The returned Writer behaves\nas if the dictionary had been written to it without producing\nany compressed output. The compressed data written to w\ncan only be decompressed by a Reader initialized with the\nsame dictionary.\n"
;;   {:added "1.0"
;;    :go "newWriterDict(w, level, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/flate/deflate.go:680:22) w, ^Int level, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/flate/deflate.go:680:49) dict])

JOKER FUNC fmt.Errorf has:
;; (defn ^Error Errorf
;;   "Errorf formats according to a format specifier and returns the string\nas a value that satisfies error.\n"
;;   {:added "1.0"
;;    :go "errorf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:211:30) a])

JOKER FUNC fmt.Fprint has:
;; (defn ^[n err] Fprint
;;   "Fprint formats using the default formats for its operands and writes to w.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n"
;;   {:added "1.0"
;;    :go "fprint(w, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/print.go:220:15) w, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:220:28) a])

JOKER FUNC fmt.Fprintf has:
;; (defn ^[n err] Fprintf
;;   "Fprintf formats according to a format specifier and writes to w.\nIt returns the number of bytes written and any write error encountered.\n"
;;   {:added "1.0"
;;    :go "fprintf(w, format, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/print.go:186:16) w, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:186:44) a])

JOKER FUNC fmt.Fprintln has:
;; (defn ^[n err] Fprintln
;;   "Fprintln formats using the default formats for its operands and writes to w.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n"
;;   {:added "1.0"
;;    :go "fprintln(w, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/print.go:252:17) w, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:252:30) a])

JOKER FUNC fmt.Fscan has:
;; (defn ^[n err] Fscan
;;   "Fscan scans text read from r, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n"
;;   {:added "1.0"
;;    :go "fscan(r, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/scan.go:121:14) r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:121:27) a])

JOKER FUNC fmt.Fscanf has:
;; (defn ^[n err] Fscanf
;;   "Fscanf scans text read from r, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n"
;;   {:added "1.0"
;;    :go "fscanf(r, format, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/scan.go:141:15) r, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:141:43) a])

JOKER FUNC fmt.Fscanln has:
;; (defn ^[n err] Fscanln
;;   "Fscanln is similar to Fscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n"
;;   {:added "1.0"
;;    :go "fscanln(r, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/fmt/scan.go:130:16) r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:130:29) a])

JOKER FUNC fmt.Print has:
;; (defn ^[n err] Print
;;   "Print formats using the default formats for its operands and writes to standard output.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n"
;;   {:added "1.0"
;;    :go "print(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:231:14) a])

JOKER FUNC fmt.Printf has:
;; (defn ^[n err] Printf
;;   "Printf formats according to a format specifier and writes to standard output.\nIt returns the number of bytes written and any write error encountered.\n"
;;   {:added "1.0"
;;    :go "printf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:196:30) a])

JOKER FUNC fmt.Println has:
;; (defn ^[n err] Println
;;   "Println formats using the default formats for its operands and writes to standard output.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n"
;;   {:added "1.0"
;;    :go "println(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:263:16) a])

JOKER FUNC fmt.Scan has:
;; (defn ^[n err] Scan
;;   "Scan scans text read from standard input, storing successive\nspace-separated values into successive arguments. Newlines count\nas space. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\n"
;;   {:added "1.0"
;;    :go "scan(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:63:13) a])

JOKER FUNC fmt.Scanf has:
;; (defn ^[n err] Scanf
;;   "Scanf scans text read from standard input, storing successive\nspace-separated values into successive arguments as determined by\nthe format. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\nNewlines in the input must match newlines in the format.\nThe one exception: the verb %c always scans the next rune in the\ninput, even if it is a space (or tab etc.) or newline.\n"
;;   {:added "1.0"
;;    :go "scanf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:80:29) a])

JOKER FUNC fmt.Scanln has:
;; (defn ^[n err] Scanln
;;   "Scanln is similar to Scan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n"
;;   {:added "1.0"
;;    :go "scanln(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:69:15) a])

JOKER FUNC fmt.Sprint has:
;; (defn ^String Sprint
;;   "Sprint formats using the default formats for its operands and returns the resulting string.\nSpaces are added between operands when neither is a string.\n"
;;   {:added "1.0"
;;    :go "sprint(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:237:15) a])

JOKER FUNC fmt.Sprintf has:
;; (defn ^String Sprintf
;;   "Sprintf formats according to a format specifier and returns the resulting string.\n"
;;   {:added "1.0"
;;    :go "sprintf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:201:31) a])

JOKER FUNC fmt.Sprintln has:
;; (defn ^String Sprintln
;;   "Sprintln formats using the default formats for its operands and returns the resulting string.\nSpaces are always added between operands and a newline is appended.\n"
;;   {:added "1.0"
;;    :go "sprintln(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/print.go:269:17) a])

JOKER FUNC fmt.Sscan has:
;; (defn ^[n err] Sscan
;;   "Sscan scans the argument string, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n"
;;   {:added "1.0"
;;    :go "sscan(str, a)"}
;;   [^String str, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:99:26) a])

JOKER FUNC fmt.Sscanf has:
;; (defn ^[n err] Sscanf
;;   "Sscanf scans the argument string, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n"
;;   {:added "1.0"
;;    :go "sscanf(str, format, a)"}
;;   [^String str, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:113:42) a])

JOKER FUNC fmt.Sscanln has:
;; (defn ^[n err] Sscanln
;;   "Sscanln is similar to Sscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n"
;;   {:added "1.0"
;;    :go "sscanln(str, a)"}
;;   [^String str, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/fmt/scan.go:105:28) a])

JOKER FUNC fnv.New128 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:70:15) New128
;;   "New128 returns a new 128-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n"
;;   {:added "1.0"
;;    :go "new128()"}
;;   [])

JOKER FUNC fnv.New128a has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:79:16) New128a
;;   "New128a returns a new 128-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n"
;;   {:added "1.0"
;;    :go "new128a()"}
;;   [])

JOKER FUNC fnv.New32 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:42:14) New32
;;   "New32 returns a new 32-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n"
;;   {:added "1.0"
;;    :go "new32()"}
;;   [])

JOKER FUNC fnv.New32a has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:49:15) New32a
;;   "New32a returns a new 32-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n"
;;   {:added "1.0"
;;    :go "new32a()"}
;;   [])

JOKER FUNC fnv.New64 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:56:14) New64
;;   "New64 returns a new 64-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n"
;;   {:added "1.0"
;;    :go "new64()"}
;;   [])

JOKER FUNC fnv.New64a has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/hash/fnv/fnv.go:63:15) New64a
;;   "New64a returns a new 64-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n"
;;   {:added "1.0"
;;    :go "new64a()"}
;;   [])

JOKER FUNC format.Node has:
;; (defn ^Error Node
;;   "Node formats node in canonical gofmt style and writes the result to dst.\n\nThe node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n[]ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,\nor ast.Stmt. Node does not modify node. Imports are not sorted for\nnodes representing partial source files (for instance, if the node is\nnot an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).\n\nThe function may return early (before the entire result is written)\nand return a formatting error, for instance due to an incorrect AST.\n"
;;   {:added "1.0"
;;    :go "node(dst, fset, node)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/format/format.go:42:15) dst, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/format/format.go:42:31) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/format/format.go:42:52) node])

JOKER FUNC format.Source has:
;; (defn ^[[ABEND042(cannot find typename format.byte)] Error] Source
;;   "Source formats src in canonical gofmt style and returns the result\nor an (I/O or syntax) error. src is expected to be a syntactically\ncorrect Go source file, or a list of Go declarations or statements.\n\nIf src is a partial source file, the leading and trailing space of src\nis applied to the result (such that it has the same leading and trailing\nspace as src), and the result is indented by the same amount as the first\nline of src containing code. Imports are not sorted for partial source files.\n"
;;   {:added "1.0"
;;    :go "source(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/format/format.go:91:17) src])

JOKER FUNC gif.Decode has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:561:27) Error] Decode
;;   "Decode reads a GIF image from r and returns the first embedded\nimage as an image.Image.\n"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:561:15) r])

JOKER FUNC gif.DecodeAll has:
;; (defn ^[{:image ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/gif/reader.go:571:8) Image, :delay ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/gif/reader.go:572:8) Delay, :loopcount ^Int LoopCount, :disposal ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/gif/reader.go:583:11) Disposal, :config ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:593:9) Config, :backgroundindex BackgroundIndex} Error] DecodeAll
;;   "DecodeAll reads a GIF image from r and returns the sequential frames\nand timing information.\n"
;;   {:added "1.0"
;;    :go "decodeAll(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:601:18) r])

JOKER FUNC gif.DecodeConfig has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:623:33) Error] DecodeConfig
;;   "DecodeConfig returns the global color model and dimensions of a GIF image\nwithout decoding the entire image.\n"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/reader.go:623:21) r])

JOKER FUNC gif.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in GIF format.\n"
;;   {:added "1.0"
;;    :go "encode(w, m, o)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/writer.go:418:15) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/writer.go:418:28) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/image/gif/writer.go:418:43) o])

JOKER FUNC gif.EncodeAll has:
;; (defn ^Error EncodeAll
;;   "EncodeAll writes the images in g to w in GIF format with the\ngiven loop count and delay between frames.\n"
;;   {:added "1.0"
;;    :go "encodeAll(w, g)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/gif/writer.go:372:18) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/image/gif/writer.go:372:31) g])

JOKER FUNC gob.NewDecoder has:
;; (defn ^{:mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/decoder.go:27:15) mutex, :r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/decoder.go:28:15) r, :buf buf, :wiretype ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/gob/decoder.go:30:15) wireType, :decodercache ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/gob/decoder.go:31:15) decoderCache, :ignorercache ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/gob/decoder.go:32:15) ignorerCache, :freelist ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/gob/decoder.go:33:15) freeList, :countbuf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/gob/decoder.go:34:15) countBuf, :err err} NewDecoder
;;   "NewDecoder returns a new decoder that reads from the io.Reader.\nIf r does not also implement io.ByteReader, it will be wrapped in a\nbufio.Reader.\n"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/decoder.go:41:19) r])

JOKER FUNC gob.NewEncoder has:
;; (defn ^{:mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/encoder.go:17:13) mutex, :w ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/gob/encoder.go:18:13) w, :sent ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/gob/encoder.go:19:13) sent, :countstate ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/gob/encoder.go:20:13) countState, :freelist ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/gob/encoder.go:21:13) freeList, :bytebuf byteBuf, :err err} NewEncoder
;;   "NewEncoder returns a new encoder that will transmit on the io.Writer.\n"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/gob/encoder.go:33:19) w])

JOKER FUNC gob.Register has:
;; (defn Register
;;   "Register records a type, identified by a value for that type, under its\ninternal type name. That name will identify the concrete type of a value\nsent or received as an interface variable. Only types that will be\ntransferred as implementations of interface values need to be registered.\nExpecting to be used only during initialization, it panics if the mapping\nbetween types and names is not a bijection.\n"
;;   {:added "1.0"
;;    :go "register(value)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/gob/type.go:836:21) value])

JOKER FUNC gob.RegisterName has:
;; (defn RegisterName
;;   "RegisterName is like Register but uses the provided name rather than the\ntype's default.\n"
;;   {:added "1.0"
;;    :go "registerName(name, value)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/gob/type.go:807:38) value])

JOKER FUNC gosym.NewLineTable has:
;; (defn ^{:data ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/pclntab.go:31:7) Data, :pc PC, :line ^Int Line, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/gosym/pclntab.go:36:11) mu, :go12 ^Int go12, :binary ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/gosym/pclntab.go:38:11) binary, :quantum quantum, :ptrsize ptrsize, :functab ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/pclntab.go:41:11) functab, :nfunctab nfunctab, :filetab ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/pclntab.go:43:11) filetab, :nfiletab nfiletab, :filemap ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/pclntab.go:45:11) fileMap, :strings ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/pclntab.go:46:11) strings} NewLineTable
;;   "NewLineTable returns a new PC/line table\ncorresponding to the encoded data.\nText must be the start address of the\ncorresponding text segment.\n"
;;   {:added "1.0"
;;    :go "newLineTable(data, text)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/pclntab.go:124:24) data, text])

JOKER FUNC gosym.NewTable has:
;; (defn ^[{:syms ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/symtab.go:119:8) Syms, :funcs ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/symtab.go:120:8) Funcs, :files ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/debug/gosym/symtab.go:121:8) Files, :objs ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/symtab.go:122:8) Objs, :go12line ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/debug/gosym/symtab.go:124:11) go12line} Error] NewTable
;;   "NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF),\nreturning an in-memory representation.\nStarting with Go 1.3, the Go symbol table no longer includes symbol data.\n"
;;   {:added "1.0"
;;    :go "newTable(symtab, pcln)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/gosym/symtab.go:283:22) symtab, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/debug/gosym/symtab.go:283:35) pcln])

JOKER FUNC gzip.NewReader has:
;; (defn ^[{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gunzip.go:76:15) r, :decompressor ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gunzip.go:77:15) decompressor, :digest digest, :size size, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/gzip/gunzip.go:80:15) buf, :err err, :multistream multistream} Error] NewReader
;;   "NewReader creates a new Reader reading the given reader.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nIt is the caller's responsibility to call Close on the Reader when done.\n\nThe Reader.Header fields will be valid in the Reader returned.\n"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gunzip.go:92:18) r])

JOKER FUNC gzip.NewWriter has:
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:30:14) w, :level ^Int level, :wroteheader wroteHeader, :compressor ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/compress/gzip/gzip.go:33:14) compressor, :digest digest, :size size, :closed closed, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/gzip/gzip.go:37:14) buf, :err err} NewWriter
;;   "NewWriter returns a new Writer.\nWrites to the returned writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nCallers that wish to set the fields in Writer.Header must do so before\nthe first call to Write, Flush, or Close.\n"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:49:18) w])

JOKER FUNC gzip.NewWriterLevel has:
;; (defn ^[{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:30:14) w, :level ^Int level, :wroteheader wroteHeader, :compressor ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/compress/gzip/gzip.go:33:14) compressor, :digest digest, :size size, :closed closed, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/gzip/gzip.go:37:14) buf, :err err} Error] NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n"
;;   {:added "1.0"
;;    :go "newWriterLevel(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/gzip/gzip.go:60:23) w, ^Int level])

JOKER FUNC heap.Fix has:
;; (defn Fix
;;   "Fix re-establishes the heap ordering after the element at index i has changed its value.\nChanging the value of the element at index i and then calling Fix is equivalent to,\nbut less expensive than, calling Remove(h, i) followed by a Push of the new value.\nThe complexity is O(log(n)) where n = h.Len().\n"
;;   {:added "1.0"
;;    :go "fix(h, i)"}
;;   [h, ^Int i])

JOKER FUNC heap.Init has:
;; (defn Init
;;   "Init establishes the heap invariants required by the other routines in this package.\nInit is idempotent with respect to the heap invariants\nand may be called whenever the heap invariants may have been invalidated.\nIts complexity is O(n) where n = h.Len().\n"
;;   {:added "1.0"
;;    :go "init(h)"}
;;   [h])

JOKER FUNC heap.Pop has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/heap/heap.go:62:23) Pop
;;   "Pop removes the minimum element (according to Less) from the heap\nand returns it. The complexity is O(log(n)) where n = h.Len().\nIt is equivalent to Remove(h, 0).\n"
;;   {:added "1.0"
;;    :go "pop(h)"}
;;   [h])

JOKER FUNC heap.Push has:
;; (defn Push
;;   "Push pushes the element x onto the heap. The complexity is\nO(log(n)) where n = h.Len().\n"
;;   {:added "1.0"
;;    :go "push(h, x)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/heap/heap.go:53:26) x])

JOKER FUNC heap.Remove has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/heap/heap.go:72:33) Remove
;;   "Remove removes the element at index i from the heap.\nThe complexity is O(log(n)) where n = h.Len().\n"
;;   {:added "1.0"
;;    :go "remove(h, i)"}
;;   [h, ^Int i])

JOKER FUNC hex.Decode has:
;; (defn ^[Int Error] Decode
;;   "Decode decodes src into DecodedLen(len(src)) bytes,\nreturning the actual number of bytes written to dst.\n\nDecode expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, Decode returns the number\nof bytes decoded before the error.\n"
;;   {:added "1.0"
;;    :go "decode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:57:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:57:22) src])

JOKER FUNC hex.DecodeString has:
;; (defn ^[[ABEND042(cannot find typename hex.byte)] Error] DecodeString
;;   "DecodeString returns the bytes represented by the hexadecimal string s.\n\nDecodeString expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, DecodeString returns\nthe bytes decoded before the error.\n"
;;   {:added "1.0"
;;    :go "decodeString(s)"}
;;   [^String s])

JOKER FUNC hex.DecodedLen has:
(defn ^Int DecodedLen
  "DecodedLen returns the length of a decoding of x source bytes.\nSpecifically, it returns x / 2.\n"
  {:added "1.0"
   :go "decodedLen(x)"}
  [^Int x])

JOKER FUNC hex.Dump has:
;; (defn ^String Dump
;;   "Dump returns a string that contains a hex dump of the given data. The format\nof the hex dump matches the output of `hexdump -C` on the command line.\n"
;;   {:added "1.0"
;;    :go "dump(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:118:16) data])

JOKER FUNC hex.Dumper has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:204:26) Dumper
;;   "Dumper returns a WriteCloser that writes a hex dump of all written data to\nw. The format of the dump matches the output of `hexdump -C` on the command\nline.\n"
;;   {:added "1.0"
;;    :go "dumper(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:204:15) w])

JOKER FUNC hex.Encode has:
;; (defn ^Int Encode
;;   "Encode encodes src into EncodedLen(len(src))\nbytes of dst. As a convenience, it returns the number\nof bytes written to dst, but this value is always EncodedLen(len(src)).\nEncode implements hexadecimal encoding.\n"
;;   {:added "1.0"
;;    :go "encode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:25:22) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:25:22) src])

JOKER FUNC hex.EncodeToString has:
;; (defn ^String EncodeToString
;;   "EncodeToString returns the hexadecimal encoding of src.\n"
;;   {:added "1.0"
;;    :go "encodeToString(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/hex/hex.go:96:25) src])

JOKER FUNC hex.EncodedLen has:
(defn ^Int EncodedLen
  "EncodedLen returns the length of an encoding of n source bytes.\nSpecifically, it returns n * 2.\n"
  {:added "1.0"
   :go "encodedLen(n)"}
  [^Int n])

JOKER FUNC hex.NewDecoder has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:165:30) NewDecoder
;;   "NewDecoder returns an io.Reader that decodes hexadecimal characters from r.\nNewDecoder expects that r contain only an even number of hexadecimal characters.\n"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:165:19) r])

JOKER FUNC hex.NewEncoder has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:136:30) NewEncoder
;;   "NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.\n"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/hex/hex.go:136:19) w])

JOKER FUNC hmac.Equal has:
;; (defn ^ABEND042(cannot find typename hmac.bool) Equal
;;   "Equal compares two MACs for equality without leaking timing information.\n"
;;   {:added "1.0"
;;    :go "equal(mac1, mac2)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/hmac/hmac.go:96:23) mac1, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/hmac/hmac.go:96:23) mac2])

JOKER FUNC hmac.New has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/hmac/hmac.go:70:42) New
;;   "New returns a new HMAC hash using the given hash.Hash type and key.\nNote that unlike other hash implementations in the standard library,\nthe returned Hash does not implement encoding.BinaryMarshaler\nor encoding.BinaryUnmarshaler.\n"
;;   {:added "1.0"
;;    :go "new(h, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/hmac/hmac.go:70:12) h, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/hmac/hmac.go:70:34) key])

JOKER FUNC hpack.AppendHuffmanString has:
;; (defn ^[ABEND042(cannot find typename hpack.byte)] AppendHuffmanString
;;   "AppendHuffmanString appends s, as encoded in Huffman codes, to dst\nand returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendHuffmanString(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:160:30) dst, ^String s])

JOKER FUNC hpack.HuffmanDecode has:
;; (defn ^[Int Error] HuffmanDecode
;;   "HuffmanDecode decodes the string in v and writes the expanded\nresult to w, returning the number of bytes written to w and the\nWrite call's return value. At most one Write call is made.\n"
;;   {:added "1.0"
;;    :go "huffmanDecode(w, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:21:22) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:21:35) v])

JOKER FUNC hpack.HuffmanDecodeToString has:
;; (defn ^[String Error] HuffmanDecodeToString
;;   "HuffmanDecodeToString decodes the string in v.\n"
;;   {:added "1.0"
;;    :go "huffmanDecodeToString(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/huffman.go:32:30) v])

JOKER FUNC hpack.HuffmanEncodeLength has:
;; (defn ^ABEND042(cannot find typename hpack.uint64) HuffmanEncodeLength
;;   "HuffmanEncodeLength returns the number of bytes required to encode\ns in Huffman codes. The result is round up to byte boundary.\n"
;;   {:added "1.0"
;;    :go "huffmanEncodeLength(s)"}
;;   [^String s])

JOKER FUNC hpack.NewDecoder has:
;; (defn ^{:dyntab dynTab, :emit ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go:81:9) emit, :emitenabled emitEnabled, :maxstrlen ^Int maxStrLen, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go:90:6) buf, :savebuf ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go:94:10) saveBuf} NewDecoder
;;   "NewDecoder returns a new decoder with the provided maximum dynamic\ntable size. The emitFunc will be called for each valid field\nparsed, in the same goroutine as calls to Write, before Write returns.\n"
;;   {:added "1.0"
;;    :go "newDecoder(maxDynamicTableSize, emitFunc)"}
;;   [maxDynamicTableSize, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/hpack.go:100:54) emitFunc])

JOKER FUNC hpack.NewEncoder has:
;; (defn ^{:dyntab dynTab, :minsize minSize, :maxsizelimit maxSizeLimit, :tablesizeupdate tableSizeUpdate, :w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/encode.go:29:18) w, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/encode.go:30:18) buf} NewEncoder
;;   "NewEncoder returns a new Encoder which performs HPACK encoding. An\nencoded data is written to w.\n"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/net/http2/hpack/encode.go:35:19) w])

JOKER FUNC html.EscapeString has:
(defn ^String EscapeString
  "EscapeString escapes special characters like \"<\" to become \"&lt;\". It\nescapes only five such characters: <, >, &, ' and \".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n"
  {:added "1.0"
   :go "escapeString(s)"}
  [^String s])

JOKER FUNC html.UnescapeString has:
(defn ^String UnescapeString
  "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a\nlarger range of entities than EscapeString escapes. For example, \"&aacute;\"\nunescapes to \"\", as does \"&#225;\" and \"&#xE1;\".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n"
  {:added "1.0"
   :go "unescapeString(s)"}
  [^String s])

JOKER FUNC http.CanonicalHeaderKey has:
(defn ^String CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n"
  {:added "1.0"
   :go "canonicalHeaderKey(s)"}
  [^String s])

JOKER FUNC http.DetectContentType has:
;; (defn ^String DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n"
;;   {:added "1.0"
;;    :go "detectContentType(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/http/sniff.go:21:29) data])

JOKER FUNC http.Error has:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n"
;;   {:added "1.0"
;;    :go "error(w, error, code)"}
;;   [w, ^String error, ^Int code])

JOKER FUNC http.FileServer has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/server.go:84:14) FileServer
;;   "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n"
;;   {:added "1.0"
;;    :go "fileServer(root)"}
;;   [root])

JOKER FUNC http.Get has:
(defn ^[resp err] Get
  "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n"
  {:added "1.0"
   :go "get(url)"}
  [^String url])

JOKER FUNC http.Handle has:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n"
;;   {:added "1.0"
;;    :go "handle(pattern, handler)"}
;;   [^String pattern, handler])

JOKER FUNC http.HandleFunc has:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n"
;;   {:added "1.0"
;;    :go "handleFunc(pattern, handler)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/server.go:2406:41) handler])

JOKER FUNC http.Head has:
(defn ^[resp err] Head
  "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n"
  {:added "1.0"
   :go "head(url)"}
  [^String url])

JOKER FUNC http.ListenAndServe has:
(defn ^Error ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n"
  {:added "1.0"
   :go "listenAndServe(addr, handler)"}
  [^String addr, handler])

JOKER FUNC http.ListenAndServeTLS has:
(defn ^Error ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n"
  {:added "1.0"
   :go "listenAndServeTLS(addr, certFile, keyFile, handler)"}
  [^String addr, ^String certFile, ^String keyFile, handler])

JOKER FUNC http.MaxBytesReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:1056:65) MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n"
;;   {:added "1.0"
;;    :go "maxBytesReader(w, r, n)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:1056:41) r, n])

JOKER FUNC http.NewFileTransport has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/client.go:115:19) NewFileTransport
;;   "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n"
;;   {:added "1.0"
;;    :go "newFileTransport(fs)"}
;;   [fs])

JOKER FUNC http.NewRequest has:
;; (defn ^[{:method ^String Method, :url ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:127:6) URL, :proto ^String Proto, :protomajor ^Int ProtoMajor, :protominor ^Int ProtoMinor, :header Header, :body ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:181:7) Body, :getbody ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/request.go:189:10) GetBody, :contentlength ContentLength, :transferencoding ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/http/request.go:204:19) TransferEncoding, :close Close, :host ^String Host, :form ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:241:7) Form, :postform ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:248:11) PostForm, :multipartform ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:253:16) MultipartForm, :trailer Trailer, :remoteaddr ^String RemoteAddr, :requesturi ^String RequestURI, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:297:6) TLS, :cancel ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/net/http/request.go:308:9) Cancel, :response ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:313:11) Response, :ctx ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:319:6) ctx} Error] NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n"
;;   {:added "1.0"
;;    :go "newRequest(method, url, body)"}
;;   [^String method, ^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:792:42) body])

JOKER FUNC http.NewServeMux has:
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/server.go:2150:8) mu, :m ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/server.go:2151:8) m, :hosts hosts} NewServeMux
;;   "NewServeMux allocates and returns a new ServeMux.\n"
;;   {:added "1.0"
;;    :go "newServeMux()"}
;;   [])

JOKER FUNC http.NotFound has:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n"
;;   {:added "1.0"
;;    :go "notFound(w, r)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/server.go:1981:35) r])

JOKER FUNC http.NotFoundHandler has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/server.go:84:14) NotFoundHandler
;;   "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n"
;;   {:added "1.0"
;;    :go "notFoundHandler()"}
;;   [])

JOKER FUNC http.ParseHTTPVersion has:
(defn ^[major minor ok] ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n"
  {:added "1.0"
   :go "parseHTTPVersion(vers)"}
  [^String vers])

JOKER FUNC http.ParseTime has:
(defn ^[t err] ParseTime
  "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n"
  {:added "1.0"
   :go "parseTime(text)"}
  [^String text])

JOKER FUNC http.Post has:
;; (defn ^[resp err] Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n"
;;   {:added "1.0"
;;    :go "post(url, contentType, body)"}
;;   [^String url, ^String contentType, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/client.go:748:41) body])

JOKER FUNC http.PostForm has:
;; (defn ^[resp err] PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n"
;;   {:added "1.0"
;;    :go "postForm(url, data)"}
;;   [^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/client.go:785:32) data])

JOKER FUNC http.ProxyFromEnvironment has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/transport.go:345:43) Error] ProxyFromEnvironment
;;   "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n"
;;   {:added "1.0"
;;    :go "proxyFromEnvironment(req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/transport.go:345:31) req])

JOKER FUNC http.ProxyURL has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/transport.go:351:34) ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n"
;;   {:added "1.0"
;;    :go "proxyURL(fixedURL)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/transport.go:351:24) fixedURL])

JOKER FUNC http.ReadRequest has:
;; (defn ^[{:method ^String Method, :url ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:127:6) URL, :proto ^String Proto, :protomajor ^Int ProtoMajor, :protominor ^Int ProtoMinor, :header Header, :body ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:181:7) Body, :getbody ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/request.go:189:10) GetBody, :contentlength ContentLength, :transferencoding ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/http/request.go:204:19) TransferEncoding, :close Close, :host ^String Host, :form ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:241:7) Form, :postform ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:248:11) PostForm, :multipartform ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:253:16) MultipartForm, :trailer Trailer, :remoteaddr ^String RemoteAddr, :requesturi ^String RequestURI, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:297:6) TLS, :cancel ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/net/http/request.go:308:9) Cancel, :response ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:313:11) Response, :ctx ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/request.go:319:6) ctx} Error] ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n"
;;   {:added "1.0"
;;    :go "readRequest(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/request.go:942:20) b])

JOKER FUNC http.ReadResponse has:
;; (defn ^[{:status ^String Status, :statuscode ^Int StatusCode, :proto ^String Proto, :protomajor ^Int ProtoMajor, :protominor ^Int ProtoMinor, :header Header, :body ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/response.go:66:7) Body, :contentlength ContentLength, :transferencoding ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/http/response.go:76:19) TransferEncoding, :close Close, :uncompressed Uncompressed, :trailer Trailer, :request ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/response.go:109:10) Request, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/response.go:115:6) TLS} Error] ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n"
;;   {:added "1.0"
;;    :go "readResponse(r, req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/response.go:148:21) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/response.go:148:40) req])

JOKER FUNC http.Redirect has:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n"
;;   {:added "1.0"
;;    :go "redirect(w, r, url, code)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/server.go:2020:35) r, ^String url, ^Int code])

JOKER FUNC http.RedirectHandler has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/server.go:84:14) RedirectHandler
;;   "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n"
;;   {:added "1.0"
;;    :go "redirectHandler(url, code)"}
;;   [^String url, ^Int code])

JOKER FUNC http.Serve has:
;; (defn ^Error Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n"
;;   {:added "1.0"
;;    :go "serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/server.go:2421:14) l, handler])

JOKER FUNC http.ServeContent has:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n"
;;   {:added "1.0"
;;    :go "serveContent(w, req, name, modtime, content)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fs.go:151:41) req, ^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fs.go:151:72) modtime, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fs.go:151:91) content])

JOKER FUNC http.ServeFile has:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n"
;;   {:added "1.0"
;;    :go "serveFile(w, r, name)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fs.go:670:36) r, ^String name])

JOKER FUNC http.ServeTLS has:
;; (defn ^Error ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n"
;;   {:added "1.0"
;;    :go "serveTLS(l, handler, certFile, keyFile)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/server.go:2438:17) l, handler, ^String certFile, ^String keyFile])

JOKER FUNC http.SetCookie has:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n"
;;   {:added "1.0"
;;    :go "setCookie(w, cookie)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/cookie.go:157:41) cookie])

JOKER FUNC http.StatusText has:
(defn ^String StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n"
  {:added "1.0"
   :go "statusText(code)"}
  [^Int code])

JOKER FUNC http.StripPrefix has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/server.go:84:14) StripPrefix
;;   "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n"
;;   {:added "1.0"
;;    :go "stripPrefix(prefix, h)"}
;;   [^String prefix, h])

JOKER FUNC http.TimeoutHandler has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/http/server.go:84:14) TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n"
;;   {:added "1.0"
;;    :go "timeoutHandler(h, dt, msg)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/server.go:3106:35) dt, ^String msg])

JOKER FUNC httpguts.HeaderValuesContainsToken has:
;; (defn ^ABEND042(cannot find typename httpguts.bool) HeaderValuesContainsToken
;;   "HeaderValuesContainsToken reports whether any string in values\ncontains the provided token, ASCII case-insensitively.\n"
;;   {:added "1.0"
;;    :go "headerValuesContainsToken(values, token)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/http/httpguts/httplex.go:106:39) values, ^String token])

JOKER FUNC httpguts.IsTokenRune has:
;; (defn ^ABEND042(cannot find typename httpguts.bool) IsTokenRune
;;   {:added "1.0"
;;    :go "isTokenRune(r)"}
;;   [r])

JOKER FUNC httpguts.PunycodeHostPort has:
(defn ^[String Error] PunycodeHostPort
  "PunycodeHostPort returns the IDNA Punycode version\nof the provided \"host\" or \"host:port\" string.\n"
  {:added "1.0"
   :go "punycodeHostPort(v)"}
  [^String v])

JOKER FUNC httpguts.ValidHeaderFieldName has:
;; (defn ^ABEND042(cannot find typename httpguts.bool) ValidHeaderFieldName
;;   "ValidHeaderFieldName reports whether v is a valid HTTP/1.x header name.\nHTTP/2 imposes the additional restriction that uppercase ASCII\nletters are not allowed.\n\n RFC 7230 says:\n  header-field   = field-name \":\" OWS field-value OWS\n  field-name     = token\n  token          = 1*tchar\n  tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /\n          \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n"
;;   {:added "1.0"
;;    :go "validHeaderFieldName(v)"}
;;   [^String v])

JOKER FUNC httpguts.ValidHeaderFieldValue has:
;; (defn ^ABEND042(cannot find typename httpguts.bool) ValidHeaderFieldValue
;;   "ValidHeaderFieldValue reports whether v is a valid \"field-value\" according to\nhttp://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 :\n\n       message-header = field-name \":\" [ field-value ]\n       field-value    = *( field-content | LWS )\n       field-content  = <the OCTETs making up the field-value\n                        and consisting of either *TEXT or combinations\n                        of token, separators, and quoted-string>\n\nhttp://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2 :\n\n       TEXT           = <any OCTET except CTLs,\n                         but including LWS>\n       LWS            = [CRLF] 1*( SP | HT )\n       CTL            = <any US-ASCII control character\n                        (octets 0 - 31) and DEL (127)>\n\nRFC 7230 says:\n field-value    = *( field-content / obs-fold )\n obj-fold       =  N/A to http2, and deprecated\n field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n field-vchar    = VCHAR / obs-text\n obs-text       = %x80-FF\n VCHAR          = \"any visible [USASCII] character\"\n\nhttp2 further says: \"Similarly, HTTP/2 allows header field values\nthat are not valid. While most of the values that can be encoded\nwill not alter header field parsing, carriage return (CR, ASCII\n0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII\n0x0) might be exploited by an attacker if they are translated\nverbatim. Any request or response that contains a character not\npermitted in a header field value MUST be treated as malformed\n(Section 8.1.2.6). Valid characters are defined by the\nfield-content ABNF rule in Section 3.2 of [RFC7230].\"\n\nThis function does not (yet?) properly handle the rejection of\nstrings that begin or end with SP or HTAB.\n"
;;   {:added "1.0"
;;    :go "validHeaderFieldValue(v)"}
;;   [^String v])

JOKER FUNC httpguts.ValidHostHeader has:
;; (defn ^ABEND042(cannot find typename httpguts.bool) ValidHostHeader
;;   "ValidHostHeader reports whether h is a valid host header.\n"
;;   {:added "1.0"
;;    :go "validHostHeader(h)"}
;;   [^String h])

JOKER FUNC httpguts.ValidTrailerHeader has:
;; (defn ^ABEND042(cannot find typename httpguts.bool) ValidTrailerHeader
;;   "ValidTrailerHeader reports whether name is a valid header field name to appear\nin trailers.\nSee RFC 7230, Section 4.1.2\n"
;;   {:added "1.0"
;;    :go "validTrailerHeader(name)"}
;;   [^String name])

JOKER FUNC httpproxy.FromEnvironment has:
(defn ^{:httpproxy ^String HTTPProxy, :httpsproxy ^String HTTPSProxy, :noproxy ^String NoProxy, :cgi CGI} FromEnvironment
  "FromEnvironment returns a Config instance populated from the\nenvironment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the\nlowercase versions thereof). HTTPS_PROXY takes precedence over\nHTTP_PROXY for https requests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed. An error\nis returned if the value is a different form.\n"
  {:added "1.0"
   :go "fromEnvironment()"}
  [])

JOKER FUNC httptest.NewRecorder has:
;; (defn ^{:code ^Int Code, :headermap ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/recorder.go:35:12) HeaderMap, :body ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/recorder.go:39:7) Body, :flushed Flushed, :result ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/recorder.go:44:14) result, :snapheader ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/recorder.go:45:14) snapHeader, :wroteheader wroteHeader} NewRecorder
;;   "NewRecorder returns an initialized ResponseRecorder.\n"
;;   {:added "1.0"
;;    :go "newRecorder()"}
;;   [])

JOKER FUNC httptest.NewRequest has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/httptest.go:41:57) NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n"
;;   {:added "1.0"
;;    :go "newRequest(method, target, body)"}
;;   [^String method, ^String target, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/httptest.go:41:45) body])

JOKER FUNC httptest.NewServer has:
;; (defn ^{:url ^String URL, :listener ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:28:11) Listener, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:33:6) TLS, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:37:9) Config, :certificate ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:40:14) certificate, :wg ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:44:5) wg, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:46:9) mu, :closed closed, :conns ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httptest/server.go:48:9) conns, :client ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:52:9) client} NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n"
;;   {:added "1.0"
;;    :go "newServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:80:24) handler])

JOKER FUNC httptest.NewTLSServer has:
;; (defn ^{:url ^String URL, :listener ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:28:11) Listener, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:33:6) TLS, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:37:9) Config, :certificate ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:40:14) certificate, :wg ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:44:5) wg, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:46:9) mu, :closed closed, :conns ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httptest/server.go:48:9) conns, :client ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:52:9) client} NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n"
;;   {:added "1.0"
;;    :go "newTLSServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:160:27) handler])

JOKER FUNC httptest.NewUnstartedServer has:
;; (defn ^{:url ^String URL, :listener ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:28:11) Listener, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:33:6) TLS, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:37:9) Config, :certificate ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:40:14) certificate, :wg ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:44:5) wg, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:46:9) mu, :closed closed, :conns ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httptest/server.go:48:9) conns, :client ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptest/server.go:52:9) client} NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n"
;;   {:added "1.0"
;;    :go "newUnstartedServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptest/server.go:92:33) handler])

JOKER FUNC httptrace.ContextClientTrace has:
;; (defn ^{:getconn ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:85:10) GetConn, :gotconn ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:91:10) GotConn, :putidleconn ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:101:14) PutIdleConn, :gotfirstresponsebyte ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:105:23) GotFirstResponseByte, :got100continue ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:109:17) Got100Continue, :got1xxresponse ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:115:17) Got1xxResponse, :dnsstart ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:118:11) DNSStart, :dnsdone ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:121:10) DNSDone, :connectstart ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:126:15) ConnectStart, :connectdone ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:133:14) ConnectDone, :tlshandshakestart ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:138:20) TLSHandshakeStart, :tlshandshakedone ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:143:19) TLSHandshakeDone, :wroteheaderfield ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:148:19) WroteHeaderField, :wroteheaders ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:152:15) WroteHeaders, :wait100continue ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:158:18) Wait100Continue, :wroterequest ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httptrace/trace.go:163:15) WroteRequest} ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n"
;;   {:added "1.0"
;;    :go "contextClientTrace(ctx)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptrace/trace.go:24:29) ctx])

JOKER FUNC httptrace.WithClientTrace has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptrace/trace.go:34:63) WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n"
;;   {:added "1.0"
;;    :go "withClientTrace(ctx, trace)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httptrace/trace.go:34:26) ctx, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httptrace/trace.go:34:49) trace])

JOKER FUNC httputil.DumpRequest has:
;; (defn ^[[ABEND042(cannot find typename httputil.byte)] Error] DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n"
;;   {:added "1.0"
;;    :go "dumpRequest(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/dump.go:191:22) req, body])

JOKER FUNC httputil.DumpRequestOut has:
;; (defn ^[[ABEND042(cannot find typename httputil.byte)] Error] DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n"
;;   {:added "1.0"
;;    :go "dumpRequestOut(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/dump.go:66:25) req, body])

JOKER FUNC httputil.DumpResponse has:
;; (defn ^[[ABEND042(cannot find typename httputil.byte)] Error] DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n"
;;   {:added "1.0"
;;    :go "dumpResponse(resp, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/dump.go:281:24) resp, body])

JOKER FUNC httputil.NewChunkedReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/httputil.go:20:36) NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n"
;;   {:added "1.0"
;;    :go "newChunkedReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/httputil.go:20:25) r])

JOKER FUNC httputil.NewChunkedWriter has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/httputil.go:35:36) NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n"
;;   {:added "1.0"
;;    :go "newChunkedWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/httputil.go:35:25) w])

JOKER FUNC httputil.NewClientConn has:
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:231:18) mu, :c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:232:18) c, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:233:18) r, :re re, :we we, :lastbody ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:235:18) lastbody, :nread ^Int nread, :nwritten ^Int nwritten, :pipereq ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httputil/persist.go:237:18) pipereq, :pipe ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:239:11) pipe, :writereq ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httputil/persist.go:240:11) writeReq} NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n"
;;   {:added "1.0"
;;    :go "newClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:248:22) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:248:34) r])

JOKER FUNC httputil.NewProxyClientConn has:
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:231:18) mu, :c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:232:18) c, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:233:18) r, :re re, :we we, :lastbody ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:235:18) lastbody, :nread ^Int nread, :nwritten ^Int nwritten, :pipereq ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httputil/persist.go:237:18) pipereq, :pipe ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:239:11) pipe, :writereq ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httputil/persist.go:240:11) writeReq} NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n"
;;   {:added "1.0"
;;    :go "newProxyClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:265:27) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:265:39) r])

JOKER FUNC httputil.NewServerConn has:
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:38:18) mu, :c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:39:18) c, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:40:18) r, :re re, :we we, :lastbody ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:42:18) lastbody, :nread ^Int nread, :nwritten ^Int nwritten, :pipereq ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/http/httputil/persist.go:44:18) pipereq, :pipe ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:46:7) pipe} NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n"
;;   {:added "1.0"
;;    :go "newServerConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/persist.go:54:22) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/persist.go:54:34) r])

JOKER FUNC httputil.NewSingleHostReverseProxy has:
;; (defn ^{:director ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httputil/reverseproxy.go:35:11) Director, :transport ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/reverseproxy.go:39:12) Transport, :flushinterval ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/httputil/reverseproxy.go:45:16) FlushInterval, :errorlog ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/reverseproxy.go:51:11) ErrorLog, :bufferpool BufferPool, :modifyresponse ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httputil/reverseproxy.go:67:17) ModifyResponse, :errorhandler ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/httputil/reverseproxy.go:74:15) ErrorHandler} NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n"
;;   {:added "1.0"
;;    :go "newSingleHostReverseProxy(target)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/httputil/reverseproxy.go:103:39) target])

JOKER FUNC idna.BidiRule has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13) BidiRule
;;   "BidiRule enables the Bidi rule as defined in RFC 5893. Any application\nthat relies on proper validation of labels should include this rule.\n"
;;   {:added "1.0"
;;    :go "bidiRule()"}
;;   [])

JOKER FUNC idna.MapForLookup has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13) MapForLookup
;;   "MapForLookup sets validation and mapping options such that a given IDN is\ntransformed for domain name lookup according to the requirements set out in\nSection 5 of RFC 5891. The mappings follow the recommendations of RFC 5894,\nRFC 5895 and UTS 46. It does not add the Bidi Rule. Use the BidiRule option\nto add this check.\n\nThe mappings include normalization and mapping case, width and other\ncompatibility mappings.\n"
;;   {:added "1.0"
;;    :go "mapForLookup()"}
;;   [])

JOKER FUNC idna.New has:
;; (defn ^{} New
;;   "New creates a new Profile.\n\nWith no options, the returned Profile is the most permissive and equals the\nPunycode Profile. Options can be passed to further restrict the Profile. The\nMapForLookup and ValidateForRegistration options set a collection of options,\nfor lookup and registration purposes respectively, which can be tailored by\nadding more fine-grained options, where later options override earlier\noptions.\n"
;;   {:added "1.0"
;;    :go "new(o)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:189:12) o])

JOKER FUNC idna.RemoveLeadingDots has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13) RemoveLeadingDots
;;   "RemoveLeadingDots removes leading label separators. Leading runes that map to\ndots, such as U+3002 IDEOGRAPHIC FULL STOP, are removed as well.\n\nThis is the behavior suggested by the UTS #46 and is adopted by some\nbrowsers.\n"
;;   {:added "1.0"
;;    :go "removeLeadingDots(remove)"}
;;   [remove])

JOKER FUNC idna.StrictDomainName has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13) StrictDomainName
;;   "StrictDomainName limits the set of permissible ASCII characters to those\nallowed in domain names as defined in RFC 1034 (A-Z, a-z, 0-9 and the\nhyphen). This is set by default for MapForLookup and ValidateForRegistration.\n\nThis option is useful, for instance, for browsers that allow characters\noutside this range, for example a '_' (U+005F LOW LINE). See\nhttp://www.rfc-editor.org/std/std3.txt for more details This option\ncorresponds to the UseSTD3ASCIIRules option in UTS #46.\n"
;;   {:added "1.0"
;;    :go "strictDomainName(use)"}
;;   [use])

JOKER FUNC idna.ToASCII has:
(defn ^[String Error] ToASCII
  "ToASCII is a wrapper for Punycode.ToASCII.\n"
  {:added "1.0"
   :go "toASCII(s)"}
  [^String s])

JOKER FUNC idna.ToUnicode has:
(defn ^[String Error] ToUnicode
  "ToUnicode is a wrapper for Punycode.ToUnicode.\n"
  {:added "1.0"
   :go "toUnicode(s)"}
  [^String s])

JOKER FUNC idna.Transitional has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13) Transitional
;;   "Transitional sets a Profile to use the Transitional mapping as defined in UTS\n#46. This will cause, for example, \"\" to be mapped to \"ss\". Using the\ntransitional mapping provides a compromise between IDNA2003 and IDNA2008\ncompatibility. It is used by most browsers when resolving domain names. This\noption is only meaningful if combined with MapForLookup.\n"
;;   {:added "1.0"
;;    :go "transitional(transitional)"}
;;   [transitional])

JOKER FUNC idna.ValidateForRegistration has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13) ValidateForRegistration
;;   "ValidateForRegistration sets validation options to verify that a given IDN is\nproperly formatted for registration as defined by Section 4 of RFC 5891.\n"
;;   {:added "1.0"
;;    :go "validateForRegistration()"}
;;   [])

JOKER FUNC idna.ValidateLabels has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13) ValidateLabels
;;   "ValidateLabels sets whether to check the mandatory label validation criteria\nas defined in Section 5.4 of RFC 5891. This includes testing for correct use\nof hyphens ('-'), normalization, validity of runes, and the context rules.\n"
;;   {:added "1.0"
;;    :go "validateLabels(enable)"}
;;   [enable])

JOKER FUNC idna.VerifyDNSLength has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/net/idna/idna.go:54:13) VerifyDNSLength
;;   "VerifyDNSLength sets whether a Profile should fail if any of the IDN parts\nare longer than allowed by the RFC.\n"
;;   {:added "1.0"
;;    :go "verifyDNSLength(verify)"}
;;   [verify])

JOKER FUNC image.Decode has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/image/image.go:36:12) String Error] Decode
;;   "Decode decodes an image that has been encoded in a registered format.\nThe string returned is the format name used during format registration.\nFormat registration is typically done by an init function in the codec-\nspecific package.\n"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/format.go:78:15) r])

JOKER FUNC image.DecodeConfig has:
;; (defn ^[{:colormodel ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/image.go:30:16) ColorModel, :width ^Int Width, :height ^Int Height} String Error] DecodeConfig
;;   "DecodeConfig decodes the color model and dimensions of an image that has\nbeen encoded in a registered format. The string returned is the format name\nused during format registration. Format registration is typically done by\nan init function in the codec-specific package.\n"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/format.go:92:21) r])

JOKER FUNC image.NewAlpha has:
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/image.go:485:6) Pix, :stride ^Int Stride, :rect Rect} NewAlpha
;;   "NewAlpha returns a new Alpha image with the given bounds.\n"
;;   {:added "1.0"
;;    :go "newAlpha(r)"}
;;   [r])

JOKER FUNC image.NewAlpha16 has:
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/image.go:577:6) Pix, :stride ^Int Stride, :rect Rect} NewAlpha16
;;   "NewAlpha16 returns a new Alpha16 image with the given bounds.\n"
;;   {:added "1.0"
;;    :go "newAlpha16(r)"}
;;   [r])

JOKER FUNC image.NewCMYK has:
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/image.go:833:6) Pix, :stride ^Int Stride, :rect Rect} NewCMYK
;;   "NewCMYK returns a new CMYK image with the given bounds.\n"
;;   {:added "1.0"
;;    :go "newCMYK(r)"}
;;   [r])

JOKER FUNC image.NewGray has:
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/image.go:672:6) Pix, :stride ^Int Stride, :rect Rect} NewGray
;;   "NewGray returns a new Gray image with the given bounds.\n"
;;   {:added "1.0"
;;    :go "newGray(r)"}
;;   [r])

JOKER FUNC image.NewGray16 has:
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/image.go:751:6) Pix, :stride ^Int Stride, :rect Rect} NewGray16
;;   "NewGray16 returns a new Gray16 image with the given bounds.\n"
;;   {:added "1.0"
;;    :go "newGray16(r)"}
;;   [r])

JOKER FUNC image.NewNRGBA has:
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/image.go:274:6) Pix, :stride ^Int Stride, :rect Rect} NewNRGBA
;;   "NewNRGBA returns a new NRGBA image with the given bounds.\n"
;;   {:added "1.0"
;;    :go "newNRGBA(r)"}
;;   [r])

JOKER FUNC image.NewNRGBA64 has:
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/image.go:373:6) Pix, :stride ^Int Stride, :rect Rect} NewNRGBA64
;;   "NewNRGBA64 returns a new NRGBA64 image with the given bounds.\n"
;;   {:added "1.0"
;;    :go "newNRGBA64(r)"}
;;   [r])

JOKER FUNC image.NewNYCbCrA has:
;; (defn ^{:a ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/ycbcr.go:191:10) A, :astride ^Int AStride} NewNYCbCrA
;;   "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample\nratio.\n"
;;   {:added "1.0"
;;    :go "newNYCbCrA(r, subsampleRatio)"}
;;   [r, subsampleRatio])

JOKER FUNC image.NewPaletted has:
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/image.go:919:6) Pix, :stride ^Int Stride, :rect Rect, :palette ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/image.go:925:10) Palette} NewPaletted
;;   "NewPaletted returns a new Paletted image with the given width, height and\npalette.\n"
;;   {:added "1.0"
;;    :go "newPaletted(r, p)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/image.go:1019:33) p])

JOKER FUNC image.NewRGBA has:
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/image.go:63:6) Pix, :stride ^Int Stride, :rect Rect} NewRGBA
;;   "NewRGBA returns a new RGBA image with the given bounds.\n"
;;   {:added "1.0"
;;    :go "newRGBA(r)"}
;;   [r])

JOKER FUNC image.NewRGBA64 has:
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/image.go:162:6) Pix, :stride ^Int Stride, :rect Rect} NewRGBA64
;;   "NewRGBA64 returns a new RGBA64 image with the given bounds.\n"
;;   {:added "1.0"
;;    :go "newRGBA64(r)"}
;;   [r])

JOKER FUNC image.NewUniform has:
;; (defn ^{:c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/names.go:25:4) C} NewUniform
;;   {:added "1.0"
;;    :go "newUniform(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/names.go:50:19) c])

JOKER FUNC image.NewYCbCr has:
;; (defn ^{:y ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/ycbcr.go:55:17) Y, :cb ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/ycbcr.go:55:17) Cb, :cr ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/image/ycbcr.go:55:17) Cr, :ystride ^Int YStride, :cstride ^Int CStride, :subsampleratio SubsampleRatio, :rect Rect} NewYCbCr
;;   "NewYCbCr returns a new YCbCr image with the given bounds and subsample\nratio.\n"
;;   {:added "1.0"
;;    :go "newYCbCr(r, subsampleRatio)"}
;;   [r, subsampleRatio])

JOKER FUNC image.Pt has:
(defn ^{:x ^Int X, :y ^Int Y} Pt
  "Pt is shorthand for Point{X, Y}.\n"
  {:added "1.0"
   :go "pt(X, Y)"}
  [^Int X, ^Int Y])

JOKER FUNC image.Rect has:
(defn ^{:min Min, :max Max} Rect
  "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned\nrectangle has minimum and maximum coordinates swapped if necessary so that\nit is well-formed.\n"
  {:added "1.0"
   :go "rect(x0, y0, x1, y1)"}
  [^Int x0, ^Int y0, ^Int x1, ^Int y1])

JOKER FUNC image.RegisterFormat has:
;; (defn RegisterFormat
;;   "RegisterFormat registers an image format for use by Decode.\nName is the name of the format, like \"jpeg\" or \"png\".\nMagic is the magic prefix that identifies the format's encoding. The magic\nstring can contain \"?\" wildcards that each match any one byte.\nDecode is the function that decodes the encoded image.\nDecodeConfig is the function that decodes just its configuration.\n"
;;   {:added "1.0"
;;    :go "registerFormat(name, magic, decode, decodeConfig)"}
;;   [^String name, ^String magic, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/format.go:32:48) decode, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/format.go:32:93) decodeConfig])

JOKER FUNC importer.Default has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/importer/importer.go:75:16) Default
;;   "Default returns an Importer for the compiler that built the running binary.\nIf available, the result implements types.ImporterFrom.\n"
;;   {:added "1.0"
;;    :go "default()"}
;;   [])

JOKER FUNC importer.For has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/importer/importer.go:42:42) For
;;   "For returns an Importer for importing from installed packages\nfor the compilers \"gc\" and \"gccgo\", or for importing directly\nfrom the source if the compiler argument is \"source\". In this\nlatter case, importing may fail under circumstances where the\nexported API is not entirely defined in pure Go source code\n(if the package API depends on cgo-defined entities, the type\nchecker won't have access to those).\n\nIf lookup is nil, the default package lookup mechanism for the\ngiven compiler is used, and the resulting importer attempts\nto resolve relative and absolute import paths to canonical\nimport path IDs before finding the imported file.\n\nIf lookup is non-nil, then the returned importer calls lookup\neach time it needs to resolve an import path. In this mode\nthe importer can only be invoked with canonical import paths\n(not relative or absolute ones); it is assumed that the translation\nto canonical import paths is being done by the client of the\nimporter.\n"
;;   {:added "1.0"
;;    :go "for(compiler, lookup)"}
;;   [^String compiler, lookup])

JOKER FUNC io.Copy has:
(defn ^[written err] Copy
  "Copy copies from src to dst until either EOF is reached\non src or an error occurs. It returns the number of bytes\ncopied and the first error encountered while copying, if any.\n\nA successful Copy returns err == nil, not err == EOF.\nBecause Copy is defined to read from src until EOF, it does\nnot treat an EOF from Read as an error to be reported.\n\nIf src implements the WriterTo interface,\nthe copy is implemented by calling src.WriteTo(dst).\nOtherwise, if dst implements the ReaderFrom interface,\nthe copy is implemented by calling dst.ReadFrom(src).\n"
  {:added "1.0"
   :go "copy(dst, src)"}
  [dst, src])

JOKER FUNC io.CopyBuffer has:
;; (defn ^[written err] CopyBuffer
;;   "CopyBuffer is identical to Copy except that it stages through the\nprovided buffer (if one is required) rather than allocating a\ntemporary one. If buf is nil, one is allocated; otherwise if it has\nzero length, CopyBuffer panics.\n"
;;   {:added "1.0"
;;    :go "copyBuffer(dst, src, buf)"}
;;   [dst, src, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/io.go:371:45) buf])

JOKER FUNC io.CopyN has:
(defn ^[written err] CopyN
  "CopyN copies n bytes (or until an error) from src to dst.\nIt returns the number of bytes copied and the earliest\nerror encountered while copying.\nOn return, written == n if and only if err == nil.\n\nIf dst implements the ReaderFrom interface,\nthe copy is implemented using it.\n"
  {:added "1.0"
   :go "copyN(dst, src, n)"}
  [dst, src, n])

JOKER FUNC io.LimitReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/io/io.go:77:13) LimitReader
;;   "LimitReader returns a Reader that reads from r\nbut stops with EOF after n bytes.\nThe underlying implementation is a *LimitedReader.\n"
;;   {:added "1.0"
;;    :go "limitReader(r, n)"}
;;   [r, n])

JOKER FUNC io.MultiReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/io/io.go:77:13) MultiReader
;;   "MultiReader returns a Reader that's the logical concatenation of\nthe provided input readers. They're read sequentially. Once all\ninputs have returned EOF, Read will return EOF.  If any of the readers\nreturn a non-nil, non-EOF error, Read will return that error.\n"
;;   {:added "1.0"
;;    :go "multiReader(readers)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/io/multi.go:48:26) readers])

JOKER FUNC io.MultiWriter has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/io/io.go:90:13) MultiWriter
;;   "MultiWriter creates a writer that duplicates its writes to all the\nprovided writers, similar to the Unix tee(1) command.\n\nEach write is written to each listed writer, one at a time.\nIf a listed writer returns an error, that overall write operation\nstops and returns the error; it does not continue down the list.\n"
;;   {:added "1.0"
;;    :go "multiWriter(writers)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/io/multi.go:102:26) writers])

JOKER FUNC io.NewSectionReader has:
(defn ^{:r r, :base base, :off off, :limit limit} NewSectionReader
  "NewSectionReader returns a SectionReader that reads from r\nstarting at offset off and stops with EOF after n bytes.\n"
  {:added "1.0"
   :go "newSectionReader(r, off, n)"}
  [r, off, n])

JOKER FUNC io.Pipe has:
;; (defn ^[{:p ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/io/pipe.go:118:4) p} {:p ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/io/pipe.go:144:4) p}] Pipe
;;   "Pipe creates a synchronous in-memory pipe.\nIt can be used to connect code expecting an io.Reader\nwith code expecting an io.Writer.\n\nReads and Writes on the pipe are matched one to one\nexcept when multiple Reads are needed to consume a single Write.\nThat is, each Write to the PipeWriter blocks until it has satisfied\none or more Reads from the PipeReader that fully consume\nthe written data.\nThe data is copied directly from the Write to the corresponding\nRead (or Reads); there is no internal buffering.\n\nIt is safe to call Read and Write in parallel with each other or with Close.\nParallel calls to Read and parallel calls to Write are also safe:\nthe individual calls will be gated sequentially.\n"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC io.ReadAtLeast has:
;; (defn ^[n err] ReadAtLeast
;;   "ReadAtLeast reads from r into buf until it has read at least min bytes.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading fewer than min bytes,\nReadAtLeast returns ErrUnexpectedEOF.\nIf min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\nOn return, n >= min if and only if err == nil.\nIf r returns an error having read at least min bytes, the error is dropped.\n"
;;   {:added "1.0"
;;    :go "readAtLeast(r, buf, min)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/io.go:304:32) buf, ^Int min])

JOKER FUNC io.ReadFull has:
;; (defn ^[n err] ReadFull
;;   "ReadFull reads exactly len(buf) bytes from r into buf.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nReadFull returns ErrUnexpectedEOF.\nOn return, n == len(buf) if and only if err == nil.\nIf r returns an error having read at least len(buf) bytes, the error is dropped.\n"
;;   {:added "1.0"
;;    :go "readFull(r, buf)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/io.go:328:29) buf])

JOKER FUNC io.TeeReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/io/io.go:77:13) TeeReader
;;   "TeeReader returns a Reader that writes to w what it reads from r.\nAll reads from r performed through it are matched with\ncorresponding writes to w. There is no internal buffering -\nthe write must complete before the read completes.\nAny error encountered while writing is reported as a read error.\n"
;;   {:added "1.0"
;;    :go "teeReader(r, w)"}
;;   [r, w])

JOKER FUNC io.WriteString has:
(defn ^[n err] WriteString
  "WriteString writes the contents of the string s to w, which accepts a slice of bytes.\nIf w implements a WriteString method, it is invoked directly.\nOtherwise, w.Write is called exactly once.\n"
  {:added "1.0"
   :go "writeString(w, s)"}
  [w, ^String s])

JOKER FUNC iotest.DataErrReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:45:33) DataErrReader
;;   "DataErrReader changes the way errors are handled by a Reader. Normally, a\nReader returns an error (typically EOF) from the first Read call after the\nlast piece of data is read. DataErrReader wraps a Reader and changes its\nbehavior so the final error is returned along with the final data, instead\nof in the first call after the final data.\n"
;;   {:added "1.0"
;;    :go "dataErrReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:45:22) r])

JOKER FUNC iotest.HalfReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:30:30) HalfReader
;;   "HalfReader returns a Reader that implements Read\nby reading half as many requested bytes from r.\n"
;;   {:added "1.0"
;;    :go "halfReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:30:19) r])

JOKER FUNC iotest.NewReadLogger has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/logger.go:52:48) NewReadLogger
;;   "NewReadLogger returns a reader that behaves like r except\nthat it logs (using log.Printf) each read to standard error,\nprinting the prefix and the hexadecimal data read.\n"
;;   {:added "1.0"
;;    :go "newReadLogger(prefix, r)"}
;;   [^String prefix, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/logger.go:52:37) r])

JOKER FUNC iotest.NewWriteLogger has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/logger.go:30:49) NewWriteLogger
;;   "NewWriteLogger returns a writer that behaves like w except\nthat it logs (using log.Printf) each write to standard error,\nprinting the prefix and the hexadecimal data written.\n"
;;   {:added "1.0"
;;    :go "newWriteLogger(prefix, w)"}
;;   [^String prefix, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/logger.go:30:38) w])

JOKER FUNC iotest.OneByteReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:15:33) OneByteReader
;;   "OneByteReader returns a Reader that implements\neach non-empty Read by reading one byte from r.\n"
;;   {:added "1.0"
;;    :go "oneByteReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:15:22) r])

JOKER FUNC iotest.TimeoutReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:75:33) TimeoutReader
;;   "TimeoutReader returns ErrTimeout on the second read\nwith no data. Subsequent calls to read succeed.\n"
;;   {:added "1.0"
;;    :go "timeoutReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/reader.go:75:22) r])

JOKER FUNC iotest.TruncateWriter has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/writer.go:11:43) TruncateWriter
;;   "TruncateWriter returns a Writer that writes to w\nbut stops silently after n bytes.\n"
;;   {:added "1.0"
;;    :go "truncateWriter(w, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/iotest/writer.go:11:23) w, n])

JOKER FUNC ioutil.NopCloser has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:118:29) NopCloser
;;   "NopCloser returns a ReadCloser with a no-op Close method wrapping\nthe provided Reader r.\n"
;;   {:added "1.0"
;;    :go "nopCloser(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:118:18) r])

JOKER FUNC ioutil.ReadAll has:
;; (defn ^[[ABEND042(cannot find typename ioutil.byte)] Error] ReadAll
;;   "ReadAll reads from r until an error or EOF and returns the data it read.\nA successful call returns err == nil, not err == EOF. Because ReadAll is\ndefined to read from src until EOF, it does not treat an EOF from Read\nas an error to be reported.\n"
;;   {:added "1.0"
;;    :go "readAll(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:44:16) r])

JOKER FUNC ioutil.ReadDir has:
;; (defn ^[[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:96:33)] Error] ReadDir
;;   "ReadDir reads the directory named by dirname and returns\na list of directory entries sorted by filename.\n"
;;   {:added "1.0"
;;    :go "readDir(dirname)"}
;;   [^String dirname])

JOKER FUNC ioutil.ReadFile has:
;; (defn ^[[ABEND042(cannot find typename ioutil.byte)] Error] ReadFile
;;   "ReadFile reads the file named by filename and returns the contents.\nA successful call returns err == nil, not err == EOF. Because ReadFile\nreads the whole file, it does not treat an EOF from Read as an error\nto be reported.\n"
;;   {:added "1.0"
;;    :go "readFile(filename)"}
;;   [^String filename])

JOKER FUNC ioutil.TempDir has:
(defn ^[name err] TempDir
  "TempDir creates a new temporary directory in the directory dir\nwith a name beginning with prefix and returns the path of the\nnew directory. If dir is the empty string, TempDir uses the\ndefault directory for temporary files (see os.TempDir).\nMultiple programs calling TempDir simultaneously\nwill not choose the same directory. It is the caller's responsibility\nto remove the directory when no longer needed.\n"
  {:added "1.0"
   :go "tempDir(dir, prefix)"}
  [^String dir, ^String prefix])

JOKER FUNC ioutil.TempFile has:
(defn ^[f err] TempFile
  "TempFile creates a new temporary file in the directory dir,\nopens the file for reading and writing, and returns the resulting *os.File.\nThe filename is generated by taking pattern and adding a random\nstring to the end. If pattern includes a \"*\", the random string\nreplaces the last \"*\".\nIf dir is the empty string, TempFile uses the default directory\nfor temporary files (see os.TempDir).\nMultiple programs calling TempFile simultaneously\nwill not choose the same file. The caller can use f.Name()\nto find the pathname of the file. It is the caller's responsibility\nto remove the file when no longer needed.\n"
  {:added "1.0"
   :go "tempFile(dir, pattern)"}
  [^String dir, ^String pattern])

JOKER FUNC ioutil.WriteFile has:
;; (defn ^Error WriteFile
;;   "WriteFile writes data to a file named by filename.\nIf the file does not exist, WriteFile creates it with permissions perm;\notherwise WriteFile truncates it before writing.\n"
;;   {:added "1.0"
;;    :go "writeFile(filename, data, perm)"}
;;   [^String filename, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/io/ioutil/ioutil.go:79:38) data, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/io/ioutil/ioutil.go:79:51) perm])

JOKER FUNC jpeg.Decode has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/reader.go:777:27) Error] Decode
;;   "Decode reads a JPEG image from r and returns it as an image.Image.\n"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/reader.go:777:15) r])

JOKER FUNC jpeg.DecodeConfig has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/reader.go:784:33) Error] DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a JPEG image without\ndecoding the entire image.\n"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/reader.go:784:21) r])

JOKER FUNC jpeg.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\noptions. Default parameters are used if a nil *Options is passed.\n"
;;   {:added "1.0"
;;    :go "encode(w, m, o)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/writer.go:575:15) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/jpeg/writer.go:575:28) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/image/jpeg/writer.go:575:43) o])

JOKER FUNC json.Compact has:
;; (defn ^Error Compact
;;   "Compact appends to dst the JSON-encoded src with\ninsignificant space characters elided.\n"
;;   {:added "1.0"
;;    :go "compact(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/json/indent.go:11:18) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/indent.go:11:37) src])

JOKER FUNC json.HTMLEscape has:
;; (defn HTMLEscape
;;   "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029\ncharacters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029\nso that the JSON will be safe to embed inside HTML <script> tags.\nFor historical reasons, web browsers don't honor standard HTML\nescaping within <script> tags, so an alternative JSON encoding must\nbe used.\n"
;;   {:added "1.0"
;;    :go "hTMLEscape(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/json/encode.go:194:21) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/encode.go:194:40) src])

JOKER FUNC json.Indent has:
;; (defn ^Error Indent
;;   "Indent appends to dst an indented form of the JSON-encoded src.\nEach element in a JSON object or array begins on a new,\nindented line beginning with prefix followed by one or more\ncopies of indent according to the indentation nesting.\nThe data appended to dst does not begin with the prefix nor\nany indentation, to make it easier to embed inside other formatted JSON data.\nAlthough leading space characters (space, tab, carriage return, newline)\nat the beginning of src are dropped, trailing space characters\nat the end of src are preserved and copied to dst.\nFor example, if src has no trailing spaces, neither will dst;\nif src ends in a trailing newline, so will dst.\n"
;;   {:added "1.0"
;;    :go "indent(dst, src, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/json/indent.go:79:17) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/indent.go:79:36) src, ^String prefix, ^String indent])

JOKER FUNC json.Marshal has:
;; (defn ^[[ABEND042(cannot find typename json.byte)] Error] Marshal
;;   "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively.\nIf an encountered value implements the Marshaler interface\nand is not a nil pointer, Marshal calls its MarshalJSON method\nto produce JSON. If no MarshalJSON method is present but the\nvalue implements encoding.TextMarshaler instead, Marshal calls\nits MarshalText method and encodes the result as a JSON string.\nThe nil pointer exception is not strictly necessary\nbut mimics a similar, necessary exception in the behavior of\nUnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers.\n\nString values encode as JSON strings coerced to valid UTF-8,\nreplacing invalid bytes with the Unicode replacement rune.\nThe angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\nto keep some browsers from misinterpreting JSON output as HTML.\nAmpersand \"&\" is also escaped to \"\\u0026\" for the same reason.\nThis escaping can be disabled using an Encoder that had SetEscapeHTML(false)\ncalled on it.\n\nArray and slice values encode as JSON arrays, except that\n[]byte encodes as a base64-encoded string, and a nil slice\nencodes as the null JSON value.\n\nStruct values encode as JSON objects.\nEach exported struct field becomes a member of the object, using the\nfield name as the object key, unless the field is omitted for one of the\nreasons given below.\n\nThe encoding of each struct field can be customized by the format string\nstored under the \"json\" key in the struct field's tag.\nThe format string gives the name of the field, possibly followed by a\ncomma-separated list of options. The name may be empty in order to\nspecify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted\nfrom the encoding if the field has an empty value, defined as\nfalse, 0, a nil pointer, a nil interface value, and any empty array,\nslice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted.\nNote that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n  // Field appears in JSON as key \"myName\".\n  Field int `json:\"myName\"`\n\n  // Field appears in JSON as key \"myName\" and\n  // the field is omitted from the object if its value is empty,\n  // as defined above.\n  Field int `json:\"myName,omitempty\"`\n\n  // Field appears in JSON as key \"Field\" (the default), but\n  // the field is skipped if empty.\n  // Note the leading comma.\n  Field int `json:\",omitempty\"`\n\n  // Field is ignored by this package.\n  Field int `json:\"-\"`\n\n  // Field appears in JSON as key \"-\".\n  Field int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a\nJSON-encoded string. It applies only to fields of string, floating point,\ninteger, or boolean types. This extra level of encoding is sometimes used\nwhen communicating with JavaScript programs:\n\n   Int64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of\nonly Unicode letters, digits, and ASCII punctuation except quotation\nmarks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields\nwere fields in the outer struct, subject to the usual Go visibility rules amended\nas described in the next paragraph.\nAn anonymous struct field with a name given in its JSON tag is treated as\nhaving that name, rather than being anonymous.\nAn anonymous struct field of interface type is treated the same as having\nthat type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when\ndeciding which field to marshal or unmarshal. If there are\nmultiple fields at the same level, and that level is the least\nnested (and would therefore be the nesting level selected by the\nusual Go rules), the following extra rules apply:\n\n1) Of those fields, if any are JSON-tagged, only tagged fields are considered,\neven if there are multiple untagged fields that would otherwise conflict.\n\n2) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1.\nPrior to Go 1.1, anonymous struct fields were ignored. To force ignoring of\nan anonymous struct field in both current and earlier versions, give the field\na JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a\nstring, an integer type, or implement encoding.TextMarshaler. The map keys\nare sorted and used as JSON object keys by applying the following rules,\nsubject to the UTF-8 coercion described for string values above:\n  - string keys are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to.\nA nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface.\nA nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON.\nAttempting to encode such a value causes Marshal to return\nan UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not\nhandle them. Passing cyclic structures to Marshal will result in\nan infinite recursion.\n"
;;   {:added "1.0"
;;    :go "marshal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/json/encode.go:157:16) v])

JOKER FUNC json.MarshalIndent has:
;; (defn ^[[ABEND042(cannot find typename json.byte)] Error] MarshalIndent
;;   "MarshalIndent is like Marshal but applies Indent to format the output.\nEach JSON element in the output will begin on a new line beginning with prefix\nfollowed by one or more copies of indent according to the indentation nesting.\n"
;;   {:added "1.0"
;;    :go "marshalIndent(v, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/json/encode.go:175:22) v, ^String prefix, ^String indent])

JOKER FUNC json.NewDecoder has:
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:15:10) r, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/stream.go:16:10) buf, :d d, :scanp ^Int scanp, :scanned scanned, :scan scan, :err err, :tokenstate ^Int tokenState, :tokenstack ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/stream.go:24:13) tokenStack} NewDecoder
;;   "NewDecoder returns a new decoder that reads from r.\n\nThe decoder introduces its own buffering and may\nread data from r beyond the JSON values requested.\n"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:31:19) r])

JOKER FUNC json.NewEncoder has:
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:176:13) w, :err err, :escapehtml escapeHTML, :indentbuf ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/json/stream.go:180:15) indentBuf, :indentprefix ^String indentPrefix, :indentvalue ^String indentValue} NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/json/stream.go:186:19) w])

JOKER FUNC json.Unmarshal has:
;; (defn ^Error Unmarshal
;;   "Unmarshal parses the JSON-encoded data and stores the result\nin the value pointed to by v. If v is nil or not a pointer,\nUnmarshal returns an InvalidUnmarshalError.\n\nUnmarshal uses the inverse of the encodings that\nMarshal uses, allocating maps, slices, and pointers as necessary,\nwith the following additional rules:\n\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of\nthe JSON being the JSON literal null. In that case, Unmarshal sets\nthe pointer to nil. Otherwise, Unmarshal unmarshals the JSON into\nthe value pointed at by the pointer. If the pointer is nil, Unmarshal\nallocates a new value for it to point to.\n\nTo unmarshal JSON into a value implementing the Unmarshaler interface,\nUnmarshal calls that value's UnmarshalJSON method, including\nwhen the input is a JSON null.\nOtherwise, if the value implements encoding.TextUnmarshaler\nand the input is a JSON quoted string, Unmarshal calls that value's\nUnmarshalText method with the unquoted form of the string.\n\nTo unmarshal JSON into a struct, Unmarshal matches incoming object\nkeys to the keys used by Marshal (either the struct field name or its tag),\npreferring an exact match but also accepting a case-insensitive match. By\ndefault, object keys which don't have a corresponding struct field are\nignored (see Decoder.DisallowUnknownFields for an alternative).\n\nTo unmarshal JSON into an interface value,\nUnmarshal stores one of these in the interface value:\n\n\tbool, for JSON booleans\n\tfloat64, for JSON numbers\n\tstring, for JSON strings\n\t[]interface{}, for JSON arrays\n\tmap[string]interface{}, for JSON objects\n\tnil for JSON null\n\nTo unmarshal a JSON array into a slice, Unmarshal resets the slice length\nto zero and then appends each element to the slice.\nAs a special case, to unmarshal an empty JSON array into a slice,\nUnmarshal replaces the slice with a new empty slice.\n\nTo unmarshal a JSON array into a Go array, Unmarshal decodes\nJSON array elements into corresponding Go array elements.\nIf the Go array is smaller than the JSON array,\nthe additional JSON array elements are discarded.\nIf the JSON array is smaller than the Go array,\nthe additional Go array elements are set to zero values.\n\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to\nuse. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal\nreuses the existing map, keeping existing entries. Unmarshal then stores\nkey-value pairs from the JSON object into the map. The map's key type must\neither be a string, an integer, or implement encoding.TextUnmarshaler.\n\nIf a JSON value is not appropriate for a given target type,\nor if a JSON number overflows the target type, Unmarshal\nskips that field and completes the unmarshaling as best it can.\nIf no more serious errors are encountered, Unmarshal returns\nan UnmarshalTypeError describing the earliest such error. In any\ncase, it's not guaranteed that all the remaining fields following\nthe problematic one will be unmarshaled into the target object.\n\nThe JSON null value unmarshals into an interface, map, pointer, or slice\nby setting that Go value to nil. Because null is often used in JSON to mean\n``not present,'' unmarshaling a JSON null into any other Go type has no effect\non the value and produces no error.\n\nWhen unmarshaling quoted strings, invalid UTF-8 or\ninvalid UTF-16 surrogate pairs are not treated as an error.\nInstead, they are replaced by the Unicode replacement\ncharacter U+FFFD.\n"
;;   {:added "1.0"
;;    :go "unmarshal(data, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/decode.go:96:21) data, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/json/decode.go:96:31) v])

JOKER FUNC json.Valid has:
;; (defn ^ABEND042(cannot find typename json.bool) Valid
;;   "Valid reports whether data is a valid JSON encoding.\n"
;;   {:added "1.0"
;;    :go "valid(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/scanner.go:19:17) data])

JOKER FUNC jsonrpc.Dial has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:118:38) Error] Dial
;;   "Dial connects to a JSON-RPC server at the specified network address.\n"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC jsonrpc.NewClient has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:113:42) NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n"
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:113:21) conn])

JOKER FUNC jsonrpc.NewClientCodec has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:37:46) NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n"
;;   {:added "1.0"
;;    :go "newClientCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/client.go:37:26) conn])

JOKER FUNC jsonrpc.NewServerCodec has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/server.go:37:46) NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n"
;;   {:added "1.0"
;;    :go "newServerCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/server.go:37:26) conn])

JOKER FUNC jsonrpc.ServeConn has:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n"
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/server.go:132:21) conn])

JOKER FUNC list.New has:
(defn ^{:root root, :len ^Int len} New
  "New returns an initialized list.\n"
  {:added "1.0"
   :go "new()"}
  [])

JOKER FUNC log.Fatal has:
;; (defn Fatal
;;   "Fatal is equivalent to Print() followed by a call to os.Exit(1).\n"
;;   {:added "1.0"
;;    :go "fatal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:305:14) v])

JOKER FUNC log.Fatalf has:
;; (defn Fatalf
;;   "Fatalf is equivalent to Printf() followed by a call to os.Exit(1).\n"
;;   {:added "1.0"
;;    :go "fatalf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:311:30) v])

JOKER FUNC log.Fatalln has:
;; (defn Fatalln
;;   "Fatalln is equivalent to Println() followed by a call to os.Exit(1).\n"
;;   {:added "1.0"
;;    :go "fatalln(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:317:16) v])

JOKER FUNC log.Flags has:
(defn ^Int Flags
  "Flags returns the output flags for the standard logger.\n"
  {:added "1.0"
   :go "flags()"}
  [])

JOKER FUNC log.New has:
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:51:9) mu, :prefix ^String prefix, :flag ^Int flag, :out ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:54:9) out, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/log/log.go:55:9) buf} New
;;   "New creates a new Logger. The out variable sets the\ndestination to which log data will be written.\nThe prefix appears at the beginning of each generated log line.\nThe flag argument defines the logging properties.\n"
;;   {:added "1.0"
;;    :go "new(out, prefix, flag)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:62:14) out, ^String prefix, ^Int flag])

JOKER FUNC log.Output has:
(defn ^Error Output
  "Output writes the output for a logging event. The string s contains\nthe text to print after the prefix specified by the flags of the\nLogger. A newline is appended if the last character of s is not\nalready a newline. Calldepth is the count of the number of\nframes to skip when computing the file name and line number\nif Llongfile or Lshortfile is set; a value of 1 will print the details\nfor the caller of Output.\n"
  {:added "1.0"
   :go "output(calldepth, s)"}
  [^Int calldepth, ^String s])

JOKER FUNC log.Panic has:
;; (defn Panic
;;   "Panic is equivalent to Print() followed by a call to panic().\n"
;;   {:added "1.0"
;;    :go "panic(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:323:14) v])

JOKER FUNC log.Panicf has:
;; (defn Panicf
;;   "Panicf is equivalent to Printf() followed by a call to panic().\n"
;;   {:added "1.0"
;;    :go "panicf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:330:30) v])

JOKER FUNC log.Panicln has:
;; (defn Panicln
;;   "Panicln is equivalent to Println() followed by a call to panic().\n"
;;   {:added "1.0"
;;    :go "panicln(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:337:16) v])

JOKER FUNC log.Prefix has:
(defn ^String Prefix
  "Prefix returns the output prefix for the standard logger.\n"
  {:added "1.0"
   :go "prefix()"}
  [])

JOKER FUNC log.Print has:
;; (defn Print
;;   "Print calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Print.\n"
;;   {:added "1.0"
;;    :go "print(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:288:14) v])

JOKER FUNC log.Printf has:
;; (defn Printf
;;   "Printf calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Printf.\n"
;;   {:added "1.0"
;;    :go "printf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:294:30) v])

JOKER FUNC log.Println has:
;; (defn Println
;;   "Println calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Println.\n"
;;   {:added "1.0"
;;    :go "println(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:300:16) v])

JOKER FUNC log.SetFlags has:
;; (defn SetFlags
;;   "SetFlags sets the output flags for the standard logger.\n"
;;   {:added "1.0"
;;    :go "setFlags(flag)"}
;;   [^Int flag])

JOKER FUNC log.SetOutput has:
;; (defn SetOutput
;;   "SetOutput sets the output destination for the standard logger.\n"
;;   {:added "1.0"
;;    :go "setOutput(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:258:18) w])

JOKER FUNC log.SetPrefix has:
;; (defn SetPrefix
;;   "SetPrefix sets the output prefix for the standard logger.\n"
;;   {:added "1.0"
;;    :go "setPrefix(prefix)"}
;;   [^String prefix])

JOKER FUNC lzw.NewReader has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/lzw/reader.go:239:56) NewReader
;;   "NewReader creates a new io.ReadCloser.\nReads from the returned io.ReadCloser read and decompress data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when\nfinished reading.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. It must equal the litWidth\nused during compression.\n"
;;   {:added "1.0"
;;    :go "newReader(r, order, litWidth)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/lzw/reader.go:239:18) r, order, ^Int litWidth])

JOKER FUNC lzw.NewWriter has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/lzw/writer.go:241:56) NewWriter
;;   "NewWriter creates a new io.WriteCloser.\nWrites to the returned io.WriteCloser are compressed and written to w.\nIt is the caller's responsibility to call Close on the WriteCloser when\nfinished writing.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.\n"
;;   {:added "1.0"
;;    :go "newWriter(w, order, litWidth)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/lzw/writer.go:241:18) w, order, ^Int litWidth])

JOKER FUNC macho.NewFatFile has:
;; (defn ^[{:magic Magic, :arches ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/macho/fat.go:17:9) Arches, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/fat.go:18:9) closer} Error] NewFatFile
;;   "NewFatFile creates a new FatFile for accessing all the Mach-O images in a\nuniversal binary. The Mach-O binary is expected to start at position 0 in\nthe ReaderAt.\n"
;;   {:added "1.0"
;;    :go "newFatFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/fat.go:45:19) r])

JOKER FUNC macho.NewFile has:
;; (defn ^[{:byteorder ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:24:12) ByteOrder, :loads ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/macho/file.go:25:12) Loads, :sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/macho/file.go:26:12) Sections, :symtab ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/debug/macho/file.go:28:11) Symtab, :dysymtab ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/debug/macho/file.go:29:11) Dysymtab, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:31:9) closer} Error] NewFile
;;   "NewFile creates a new File for accessing a Mach-O binary in an underlying reader.\nThe Mach-O binary is expected to start at position 0 in the ReaderAt.\n"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:228:16) r])

JOKER FUNC macho.Open has:
;; (defn ^[{:byteorder ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:24:12) ByteOrder, :loads ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/macho/file.go:25:12) Loads, :sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/macho/file.go:26:12) Sections, :symtab ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/debug/macho/file.go:28:11) Symtab, :dysymtab ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/debug/macho/file.go:29:11) Dysymtab, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/file.go:31:9) closer} Error] Open
;;   "Open opens the named file using os.Open and prepares it for use as a Mach-O binary.\n"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC macho.OpenFat has:
;; (defn ^[{:magic Magic, :arches ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/macho/fat.go:17:9) Arches, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/macho/fat.go:18:9) closer} Error] OpenFat
;;   "OpenFat opens the named file using os.Open and prepares it for use as a Mach-O\nuniversal binary.\n"
;;   {:added "1.0"
;;    :go "openFat(name)"}
;;   [^String name])

JOKER FUNC mail.ParseAddress has:
(defn ^[{:name ^String Name, :address ^String Address} Error] ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n"
  {:added "1.0"
   :go "parseAddress(address)"}
  [^String address])

JOKER FUNC mail.ParseAddressList has:
(defn ^[[{:name ^String Name, :address ^String Address}] Error] ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n"
  {:added "1.0"
   :go "parseAddressList(list)"}
  [^String list])

JOKER FUNC mail.ParseDate has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/mail/message.go:95:30) Error] ParseDate
;;   "ParseDate parses an RFC 5322 date string.\n"
;;   {:added "1.0"
;;    :go "parseDate(date)"}
;;   [^String date])

JOKER FUNC mail.ReadMessage has:
;; (defn ^[msg err] ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n"
;;   {:added "1.0"
;;    :go "readMessage(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/mail/message.go:52:20) r])

JOKER FUNC math.Abs has:
;; (defn ^ABEND042(cannot find typename math.float64) Abs
;;   "Abs returns the absolute value of x.\n\nSpecial cases are:\n\tAbs(Inf) = +Inf\n\tAbs(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "abs(x)"}
;;   [x])

JOKER FUNC math.Acos has:
;; (defn ^ABEND042(cannot find typename math.float64) Acos
;;   "Acos returns the arccosine, in radians, of x.\n\nSpecial case is:\n\tAcos(x) = NaN if x < -1 or x > 1\n"
;;   {:added "1.0"
;;    :go "acos(x)"}
;;   [x])

JOKER FUNC math.Acosh has:
;; (defn ^ABEND042(cannot find typename math.float64) Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nSpecial cases are:\n\tAcosh(+Inf) = +Inf\n\tAcosh(x) = NaN if x < 1\n\tAcosh(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "acosh(x)"}
;;   [x])

JOKER FUNC math.Asin has:
;; (defn ^ABEND042(cannot find typename math.float64) Asin
;;   "Asin returns the arcsine, in radians, of x.\n\nSpecial cases are:\n\tAsin(0) = 0\n\tAsin(x) = NaN if x < -1 or x > 1\n"
;;   {:added "1.0"
;;    :go "asin(x)"}
;;   [x])

JOKER FUNC math.Asinh has:
;; (defn ^ABEND042(cannot find typename math.float64) Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nSpecial cases are:\n\tAsinh(0) = 0\n\tAsinh(Inf) = Inf\n\tAsinh(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "asinh(x)"}
;;   [x])

JOKER FUNC math.Atan has:
;; (defn ^ABEND042(cannot find typename math.float64) Atan
;;   "Atan returns the arctangent, in radians, of x.\n\nSpecial cases are:\n     Atan(0) = 0\n     Atan(Inf) = Pi/2\n"
;;   {:added "1.0"
;;    :go "atan(x)"}
;;   [x])

JOKER FUNC math.Atan2 has:
;; (defn ^ABEND042(cannot find typename math.float64) Atan2
;;   "Atan2 returns the arc tangent of y/x, using\nthe signs of the two to determine the quadrant\nof the return value.\n\nSpecial cases are (in order):\n\tAtan2(y, NaN) = NaN\n\tAtan2(NaN, x) = NaN\n\tAtan2(+0, x>=0) = +0\n\tAtan2(-0, x>=0) = -0\n\tAtan2(+0, x<=-0) = +Pi\n\tAtan2(-0, x<=-0) = -Pi\n\tAtan2(y>0, 0) = +Pi/2\n\tAtan2(y<0, 0) = -Pi/2\n\tAtan2(+Inf, +Inf) = +Pi/4\n\tAtan2(-Inf, +Inf) = -Pi/4\n\tAtan2(+Inf, -Inf) = 3Pi/4\n\tAtan2(-Inf, -Inf) = -3Pi/4\n\tAtan2(y, +Inf) = 0\n\tAtan2(y>0, -Inf) = +Pi\n\tAtan2(y<0, -Inf) = -Pi\n\tAtan2(+Inf, x) = +Pi/2\n\tAtan2(-Inf, x) = -Pi/2\n"
;;   {:added "1.0"
;;    :go "atan2(y, x)"}
;;   [y, x])

JOKER FUNC math.Atanh has:
;; (defn ^ABEND042(cannot find typename math.float64) Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nSpecial cases are:\n\tAtanh(1) = +Inf\n\tAtanh(0) = 0\n\tAtanh(-1) = -Inf\n\tAtanh(x) = NaN if x < -1 or x > 1\n\tAtanh(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "atanh(x)"}
;;   [x])

JOKER FUNC math.Cbrt has:
;; (defn ^ABEND042(cannot find typename math.float64) Cbrt
;;   "Cbrt returns the cube root of x.\n\nSpecial cases are:\n\tCbrt(0) = 0\n\tCbrt(Inf) = Inf\n\tCbrt(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "cbrt(x)"}
;;   [x])

JOKER FUNC math.Ceil has:
;; (defn ^ABEND042(cannot find typename math.float64) Ceil
;;   "Ceil returns the least integer value greater than or equal to x.\n\nSpecial cases are:\n\tCeil(0) = 0\n\tCeil(Inf) = Inf\n\tCeil(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "ceil(x)"}
;;   [x])

JOKER FUNC math.Copysign has:
;; (defn ^ABEND042(cannot find typename math.float64) Copysign
;;   "Copysign returns a value with the magnitude\nof x and the sign of y.\n"
;;   {:added "1.0"
;;    :go "copysign(x, y)"}
;;   [x, y])

JOKER FUNC math.Cos has:
;; (defn ^ABEND042(cannot find typename math.float64) Cos
;;   "Cos returns the cosine of the radian argument x.\n\nSpecial cases are:\n\tCos(Inf) = NaN\n\tCos(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "cos(x)"}
;;   [x])

JOKER FUNC math.Cosh has:
;; (defn ^ABEND042(cannot find typename math.float64) Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nSpecial cases are:\n\tCosh(0) = 1\n\tCosh(Inf) = +Inf\n\tCosh(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "cosh(x)"}
;;   [x])

JOKER FUNC math.Dim has:
;; (defn ^ABEND042(cannot find typename math.float64) Dim
;;   "Dim returns the maximum of x-y or 0.\n\nSpecial cases are:\n\tDim(+Inf, +Inf) = NaN\n\tDim(-Inf, -Inf) = NaN\n\tDim(x, NaN) = Dim(NaN, x) = NaN\n"
;;   {:added "1.0"
;;    :go "dim(x, y)"}
;;   [x, y])

JOKER FUNC math.Erf has:
;; (defn ^ABEND042(cannot find typename math.float64) Erf
;;   "Erf returns the error function of x.\n\nSpecial cases are:\n\tErf(+Inf) = 1\n\tErf(-Inf) = -1\n\tErf(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "erf(x)"}
;;   [x])

JOKER FUNC math.Erfc has:
;; (defn ^ABEND042(cannot find typename math.float64) Erfc
;;   "Erfc returns the complementary error function of x.\n\nSpecial cases are:\n\tErfc(+Inf) = 0\n\tErfc(-Inf) = 2\n\tErfc(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "erfc(x)"}
;;   [x])

JOKER FUNC math.Erfcinv has:
;; (defn ^ABEND042(cannot find typename math.float64) Erfcinv
;;   "Erfcinv returns the inverse of Erfc(x).\n\nSpecial cases are:\n\tErfcinv(0) = +Inf\n\tErfcinv(2) = -Inf\n\tErfcinv(x) = NaN if x < 0 or x > 2\n\tErfcinv(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "erfcinv(x)"}
;;   [x])

JOKER FUNC math.Erfinv has:
;; (defn ^ABEND042(cannot find typename math.float64) Erfinv
;;   "Erfinv returns the inverse error function of x.\n\nSpecial cases are:\n\tErfinv(1) = +Inf\n\tErfinv(-1) = -Inf\n\tErfinv(x) = NaN if x < -1 or x > 1\n\tErfinv(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "erfinv(x)"}
;;   [x])

JOKER FUNC math.Exp has:
;; (defn ^ABEND042(cannot find typename math.float64) Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nSpecial cases are:\n\tExp(+Inf) = +Inf\n\tExp(NaN) = NaN\nVery large values overflow to 0 or +Inf.\nVery small values underflow to 1.\n"
;;   {:added "1.0"
;;    :go "exp(x)"}
;;   [x])

JOKER FUNC math.Exp2 has:
;; (defn ^ABEND042(cannot find typename math.float64) Exp2
;;   "Exp2 returns 2**x, the base-2 exponential of x.\n\nSpecial cases are the same as Exp.\n"
;;   {:added "1.0"
;;    :go "exp2(x)"}
;;   [x])

JOKER FUNC math.Expm1 has:
;; (defn ^ABEND042(cannot find typename math.float64) Expm1
;;   "Expm1 returns e**x - 1, the base-e exponential of x minus 1.\nIt is more accurate than Exp(x) - 1 when x is near zero.\n\nSpecial cases are:\n\tExpm1(+Inf) = +Inf\n\tExpm1(-Inf) = -1\n\tExpm1(NaN) = NaN\nVery large values overflow to -1 or +Inf.\n"
;;   {:added "1.0"
;;    :go "expm1(x)"}
;;   [x])

JOKER FUNC math.Float32bits has:
;; (defn ^ABEND042(cannot find typename math.uint32) Float32bits
;;   "Float32bits returns the IEEE 754 binary representation of f.\n"
;;   {:added "1.0"
;;    :go "float32bits(f)"}
;;   [f])

JOKER FUNC math.Float32frombits has:
;; (defn ^ABEND042(cannot find typename math.float32) Float32frombits
;;   "Float32frombits returns the floating point number corresponding\nto the IEEE 754 binary representation b.\n"
;;   {:added "1.0"
;;    :go "float32frombits(b)"}
;;   [b])

JOKER FUNC math.Float64bits has:
;; (defn ^ABEND042(cannot find typename math.uint64) Float64bits
;;   "Float64bits returns the IEEE 754 binary representation of f.\n"
;;   {:added "1.0"
;;    :go "float64bits(f)"}
;;   [f])

JOKER FUNC math.Float64frombits has:
;; (defn ^ABEND042(cannot find typename math.float64) Float64frombits
;;   "Float64frombits returns the floating point number corresponding\nthe IEEE 754 binary representation b.\n"
;;   {:added "1.0"
;;    :go "float64frombits(b)"}
;;   [b])

JOKER FUNC math.Floor has:
;; (defn ^ABEND042(cannot find typename math.float64) Floor
;;   "Floor returns the greatest integer value less than or equal to x.\n\nSpecial cases are:\n\tFloor(0) = 0\n\tFloor(Inf) = Inf\n\tFloor(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "floor(x)"}
;;   [x])

JOKER FUNC math.Frexp has:
(defn ^[frac exp] Frexp
  "Frexp breaks f into a normalized fraction\nand an integral power of two.\nIt returns frac and exp satisfying f == frac  2**exp,\nwith the absolute value of frac in the interval [, 1).\n\nSpecial cases are:\n\tFrexp(0) = 0, 0\n\tFrexp(Inf) = Inf, 0\n\tFrexp(NaN) = NaN, 0\n"
  {:added "1.0"
   :go "frexp(f)"}
  [f])

JOKER FUNC math.Gamma has:
;; (defn ^ABEND042(cannot find typename math.float64) Gamma
;;   "Gamma returns the Gamma function of x.\n\nSpecial cases are:\n\tGamma(+Inf) = +Inf\n\tGamma(+0) = +Inf\n\tGamma(-0) = -Inf\n\tGamma(x) = NaN for integer x < 0\n\tGamma(-Inf) = NaN\n\tGamma(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "gamma(x)"}
;;   [x])

JOKER FUNC math.Hypot has:
;; (defn ^ABEND042(cannot find typename math.float64) Hypot
;;   "Hypot returns Sqrt(p*p + q*q), taking care to avoid\nunnecessary overflow and underflow.\n\nSpecial cases are:\n\tHypot(Inf, q) = +Inf\n\tHypot(p, Inf) = +Inf\n\tHypot(NaN, q) = NaN\n\tHypot(p, NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "hypot(p, q)"}
;;   [p, q])

JOKER FUNC math.Ilogb has:
(defn ^Int Ilogb
  "Ilogb returns the binary exponent of x as an integer.\n\nSpecial cases are:\n\tIlogb(Inf) = MaxInt32\n\tIlogb(0) = MinInt32\n\tIlogb(NaN) = MaxInt32\n"
  {:added "1.0"
   :go "ilogb(x)"}
  [x])

JOKER FUNC math.Inf has:
;; (defn ^ABEND042(cannot find typename math.float64) Inf
;;   "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.\n"
;;   {:added "1.0"
;;    :go "inf(sign)"}
;;   [^Int sign])

JOKER FUNC math.IsInf has:
;; (defn ^ABEND042(cannot find typename math.bool) IsInf
;;   "IsInf reports whether f is an infinity, according to sign.\nIf sign > 0, IsInf reports whether f is positive infinity.\nIf sign < 0, IsInf reports whether f is negative infinity.\nIf sign == 0, IsInf reports whether f is either infinity.\n"
;;   {:added "1.0"
;;    :go "isInf(f, sign)"}
;;   [f, ^Int sign])

JOKER FUNC math.IsNaN has:
(defn ^is IsNaN
  "IsNaN reports whether f is an IEEE 754 ``not-a-number'' value.\n"
  {:added "1.0"
   :go "isNaN(f)"}
  [f])

JOKER FUNC math.J0 has:
;; (defn ^ABEND042(cannot find typename math.float64) J0
;;   "J0 returns the order-zero Bessel function of the first kind.\n\nSpecial cases are:\n\tJ0(Inf) = 0\n\tJ0(0) = 1\n\tJ0(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "j0(x)"}
;;   [x])

JOKER FUNC math.J1 has:
;; (defn ^ABEND042(cannot find typename math.float64) J1
;;   "J1 returns the order-one Bessel function of the first kind.\n\nSpecial cases are:\n\tJ1(Inf) = 0\n\tJ1(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "j1(x)"}
;;   [x])

JOKER FUNC math.Jn has:
;; (defn ^ABEND042(cannot find typename math.float64) Jn
;;   "Jn returns the order-n Bessel function of the first kind.\n\nSpecial cases are:\n\tJn(n, Inf) = 0\n\tJn(n, NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "jn(n, x)"}
;;   [^Int n, x])

JOKER FUNC math.Ldexp has:
;; (defn ^ABEND042(cannot find typename math.float64) Ldexp
;;   "Ldexp is the inverse of Frexp.\nIt returns frac  2**exp.\n\nSpecial cases are:\n\tLdexp(0, exp) = 0\n\tLdexp(Inf, exp) = Inf\n\tLdexp(NaN, exp) = NaN\n"
;;   {:added "1.0"
;;    :go "ldexp(frac, exp)"}
;;   [frac, ^Int exp])

JOKER FUNC math.Lgamma has:
(defn ^[lgamma sign] Lgamma
  "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\n\nSpecial cases are:\n\tLgamma(+Inf) = +Inf\n\tLgamma(0) = +Inf\n\tLgamma(-integer) = +Inf\n\tLgamma(-Inf) = -Inf\n\tLgamma(NaN) = NaN\n"
  {:added "1.0"
   :go "lgamma(x)"}
  [x])

JOKER FUNC math.Log has:
;; (defn ^ABEND042(cannot find typename math.float64) Log
;;   "Log returns the natural logarithm of x.\n\nSpecial cases are:\n\tLog(+Inf) = +Inf\n\tLog(0) = -Inf\n\tLog(x < 0) = NaN\n\tLog(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "log(x)"}
;;   [x])

JOKER FUNC math.Log10 has:
;; (defn ^ABEND042(cannot find typename math.float64) Log10
;;   "Log10 returns the decimal logarithm of x.\nThe special cases are the same as for Log.\n"
;;   {:added "1.0"
;;    :go "log10(x)"}
;;   [x])

JOKER FUNC math.Log1p has:
;; (defn ^ABEND042(cannot find typename math.float64) Log1p
;;   "Log1p returns the natural logarithm of 1 plus its argument x.\nIt is more accurate than Log(1 + x) when x is near zero.\n\nSpecial cases are:\n\tLog1p(+Inf) = +Inf\n\tLog1p(0) = 0\n\tLog1p(-1) = -Inf\n\tLog1p(x < -1) = NaN\n\tLog1p(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "log1p(x)"}
;;   [x])

JOKER FUNC math.Log2 has:
;; (defn ^ABEND042(cannot find typename math.float64) Log2
;;   "Log2 returns the binary logarithm of x.\nThe special cases are the same as for Log.\n"
;;   {:added "1.0"
;;    :go "log2(x)"}
;;   [x])

JOKER FUNC math.Logb has:
;; (defn ^ABEND042(cannot find typename math.float64) Logb
;;   "Logb returns the binary exponent of x.\n\nSpecial cases are:\n\tLogb(Inf) = +Inf\n\tLogb(0) = -Inf\n\tLogb(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "logb(x)"}
;;   [x])

JOKER FUNC math.Max has:
;; (defn ^ABEND042(cannot find typename math.float64) Max
;;   "Max returns the larger of x or y.\n\nSpecial cases are:\n\tMax(x, +Inf) = Max(+Inf, x) = +Inf\n\tMax(x, NaN) = Max(NaN, x) = NaN\n\tMax(+0, 0) = Max(0, +0) = +0\n\tMax(-0, -0) = -0\n"
;;   {:added "1.0"
;;    :go "max(x, y)"}
;;   [x, y])

JOKER FUNC math.Min has:
;; (defn ^ABEND042(cannot find typename math.float64) Min
;;   "Min returns the smaller of x or y.\n\nSpecial cases are:\n\tMin(x, -Inf) = Min(-Inf, x) = -Inf\n\tMin(x, NaN) = Min(NaN, x) = NaN\n\tMin(-0, 0) = Min(0, -0) = -0\n"
;;   {:added "1.0"
;;    :go "min(x, y)"}
;;   [x, y])

JOKER FUNC math.Mod has:
;; (defn ^ABEND042(cannot find typename math.float64) Mod
;;   "Mod returns the floating-point remainder of x/y.\nThe magnitude of the result is less than y and its\nsign agrees with that of x.\n\nSpecial cases are:\n\tMod(Inf, y) = NaN\n\tMod(NaN, y) = NaN\n\tMod(x, 0) = NaN\n\tMod(x, Inf) = x\n\tMod(x, NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "mod(x, y)"}
;;   [x, y])

JOKER FUNC math.Modf has:
(defn ^[int frac] Modf
  "Modf returns integer and fractional floating-point numbers\nthat sum to f. Both values have the same sign as f.\n\nSpecial cases are:\n\tModf(Inf) = Inf, NaN\n\tModf(NaN) = NaN, NaN\n"
  {:added "1.0"
   :go "modf(f)"}
  [f])

JOKER FUNC math.NaN has:
;; (defn ^ABEND042(cannot find typename math.float64) NaN
;;   "NaN returns an IEEE 754 ``not-a-number'' value.\n"
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])

JOKER FUNC math.Nextafter has:
(defn ^r Nextafter
  "Nextafter returns the next representable float64 value after x towards y.\n\nSpecial cases are:\n\tNextafter(x, x)   = x\n\tNextafter(NaN, y) = NaN\n\tNextafter(x, NaN) = NaN\n"
  {:added "1.0"
   :go "nextafter(x, y)"}
  [x, y])

JOKER FUNC math.Nextafter32 has:
(defn ^r Nextafter32
  "Nextafter32 returns the next representable float32 value after x towards y.\n\nSpecial cases are:\n\tNextafter32(x, x)   = x\n\tNextafter32(NaN, y) = NaN\n\tNextafter32(x, NaN) = NaN\n"
  {:added "1.0"
   :go "nextafter32(x, y)"}
  [x, y])

JOKER FUNC math.Pow has:
;; (defn ^ABEND042(cannot find typename math.float64) Pow
;;   "Pow returns x**y, the base-x exponential of y.\n\nSpecial cases are (in order):\n\tPow(x, 0) = 1 for any x\n\tPow(1, y) = 1 for any y\n\tPow(x, 1) = x for any x\n\tPow(NaN, y) = NaN\n\tPow(x, NaN) = NaN\n\tPow(0, y) = Inf for y an odd integer < 0\n\tPow(0, -Inf) = +Inf\n\tPow(0, +Inf) = +0\n\tPow(0, y) = +Inf for finite y < 0 and not an odd integer\n\tPow(0, y) = 0 for y an odd integer > 0\n\tPow(0, y) = +0 for finite y > 0 and not an odd integer\n\tPow(-1, Inf) = 1\n\tPow(x, +Inf) = +Inf for |x| > 1\n\tPow(x, -Inf) = +0 for |x| > 1\n\tPow(x, +Inf) = +0 for |x| < 1\n\tPow(x, -Inf) = +Inf for |x| < 1\n\tPow(+Inf, y) = +Inf for y > 0\n\tPow(+Inf, y) = +0 for y < 0\n\tPow(-Inf, y) = Pow(-0, -y)\n\tPow(x, y) = NaN for finite x < 0 and finite non-integer y\n"
;;   {:added "1.0"
;;    :go "pow(x, y)"}
;;   [x, y])

JOKER FUNC math.Pow10 has:
;; (defn ^ABEND042(cannot find typename math.float64) Pow10
;;   "Pow10 returns 10**n, the base-10 exponential of n.\n\nSpecial cases are:\n\tPow10(n) =    0 for n < -323\n\tPow10(n) = +Inf for n > 308\n"
;;   {:added "1.0"
;;    :go "pow10(n)"}
;;   [^Int n])

JOKER FUNC math.Remainder has:
;; (defn ^ABEND042(cannot find typename math.float64) Remainder
;;   "Remainder returns the IEEE 754 floating-point remainder of x/y.\n\nSpecial cases are:\n\tRemainder(Inf, y) = NaN\n\tRemainder(NaN, y) = NaN\n\tRemainder(x, 0) = NaN\n\tRemainder(x, Inf) = x\n\tRemainder(x, NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "remainder(x, y)"}
;;   [x, y])

JOKER FUNC math.Round has:
;; (defn ^ABEND042(cannot find typename math.float64) Round
;;   "Round returns the nearest integer, rounding half away from zero.\n\nSpecial cases are:\n\tRound(0) = 0\n\tRound(Inf) = Inf\n\tRound(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "round(x)"}
;;   [x])

JOKER FUNC math.RoundToEven has:
;; (defn ^ABEND042(cannot find typename math.float64) RoundToEven
;;   "RoundToEven returns the nearest integer, rounding ties to even.\n\nSpecial cases are:\n\tRoundToEven(0) = 0\n\tRoundToEven(Inf) = Inf\n\tRoundToEven(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "roundToEven(x)"}
;;   [x])

JOKER FUNC math.Signbit has:
;; (defn ^ABEND042(cannot find typename math.bool) Signbit
;;   "Signbit returns true if x is negative or negative zero.\n"
;;   {:added "1.0"
;;    :go "signbit(x)"}
;;   [x])

JOKER FUNC math.Sin has:
;; (defn ^ABEND042(cannot find typename math.float64) Sin
;;   "Sin returns the sine of the radian argument x.\n\nSpecial cases are:\n\tSin(0) = 0\n\tSin(Inf) = NaN\n\tSin(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "sin(x)"}
;;   [x])

JOKER FUNC math.Sincos has:
(defn ^[sin cos] Sincos
  "Sincos returns Sin(x), Cos(x).\n\nSpecial cases are:\n\tSincos(0) = 0, 1\n\tSincos(Inf) = NaN, NaN\n\tSincos(NaN) = NaN, NaN\n"
  {:added "1.0"
   :go "sincos(x)"}
  [x])

JOKER FUNC math.Sinh has:
;; (defn ^ABEND042(cannot find typename math.float64) Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nSpecial cases are:\n\tSinh(0) = 0\n\tSinh(Inf) = Inf\n\tSinh(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "sinh(x)"}
;;   [x])

JOKER FUNC math.Sqrt has:
;; (defn ^ABEND042(cannot find typename math.float64) Sqrt
;;   "Sqrt returns the square root of x.\n\nSpecial cases are:\n\tSqrt(+Inf) = +Inf\n\tSqrt(0) = 0\n\tSqrt(x < 0) = NaN\n\tSqrt(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "sqrt(x)"}
;;   [x])

JOKER FUNC math.Tan has:
;; (defn ^ABEND042(cannot find typename math.float64) Tan
;;   "Tan returns the tangent of the radian argument x.\n\nSpecial cases are:\n\tTan(0) = 0\n\tTan(Inf) = NaN\n\tTan(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "tan(x)"}
;;   [x])

JOKER FUNC math.Tanh has:
;; (defn ^ABEND042(cannot find typename math.float64) Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nSpecial cases are:\n\tTanh(0) = 0\n\tTanh(Inf) = 1\n\tTanh(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "tanh(x)"}
;;   [x])

JOKER FUNC math.Trunc has:
;; (defn ^ABEND042(cannot find typename math.float64) Trunc
;;   "Trunc returns the integer value of x.\n\nSpecial cases are:\n\tTrunc(0) = 0\n\tTrunc(Inf) = Inf\n\tTrunc(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "trunc(x)"}
;;   [x])

JOKER FUNC math.Y0 has:
;; (defn ^ABEND042(cannot find typename math.float64) Y0
;;   "Y0 returns the order-zero Bessel function of the second kind.\n\nSpecial cases are:\n\tY0(+Inf) = 0\n\tY0(0) = -Inf\n\tY0(x < 0) = NaN\n\tY0(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "y0(x)"}
;;   [x])

JOKER FUNC math.Y1 has:
;; (defn ^ABEND042(cannot find typename math.float64) Y1
;;   "Y1 returns the order-one Bessel function of the second kind.\n\nSpecial cases are:\n\tY1(+Inf) = 0\n\tY1(0) = -Inf\n\tY1(x < 0) = NaN\n\tY1(NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "y1(x)"}
;;   [x])

JOKER FUNC math.Yn has:
;; (defn ^ABEND042(cannot find typename math.float64) Yn
;;   "Yn returns the order-n Bessel function of the second kind.\n\nSpecial cases are:\n\tYn(n, +Inf) = 0\n\tYn(n  0, 0) = -Inf\n\tYn(n < 0, 0) = +Inf if n is odd, -Inf if n is even\n\tYn(n, x < 0) = NaN\n\tYn(n, NaN) = NaN\n"
;;   {:added "1.0"
;;    :go "yn(n, x)"}
;;   [^Int n, x])

JOKER FUNC md5.New has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/md5/md5.go:130:12) New
;;   "New returns a new hash.Hash computing the MD5 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC md5.Sum has:
;; (defn ^[ABEND042(cannot find typename md5.byte)] Sum
;;   "Sum returns the MD5 checksum of the data.\n"
;;   {:added "1.0"
;;    :go "sum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/md5/md5.go:204:15) data])

JOKER FUNC mime.AddExtensionType has:
(defn ^Error AddExtensionType
  "AddExtensionType sets the MIME type associated with\nthe extension ext to typ. The extension should begin with\na leading dot, as in \".html\".\n"
  {:added "1.0"
   :go "addExtensionType(ext, typ)"}
  [^String ext, ^String typ])

JOKER FUNC mime.ExtensionsByType has:
(defn ^[[String] Error] ExtensionsByType
  "ExtensionsByType returns the extensions known to be associated with the MIME\ntype typ. The returned extensions will each begin with a leading dot, as in\n\".html\". When typ has no associated extensions, ExtensionsByType returns an\nnil slice.\n"
  {:added "1.0"
   :go "extensionsByType(typ)"}
  [^String typ])

JOKER FUNC mime.FormatMediaType has:
;; (defn ^String FormatMediaType
;;   "FormatMediaType serializes mediatype t and the parameters\nparam as a media type conforming to RFC 2045 and RFC 2616.\nThe type and parameter names are written in lower-case.\nWhen any of the arguments result in a standard violation then\nFormatMediaType returns the empty string.\n"
;;   {:added "1.0"
;;    :go "formatMediaType(t, param)"}
;;   [^String t, ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/mime/mediatype.go:20:38) param])

JOKER FUNC mime.ParseMediaType has:
(defn ^[mediatype params err] ParseMediaType
  "ParseMediaType parses a media type value and any optional\nparameters, per RFC 1521.  Media types are the values in\nContent-Type and Content-Disposition headers (RFC 2183).\nOn success, ParseMediaType returns the media type converted\nto lowercase and trimmed of white space and a non-nil map.\nIf there is an error parsing the optional parameter,\nthe media type will be returned along with the error\nErrInvalidMediaParameter.\nThe returned map, params, maps from the lowercase\nattribute to the attribute value with its case preserved.\n"
  {:added "1.0"
   :go "parseMediaType(v)"}
  [^String v])

JOKER FUNC mime.TypeByExtension has:
(defn ^String TypeByExtension
  "TypeByExtension returns the MIME type associated with the file extension ext.\nThe extension ext should begin with a leading dot, as in \".html\".\nWhen ext has no associated type, TypeByExtension returns \"\".\n\nExtensions are looked up first case-sensitively, then case-insensitively.\n\nThe built-in table is small but on unix it is augmented by the local\nsystem's mime.types file(s) if available under one or more of these\nnames:\n\n  /etc/mime.types\n  /etc/apache2/mime.types\n  /etc/apache/mime.types\n\nOn Windows, MIME types are extracted from the registry.\n\nText types have the charset parameter set to \"utf-8\" by default.\n"
  {:added "1.0"
   :go "typeByExtension(ext)"}
  [^String ext])

JOKER FUNC multipart.NewReader has:
;; (defn ^{:bufreader ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/mime/multipart/multipart.go:289:12) bufReader, :currentpart ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/mime/multipart/multipart.go:291:14) currentPart, :partsread ^Int partsRead, :nl ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/mime/multipart/multipart.go:294:19) nl, :nldashboundary ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/mime/multipart/multipart.go:295:19) nlDashBoundary, :dashboundarydash ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/mime/multipart/multipart.go:296:19) dashBoundaryDash, :dashboundary ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/mime/multipart/multipart.go:297:19) dashBoundary} NewReader
;;   "NewReader creates a new multipart Reader reading from r using the\ngiven MIME boundary.\n\nThe boundary is usually obtained from the \"boundary\" parameter of\nthe message's \"Content-Type\" header. Use mime.ParseMediaType to\nparse such headers.\n"
;;   {:added "1.0"
;;    :go "newReader(r, boundary)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/multipart.go:99:18) r, ^String boundary])

JOKER FUNC multipart.NewWriter has:
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/writer.go:20:11) w, :boundary ^String boundary, :lastpart ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/mime/multipart/writer.go:22:11) lastpart} NewWriter
;;   "NewWriter returns a new multipart Writer with a random boundary,\nwriting to w.\n"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/multipart/writer.go:27:18) w])

JOKER FUNC net.CIDRMask has:
;; (defn ^[ABEND042(cannot find typename net.byte)] CIDRMask
;;   "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n"
;;   {:added "1.0"
;;    :go "cIDRMask(ones, bits)"}
;;   [^Int ones, ^Int bits])

JOKER FUNC net.Dial has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:113:11) Error] Dial
;;   "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.DialIP has:
;; (defn ^[{} Error] DialIP
;;   "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n"
;;   {:added "1.0"
;;    :go "dialIP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/iprawsock.go:211:42) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/iprawsock.go:211:42) raddr])

JOKER FUNC net.DialTCP has:
;; (defn ^[{} Error] DialTCP
;;   "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n"
;;   {:added "1.0"
;;    :go "dialTCP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/tcpsock.go:206:43) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/tcpsock.go:206:43) raddr])

JOKER FUNC net.DialTimeout has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:113:11) Error] DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n"
;;   {:added "1.0"
;;    :go "dialTimeout(network, address, timeout)"}
;;   [^String network, ^String address, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/dial.go:313:51) timeout])

JOKER FUNC net.DialUDP has:
;; (defn ^[{} Error] DialUDP
;;   "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n"
;;   {:added "1.0"
;;    :go "dialUDP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:205:43) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:205:43) raddr])

JOKER FUNC net.DialUnix has:
;; (defn ^[{} Error] DialUnix
;;   "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n"
;;   {:added "1.0"
;;    :go "dialUnix(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:200:44) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:200:44) raddr])

JOKER FUNC net.FileConn has:
;; (defn ^[c err] FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n"
;;   {:added "1.0"
;;    :go "fileConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/file.go:21:17) f])

JOKER FUNC net.FileListener has:
;; (defn ^[ln err] FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n"
;;   {:added "1.0"
;;    :go "fileListener(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/file.go:33:21) f])

JOKER FUNC net.FilePacketConn has:
;; (defn ^[c err] FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n"
;;   {:added "1.0"
;;    :go "filePacketConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/file.go:45:23) f])

JOKER FUNC net.IPv4 has:
;; (defn ^[ABEND042(cannot find typename net.byte)] IPv4
;;   "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n"
;;   {:added "1.0"
;;    :go "iPv4(a, b, c, d)"}
;;   [a, b, c, d])

JOKER FUNC net.IPv4Mask has:
;; (defn ^[ABEND042(cannot find typename net.byte)] IPv4Mask
;;   "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n"
;;   {:added "1.0"
;;    :go "iPv4Mask(a, b, c, d)"}
;;   [a, b, c, d])

JOKER FUNC net.InterfaceAddrs has:
;; (defn ^[[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:105:11)] Error] InterfaceAddrs
;;   "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n"
;;   {:added "1.0"
;;    :go "interfaceAddrs()"}
;;   [])

JOKER FUNC net.InterfaceByIndex has:
(defn ^[{:index ^Int Index, :mtu ^Int MTU, :name ^String Name, :hardwareaddr HardwareAddr, :flags Flags} Error] InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n"
  {:added "1.0"
   :go "interfaceByIndex(index)"}
  [^Int index])

JOKER FUNC net.InterfaceByName has:
(defn ^[{:index ^Int Index, :mtu ^Int MTU, :name ^String Name, :hardwareaddr HardwareAddr, :flags Flags} Error] InterfaceByName
  "InterfaceByName returns the interface specified by name.\n"
  {:added "1.0"
   :go "interfaceByName(name)"}
  [^String name])

JOKER FUNC net.Interfaces has:
(defn ^[[{:index ^Int Index, :mtu ^Int MTU, :name ^String Name, :hardwareaddr HardwareAddr, :flags Flags}] Error] Interfaces
  "Interfaces returns a list of the system's network interfaces.\n"
  {:added "1.0"
   :go "interfaces()"}
  [])

JOKER FUNC net.JoinHostPort has:
(defn ^String JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n"
  {:added "1.0"
   :go "joinHostPort(host, port)"}
  [^String host, ^String port])

JOKER FUNC net.Listen has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:365:15) Error] Listen
;;   "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n"
;;   {:added "1.0"
;;    :go "listen(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ListenIP has:
;; (defn ^[{} Error] ListenIP
;;   "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n"
;;   {:added "1.0"
;;    :go "listenIP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/iprawsock.go:230:37) laddr])

JOKER FUNC net.ListenMulticastUDP has:
;; (defn ^[{} Error] ListenMulticastUDP
;;   "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n"
;;   {:added "1.0"
;;    :go "listenMulticastUDP(network, ifi, gaddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:265:45) ifi, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:265:63) gaddr])

JOKER FUNC net.ListenPacket has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:303:17) Error] ListenPacket
;;   "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n"
;;   {:added "1.0"
;;    :go "listenPacket(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC net.ListenTCP has:
;; (defn ^[{:fd ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/tcpsock.go:226:5) fd} Error] ListenTCP
;;   "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n"
;;   {:added "1.0"
;;    :go "listenTCP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/tcpsock.go:323:38) laddr])

JOKER FUNC net.ListenUDP has:
;; (defn ^[{} Error] ListenUDP
;;   "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n"
;;   {:added "1.0"
;;    :go "listenUDP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/udpsock.go:231:38) laddr])

JOKER FUNC net.ListenUnix has:
;; (defn ^[{:fd ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:218:13) fd, :path ^String path, :unlink unlink, :unlinkonce ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/unixsock.go:221:13) unlinkOnce} Error] ListenUnix
;;   "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n"
;;   {:added "1.0"
;;    :go "listenUnix(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:314:39) laddr])

JOKER FUNC net.ListenUnixgram has:
;; (defn ^[{} Error] ListenUnixgram
;;   "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n"
;;   {:added "1.0"
;;    :go "listenUnixgram(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/unixsock.go:334:43) laddr])

JOKER FUNC net.LookupAddr has:
(defn ^[names err] LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n"
  {:added "1.0"
   :go "lookupAddr(addr)"}
  [^String addr])

JOKER FUNC net.LookupCNAME has:
(defn ^[cname err] LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n"
  {:added "1.0"
   :go "lookupCNAME(host)"}
  [^String host])

JOKER FUNC net.LookupHost has:
(defn ^[addrs err] LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n"
  {:added "1.0"
   :go "lookupHost(host)"}
  [^String host])

JOKER FUNC net.LookupIP has:
;; (defn ^[[[ABEND042(cannot find typename net.byte)]] Error] LookupIP
;;   "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n"
;;   {:added "1.0"
;;    :go "lookupIP(host)"}
;;   [^String host])

JOKER FUNC net.LookupMX has:
(defn ^[[{:host ^String Host, :pref ^Int Pref}] Error] LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n"
  {:added "1.0"
   :go "lookupMX(name)"}
  [^String name])

JOKER FUNC net.LookupNS has:
(defn ^[[{:host ^String Host}] Error] LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n"
  {:added "1.0"
   :go "lookupNS(name)"}
  [^String name])

JOKER FUNC net.LookupPort has:
(defn ^[port err] LookupPort
  "LookupPort looks up the port for the given network and service.\n"
  {:added "1.0"
   :go "lookupPort(network, service)"}
  [^String network, ^String service])

JOKER FUNC net.LookupSRV has:
(defn ^[cname addrs err] LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n"
  {:added "1.0"
   :go "lookupSRV(service, proto, name)"}
  [^String service, ^String proto, ^String name])

JOKER FUNC net.LookupTXT has:
(defn ^[[String] Error] LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n"
  {:added "1.0"
   :go "lookupTXT(name)"}
  [^String name])

JOKER FUNC net.ParseCIDR has:
;; (defn ^[[ABEND042(cannot find typename net.byte)] {:ip IP, :mask Mask} Error] ParseCIDR
;;   "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n"
;;   {:added "1.0"
;;    :go "parseCIDR(s)"}
;;   [^String s])

JOKER FUNC net.ParseIP has:
;; (defn ^[ABEND042(cannot find typename net.byte)] ParseIP
;;   "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n"
;;   {:added "1.0"
;;    :go "parseIP(s)"}
;;   [^String s])

JOKER FUNC net.ParseMAC has:
(defn ^[hw err] ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n"
  {:added "1.0"
   :go "parseMAC(s)"}
  [^String s])

JOKER FUNC net.Pipe has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:113:11) ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/net.go:113:11)] Pipe
;;   "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC net.ResolveIPAddr has:
(defn ^[{:ip IP, :zone ^String Zone} Error] ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n"
  {:added "1.0"
   :go "resolveIPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveTCPAddr has:
(defn ^[{:ip IP, :port ^Int Port, :zone ^String Zone} Error] ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n"
  {:added "1.0"
   :go "resolveTCPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveUDPAddr has:
(defn ^[{:ip IP, :port ^Int Port, :zone ^String Zone} Error] ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n"
  {:added "1.0"
   :go "resolveUDPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveUnixAddr has:
(defn ^[{:name ^String Name, :net ^String Net} Error] ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n"
  {:added "1.0"
   :go "resolveUnixAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.SplitHostPort has:
(defn ^[host port err] SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n"
  {:added "1.0"
   :go "splitHostPort(hostport)"}
  [^String hostport])

JOKER FUNC nettest.TestConn has:
;; (defn TestConn
;;   "TestConn tests that a net.Conn implementation properly satisfies the interface.\nThe tests should not produce any false positives, but may experience\nfalse negatives. Thus, some issues may only be detected when the test is\nrun multiple times. For maximal effectiveness, run the tests under the\nrace detector.\n"
;;   {:added "1.0"
;;    :go "testConn(t, mp)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/net/nettest/conntest.go:37:17) t, mp])

JOKER FUNC os.Chdir has:
(defn ^Error Chdir
  "Chdir changes the current working directory to the named directory.\nIf there is an error, it will be of type *PathError.\n"
  {:added "1.0"
   :go "chdir(dir)"}
  [^String dir])

JOKER FUNC os.Chmod has:
(defn ^Error Chmod
  "Chmod changes the mode of the named file to mode.\nIf the file is a symbolic link, it changes the mode of the link's target.\nIf there is an error, it will be of type *PathError.\n\nA different subset of the mode bits are used, depending on the\noperating system.\n\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and\nModeSticky are used.\n\nOn Windows, the mode must be non-zero but otherwise only the 0200\nbit (owner writable) of mode is used; it controls whether the\nfile's read-only attribute is set or cleared. attribute. The other\nbits are currently unused. Use mode 0400 for a read-only file and\n0600 for a readable+writable file.\n\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,\nand ModeTemporary are used.\n"
  {:added "1.0"
   :go "chmod(name, mode)"}
  [^String name, mode])

JOKER FUNC os.Chown has:
(defn ^Error Chown
  "Chown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link's target.\nA uid or gid of -1 means to not change that value.\nIf there is an error, it will be of type *PathError.\n\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\nEPLAN9 error, wrapped in *PathError.\n"
  {:added "1.0"
   :go "chown(name, uid, gid)"}
  [^String name, ^Int uid, ^Int gid])

JOKER FUNC os.Chtimes has:
;; (defn ^Error Chtimes
;;   "Chtimes changes the access and modification times of the named\nfile, similar to the Unix utime() or utimes() functions.\n\nThe underlying filesystem may truncate or round the values to a\nless precise time unit.\nIf there is an error, it will be of type *PathError.\n"
;;   {:added "1.0"
;;    :go "chtimes(name, atime, mtime)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/file_posix.go:140:33) atime, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/file_posix.go:140:50) mtime])

JOKER FUNC os.Clearenv has:
;; (defn Clearenv
;;   "Clearenv deletes all environment variables.\n"
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])

JOKER FUNC os.Create has:
(defn ^[{} Error] Create
  "Create creates the named file with mode 0666 (before umask), truncating\nit if it already exists. If successful, methods on the returned\nFile can be used for I/O; the associated file descriptor has mode\nO_RDWR.\nIf there is an error, it will be of type *PathError.\n"
  {:added "1.0"
   :go "create(name)"}
  [^String name])

JOKER FUNC os.Environ has:
(defn ^[String] Environ
  "Environ returns a copy of strings representing the environment,\nin the form \"key=value\".\n"
  {:added "1.0"
   :go "environ()"}
  [])

JOKER FUNC os.Executable has:
(defn ^[String Error] Executable
  "Executable returns the path name for the executable that started\nthe current process. There is no guarantee that the path is still\npointing to the correct executable. If a symlink was used to start\nthe process, depending on the operating system, the result might\nbe the symlink or the path it pointed to. If a stable result is\nneeded, path/filepath.EvalSymlinks might help.\n\nExecutable returns an absolute path unless an error occurred.\n\nThe main use case is finding resources located relative to an\nexecutable.\n\nExecutable is not supported on nacl.\n"
  {:added "1.0"
   :go "executable()"}
  [])

JOKER FUNC os.Exit has:
;; (defn Exit
;;   "Exit causes the current program to exit with the given status code.\nConventionally, code zero indicates success, non-zero an error.\nThe program terminates immediately; deferred functions are not run.\n"
;;   {:added "1.0"
;;    :go "exit(code)"}
;;   [^Int code])

JOKER FUNC os.Expand has:
;; (defn ^String Expand
;;   "Expand replaces ${var} or $var in the string based on the mapping function.\nFor example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\n"
;;   {:added "1.0"
;;    :go "expand(s, mapping)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/os/env.go:16:31) mapping])

JOKER FUNC os.ExpandEnv has:
(defn ^String ExpandEnv
  "ExpandEnv replaces ${var} or $var in the string according to the values\nof the current environment variables. References to undefined\nvariables are replaced by the empty string.\n"
  {:added "1.0"
   :go "expandEnv(s)"}
  [^String s])

JOKER FUNC os.FindProcess has:
;; (defn ^[{:pid ^Int Pid, :handle handle, :isdone isdone, :sigmu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec.go:21:9) sigMu} Error] FindProcess
;;   "FindProcess looks for a running process by its pid.\n\nThe Process it returns can be used to obtain information\nabout the underlying operating system process.\n\nOn Unix systems, FindProcess always succeeds and returns a Process\nfor the given pid, regardless of whether the process exists.\n"
;;   {:added "1.0"
;;    :go "findProcess(pid)"}
;;   [^Int pid])

JOKER FUNC os.Getegid has:
(defn ^Int Getegid
  "Getegid returns the numeric effective group id of the caller.\n\nOn Windows, it returns -1.\n"
  {:added "1.0"
   :go "getegid()"}
  [])

JOKER FUNC os.Getenv has:
(defn ^String Getenv
  "Getenv retrieves the value of the environment variable named by the key.\nIt returns the value, which will be empty if the variable is not present.\nTo distinguish between an empty value and an unset value, use LookupEnv.\n"
  {:added "1.0"
   :go "getenv(key)"}
  [^String key])

JOKER FUNC os.Geteuid has:
(defn ^Int Geteuid
  "Geteuid returns the numeric effective user id of the caller.\n\nOn Windows, it returns -1.\n"
  {:added "1.0"
   :go "geteuid()"}
  [])

JOKER FUNC os.Getgid has:
(defn ^Int Getgid
  "Getgid returns the numeric group id of the caller.\n\nOn Windows, it returns -1.\n"
  {:added "1.0"
   :go "getgid()"}
  [])

JOKER FUNC os.Getgroups has:
(defn ^[[Int] Error] Getgroups
  "Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n\nOn Windows, it returns syscall.EWINDOWS. See the os/user package\nfor a possible alternative.\n"
  {:added "1.0"
   :go "getgroups()"}
  [])

JOKER FUNC os.Getpagesize has:
(defn ^Int Getpagesize
  "Getpagesize returns the underlying system's memory page size.\n"
  {:added "1.0"
   :go "getpagesize()"}
  [])

JOKER FUNC os.Getpid has:
(defn ^Int Getpid
  "Getpid returns the process id of the caller.\n"
  {:added "1.0"
   :go "getpid()"}
  [])

JOKER FUNC os.Getppid has:
(defn ^Int Getppid
  "Getppid returns the process id of the caller's parent.\n"
  {:added "1.0"
   :go "getppid()"}
  [])

JOKER FUNC os.Getuid has:
(defn ^Int Getuid
  "Getuid returns the numeric user id of the caller.\n\nOn Windows, it returns -1.\n"
  {:added "1.0"
   :go "getuid()"}
  [])

JOKER FUNC os.Getwd has:
(defn ^[dir err] Getwd
  "Getwd returns a rooted path name corresponding to the\ncurrent directory. If the current directory can be\nreached via multiple paths (due to symbolic links),\nGetwd may return any one of them.\n"
  {:added "1.0"
   :go "getwd()"}
  [])

JOKER FUNC os.Hostname has:
(defn ^[name err] Hostname
  "Hostname returns the host name reported by the kernel.\n"
  {:added "1.0"
   :go "hostname()"}
  [])

JOKER FUNC os.IsExist has:
;; (defn ^ABEND042(cannot find typename os.bool) IsExist
;;   "IsExist returns a boolean indicating whether the error is known to report\nthat a file or directory already exists. It is satisfied by ErrExist as\nwell as some syscall errors.\n"
;;   {:added "1.0"
;;    :go "isExist(err)"}
;;   [err])

JOKER FUNC os.IsNotExist has:
;; (defn ^ABEND042(cannot find typename os.bool) IsNotExist
;;   "IsNotExist returns a boolean indicating whether the error is known to\nreport that a file or directory does not exist. It is satisfied by\nErrNotExist as well as some syscall errors.\n"
;;   {:added "1.0"
;;    :go "isNotExist(err)"}
;;   [err])

JOKER FUNC os.IsPathSeparator has:
;; (defn ^ABEND042(cannot find typename os.bool) IsPathSeparator
;;   "IsPathSeparator reports whether c is a directory separator character.\n"
;;   {:added "1.0"
;;    :go "isPathSeparator(c)"}
;;   [c])

JOKER FUNC os.IsPermission has:
;; (defn ^ABEND042(cannot find typename os.bool) IsPermission
;;   "IsPermission returns a boolean indicating whether the error is known to\nreport that permission is denied. It is satisfied by ErrPermission as well\nas some syscall errors.\n"
;;   {:added "1.0"
;;    :go "isPermission(err)"}
;;   [err])

JOKER FUNC os.IsTimeout has:
;; (defn ^ABEND042(cannot find typename os.bool) IsTimeout
;;   "IsTimeout returns a boolean indicating whether the error is known\nto report that a timeout occurred.\n"
;;   {:added "1.0"
;;    :go "isTimeout(err)"}
;;   [err])

JOKER FUNC os.Lchown has:
(defn ^Error Lchown
  "Lchown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link itself.\nIf there is an error, it will be of type *PathError.\n\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped\nin *PathError.\n"
  {:added "1.0"
   :go "lchown(name, uid, gid)"}
  [^String name, ^Int uid, ^Int gid])

JOKER FUNC os.Link has:
(defn ^Error Link
  "Link creates newname as a hard link to the oldname file.\nIf there is an error, it will be of type *LinkError.\n"
  {:added "1.0"
   :go "link(oldname, newname)"}
  [^String oldname, ^String newname])

JOKER FUNC os.LookupEnv has:
;; (defn ^[String ABEND042(cannot find typename os.bool)] LookupEnv
;;   "LookupEnv retrieves the value of the environment variable named\nby the key. If the variable is present in the environment the\nvalue (which may be empty) is returned and the boolean is true.\nOtherwise the returned value will be empty and the boolean will\nbe false.\n"
;;   {:added "1.0"
;;    :go "lookupEnv(key)"}
;;   [^String key])

JOKER FUNC os.Lstat has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/os/types.go:21:15) Error] Lstat
;;   "Lstat returns a FileInfo describing the named file.\nIf the file is a symbolic link, the returned FileInfo\ndescribes the symbolic link. Lstat makes no attempt to follow the link.\nIf there is an error, it will be of type *PathError.\n"
;;   {:added "1.0"
;;    :go "lstat(name)"}
;;   [^String name])

JOKER FUNC os.Mkdir has:
(defn ^Error Mkdir
  "Mkdir creates a new directory with the specified name and permission\nbits (before umask).\nIf there is an error, it will be of type *PathError.\n"
  {:added "1.0"
   :go "mkdir(name, perm)"}
  [^String name, perm])

JOKER FUNC os.MkdirAll has:
(defn ^Error MkdirAll
  "MkdirAll creates a directory named path,\nalong with any necessary parents, and returns nil,\nor else returns an error.\nThe permission bits perm (before umask) are used for all\ndirectories that MkdirAll creates.\nIf path is already a directory, MkdirAll does nothing\nand returns nil.\n"
  {:added "1.0"
   :go "mkdirAll(path, perm)"}
  [^String path, perm])

JOKER FUNC os.NewFile has:
(defn ^{} NewFile
  "NewFile returns a new File with the given file descriptor and\nname. The returned value will be nil if fd is not a valid file\ndescriptor. On Unix systems, if the file descriptor is in\nnon-blocking mode, NewFile will attempt to return a pollable File\n(one for which the SetDeadline methods work).\n"
  {:added "1.0"
   :go "newFile(fd, name)"}
  [fd, ^String name])

JOKER FUNC os.NewSyscallError has:
(defn ^Error NewSyscallError
  "NewSyscallError returns, as an error, a new SyscallError\nwith the given system call name and error details.\nAs a convenience, if err is nil, NewSyscallError returns nil.\n"
  {:added "1.0"
   :go "newSyscallError(syscall, err)"}
  [^String syscall, err])

JOKER FUNC os.Open has:
(defn ^[{} Error] Open
  "Open opens the named file for reading. If successful, methods on\nthe returned file can be used for reading; the associated file\ndescriptor has mode O_RDONLY.\nIf there is an error, it will be of type *PathError.\n"
  {:added "1.0"
   :go "open(name)"}
  [^String name])

JOKER FUNC os.OpenFile has:
(defn ^[{} Error] OpenFile
  "OpenFile is the generalized open call; most users will use Open\nor Create instead. It opens the named file with specified flag\n(O_RDONLY etc.) and perm (before umask), if applicable. If successful,\nmethods on the returned File can be used for I/O.\nIf there is an error, it will be of type *PathError.\n"
  {:added "1.0"
   :go "openFile(name, flag, perm)"}
  [^String name, ^Int flag, perm])

JOKER FUNC os.Pipe has:
(defn ^[r w err] Pipe
  "Pipe returns a connected pair of Files; reads from r return bytes written to w.\nIt returns the files and an error, if any.\n"
  {:added "1.0"
   :go "pipe()"}
  [])

JOKER FUNC os.Readlink has:
(defn ^[String Error] Readlink
  "Readlink returns the destination of the named symbolic link.\nIf there is an error, it will be of type *PathError.\n"
  {:added "1.0"
   :go "readlink(name)"}
  [^String name])

JOKER FUNC os.Remove has:
(defn ^Error Remove
  "Remove removes the named file or (empty) directory.\nIf there is an error, it will be of type *PathError.\n"
  {:added "1.0"
   :go "remove(name)"}
  [^String name])

JOKER FUNC os.RemoveAll has:
(defn ^Error RemoveAll
  "RemoveAll removes path and any children it contains.\nIt removes everything it can but returns the first error\nit encounters. If the path does not exist, RemoveAll\nreturns nil (no error).\n"
  {:added "1.0"
   :go "removeAll(path)"}
  [^String path])

JOKER FUNC os.Rename has:
(defn ^Error Rename
  "Rename renames (moves) oldpath to newpath.\nIf newpath already exists and is not a directory, Rename replaces it.\nOS-specific restrictions may apply when oldpath and newpath are in different directories.\nIf there is an error, it will be of type *LinkError.\n"
  {:added "1.0"
   :go "rename(oldpath, newpath)"}
  [^String oldpath, ^String newpath])

JOKER FUNC os.SameFile has:
;; (defn ^ABEND042(cannot find typename os.bool) SameFile
;;   "SameFile reports whether fi1 and fi2 describe the same file.\nFor example, on Unix this means that the device and inode fields\nof the two underlying structures are identical; on other systems\nthe decision may be based on the path names.\nSameFile only applies to results returned by this package's Stat.\nIt returns false in other cases.\n"
;;   {:added "1.0"
;;    :go "sameFile(fi1, fi2)"}
;;   [fi1, fi2])

JOKER FUNC os.Setenv has:
(defn ^Error Setenv
  "Setenv sets the value of the environment variable named by the key.\nIt returns an error, if any.\n"
  {:added "1.0"
   :go "setenv(key, value)"}
  [^String key, ^String value])

JOKER FUNC os.StartProcess has:
;; (defn ^[{:pid ^Int Pid, :handle handle, :isdone isdone, :sigmu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/exec.go:21:9) sigMu} Error] StartProcess
;;   "StartProcess starts a new process with the program, arguments and attributes\nspecified by name, argv and attr. The argv slice will become os.Args in the\nnew process, so it normally starts with the program name.\n\nIf the calling goroutine has locked the operating system thread\nwith runtime.LockOSThread and modified any inheritable OS-level\nthread state (for example, Linux or Plan 9 name spaces), the new\nprocess will inherit the caller's thread state.\n\nStartProcess is a low-level interface. The os/exec package provides\nhigher-level interfaces.\n\nIf there is an error, it will be of type *PathError.\n"
;;   {:added "1.0"
;;    :go "startProcess(name, argv, attr)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/os/exec.go:100:37) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/os/exec.go:100:52) attr])

JOKER FUNC os.Stat has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/os/types.go:21:15) Error] Stat
;;   "Stat returns a FileInfo describing the named file.\nIf there is an error, it will be of type *PathError.\n"
;;   {:added "1.0"
;;    :go "stat(name)"}
;;   [^String name])

JOKER FUNC os.Symlink has:
(defn ^Error Symlink
  "Symlink creates newname as a symbolic link to oldname.\nIf there is an error, it will be of type *LinkError.\n"
  {:added "1.0"
   :go "symlink(oldname, newname)"}
  [^String oldname, ^String newname])

JOKER FUNC os.TempDir has:
(defn ^String TempDir
  "TempDir returns the default directory to use for temporary files.\n\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp.\nOn Windows, it uses GetTempPath, returning the first non-empty\nvalue from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.\nOn Plan 9, it returns /tmp.\n\nThe directory is neither guaranteed to exist nor have accessible\npermissions.\n"
  {:added "1.0"
   :go "tempDir()"}
  [])

JOKER FUNC os.Truncate has:
(defn ^Error Truncate
  "Truncate changes the size of the named file.\nIf the file is a symbolic link, it changes the size of the link's target.\nIf there is an error, it will be of type *PathError.\n"
  {:added "1.0"
   :go "truncate(name, size)"}
  [^String name, size])

JOKER FUNC os.Unsetenv has:
(defn ^Error Unsetenv
  "Unsetenv unsets a single environment variable.\n"
  {:added "1.0"
   :go "unsetenv(key)"}
  [^String key])

JOKER FUNC os.UserCacheDir has:
(defn ^[String Error] UserCacheDir
  "UserCacheDir returns the default root directory to use for user-specific\ncached data. Users should create their own application-specific subdirectory\nwithin this one and use that.\n\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by\nhttps://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html if\nnon-empty, else $HOME/.cache.\nOn Darwin, it returns $HOME/Library/Caches.\nOn Windows, it returns %LocalAppData%.\nOn Plan 9, it returns $home/lib/cache.\n\nIf the location cannot be determined (for example, $HOME is not defined),\nthen it will return an error.\n"
  {:added "1.0"
   :go "userCacheDir()"}
  [])

JOKER FUNC parse.IsEmptyTree has:
;; (defn ^ABEND042(cannot find typename parse.bool) IsEmptyTree
;;   "IsEmptyTree reports whether this tree (node) is empty of everything but space.\n"
;;   {:added "1.0"
;;    :go "isEmptyTree(n)"}
;;   [n])

JOKER FUNC parse.New has:
;; (defn ^{:name ^String Name, :parsename ^String ParseName, :root ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/text/template/parse/parse.go:23:12) Root, :text ^String text, :funcs ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/text/template/parse/parse.go:26:12) funcs, :lex ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/text/template/parse/parse.go:27:12) lex, :token ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/text/template/parse/parse.go:28:12) token, :peekcount ^Int peekCount, :vars ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/text/template/parse/parse.go:30:12) vars, :treeset ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/text/template/parse/parse.go:31:12) treeSet} New
;;   "New allocates a new parse tree with the given name.\n"
;;   {:added "1.0"
;;    :go "new(name, funcs)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/text/template/parse/parse.go:125:29) funcs])

JOKER FUNC parse.NewIdentifier has:
;; (defn ^{:tr ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/text/template/parse/node.go:285:8) tr, :ident ^String Ident} NewIdentifier
;;   "NewIdentifier returns a new IdentifierNode with the given identifier name.\n"
;;   {:added "1.0"
;;    :go "newIdentifier(ident)"}
;;   [^String ident])

JOKER FUNC parse.Parse has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/text/template/parse/parse.go:51:88) Error] Parse
;;   "Parse returns a map from template name to parse.Tree, created by parsing the\ntemplates described in the argument string. The top-level template will be\ngiven the specified name. If an error is encountered, parsing stops and an\nempty map is returned with the error.\n"
;;   {:added "1.0"
;;    :go "parse(name, text, leftDelim, rightDelim, funcs)"}
;;   [^String name, ^String text, ^String leftDelim, ^String rightDelim, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/text/template/parse/parse.go:51:60) funcs])

JOKER FUNC parser.ParseDir has:
;; (defn ^[pkgs first] ParseDir
;;   "ParseDir calls ParseFile for all files with names ending in \".go\" in the\ndirectory specified by path and returns a map of package name -> package\nAST with all the packages found.\n\nIf filter != nil, only the files with os.FileInfo entries passing through\nthe filter (and ending in \".go\") are considered. The mode bits are passed\nto ParseFile unchanged. Position information is recorded in fset, which\nmust not be nil.\n\nIf the directory couldn't be read, a nil map and the respective error are\nreturned. If a parse error occurred, a non-nil but incomplete map and the\nfirst error encountered are returned.\n"
;;   {:added "1.0"
;;    :go "parseDir(fset, path, filter, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/parser/interface.go:135:20) fset, ^String path, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/parser/interface.go:135:56) filter, mode])

JOKER FUNC parser.ParseExpr has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/parser/interface.go:230:27) Error] ParseExpr
;;   "ParseExpr is a convenience function for obtaining the AST of an expression x.\nThe position information recorded in the AST is undefined. The filename used\nin error messages is the empty string.\n"
;;   {:added "1.0"
;;    :go "parseExpr(x)"}
;;   [^String x])

JOKER FUNC parser.ParseExprFrom has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/parser/interface.go:176:87) Error] ParseExprFrom
;;   "ParseExprFrom is a convenience function for parsing an expression.\nThe arguments have the same meaning as for ParseFile, but the source must\nbe a valid Go (type or value) expression. Specifically, fset must not\nbe nil.\n"
;;   {:added "1.0"
;;    :go "parseExprFrom(fset, filename, src, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/parser/interface.go:176:25) fset, ^String filename, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/parser/interface.go:176:62) src, mode])

JOKER FUNC parser.ParseFile has:
;; (defn ^[f err] ParseFile
;;   "ParseFile parses the source code of a single Go source file and returns\nthe corresponding ast.File node. The source code may be provided via\nthe filename of the source file, or via the src parameter.\n\nIf src != nil, ParseFile parses the source from src and the filename is\nonly used when recording position information. The type of the argument\nfor the src parameter must be string, []byte, or io.Reader.\nIf src == nil, ParseFile parses the file specified by filename.\n\nThe mode parameter controls the amount of source text parsed and other\noptional parser functionality. Position information is recorded in the\nfile set fset, which must not be nil.\n\nIf the source couldn't be read, the returned AST is nil and the error\nindicates the specific failure. If the source was read but syntax\nerrors were found, the result is a partial AST (with ast.Bad* nodes\nrepresenting the fragments of erroneous source code). Multiple errors\nare returned via a scanner.ErrorList which is sorted by file position.\n"
;;   {:added "1.0"
;;    :go "parseFile(fset, filename, src, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/parser/interface.go:80:21) fset, ^String filename, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/parser/interface.go:80:58) src, mode])

JOKER FUNC path.Base has:
(defn ^String Base
  "Base returns the last element of path.\nTrailing slashes are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of slashes, Base returns \"/\".\n"
  {:added "1.0"
   :go "base(path)"}
  [^String path])

JOKER FUNC path.Clean has:
(defn ^String Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple slashes with a single slash.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path.\n\nThe returned path ends in a slash only if it is the root \"/\".\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n"
  {:added "1.0"
   :go "clean(path)"}
  [^String path])

JOKER FUNC path.Dir has:
(defn ^String Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element using Split, the path is Cleaned and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of slashes followed by non-slash bytes, Dir\nreturns a single slash. In any other case, the returned path does not end in a\nslash.\n"
  {:added "1.0"
   :go "dir(path)"}
  [^String path])

JOKER FUNC path.Ext has:
(defn ^String Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final slash-separated element of path;\nit is empty if there is no dot.\n"
  {:added "1.0"
   :go "ext(path)"}
  [^String path])

JOKER FUNC path.IsAbs has:
;; (defn ^ABEND042(cannot find typename path.bool) IsAbs
;;   "IsAbs reports whether the path is absolute.\n"
;;   {:added "1.0"
;;    :go "isAbs(path)"}
;;   [^String path])

JOKER FUNC path.Join has:
;; (defn ^String Join
;;   "Join joins any number of path elements into a single path, adding a\nseparating slash if necessary. The result is Cleaned; in particular,\nall empty strings are ignored.\n"
;;   {:added "1.0"
;;    :go "join(elem)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/path/path.go:155:16) elem])

JOKER FUNC path.Match has:
(defn ^[matched err] Match
  "Match reports whether name matches the shell pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-/ characters\n\t\t'?'         matches any single non-/ character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n"
  {:added "1.0"
   :go "match(pattern, name)"}
  [^String pattern, ^String name])

JOKER FUNC path.Split has:
(defn ^[dir file] Split
  "Split splits path immediately following the final slash,\nseparating it into a directory and file name component.\nIf there is no slash in path, Split returns an empty dir and\nfile set to path.\nThe returned values have the property that path = dir+file.\n"
  {:added "1.0"
   :go "split(path)"}
  [^String path])

JOKER FUNC pe.NewFile has:
;; (defn ^[{:optionalheader ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/debug/pe/file.go:25:17) OptionalHeader, :sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/pe/file.go:26:17) Sections, :symbols ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/pe/file.go:27:17) Symbols, :coffsymbols ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/pe/file.go:28:17) COFFSymbols, :stringtable StringTable, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/pe/file.go:31:9) closer} Error] NewFile
;;   "NewFile creates a new File for accessing a PE binary in an underlying reader.\n"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/pe/file.go:69:16) r])

JOKER FUNC pe.Open has:
;; (defn ^[{:optionalheader ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/debug/pe/file.go:25:17) OptionalHeader, :sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/pe/file.go:26:17) Sections, :symbols ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/pe/file.go:27:17) Symbols, :coffsymbols ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/pe/file.go:28:17) COFFSymbols, :stringtable StringTable, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/pe/file.go:31:9) closer} Error] Open
;;   "Open opens the named file using os.Open and prepares it for use as a PE binary.\n"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC pem.Decode has:
;; (defn ^[p rest] Decode
;;   "Decode will find the next PEM formatted block (certificate, private key\netc) in the input. It returns that block and the remainder of the input. If\nno PEM data is found, p is nil and the whole of the input is returned in\nrest.\n"
;;   {:added "1.0"
;;    :go "decode(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/pem/pem.go:78:18) data])

JOKER FUNC pem.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the PEM encoding of b to out.\n"
;;   {:added "1.0"
;;    :go "encode(out, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/pem/pem.go:256:17) out, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/pem/pem.go:256:30) b])

JOKER FUNC pem.EncodeToMemory has:
;; (defn ^[ABEND042(cannot find typename pem.byte)] EncodeToMemory
;;   "EncodeToMemory returns the PEM encoding of b.\n\nIf b has invalid headers and cannot be encoded,\nEncodeToMemory returns nil. If it is important to\nreport details about this error case, use Encode instead.\n"
;;   {:added "1.0"
;;    :go "encodeToMemory(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/pem/pem.go:326:23) b])

JOKER FUNC plan9obj.NewFile has:
;; (defn ^[{:sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/plan9obj/file.go:29:11) Sections, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/plan9obj/file.go:30:11) closer} Error] NewFile
;;   "NewFile creates a new File for accessing a Plan 9 binary in an underlying reader.\nThe Plan 9 binary is expected to start at position 0 in the ReaderAt.\n"
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/plan9obj/file.go:135:16) r])

JOKER FUNC plan9obj.Open has:
;; (defn ^[{:sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/debug/plan9obj/file.go:29:11) Sections, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/debug/plan9obj/file.go:30:11) closer} Error] Open
;;   "Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.\n"
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])

JOKER FUNC plugin.Open has:
;; (defn ^[{:pluginpath ^String pluginpath, :err ^String err, :loaded ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/plugin/plugin.go:24:13) loaded, :syms ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/plugin/plugin.go:25:13) syms} Error] Open
;;   "Open opens a Go plugin.\nIf a path has already been opened, then the existing *Plugin is returned.\nIt is safe for concurrent use by multiple goroutines.\n"
;;   {:added "1.0"
;;    :go "open(path)"}
;;   [^String path])

JOKER FUNC png.Decode has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/reader.go:952:27) Error] Decode
;;   "Decode reads a PNG image from r and returns it as an image.Image.\nThe type of Image returned depends on the PNG contents.\n"
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/reader.go:952:15) r])

JOKER FUNC png.DecodeConfig has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/reader.go:976:33) Error] DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a PNG image without\ndecoding the entire image.\n"
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/reader.go:976:21) r])

JOKER FUNC png.Encode has:
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in PNG format. Any Image may be\nencoded, but images that are not image.NRGBA might be encoded lossily.\n"
;;   {:added "1.0"
;;    :go "encode(w, m)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/writer.go:523:15) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/png/writer.go:523:28) m])

JOKER FUNC poly1305.Sum has:
;; (defn Sum
;;   "Sum generates an authenticator for m using a one-time key and puts the\n16-byte result into out. Authenticating two different messages with the same\nkey allows an attacker to forge messages at will.\n"
;;   {:added "1.0"
;;    :go "sum(out, m, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:14) out, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:27) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:39) key])

JOKER FUNC poly1305.Verify has:
;; (defn ^ABEND042(cannot find typename poly1305.bool) Verify
;;   "Verify returns true if mac is a valid authenticator for m with the given\nkey.\n"
;;   {:added "1.0"
;;    :go "verify(mac, m, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/poly1305.go:29:17) mac, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/poly1305.go:29:30) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/poly1305.go:29:42) key])

JOKER FUNC pprof.Cmdline has:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n"
;;   {:added "1.0"
;;    :go "cmdline(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:83:16) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:83:39) r])

JOKER FUNC pprof.Do has:
;; (defn Do
;;   "Do calls f with a copy of the parent context with the\ngiven labels added to the parent's label map.\nEach key/value pair in labels is inserted into the label map in the\norder provided, overriding any previous value for the same key.\nThe augmented label map will be set for the duration of the call to f\nand restored once f returns.\n"
;;   {:added "1.0"
;;    :go "do(ctx, labels, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/runtime.go:31:13) ctx, labels, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/runtime.go:31:49) f])

JOKER FUNC pprof.ForLabels has:
;; (defn ForLabels
;;   "ForLabels invokes f with each label set on the context.\nThe function f should return true to continue iteration or false to stop iteration early.\n"
;;   {:added "1.0"
;;    :go "forLabels(ctx, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:78:20) ctx, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/label.go:78:39) f])

JOKER FUNC pprof.Handler has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:221:27) Handler
;;   "Handler returns an HTTP handler that serves the named profile.\n"
;;   {:added "1.0"
;;    :go "handler(name)"}
;;   [^String name])

JOKER FUNC pprof.Index has:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n"
;;   {:added "1.0"
;;    :go "index(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:264:14) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:264:37) r])

JOKER FUNC pprof.Label has:
;; (defn ^[String ABEND042(cannot find typename pprof.bool)] Label
;;   "Label returns the value of the label with the given key on ctx, and a boolean indicating\nwhether that label exists.\n"
;;   {:added "1.0"
;;    :go "label(ctx, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:70:16) ctx, ^String key])

JOKER FUNC pprof.Labels has:
;; (defn ^{:list ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/pprof/label.go:18:7) list} Labels
;;   "Labels takes an even number of strings representing key-value pairs\nand makes a LabelSet containing them.\nA label overwrites a prior label with the same key.\n"
;;   {:added "1.0"
;;    :go "labels(args)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/runtime/pprof/label.go:57:18) args])

JOKER FUNC pprof.Lookup has:
;; (defn ^{:name ^String name, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/pprof.go:134:8) mu, :m ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/runtime/pprof/pprof.go:135:8) m, :count ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:136:8) count, :write ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:137:8) write} Lookup
;;   "Lookup returns the profile with the given name, or nil if no such profile exists.\n"
;;   {:added "1.0"
;;    :go "lookup(name)"}
;;   [^String name])

JOKER FUNC pprof.NewProfile has:
;; (defn ^{:name ^String name, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/pprof.go:134:8) mu, :m ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/runtime/pprof/pprof.go:135:8) m, :count ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:136:8) count, :write ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:137:8) write} NewProfile
;;   "NewProfile creates a new profile with the given name.\nIf a profile with that name already exists, NewProfile panics.\nThe convention is to use a 'import/path.' prefix to create\nseparate name spaces for each package.\nFor compatibility with various tools that read pprof data,\nprofile names should not contain spaces.\n"
;;   {:added "1.0"
;;    :go "newProfile(name)"}
;;   [^String name])

JOKER FUNC pprof.Profile has:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n"
;;   {:added "1.0"
;;    :go "profile(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:116:16) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:116:39) r])

JOKER FUNC pprof.Profiles has:
;; (defn ^[{:name ^String name, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/pprof.go:134:8) mu, :m ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/runtime/pprof/pprof.go:135:8) m, :count ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:136:8) count, :write ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/pprof.go:137:8) write}] Profiles
;;   "Profiles returns a slice of all the known profiles, sorted by name.\n"
;;   {:added "1.0"
;;    :go "profiles()"}
;;   [])

JOKER FUNC pprof.SetGoroutineLabels has:
;; (defn SetGoroutineLabels
;;   "SetGoroutineLabels sets the current goroutine's labels to match ctx.\nThis is a lower-level API than Do, which should be used instead when possible.\n"
;;   {:added "1.0"
;;    :go "setGoroutineLabels(ctx)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/runtime.go:20:29) ctx])

JOKER FUNC pprof.StartCPUProfile has:
;; (defn ^Error StartCPUProfile
;;   "StartCPUProfile enables CPU profiling for the current process.\nWhile profiling, the profile will be buffered and written to w.\nStartCPUProfile returns an error if profiling is already enabled.\n\nOn Unix-like systems, StartCPUProfile does not work by default for\nGo code built with -buildmode=c-archive or -buildmode=c-shared.\nStartCPUProfile relies on the SIGPROF signal, but that signal will\nbe delivered to the main program's SIGPROF signal handler (if any)\nnot to the one used by Go. To make it work, call os/signal.Notify\nfor syscall.SIGPROF, but note that doing so may break any profiling\nbeing done by the main program.\n"
;;   {:added "1.0"
;;    :go "startCPUProfile(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/pprof.go:740:24) w])

JOKER FUNC pprof.StopCPUProfile has:
;; (defn StopCPUProfile
;;   "StopCPUProfile stops the current CPU profile, if any.\nStopCPUProfile only returns after all the writes for the\nprofile have completed.\n"
;;   {:added "1.0"
;;    :go "stopCPUProfile()"}
;;   [])

JOKER FUNC pprof.Symbol has:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n"
;;   {:added "1.0"
;;    :go "symbol(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:174:15) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:174:38) r])

JOKER FUNC pprof.Trace has:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n"
;;   {:added "1.0"
;;    :go "trace(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:145:14) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:145:37) r])

JOKER FUNC pprof.WithLabels has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:39:55) WithLabels
;;   "WithLabels returns a new context.Context with the given labels added.\nA label overwrites a prior label with the same key.\n"
;;   {:added "1.0"
;;    :go "withLabels(ctx, labels)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:39:21) ctx, labels])

JOKER FUNC pprof.WriteHeapProfile has:
;; (defn ^Error WriteHeapProfile
;;   "WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0).\nIt is preserved for backwards compatibility.\n"
;;   {:added "1.0"
;;    :go "writeHeapProfile(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/pprof.go:520:25) w])

JOKER FUNC printer.Fprint has:
;; (defn ^Error Fprint
;;   "Fprint \"pretty-prints\" an AST node to output.\nIt calls Config.Fprint with default settings.\nNote that gofmt uses tabs for indentation but spaces for alignment;\nuse format.Node (package go/format) for output that matches gofmt.\n"
;;   {:added "1.0"
;;    :go "fprint(output, fset, node)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/printer/printer.go:1359:20) output, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/printer/printer.go:1359:36) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/printer/printer.go:1359:57) node])

JOKER FUNC quick.Check has:
;; (defn ^Error Check
;;   "Check looks for an input to f, any function that returns bool,\nsuch that f returns false. It calls f repeatedly, with arbitrary\nvalues for each argument. If f returns false on a given input,\nCheck returns that input as a *CheckError.\nFor example:\n\n\tfunc TestOddMultipleOfThree(t *testing.T) {\n\t\tf := func(x int) bool {\n\t\t\ty := OddMultipleOfThree(x)\n\t\t\treturn y%2 == 1 && y%3 == 0\n\t\t}\n\t\tif err := quick.Check(f, nil); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n"
;;   {:added "1.0"
;;    :go "check(f, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/testing/quick/quick.go:262:14) f, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/testing/quick/quick.go:262:34) config])

JOKER FUNC quick.CheckEqual has:
;; (defn ^Error CheckEqual
;;   "CheckEqual looks for an input on which f and g return different results.\nIt calls f and g repeatedly with arbitrary values for each argument.\nIf f and g return different answers, CheckEqual returns a *CheckEqualError\ndescribing the input and the outputs.\n"
;;   {:added "1.0"
;;    :go "checkEqual(f, g, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/testing/quick/quick.go:301:22) f, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/testing/quick/quick.go:301:22) g, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/testing/quick/quick.go:301:42) config])

JOKER FUNC quick.Value has:
;; (defn ^[value ok] Value
;;   "Value returns an arbitrary value of the given type.\nIf the type implements the Generator interface, that will be used.\nNote: To create arbitrary values for structs, all the fields must be exported.\n"
;;   {:added "1.0"
;;    :go "value(t, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/quick/quick.go:59:14) t, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/testing/quick/quick.go:59:33) rand])

JOKER FUNC quotedprintable.NewReader has:
;; (defn ^{:br ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/mime/quotedprintable/reader.go:18:7) br, :rerr rerr, :line ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/mime/quotedprintable/reader.go:20:7) line} NewReader
;;   "NewReader returns a quoted-printable reader, decoding from r.\n"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/quotedprintable/reader.go:24:18) r])

JOKER FUNC quotedprintable.NewWriter has:
;; (defn ^{:binary Binary, :w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/quotedprintable/writer.go:17:7) w, :i ^Int i, :line ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/mime/quotedprintable/writer.go:19:7) line, :cr cr} NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/mime/quotedprintable/writer.go:24:18) w])

JOKER FUNC rand.ExpFloat64 has:
;; (defn ^ABEND042(cannot find typename rand.float64) ExpFloat64
;;   "ExpFloat64 returns an exponentially distributed float64 in the range\n(0, +math.MaxFloat64] with an exponential distribution whose rate parameter\n(lambda) is 1 and whose mean is 1/lambda (1) from the default Source.\nTo produce a distribution with a different rate parameter,\ncallers can adjust the output using:\n\n sample = ExpFloat64() / desiredRateParameter\n"
;;   {:added "1.0"
;;    :go "expFloat64()"}
;;   [])

JOKER FUNC rand.Float32 has:
;; (defn ^ABEND042(cannot find typename rand.float32) Float32
;;   "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n"
;;   {:added "1.0"
;;    :go "float32()"}
;;   [])

JOKER FUNC rand.Float64 has:
;; (defn ^ABEND042(cannot find typename rand.float64) Float64
;;   "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n"
;;   {:added "1.0"
;;    :go "float64()"}
;;   [])

JOKER FUNC rand.Int31 has:
;; (defn ^ABEND042(cannot find typename rand.int32) Int31
;;   "Int31 returns a non-negative pseudo-random 31-bit integer as an int32\nfrom the default Source.\n"
;;   {:added "1.0"
;;    :go "int31()"}
;;   [])

JOKER FUNC rand.Int31n has:
;; (defn ^ABEND042(cannot find typename rand.int32) Int31n
;;   "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n"
;;   {:added "1.0"
;;    :go "int31n(n)"}
;;   [n])

JOKER FUNC rand.Int63 has:
;; (defn ^ABEND042(cannot find typename rand.int64) Int63
;;   "Int63 returns a non-negative pseudo-random 63-bit integer as an int64\nfrom the default Source.\n"
;;   {:added "1.0"
;;    :go "int63()"}
;;   [])

JOKER FUNC rand.Int63n has:
;; (defn ^ABEND042(cannot find typename rand.int64) Int63n
;;   "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n"
;;   {:added "1.0"
;;    :go "int63n(n)"}
;;   [n])

JOKER FUNC rand.Intn has:
(defn ^Int Intn
  "Intn returns, as an int, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n"
  {:added "1.0"
   :go "intn(n)"}
  [^Int n])

JOKER FUNC rand.New has:
(defn ^{:src src, :s64 s64, :readval readVal, :readpos readPos} New
  "New returns a new Rand that uses random values from src\nto generate other random values.\n"
  {:added "1.0"
   :go "new(src)"}
  [src])

JOKER FUNC rand.NewSource has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/math/rand/rand.go:25:13) NewSource
;;   "NewSource returns a new pseudo-random Source seeded with the given value.\nUnlike the default Source used by top-level functions, this source is not\nsafe for concurrent use by multiple goroutines.\n"
;;   {:added "1.0"
;;    :go "newSource(seed)"}
;;   [seed])

JOKER FUNC rand.NewZipf has:
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/math/rand/zipf.go:16:15) r, :imax imax, :v v, :q q, :s s, :oneminusq oneminusQ, :oneminusqinv oneminusQinv, :hxm hxm, :hx0minushxm hx0minusHxm} NewZipf
;;   "NewZipf returns a Zipf variate generator.\nThe generator generates values k  [0, imax]\nsuch that P(k) is proportional to (v + k) ** (-s).\nRequirements: s > 1 and v >= 1.\n"
;;   {:added "1.0"
;;    :go "newZipf(r, s, v, imax)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/math/rand/zipf.go:39:16) r, s, v, imax])

JOKER FUNC rand.NormFloat64 has:
;; (defn ^ABEND042(cannot find typename rand.float64) NormFloat64
;;   "NormFloat64 returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with\nstandard normal distribution (mean = 0, stddev = 1)\nfrom the default Source.\nTo produce a different normal distribution, callers can\nadjust the output using:\n\n sample = NormFloat64() * desiredStdDev + desiredMean\n"
;;   {:added "1.0"
;;    :go "normFloat64()"}
;;   [])

JOKER FUNC rand.Perm has:
(defn ^[Int] Perm
  "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n)\nfrom the default Source.\n"
  {:added "1.0"
   :go "perm(n)"}
  [^Int n])

JOKER FUNC rand.Prime has:
;; (defn ^[p err] Prime
;;   "Prime returns a number, p, of the given size, such that p is prime\nwith high probability.\nPrime will return error for any error returned by rand.Read or if bits < 2.\n"
;;   {:added "1.0"
;;    :go "prime(rand, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rand/util.go:31:17) rand, ^Int bits])

JOKER FUNC rand.Seed has:
;; (defn Seed
;;   "Seed uses the provided seed value to initialize the default Source to a\ndeterministic state. If Seed is not called, the generator behaves as\nif seeded by Seed(1). Seed values that have the same remainder when\ndivided by 2^31-1 generate the same pseudo-random sequence.\nSeed, unlike the Rand.Seed method, is safe for concurrent use.\n"
;;   {:added "1.0"
;;    :go "seed(seed)"}
;;   [seed])

JOKER FUNC rand.Shuffle has:
;; (defn Shuffle
;;   "Shuffle pseudo-randomizes the order of elements using the default Source.\nn is the number of elements. Shuffle panics if n < 0.\nswap swaps the elements with indexes i and j.\n"
;;   {:added "1.0"
;;    :go "shuffle(n, swap)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/math/rand/rand.go:346:26) swap])

JOKER FUNC rand.Uint32 has:
;; (defn ^ABEND042(cannot find typename rand.uint32) Uint32
;;   "Uint32 returns a pseudo-random 32-bit value as a uint32\nfrom the default Source.\n"
;;   {:added "1.0"
;;    :go "uint32()"}
;;   [])

JOKER FUNC rand.Uint64 has:
;; (defn ^ABEND042(cannot find typename rand.uint64) Uint64
;;   "Uint64 returns a pseudo-random 64-bit value as a uint64\nfrom the default Source.\n"
;;   {:added "1.0"
;;    :go "uint64()"}
;;   [])

JOKER FUNC rc4.NewCipher has:
;; (defn ^[{:s ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rc4/rc4.go:19:7) s, :i i, :j j} Error] NewCipher
;;   "NewCipher creates and returns a new Cipher. The key argument should be the\nRC4 key, at least 1 byte and at most 256 bytes.\n"
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rc4/rc4.go:31:20) key])

JOKER FUNC reflect.Append has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} Append
;;   "Append appends the values x to a slice s and returns the resulting slice.\nAs in Go, each x's value must be assignable to the slice's element type.\n"
;;   {:added "1.0"
;;    :go "append(s, x)"}
;;   [s, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/reflect/value.go:1890:24) x])

JOKER FUNC reflect.AppendSlice has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} AppendSlice
;;   "AppendSlice appends a slice t to a slice s and returns the resulting slice.\nThe slices s and t must have the same element type.\n"
;;   {:added "1.0"
;;    :go "appendSlice(s, t)"}
;;   [s, t])

JOKER FUNC reflect.ArrayOf has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11) ArrayOf
;;   "ArrayOf returns the array type with the given count and element type.\nFor example, if t represents int, ArrayOf(5, t) represents [5]int.\n\nIf the resulting type would be larger than the available address space,\nArrayOf panics.\n"
;;   {:added "1.0"
;;    :go "arrayOf(count, elem)"}
;;   [^Int count, elem])

JOKER FUNC reflect.ChanOf has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11) ChanOf
;;   "ChanOf returns the channel type with the given direction and element type.\nFor example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.\n\nThe gc runtime imposes a limit of 64 kB on channel element types.\nIf t's size is equal to or exceeds this limit, ChanOf panics.\n"
;;   {:added "1.0"
;;    :go "chanOf(dir, t)"}
;;   [dir, t])

JOKER FUNC reflect.Copy has:
(defn ^Int Copy
  "Copy copies the contents of src into dst until either\ndst has been filled or src has been exhausted.\nIt returns the number of elements copied.\nDst and src each must have kind Slice or Array, and\ndst and src must have the same element type.\n\nAs a special case, src can have kind String if the element type of dst is kind Uint8.\n"
  {:added "1.0"
   :go "copy(dst, src)"}
  [dst, src])

JOKER FUNC reflect.DeepEqual has:
;; (defn ^ABEND042(cannot find typename reflect.bool) DeepEqual
;;   "DeepEqual reports whether x and y are ``deeply equal,'' defined as follows.\nTwo values of identical type are deeply equal if one of the following cases applies.\nValues of distinct types are never deeply equal.\n\nArray values are deeply equal when their corresponding elements are deeply equal.\n\nStruct values are deeply equal if their corresponding fields,\nboth exported and unexported, are deeply equal.\n\nFunc values are deeply equal if both are nil; otherwise they are not deeply equal.\n\nInterface values are deeply equal if they hold deeply equal concrete values.\n\nMap values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they are the same map object or their corresponding keys\n(matched using Go equality) map to deeply equal values.\n\nPointer values are deeply equal if they are equal using Go's == operator\nor if they point to deeply equal values.\n\nSlice values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they point to the same initial entry of the same underlying array\n(that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.\nNote that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))\nare not deeply equal.\n\nOther values - numbers, bools, strings, and channels - are deeply equal\nif they are equal using Go's == operator.\n\nIn general DeepEqual is a recursive relaxation of Go's == operator.\nHowever, this idea is impossible to implement without some inconsistency.\nSpecifically, it is possible for a value to be unequal to itself,\neither because it is of func type (uncomparable in general)\nor because it is a floating-point NaN value (not equal to itself in floating-point comparison),\nor because it is an array, struct, or interface containing\nsuch a value.\nOn the other hand, pointer values are always equal to themselves,\neven if they point at or contain such problematic values,\nbecause they compare equal using Go's == operator, and that\nis a sufficient condition to be deeply equal, regardless of content.\nDeepEqual has been defined so that the same short-cut applies\nto slices and maps: if x and y are the same slice or the same map,\nthey are deeply equal regardless of content.\n\nAs DeepEqual traverses the data values it may find a cycle. The\nsecond and subsequent times that DeepEqual compares two pointer\nvalues that have been compared before, it treats the values as\nequal rather than examining the values to which they point.\nThis ensures that DeepEqual terminates.\n"
;;   {:added "1.0"
;;    :go "deepEqual(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/deepequal.go:187:21) x, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/deepequal.go:187:21) y])

JOKER FUNC reflect.FuncOf has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11) FuncOf
;;   "FuncOf returns the function type with the given argument and result types.\nFor example if k represents int and e represents string,\nFuncOf([]Type{k}, []Type{e}, false) represents func(int) string.\n\nThe variadic argument controls whether the function is variadic. FuncOf\npanics if the in[len(in)-1] does not represent a slice and variadic is\ntrue.\n"
;;   {:added "1.0"
;;    :go "funcOf(in, out, variadic)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/type.go:1924:21) in, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/type.go:1924:21) out, variadic])

JOKER FUNC reflect.Indirect has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} Indirect
;;   "Indirect returns the value that v points to.\nIf v is a nil pointer, Indirect returns a zero Value.\nIf v is not a pointer, Indirect returns v.\n"
;;   {:added "1.0"
;;    :go "indirect(v)"}
;;   [v])

JOKER FUNC reflect.MakeChan has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} MakeChan
;;   "MakeChan creates a new channel with the specified type and buffer size.\n"
;;   {:added "1.0"
;;    :go "makeChan(typ, buffer)"}
;;   [typ, ^Int buffer])

JOKER FUNC reflect.MakeFunc has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} MakeFunc
;;   "MakeFunc returns a new function of the given Type\nthat wraps the function fn. When called, that new function\ndoes the following:\n\n\t- converts its arguments to a slice of Values.\n\t- runs results := fn(args).\n\t- returns the results as a slice of Values, one per formal result.\n\nThe implementation fn can assume that the argument Value slice\nhas the number and type of arguments given by typ.\nIf typ describes a variadic function, the final Value is itself\na slice representing the variadic arguments, as in the\nbody of a variadic function. The result Value slice returned by fn\nmust have the number and type of results given by typ.\n\nThe Value.Call method allows the caller to invoke a typed function\nin terms of Values; in contrast, MakeFunc allows the caller to implement\na typed function in terms of Values.\n\nThe Examples section of the documentation includes an illustration\nof how to use MakeFunc to build a swap function for different types.\n"
;;   {:added "1.0"
;;    :go "makeFunc(typ, fn)"}
;;   [typ, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/reflect/makefunc.go:48:28) fn])

JOKER FUNC reflect.MakeMap has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} MakeMap
;;   "MakeMap creates a new map with the specified type.\n"
;;   {:added "1.0"
;;    :go "makeMap(typ)"}
;;   [typ])

JOKER FUNC reflect.MakeMapWithSize has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} MakeMapWithSize
;;   "MakeMapWithSize creates a new map with the specified type\nand initial space for approximately n elements.\n"
;;   {:added "1.0"
;;    :go "makeMapWithSize(typ, n)"}
;;   [typ, ^Int n])

JOKER FUNC reflect.MakeSlice has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} MakeSlice
;;   "MakeSlice creates a new zero-initialized slice value\nfor the specified slice type, length, and capacity.\n"
;;   {:added "1.0"
;;    :go "makeSlice(typ, len, cap)"}
;;   [typ, ^Int len, ^Int cap])

JOKER FUNC reflect.MapOf has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11) MapOf
;;   "MapOf returns the map type with the given key and element types.\nFor example, if k represents int and e represents string,\nMapOf(k, e) represents map[int]string.\n\nIf the key type is not a valid map key type (that is, if it does\nnot implement Go's == operator), MapOf panics.\n"
;;   {:added "1.0"
;;    :go "mapOf(key, elem)"}
;;   [key, elem])

JOKER FUNC reflect.New has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} New
;;   "New returns a Value representing a pointer to a new zero value\nfor the specified type. That is, the returned Value's Type is PtrTo(typ).\n"
;;   {:added "1.0"
;;    :go "new(typ)"}
;;   [typ])

JOKER FUNC reflect.NewAt has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} NewAt
;;   "NewAt returns a Value representing a pointer to a value of the\nspecified type, using p as that pointer.\n"
;;   {:added "1.0"
;;    :go "newAt(typ, p)"}
;;   [typ, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:2227:24) p])

JOKER FUNC reflect.PtrTo has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11) PtrTo
;;   "PtrTo returns the pointer type with element t.\nFor example, if t represents type Foo, PtrTo(t) represents *Foo.\n"
;;   {:added "1.0"
;;    :go "ptrTo(t)"}
;;   [t])

JOKER FUNC reflect.Select has:
;; (defn ^[chosen recv recvOK] Select
;;   "Select executes a select operation described by the list of cases.\nLike the Go select statement, it blocks until at least one of the cases\ncan proceed, makes a uniform pseudo-random choice,\nand then executes that case. It returns the index of the chosen case\nand, if that case was a receive operation, the value received and a\nboolean indicating whether the value corresponds to a send on the channel\n(as opposed to a zero value received because the channel is closed).\n"
;;   {:added "1.0"
;;    :go "select(cases)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/value.go:2025:19) cases])

JOKER FUNC reflect.SliceOf has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11) SliceOf
;;   "SliceOf returns the slice type with element type t.\nFor example, if t represents int, SliceOf(t) represents []int.\n"
;;   {:added "1.0"
;;    :go "sliceOf(t)"}
;;   [t])

JOKER FUNC reflect.StructOf has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11) StructOf
;;   "StructOf returns the struct type containing fields.\nThe Offset and Index fields are ignored and computed as they would be\nby the compiler.\n\nStructOf currently does not generate wrapper methods for embedded\nfields and panics if passed unexported StructFields.\nThese limitations may be lifted in a future version.\n"
;;   {:added "1.0"
;;    :go "structOf(fields)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/reflect/type.go:2349:22) fields])

JOKER FUNC reflect.Swapper has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/reflect/swapper.go:13:33) Swapper
;;   "Swapper returns a function that swaps the elements in the provided\nslice.\n\nSwapper panics if the provided interface is not a slice.\n"
;;   {:added "1.0"
;;    :go "swapper(slice)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/swapper.go:13:20) slice])

JOKER FUNC reflect.TypeOf has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:38:11) TypeOf
;;   "TypeOf returns the reflection Type that represents the dynamic type of i.\nIf i is a nil interface value, TypeOf returns nil.\n"
;;   {:added "1.0"
;;    :go "typeOf(i)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/type.go:1376:15) i])

JOKER FUNC reflect.ValueOf has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} ValueOf
;;   "ValueOf returns a new Value initialized to the concrete value\nstored in the interface i. ValueOf(nil) returns the zero Value.\n"
;;   {:added "1.0"
;;    :go "valueOf(i)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/reflect/value.go:2182:16) i])

JOKER FUNC reflect.Zero has:
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/reflect/value.go:38:6) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/reflect/value.go:42:6) ptr} Zero
;;   "Zero returns a Value representing the zero value for the specified type.\nThe result is different from the zero value of the Value struct,\nwhich represents no value at all.\nFor example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.\nThe returned value is neither addressable nor settable.\n"
;;   {:added "1.0"
;;    :go "zero(typ)"}
;;   [typ])

JOKER FUNC regexp.Compile has:
;; (defn ^[{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:86:10) mu, :machine ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/regexp.go:87:10) machine} Error] Compile
;;   "Compile parses a regular expression and returns, if successful,\na Regexp object that can be used to match against text.\n\nWhen matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses the one that a backtracking search would have found first.\nThis so-called leftmost-first matching is the same semantics\nthat Perl, Python, and other implementations use, although this\npackage implements it without the expense of backtracking.\nFor POSIX leftmost-longest matching, see CompilePOSIX.\n"
;;   {:added "1.0"
;;    :go "compile(expr)"}
;;   [^String expr])

JOKER FUNC regexp.CompilePOSIX has:
;; (defn ^[{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:86:10) mu, :machine ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/regexp.go:87:10) machine} Error] CompilePOSIX
;;   "CompilePOSIX is like Compile but restricts the regular expression\nto POSIX ERE (egrep) syntax and changes the match semantics to\nleftmost-longest.\n\nThat is, when matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses a match that is as long as possible.\nThis so-called leftmost-longest matching is the same semantics\nthat early regular expression implementations used and that POSIX\nspecifies.\n\nHowever, there can be multiple leftmost-longest matches, with different\nsubmatch choices, and here this package diverges from POSIX.\nAmong the possible leftmost-longest matches, this package chooses\nthe one that a backtracking search would have found first, while POSIX\nspecifies that the match be chosen to maximize the length of the first\nsubexpression, then the second, and so on from left to right.\nThe POSIX rule is computationally prohibitive and not even well-defined.\nSee https://swtch.com/~rsc/regexp/regexp2.html#posix for details.\n"
;;   {:added "1.0"
;;    :go "compilePOSIX(expr)"}
;;   [^String expr])

JOKER FUNC regexp.Match has:
;; (defn ^[matched err] Match
;;   "MatchString reports whether the byte slice b\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n"
;;   {:added "1.0"
;;    :go "match(pattern, b)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/regexp.go:475:30) b])

JOKER FUNC regexp.MatchReader has:
;; (defn ^[matched err] MatchReader
;;   "MatchReader reports whether the text returned by the RuneReader\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n"
;;   {:added "1.0"
;;    :go "matchReader(pattern, r)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:453:36) r])

JOKER FUNC regexp.MatchString has:
(defn ^[matched err] MatchString
  "MatchString reports whether the string s\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n"
  {:added "1.0"
   :go "matchString(pattern, s)"}
  [^String pattern, ^String s])

JOKER FUNC regexp.MustCompile has:
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:86:10) mu, :machine ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/regexp.go:87:10) machine} MustCompile
;;   "MustCompile is like Compile but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n"
;;   {:added "1.0"
;;    :go "mustCompile(str)"}
;;   [^String str])

JOKER FUNC regexp.MustCompilePOSIX has:
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/regexp/regexp.go:86:10) mu, :machine ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/regexp.go:87:10) machine} MustCompilePOSIX
;;   "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n"
;;   {:added "1.0"
;;    :go "mustCompilePOSIX(str)"}
;;   [^String str])

JOKER FUNC regexp.QuoteMeta has:
(defn ^String QuoteMeta
  "QuoteMeta returns a string that escapes all regular expression metacharacters\ninside the argument text; the returned string is a regular expression matching\nthe literal text.\n"
  {:added "1.0"
   :go "quoteMeta(s)"}
  [^String s])

JOKER FUNC ring.New has:
;; (defn ^{:next ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/container/ring/ring.go:15:13) next, :prev ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/container/ring/ring.go:15:13) prev, :value ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/ring/ring.go:16:13) Value} New
;;   "New creates a ring of n elements.\n"
;;   {:added "1.0"
;;    :go "new(n)"}
;;   [^Int n])

JOKER FUNC route.FetchRIB has:
;; (defn ^[[ABEND042(cannot find typename route.byte)] Error] FetchRIB
;;   "FetchRIB fetches a routing information base from the operating\nsystem.\n\nThe provided af must be an address family.\n\nThe provided arg must be a RIBType-specific argument.\nWhen RIBType is related to routes, arg might be a set of route\nflags. When RIBType is related to network interfaces, arg might be\nan interface index or a set of interface flags. In most cases, zero\nmeans a wildcard.\n"
;;   {:added "1.0"
;;    :go "fetchRIB(af, typ, arg)"}
;;   [^Int af, typ, ^Int arg])

JOKER FUNC route.ParseRIB has:
;; (defn ^[[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/vendor/golang_org/x/net/route/message.go:10:14)] Error] ParseRIB
;;   "ParseRIB parses b as a routing information base and returns a list\nof routing messages.\n"
;;   {:added "1.0"
;;    :go "parseRIB(typ, b)"}
;;   [typ, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/net/route/message.go:33:30) b])

JOKER FUNC rpc.Accept has:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n"
;;   {:added "1.0"
;;    :go "accept(lis)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:692:17) lis])

JOKER FUNC rpc.Dial has:
;; (defn ^[{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:44:11) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:47:11) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/rpc/client.go:49:11) pending, :closing closing, :shutdown shutdown} Error] Dial
;;   "Dial connects to an RPC server at the specified network address.\n"
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC rpc.DialHTTP has:
;; (defn ^[{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:44:11) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:47:11) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/rpc/client.go:49:11) pending, :closing closing, :shutdown shutdown} Error] DialHTTP
;;   "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n"
;;   {:added "1.0"
;;    :go "dialHTTP(network, address)"}
;;   [^String network, ^String address])

JOKER FUNC rpc.DialHTTPPath has:
;; (defn ^[{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:44:11) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:47:11) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/rpc/client.go:49:11) pending, :closing closing, :shutdown shutdown} Error] DialHTTPPath
;;   "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n"
;;   {:added "1.0"
;;    :go "dialHTTPPath(network, address, path)"}
;;   [^String network, ^String address, ^String path])

JOKER FUNC rpc.HandleHTTP has:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n"
;;   {:added "1.0"
;;    :go "handleHTTP()"}
;;   [])

JOKER FUNC rpc.NewClient has:
;; (defn ^{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:44:11) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:47:11) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/rpc/client.go:49:11) pending, :closing closing, :shutdown shutdown} NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n"
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:193:21) conn])

JOKER FUNC rpc.NewClientWithCodec has:
;; (defn ^{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:44:11) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/client.go:47:11) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/rpc/client.go:49:11) pending, :closing closing, :shutdown shutdown} NewClientWithCodec
;;   "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n"
;;   {:added "1.0"
;;    :go "newClientWithCodec(codec)"}
;;   [codec])

JOKER FUNC rpc.NewServer has:
;; (defn ^{:servicemap ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:190:13) serviceMap, :reqlock ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:191:13) reqLock, :freereq ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/rpc/server.go:192:13) freeReq, :resplock ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:193:13) respLock, :freeresp ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/rpc/server.go:194:13) freeResp} NewServer
;;   "NewServer returns a new Server.\n"
;;   {:added "1.0"
;;    :go "newServer()"}
;;   [])

JOKER FUNC rpc.Register has:
;; (defn ^Error Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n"
;;   {:added "1.0"
;;    :go "register(rcvr)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/rpc/server.go:642:20) rcvr])

JOKER FUNC rpc.RegisterName has:
;; (defn ^Error RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n"
;;   {:added "1.0"
;;    :go "registerName(name, rcvr)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/rpc/server.go:646:37) rcvr])

JOKER FUNC rpc.ServeCodec has:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n"
;;   {:added "1.0"
;;    :go "serveCodec(codec)"}
;;   [codec])

JOKER FUNC rpc.ServeConn has:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n"
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:673:21) conn])

JOKER FUNC rpc.ServeRequest has:
(defn ^Error ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n"
  {:added "1.0"
   :go "serveRequest(codec)"}
  [codec])

JOKER FUNC rsa.DecryptOAEP has:
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] DecryptOAEP
;;   "OAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter, if not nil, is used to blind the private-key operation\nand avoid timing side-channel attacks. Blinding is purely internal to this\nfunction  the random data need not match that used when encrypting.\n\nThe label parameter must match the value given when encrypting. See\nEncryptOAEP for details.\n"
;;   {:added "1.0"
;;    :go "decryptOAEP(hash, random, priv, ciphertext, label)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:569:23) hash, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:569:41) random, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/rsa.go:569:57) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:569:81) ciphertext, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:569:95) label])

JOKER FUNC rsa.DecryptPKCS1v15 has:
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] DecryptPKCS1v15
;;   "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n\nNote that whether this function returns an error or not discloses secret\ninformation. If an attacker can cause this function to run repeatedly and\nlearn whether each instance returned an error then they can decrypt and\nforge signatures as if they had the private key. See\nDecryptPKCS1v15SessionKey for a way of solving this problem.\n"
;;   {:added "1.0"
;;    :go "decryptPKCS1v15(rand, priv, ciphertext)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:76:27) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:76:43) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:76:67) ciphertext])

JOKER FUNC rsa.DecryptPKCS1v15SessionKey has:
;; (defn ^Error DecryptPKCS1v15SessionKey
;;   "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\nIt returns an error if the ciphertext is the wrong length or if the\nciphertext is greater than the public modulus. Otherwise, no error is\nreturned. If the padding is valid, the resulting plaintext message is copied\ninto key. Otherwise, key is unchanged. These alternatives occur in constant\ntime. It is intended that the user of this function generate a random\nsession key beforehand and continue the protocol with the resulting value.\nThis will remove any possibility that an attacker can learn any information\nabout the plaintext.\nSee ``Chosen Ciphertext Attacks Against Protocols Based on the RSA\nEncryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n(Crypto '98).\n\nNote that if the session key is too small then it may be possible for an\nattacker to brute-force it. If they can do that then they can learn whether\na random value was used (because it'll be different for the same ciphertext)\nand thus whether the padding was correct. This defeats the point of this\nfunction. Using at least a 16-byte key will protect against this attack.\n"
;;   {:added "1.0"
;;    :go "decryptPKCS1v15SessionKey(rand, priv, ciphertext, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:109:37) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:109:53) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:109:77) ciphertext, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:109:89) key])

JOKER FUNC rsa.EncryptOAEP has:
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] EncryptOAEP
;;   "EncryptOAEP encrypts the given message with RSA-OAEP.\n\nOAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same ciphertext.\n\nThe label parameter may contain arbitrary data that will not be encrypted,\nbut which gives important context to the message. For example, if a given\npublic key is used to decrypt two types of messages then distinct label\nvalues could be used to ensure that a ciphertext for one purpose cannot be\nused for another by an attacker. If not required it can be empty.\n\nThe message must be no longer than the length of the public modulus minus\ntwice the hash length, minus a further 2.\n"
;;   {:added "1.0"
;;    :go "encryptOAEP(hash, random, pub, msg, label)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:376:23) hash, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:376:41) random, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/rsa.go:376:56) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:376:72) msg, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:376:86) label])

JOKER FUNC rsa.EncryptPKCS1v15 has:
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] EncryptPKCS1v15
;;   "EncryptPKCS1v15 encrypts the given message with RSA and the padding\nscheme from PKCS#1 v1.5.  The message must be no longer than the\nlength of the public modulus minus 11 bytes.\n\nThe rand parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same\nciphertext.\n\nWARNING: use of this function to encrypt plaintexts other than\nsession keys is dangerous. Use RSA OAEP in new protocols.\n"
;;   {:added "1.0"
;;    :go "encryptPKCS1v15(rand, pub, msg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:39:27) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:39:42) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:39:58) msg])

JOKER FUNC rsa.GenerateKey has:
;; (defn ^[{:d ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/rsa.go:90:12) D, :primes ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:91:12) Primes, :precomputed Precomputed} Error] GenerateKey
;;   "GenerateKey generates an RSA keypair of the given bit size using the\nrandom source random (for example, crypto/rand.Reader).\n"
;;   {:added "1.0"
;;    :go "generateKey(random, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:207:25) random, ^Int bits])

JOKER FUNC rsa.GenerateMultiPrimeKey has:
;; (defn ^[{:d ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/rsa.go:90:12) D, :primes ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/rsa.go:91:12) Primes, :precomputed Precomputed} Error] GenerateMultiPrimeKey
;;   "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\nsize and the given random source, as suggested in [1]. Although the public\nkeys are compatible (actually, indistinguishable) from the 2-prime case,\nthe private keys are not. Thus it may not be possible to export multi-prime\nprivate keys in certain formats or to subsequently import them into other\ncode.\n\nTable 1 in [2] suggests maximum numbers of primes for a given size.\n\n[1] US patent 4405829 (1972, expired)\n[2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n"
;;   {:added "1.0"
;;    :go "generateMultiPrimeKey(random, nprimes, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/rsa.go:222:35) random, ^Int nprimes, ^Int bits])

JOKER FUNC rsa.SignPKCS1v15 has:
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] SignPKCS1v15
;;   "SignPKCS1v15 calculates the signature of hashed using\nRSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must\nbe the result of hashing the input message using the given hash\nfunction. If hash is zero, hashed is signed directly. This isn't\nadvisable except for interoperability.\n\nIf rand is not nil then RSA blinding will be used to avoid timing\nside-channel attacks.\n\nThis function is deterministic. Thus, if the set of possible\nmessages is small, an attacker may be able to build a map from\nmessages to signatures and identify the signed messages. As ever,\nsignatures provide authenticity, not confidentiality.\n"
;;   {:added "1.0"
;;    :go "signPKCS1v15(rand, priv, hash, hashed)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:24) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:40) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:58) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:232:78) hashed])

JOKER FUNC rsa.SignPSS has:
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] SignPSS
;;   "SignPSS calculates the signature of hashed using RSASSA-PSS [1].\nNote that hashed must be the result of hashing the input message using the\ngiven hash function. The opts argument may be nil, in which case sensible\ndefaults are used.\n"
;;   {:added "1.0"
;;    :go "signPSS(rand, priv, hash, hashed, opts)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pss.go:249:19) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pss.go:249:35) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pss.go:249:53) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pss.go:249:73) hashed, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pss.go:249:86) opts])

JOKER FUNC rsa.VerifyPKCS1v15 has:
;; (defn ^Error VerifyPKCS1v15
;;   "VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. If hash is zero then hashed is used directly. This\nisn't advisable except for interoperability.\n"
;;   {:added "1.0"
;;    :go "verifyPKCS1v15(pub, hash, hashed, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:268:25) pub, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pkcs1v15.go:268:42) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:268:62) hashed, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pkcs1v15.go:268:74) sig])

JOKER FUNC rsa.VerifyPSS has:
;; (defn ^Error VerifyPSS
;;   "VerifyPSS verifies a PSS signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. The opts argument may be nil, in which case sensible\ndefaults are used.\n"
;;   {:added "1.0"
;;    :go "verifyPSS(pub, hash, hashed, sig, opts)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pss.go:274:20) pub, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/rsa/pss.go:274:37) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pss.go:274:57) hashed, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/rsa/pss.go:274:69) sig, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/rsa/pss.go:274:82) opts])

JOKER FUNC runtime.BlockProfile has:
;; (defn ^[n ok] BlockProfile
;;   "BlockProfile returns n, the number of records in the current blocking profile.\nIf len(p) >= n, BlockProfile copies the profile into p and returns n, true.\nIf len(p) < n, BlockProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.blockprofile flag instead\nof calling BlockProfile directly.\n"
;;   {:added "1.0"
;;    :go "blockProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:634:21) p])

JOKER FUNC runtime.Breakpoint has:
;; (defn Breakpoint
;;   "Breakpoint executes a breakpoint trap.\n"
;;   {:added "1.0"
;;    :go "breakpoint()"}
;;   [])

JOKER FUNC runtime.CPUProfile has:
;; (defn ^[ABEND042(cannot find typename runtime.byte)] CPUProfile
;;   "CPUProfile panics.\nIt formerly provided raw access to chunks of\na pprof-format profile generated by the runtime.\nThe details of generating that format have changed,\nso this functionality has been removed.\n\nDeprecated: use the runtime/pprof package,\nor the handlers in the net/http/pprof package,\nor the testing package's -test.cpuprofile flag instead.\n"
;;   {:added "1.0"
;;    :go "cPUProfile()"}
;;   [])

JOKER FUNC runtime.Caller has:
(defn ^[pc file line ok] Caller
  "Caller reports file and line number information about function invocations on\nthe calling goroutine's stack. The argument skip is the number of stack frames\nto ascend, with 0 identifying the caller of Caller.  (For historical reasons the\nmeaning of skip differs between Caller and Callers.) The return values report the\nprogram counter, file name, and line number within the file of the corresponding\ncall. The boolean ok is false if it was not possible to recover the information.\n"
  {:added "1.0"
   :go "caller(skip)"}
  [^Int skip])

JOKER FUNC runtime.Callers has:
;; (defn ^Int Callers
;;   "Callers fills the slice pc with the return program counters of function invocations\non the calling goroutine's stack. The argument skip is the number of stack frames\nto skip before recording in pc, with 0 identifying the frame for Callers itself and\n1 identifying the caller of Callers.\nIt returns the number of entries written to pc.\n\nTo translate these PCs into symbolic information such as function\nnames and line numbers, use CallersFrames. CallersFrames accounts\nfor inlined functions and adjusts the return program counters into\ncall program counters. Iterating over the returned slice of PCs\ndirectly is discouraged, as is using FuncForPC on any of the\nreturned PCs, since these cannot account for inlining or return\nprogram counter adjustment.\n"
;;   {:added "1.0"
;;    :go "callers(skip, pc)"}
;;   [^Int skip, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/extern.go:211:27) pc])

JOKER FUNC runtime.CallersFrames has:
;; (defn ^{:callers ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/symtab.go:17:10) callers, :stackexpander stackExpander, :elidewrapper elideWrapper} CallersFrames
;;   "CallersFrames takes a slice of PC values returned by Callers and\nprepares to return function/file/line information.\nDo not change the slice until you are done with the Frames.\n"
;;   {:added "1.0"
;;    :go "callersFrames(callers)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/symtab.go:91:28) callers])

JOKER FUNC runtime.FuncForPC has:
;; (defn ^{:opaque ^ABEND881(unrecognized Expr type *ast.StructType at: ../GOSRC/runtime/symtab.go:328:9) opaque} FuncForPC
;;   "FuncForPC returns a *Func describing the function that contains the\ngiven program counter address, or else nil.\n\nIf pc represents multiple functions because of inlining, it returns\nthe *Func describing the outermost function.\n"
;;   {:added "1.0"
;;    :go "funcForPC(pc)"}
;;   [pc])

JOKER FUNC runtime.GC has:
;; (defn GC
;;   "GC runs a garbage collection and blocks the caller until the\ngarbage collection is complete. It may also block the entire\nprogram.\n"
;;   {:added "1.0"
;;    :go "gC()"}
;;   [])

JOKER FUNC runtime.GOMAXPROCS has:
(defn ^Int GOMAXPROCS
  "GOMAXPROCS sets the maximum number of CPUs that can be executing\nsimultaneously and returns the previous setting. If n < 1, it does not\nchange the current setting.\nThe number of logical CPUs on the local machine can be queried with NumCPU.\nThis call will go away when the scheduler improves.\n"
  {:added "1.0"
   :go "gOMAXPROCS(n)"}
  [^Int n])

JOKER FUNC runtime.GOROOT has:
(defn ^String GOROOT
  "GOROOT returns the root of the Go tree. It uses the\nGOROOT environment variable, if set at process start,\nor else the root used during the Go build.\n"
  {:added "1.0"
   :go "gOROOT()"}
  [])

JOKER FUNC runtime.Goexit has:
;; (defn Goexit
;;   "Goexit terminates the goroutine that calls it. No other goroutine is affected.\nGoexit runs all deferred calls before terminating the goroutine. Because Goexit\nis not a panic, any recover calls in those deferred functions will return nil.\n\nCalling Goexit from the main goroutine terminates that goroutine\nwithout func main returning. Since func main has not returned,\nthe program continues execution of other goroutines.\nIf all other goroutines exit, the program crashes.\n"
;;   {:added "1.0"
;;    :go "goexit()"}
;;   [])

JOKER FUNC runtime.GoroutineProfile has:
;; (defn ^[n ok] GoroutineProfile
;;   "GoroutineProfile returns n, the number of records in the active goroutine stack profile.\nIf len(p) >= n, GoroutineProfile copies the profile into p and returns n, true.\nIf len(p) < n, GoroutineProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling GoroutineProfile directly.\n"
;;   {:added "1.0"
;;    :go "goroutineProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:720:25) p])

JOKER FUNC runtime.Gosched has:
;; (defn Gosched
;;   "Gosched yields the processor, allowing other goroutines to run. It does not\nsuspend the current goroutine, so execution resumes automatically.\n"
;;   {:added "1.0"
;;    :go "gosched()"}
;;   [])

JOKER FUNC runtime.KeepAlive has:
;; (defn KeepAlive
;;   "KeepAlive marks its argument as currently reachable.\nThis ensures that the object is not freed, and its finalizer is not run,\nbefore the point in the program where KeepAlive is called.\n\nA very simplified example showing where KeepAlive is required:\n\ttype File struct { d int }\n\td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n\t// ... do something if err != nil ...\n\tp := &File{d}\n\truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n\tvar buf [10]byte\n\tn, err := syscall.Read(p.d, buf[:])\n\t// Ensure p is not finalized until Read returns.\n\truntime.KeepAlive(p)\n\t// No more uses of p after this point.\n\nWithout the KeepAlive call, the finalizer could run at the start of\nsyscall.Read, closing the file descriptor before syscall.Read makes\nthe actual system call.\n"
;;   {:added "1.0"
;;    :go "keepAlive(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:446:18) x])

JOKER FUNC runtime.LockOSThread has:
;; (defn LockOSThread
;;   "LockOSThread wires the calling goroutine to its current operating system thread.\nThe calling goroutine will always execute in that thread,\nand no other goroutine will execute in it,\nuntil the calling goroutine has made as many calls to\nUnlockOSThread as to LockOSThread.\nIf the calling goroutine exits without unlocking the thread,\nthe thread will be terminated.\n\nAll init functions are run on the startup thread. Calling LockOSThread\nfrom an init function will cause the main function to be invoked on\nthat thread.\n\nA goroutine should call LockOSThread before calling OS services or\nnon-Go library functions that depend on per-thread state.\n"
;;   {:added "1.0"
;;    :go "lockOSThread()"}
;;   [])

JOKER FUNC runtime.MemProfile has:
;; (defn ^[n ok] MemProfile
;;   "MemProfile returns a profile of memory allocated and freed per allocation\nsite.\n\nMemProfile returns n, the number of records in the current memory profile.\nIf len(p) >= n, MemProfile copies the profile into p and returns n, true.\nIf len(p) < n, MemProfile does not change p and returns n, false.\n\nIf inuseZero is true, the profile includes allocation records\nwhere r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.\nThese are sites where memory was allocated, but it has all\nbeen released back to the runtime.\n\nThe returned profile may be up to two garbage collection cycles old.\nThis is to avoid skewing the profile toward allocations; because\nallocations happen in real time but frees are delayed until the garbage\ncollector performs sweeping, the profile only accounts for allocations\nthat have had a chance to be freed by the garbage collector.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.memprofile flag instead\nof calling MemProfile directly.\n"
;;   {:added "1.0"
;;    :go "memProfile(p, inuseZero)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:543:19) p, inuseZero])

JOKER FUNC runtime.MutexProfile has:
;; (defn ^[n ok] MutexProfile
;;   "MutexProfile returns n, the number of records in the current mutex profile.\nIf len(p) >= n, MutexProfile copies the profile into p and returns n, true.\nOtherwise, MutexProfile does not change p, and returns n, false.\n\nMost clients should use the runtime/pprof package\ninstead of calling MutexProfile directly.\n"
;;   {:added "1.0"
;;    :go "mutexProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:669:21) p])

JOKER FUNC runtime.NumCPU has:
(defn ^Int NumCPU
  "NumCPU returns the number of logical CPUs usable by the current process.\n\nThe set of available CPUs is checked by querying the operating system\nat process startup. Changes to operating system CPU allocation after\nprocess startup are not reflected.\n"
  {:added "1.0"
   :go "numCPU()"}
  [])

JOKER FUNC runtime.NumCgoCall has:
;; (defn ^ABEND042(cannot find typename runtime.int64) NumCgoCall
;;   "NumCgoCall returns the number of cgo calls made by the current process.\n"
;;   {:added "1.0"
;;    :go "numCgoCall()"}
;;   [])

JOKER FUNC runtime.NumGoroutine has:
(defn ^Int NumGoroutine
  "NumGoroutine returns the number of goroutines that currently exist.\n"
  {:added "1.0"
   :go "numGoroutine()"}
  [])

JOKER FUNC runtime.ReadMemStats has:
;; (defn ReadMemStats
;;   "ReadMemStats populates m with memory allocator statistics.\n\nThe returned memory allocator statistics are up to date as of the\ncall to ReadMemStats. This is in contrast with a heap profile,\nwhich is a snapshot as of the most recently completed garbage\ncollection cycle.\n"
;;   {:added "1.0"
;;    :go "readMemStats(m)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/mstats.go:457:21) m])

JOKER FUNC runtime.ReadTrace has:
;; (defn ^[ABEND042(cannot find typename runtime.byte)] ReadTrace
;;   "ReadTrace returns the next chunk of binary tracing data, blocking until data\nis available. If tracing is turned off and all the data accumulated while it\nwas on has been returned, ReadTrace returns nil. The caller must copy the\nreturned data before calling ReadTrace again.\nReadTrace must be called from one goroutine at a time.\n"
;;   {:added "1.0"
;;    :go "readTrace()"}
;;   [])

JOKER FUNC runtime.SetBlockProfileRate has:
;; (defn SetBlockProfileRate
;;   "SetBlockProfileRate controls the fraction of goroutine blocking events\nthat are reported in the blocking profile. The profiler aims to sample\nan average of one blocking event per rate nanoseconds spent blocked.\n\nTo include every blocking event in the profile, pass rate = 1.\nTo turn off profiling entirely, pass rate <= 0.\n"
;;   {:added "1.0"
;;    :go "setBlockProfileRate(rate)"}
;;   [^Int rate])

JOKER FUNC runtime.SetCPUProfileRate has:
;; (defn SetCPUProfileRate
;;   "SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\nIf hz <= 0, SetCPUProfileRate turns off profiling.\nIf the profiler is on, the rate cannot be changed without first turning it off.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.cpuprofile flag instead of calling\nSetCPUProfileRate directly.\n"
;;   {:added "1.0"
;;    :go "setCPUProfileRate(hz)"}
;;   [^Int hz])

JOKER FUNC runtime.SetCgoTraceback has:
;; (defn SetCgoTraceback
;;   "SetCgoTraceback records three C functions to use to gather\ntraceback information from C code and to convert that traceback\ninformation into symbolic information. These are used when printing\nstack traces for a program that uses cgo.\n\nThe traceback and context functions may be called from a signal\nhandler, and must therefore use only async-signal safe functions.\nThe symbolizer function may be called while the program is\ncrashing, and so must be cautious about using memory.  None of the\nfunctions may call back into Go.\n\nThe context function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t Context;\n\t};\n\nIf the Context field is 0, the context function is being called to\nrecord the current traceback context. It should record in the\nContext field whatever information is needed about the current\npoint of execution to later produce a stack trace, probably the\nstack pointer and PC. In this case the context function will be\ncalled from C code.\n\nIf the Context field is not 0, then it is a value returned by a\nprevious call to the context function. This case is called when the\ncontext is no longer needed; that is, when the Go code is returning\nto its C code caller. This permits the context function to release\nany associated resources.\n\nWhile it would be correct for the context function to record a\ncomplete a stack trace whenever it is called, and simply copy that\nout in the traceback function, in a typical program the context\nfunction will be called many times without ever recording a\ntraceback for that context. Recording a complete stack trace in a\ncall to the context function is likely to be inefficient.\n\nThe traceback function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext    uintptr\n\t\tSigContext uintptr\n\t\tBuf        *uintptr\n\t\tMax        uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t  Context;\n\t\tuintptr_t  SigContext;\n\t\tuintptr_t* Buf;\n\t\tuintptr_t  Max;\n\t};\n\nThe Context field will be zero to gather a traceback from the\ncurrent program execution point. In this case, the traceback\nfunction will be called from C code.\n\nOtherwise Context will be a value previously returned by a call to\nthe context function. The traceback function should gather a stack\ntrace from that saved point in the program execution. The traceback\nfunction may be called from an execution thread other than the one\nthat recorded the context, but only when the context is known to be\nvalid and unchanging. The traceback function may also be called\ndeeper in the call stack on the same thread that recorded the\ncontext. The traceback function may be called multiple times with\nthe same Context value; it will usually be appropriate to cache the\nresult, if possible, the first time this is called for a specific\ncontext value.\n\nIf the traceback function is called from a signal handler on a Unix\nsystem, SigContext will be the signal context argument passed to\nthe signal handler (a C ucontext_t* cast to uintptr_t). This may be\nused to start tracing at the point where the signal occurred. If\nthe traceback function is not called from a signal handler,\nSigContext will be zero.\n\nBuf is where the traceback information should be stored. It should\nbe PC values, such that Buf[0] is the PC of the caller, Buf[1] is\nthe PC of that function's caller, and so on.  Max is the maximum\nnumber of entries to store.  The function should store a zero to\nindicate the top of the stack, or that the caller is on a different\nstack, presumably a Go stack.\n\nUnlike runtime.Callers, the PC values returned should, when passed\nto the symbolizer function, return the file/line of the call\ninstruction.  No additional subtraction is required or appropriate.\n\nOn all platforms, the traceback function is invoked when a call from\nGo to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,\nand freebsd/amd64, the traceback function is also invoked when a\nsignal is received by a thread that is executing a cgo call. The\ntraceback function should not make assumptions about when it is\ncalled, as future versions of Go may make additional calls.\n\nThe symbolizer function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tPC      uintptr // program counter to fetch information for\n\t\tFile    *byte   // file name (NUL terminated)\n\t\tLineno  uintptr // line number\n\t\tFunc    *byte   // function name (NUL terminated)\n\t\tEntry   uintptr // function entry point\n\t\tMore    uintptr // set non-zero if more info for this PC\n\t\tData    uintptr // unused by runtime, available for function\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t PC;\n\t\tchar*     File;\n\t\tuintptr_t Lineno;\n\t\tchar*     Func;\n\t\tuintptr_t Entry;\n\t\tuintptr_t More;\n\t\tuintptr_t Data;\n\t};\n\nThe PC field will be a value returned by a call to the traceback\nfunction.\n\nThe first time the function is called for a particular traceback,\nall the fields except PC will be 0. The function should fill in the\nother fields if possible, setting them to 0/nil if the information\nis not available. The Data field may be used to store any useful\ninformation across calls. The More field should be set to non-zero\nif there is more information for this PC, zero otherwise. If More\nis set non-zero, the function will be called again with the same\nPC, and may return different information (this is intended for use\nwith inlined functions). If More is zero, the function will be\ncalled with the next PC value in the traceback. When the traceback\nis complete, the function will be called once more with PC set to\nzero; this may be used to free any information. Each call will\nleave the fields of the struct set to the same values they had upon\nreturn, except for the PC field when the More field is zero. The\nfunction must not keep a copy of the struct pointer between calls.\n\nWhen calling SetCgoTraceback, the version argument is the version\nnumber of the structs that the functions expect to receive.\nCurrently this must be zero.\n\nThe symbolizer function may be nil, in which case the results of\nthe traceback function will be displayed as numbers. If the\ntraceback function is nil, the symbolizer function will never be\ncalled. The context function may be nil, in which case the\ntraceback function will only be called with the context field set\nto zero.  If the context function is nil, then calls from Go to C\nto Go will not show a traceback for the C portion of the call stack.\n\nSetCgoTraceback should be called only once, ideally from an init function.\n"
;;   {:added "1.0"
;;    :go "setCgoTraceback(version, traceback, context, symbolizer)"}
;;   [^Int version, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66) traceback, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66) context, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66) symbolizer])

JOKER FUNC runtime.SetFinalizer has:
;; (defn SetFinalizer
;;   "SetFinalizer sets the finalizer associated with obj to the provided\nfinalizer function. When the garbage collector finds an unreachable block\nwith an associated finalizer, it clears the association and runs\nfinalizer(obj) in a separate goroutine. This makes obj reachable again,\nbut now without an associated finalizer. Assuming that SetFinalizer\nis not called again, the next time the garbage collector sees\nthat obj is unreachable, it will free obj.\n\nSetFinalizer(obj, nil) clears any finalizer associated with obj.\n\nThe argument obj must be a pointer to an object allocated by calling\nnew, by taking the address of a composite literal, or by taking the\naddress of a local variable.\nThe argument finalizer must be a function that takes a single argument\nto which obj's type can be assigned, and can have arbitrary ignored return\nvalues. If either of these is not true, SetFinalizer may abort the\nprogram.\n\nFinalizers are run in dependency order: if A points at B, both have\nfinalizers, and they are otherwise unreachable, only the finalizer\nfor A runs; once A is freed, the finalizer for B can run.\nIf a cyclic structure includes a block with a finalizer, that\ncycle is not guaranteed to be garbage collected and the finalizer\nis not guaranteed to run, because there is no ordering that\nrespects the dependencies.\n\nThe finalizer is scheduled to run at some arbitrary time after the\nprogram can no longer reach the object to which obj points.\nThere is no guarantee that finalizers will run before a program exits,\nso typically they are useful only for releasing non-memory resources\nassociated with an object during a long-running program.\nFor example, an os.File object could use a finalizer to close the\nassociated operating system file descriptor when a program discards\nan os.File without calling Close, but it would be a mistake\nto depend on a finalizer to flush an in-memory I/O buffer such as a\nbufio.Writer, because the buffer would not be flushed at program exit.\n\nIt is not guaranteed that a finalizer will run if the size of *obj is\nzero bytes.\n\nIt is not guaranteed that a finalizer will run for objects allocated\nin initializers for package-level variables. Such objects may be\nlinker-allocated, not heap-allocated.\n\nA finalizer may run as soon as an object becomes unreachable.\nIn order to use finalizers correctly, the program must ensure that\nthe object is reachable until it is no longer required.\nObjects stored in global variables, or that can be found by tracing\npointers from a global variable, are reachable. For other objects,\npass the object to a call of the KeepAlive function to mark the\nlast point in the function where the object must be reachable.\n\nFor example, if p points to a struct that contains a file descriptor d,\nand p has a finalizer that closes that file descriptor, and if the last\nuse of p in a function is a call to syscall.Write(p.d, buf, size), then\np may be unreachable as soon as the program enters syscall.Write. The\nfinalizer may run at that moment, closing p.d, causing syscall.Write\nto fail because it is writing to a closed file descriptor (or, worse,\nto an entirely different file descriptor opened by a different goroutine).\nTo avoid this problem, call runtime.KeepAlive(p) after the call to\nsyscall.Write.\n\nA single goroutine runs all finalizers for a program, sequentially.\nIf a finalizer must run for a long time, it should do so by starting\na new goroutine.\n"
;;   {:added "1.0"
;;    :go "setFinalizer(obj, finalizer)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:309:23) obj, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:309:46) finalizer])

JOKER FUNC runtime.SetMutexProfileFraction has:
(defn ^Int SetMutexProfileFraction
  "SetMutexProfileFraction controls the fraction of mutex contention events\nthat are reported in the mutex profile. On average 1/rate events are\nreported. The previous rate is returned.\n\nTo turn off profiling entirely, pass rate 0.\nTo just read the current rate, pass rate < 0.\n(For n>1 the details of sampling may change.)\n"
  {:added "1.0"
   :go "setMutexProfileFraction(rate)"}
  [^Int rate])

JOKER FUNC runtime.Stack has:
;; (defn ^Int Stack
;;   "Stack formats a stack trace of the calling goroutine into buf\nand returns the number of bytes written to buf.\nIf all is true, Stack formats stack traces of all other goroutines\ninto buf after the trace for the current goroutine.\n"
;;   {:added "1.0"
;;    :go "stack(buf, all)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:780:16) buf, all])

JOKER FUNC runtime.StartTrace has:
(defn ^Error StartTrace
  "StartTrace enables tracing for the current process.\nWhile tracing, the data will be buffered and available via ReadTrace.\nStartTrace returns an error if tracing is already enabled.\nMost clients should use the runtime/trace package or the testing package's\n-test.trace flag instead of calling StartTrace directly.\n"
  {:added "1.0"
   :go "startTrace()"}
  [])

JOKER FUNC runtime.StopTrace has:
;; (defn StopTrace
;;   "StopTrace stops tracing, if it was previously enabled.\nStopTrace only returns after all the reads for the trace have completed.\n"
;;   {:added "1.0"
;;    :go "stopTrace()"}
;;   [])

JOKER FUNC runtime.ThreadCreateProfile has:
;; (defn ^[n ok] ThreadCreateProfile
;;   "ThreadCreateProfile returns n, the number of records in the thread creation profile.\nIf len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true.\nIf len(p) < n, ThreadCreateProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling ThreadCreateProfile directly.\n"
;;   {:added "1.0"
;;    :go "threadCreateProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/runtime/mprof.go:698:28) p])

JOKER FUNC runtime.UnlockOSThread has:
;; (defn UnlockOSThread
;;   "UnlockOSThread undoes an earlier call to LockOSThread.\nIf this drops the number of active LockOSThread calls on the\ncalling goroutine to zero, it unwires the calling goroutine from\nits fixed operating system thread.\nIf there are no active LockOSThread calls, this is a no-op.\n\nBefore calling UnlockOSThread, the caller must ensure that the OS\nthread is suitable for running other goroutines. If the caller made\nany permanent changes to the state of the thread that would affect\nother goroutines, it should not call this function and thus leave\nthe goroutine locked to the OS thread until the goroutine (and\nhence the thread) exits.\n"
;;   {:added "1.0"
;;    :go "unlockOSThread()"}
;;   [])

JOKER FUNC runtime.Version has:
(defn ^String Version
  "Version returns the Go tree's version string.\nIt is either the commit hash and date at the time of the build or,\nwhen possible, a release tag like \"go1.3\".\n"
  {:added "1.0"
   :go "version()"}
  [])

JOKER FUNC runtime._ExternalCode has:
;; (defn _ExternalCode
;;   {:added "1.0"
;;    :go "_ExternalCode()"}
;;   [])

JOKER FUNC runtime._GC has:
;; (defn _GC
;;   {:added "1.0"
;;    :go "_GC()"}
;;   [])

JOKER FUNC runtime._LostExternalCode has:
;; (defn _LostExternalCode
;;   {:added "1.0"
;;    :go "_LostExternalCode()"}
;;   [])

JOKER FUNC runtime._LostSIGPROFDuringAtomic64 has:
;; (defn _LostSIGPROFDuringAtomic64
;;   {:added "1.0"
;;    :go "_LostSIGPROFDuringAtomic64()"}
;;   [])

JOKER FUNC runtime._System has:
;; (defn _System
;;   {:added "1.0"
;;    :go "_System()"}
;;   [])

JOKER FUNC runtime._VDSO has:
;; (defn _VDSO
;;   {:added "1.0"
;;    :go "_VDSO()"}
;;   [])

JOKER FUNC runtime._cgo_panic_internal has:
;; (defn _cgo_panic_internal
;;   {:added "1.0"
;;    :go "_cgo_panic_internal(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/cgocallback.go:11:28) p])

JOKER FUNC scanner.PrintError has:
;; (defn PrintError
;;   "PrintError is a utility function that prints a list of errors to w,\none error per line, if the err parameter is an ErrorList. Otherwise\nit prints the err string.\n"
;;   {:added "1.0"
;;    :go "printError(w, err)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/scanner/errors.go:116:19) w, err])

JOKER FUNC scanner.TokenString has:
(defn ^String TokenString
  "TokenString returns a printable string for a token or Unicode character.\n"
  {:added "1.0"
   :go "tokenString(tok)"}
  [tok])

JOKER FUNC sha1.New has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha1/sha1.go:120:12) New
;;   "New returns a new hash.Hash computing the SHA1 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC sha1.Sum has:
;; (defn ^[ABEND042(cannot find typename sha1.byte)] Sum
;;   "Sum returns the SHA-1 checksum of the data.\n"
;;   {:added "1.0"
;;    :go "sum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha1/sha1.go:260:15) data])

JOKER FUNC sha256.New has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha256/sha256.go:180:12) New
;;   "New returns a new hash.Hash computing the SHA256 checksum. The Hash\nalso implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC sha256.New224 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha256/sha256.go:187:15) New224
;;   "New224 returns a new hash.Hash computing the SHA224 checksum.\n"
;;   {:added "1.0"
;;    :go "new224()"}
;;   [])

JOKER FUNC sha256.Sum224 has:
;; (defn ^sum224 Sum224
;;   "Sum224 returns the SHA224 checksum of the data.\n"
;;   {:added "1.0"
;;    :go "sum224(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha256/sha256.go:281:18) data])

JOKER FUNC sha256.Sum256 has:
;; (defn ^[ABEND042(cannot find typename sha256.byte)] Sum256
;;   "Sum256 returns the SHA256 checksum of the data.\n"
;;   {:added "1.0"
;;    :go "sum256(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha256/sha256.go:273:18) data])

JOKER FUNC sha512.New has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha512/sha512.go:224:12) New
;;   "New returns a new hash.Hash computing the SHA-512 checksum.\n"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC sha512.New384 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha512/sha512.go:245:15) New384
;;   "New384 returns a new hash.Hash computing the SHA-384 checksum.\n"
;;   {:added "1.0"
;;    :go "new384()"}
;;   [])

JOKER FUNC sha512.New512_224 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha512/sha512.go:231:19) New512_224
;;   "New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.\n"
;;   {:added "1.0"
;;    :go "new512_224()"}
;;   [])

JOKER FUNC sha512.New512_256 has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/sha512/sha512.go:238:19) New512_256
;;   "New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.\n"
;;   {:added "1.0"
;;    :go "new512_256()"}
;;   [])

JOKER FUNC sha512.Sum384 has:
;; (defn ^sum384 Sum384
;;   "Sum384 returns the SHA384 checksum of the data.\n"
;;   {:added "1.0"
;;    :go "sum384(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:351:18) data])

JOKER FUNC sha512.Sum512 has:
;; (defn ^[ABEND042(cannot find typename sha512.byte)] Sum512
;;   "Sum512 returns the SHA512 checksum of the data.\n"
;;   {:added "1.0"
;;    :go "sum512(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:343:18) data])

JOKER FUNC sha512.Sum512_224 has:
;; (defn ^sum224 Sum512_224
;;   "Sum512_224 returns the Sum512/224 checksum of the data.\n"
;;   {:added "1.0"
;;    :go "sum512_224(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:361:22) data])

JOKER FUNC sha512.Sum512_256 has:
;; (defn ^sum256 Sum512_256
;;   "Sum512_256 returns the Sum512/256 checksum of the data.\n"
;;   {:added "1.0"
;;    :go "sum512_256(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/sha512/sha512.go:371:22) data])

JOKER FUNC signal.Ignore has:
;; (defn Ignore
;;   "Ignore causes the provided signals to be ignored. If they are received by\nthe program, nothing will happen. Ignore undoes the effect of any prior\ncalls to Notify for the provided signals.\nIf no signals are provided, all incoming signals will be ignored.\n"
;;   {:added "1.0"
;;    :go "ignore(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:85:17) sig])

JOKER FUNC signal.Ignored has:
;; (defn ^ABEND042(cannot find typename signal.bool) Ignored
;;   "Ignored reports whether sig is currently ignored.\n"
;;   {:added "1.0"
;;    :go "ignored(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/os/signal/signal.go:90:18) sig])

JOKER FUNC signal.Notify has:
;; (defn Notify
;;   "Notify causes package signal to relay incoming signals to c.\nIf no signals are provided, all incoming signals will be relayed to c.\nOtherwise, just the provided signals will.\n\nPackage signal will not block sending to c: the caller must ensure\nthat c has sufficient buffer space to keep up with the expected\nsignal rate. For a channel used for notification of just one signal value,\na buffer of size 1 is sufficient.\n\nIt is allowed to call Notify multiple times with the same channel:\neach call expands the set of signals sent to that channel.\nThe only way to remove signals from the set is to call Stop.\n\nIt is allowed to call Notify multiple times with different channels\nand the same signals: each channel receives copies of incoming\nsignals independently.\n"
;;   {:added "1.0"
;;    :go "notify(c, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/signal/signal.go:111:15) c, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:111:37) sig])

JOKER FUNC signal.Reset has:
;; (defn Reset
;;   "Reset undoes the effect of any prior calls to Notify for the provided\nsignals.\nIf no signals are provided, all signal handlers will be reset.\n"
;;   {:added "1.0"
;;    :go "reset(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:155:16) sig])

JOKER FUNC signal.Stop has:
;; (defn Stop
;;   "Stop causes package signal to stop relaying incoming signals to c.\nIt undoes the effect of all prior calls to Notify using c.\nWhen Stop returns, it is guaranteed that c will receive no more signals.\n"
;;   {:added "1.0"
;;    :go "stop(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/signal/signal.go:162:13) c])

JOKER FUNC smtp.CRAMMD5Auth has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/smtp/auth.go:15:11) CRAMMD5Auth
;;   "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n"
;;   {:added "1.0"
;;    :go "cRAMMD5Auth(username, secret)"}
;;   [^String username, ^String secret])

JOKER FUNC smtp.Dial has:
;; (defn ^[{:text ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/smtp/smtp.go:33:7) Text, :conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/smtp/smtp.go:36:7) conn, :tls tls, :servername ^String serverName, :ext ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/smtp/smtp.go:41:6) ext, :auth ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/smtp/smtp.go:43:13) auth, :localname ^String localName, :didhello didHello, :helloerror helloError} Error] Dial
;;   "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n"
;;   {:added "1.0"
;;    :go "dial(addr)"}
;;   [^String addr])

JOKER FUNC smtp.NewClient has:
;; (defn ^[{:text ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/smtp/smtp.go:33:7) Text, :conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/smtp/smtp.go:36:7) conn, :tls tls, :servername ^String serverName, :ext ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/net/smtp/smtp.go:41:6) ext, :auth ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/smtp/smtp.go:43:13) auth, :localname ^String localName, :didhello didHello, :helloerror helloError} Error] NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n"
;;   {:added "1.0"
;;    :go "newClient(conn, host)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/smtp/smtp.go:62:21) conn, ^String host])

JOKER FUNC smtp.PlainAuth has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/net/smtp/auth.go:15:11) PlainAuth
;;   "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n"
;;   {:added "1.0"
;;    :go "plainAuth(identity, username, password, host)"}
;;   [^String identity, ^String username, ^String password, ^String host])

JOKER FUNC smtp.SendMail has:
;; (defn ^Error SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n"
;;   {:added "1.0"
;;    :go "sendMail(addr, a, from, to, msg)"}
;;   [^String addr, a, ^String from, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/smtp/smtp.go:319:52) to, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/smtp/smtp.go:319:66) msg])

JOKER FUNC sort.Float64s has:
;; (defn Float64s
;;   "Float64s sorts a slice of float64s in increasing order\n(not-a-number values are treated as less than other values).\n"
;;   {:added "1.0"
;;    :go "float64s(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:311:17) a])

JOKER FUNC sort.Float64sAreSorted has:
;; (defn ^ABEND042(cannot find typename sort.bool) Float64sAreSorted
;;   "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order\n(not-a-number values are treated as less than other values).\n"
;;   {:added "1.0"
;;    :go "float64sAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:321:26) a])

JOKER FUNC sort.Ints has:
;; (defn Ints
;;   "Ints sorts a slice of ints in increasing order.\n"
;;   {:added "1.0"
;;    :go "ints(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:307:13) a])

JOKER FUNC sort.IntsAreSorted has:
;; (defn ^ABEND042(cannot find typename sort.bool) IntsAreSorted
;;   "IntsAreSorted tests whether a slice of ints is sorted in increasing order.\n"
;;   {:added "1.0"
;;    :go "intsAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:317:22) a])

JOKER FUNC sort.IsSorted has:
;; (defn ^ABEND042(cannot find typename sort.bool) IsSorted
;;   "IsSorted reports whether data is sorted.\n"
;;   {:added "1.0"
;;    :go "isSorted(data)"}
;;   [data])

JOKER FUNC sort.Reverse has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/sort.go:14:16) Reverse
;;   "Reverse returns the reverse order for data.\n"
;;   {:added "1.0"
;;    :go "reverse(data)"}
;;   [data])

JOKER FUNC sort.Search has:
;; (defn ^Int Search
;;   "Search uses binary search to find and return the smallest index i\nin [0, n) at which f(i) is true, assuming that on the range [0, n),\nf(i) == true implies f(i+1) == true. That is, Search requires that\nf is false for some (possibly empty) prefix of the input range [0, n)\nand then true for the (possibly empty) remainder; Search returns\nthe first true index. If there is no such index, Search returns n.\n(Note that the \"not found\" return value is not -1 as in, for instance,\nstrings.Index.)\nSearch calls f(i) only for i in the range [0, n).\n\nA common use of Search is to find the index i for a value x in\na sorted, indexable data structure such as an array or slice.\nIn this case, the argument f, typically a closure, captures the value\nto be searched for, and how the data structure is indexed and\nordered.\n\nFor instance, given a slice data sorted in ascending order,\nthe call Search(len(data), func(i int) bool { return data[i] >= 23 })\nreturns the smallest index i such that data[i] >= 23. If the caller\nwants to find whether 23 is in the slice, it must test data[i] == 23\nseparately.\n\nSearching data sorted in descending order would use the <=\noperator instead of the >= operator.\n\nTo complete the example above, the following code tries to find the value\nx in an integer slice data sorted in ascending order:\n\n\tx := 23\n\ti := sort.Search(len(data), func(i int) bool { return data[i] >= x })\n\tif i < len(data) && data[i] == x {\n\t\t// x is present at data[i]\n\t} else {\n\t\t// x is not present in data,\n\t\t// but i is the index where it would be inserted.\n\t}\n\nAs a more whimsical example, this program guesses your number:\n\n\tfunc GuessingGame() {\n\t\tvar s string\n\t\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\t\tanswer := sort.Search(100, func(i int) bool {\n\t\t\tfmt.Printf(\"Is your number <= %d? \", i)\n\t\t\tfmt.Scanf(\"%s\", &s)\n\t\t\treturn s != \"\" && s[0] == 'y'\n\t\t})\n\t\tfmt.Printf(\"Your number is %d.\\n\", answer)\n\t}\n"
;;   {:added "1.0"
;;    :go "search(n, f)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/search.go:59:22) f])

JOKER FUNC sort.SearchFloat64s has:
;; (defn ^Int SearchFloat64s
;;   "SearchFloat64s searches for x in a sorted slice of float64s and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n"
;;   {:added "1.0"
;;    :go "searchFloat64s(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/search.go:92:23) a, x])

JOKER FUNC sort.SearchInts has:
;; (defn ^Int SearchInts
;;   "SearchInts searches for x in a sorted slice of ints and returns the index\nas specified by Search. The return value is the index to insert x if x is\nnot present (it could be len(a)).\nThe slice must be sorted in ascending order.\n"
;;   {:added "1.0"
;;    :go "searchInts(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/search.go:83:19) a, ^Int x])

JOKER FUNC sort.SearchStrings has:
;; (defn ^Int SearchStrings
;;   "SearchStrings searches for x in a sorted slice of strings and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n"
;;   {:added "1.0"
;;    :go "searchStrings(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/search.go:101:22) a, ^String x])

JOKER FUNC sort.Slice has:
;; (defn Slice
;;   "Slice sorts the provided slice given the provided less function.\n\nThe sort is not guaranteed to be stable. For a stable sort, use\nSliceStable.\n\nThe function panics if the provided interface is not a slice.\n"
;;   {:added "1.0"
;;    :go "slice(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/slice.go:17:18) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/slice.go:17:36) less])

JOKER FUNC sort.SliceIsSorted has:
;; (defn ^ABEND042(cannot find typename sort.bool) SliceIsSorted
;;   "SliceIsSorted tests whether a slice is sorted.\n\nThe function panics if the provided interface is not a slice.\n"
;;   {:added "1.0"
;;    :go "sliceIsSorted(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/slice.go:37:26) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/slice.go:37:44) less])

JOKER FUNC sort.SliceStable has:
;; (defn SliceStable
;;   "SliceStable sorts the provided slice given the provided less\nfunction while keeping the original order of equal elements.\n\nThe function panics if the provided interface is not a slice.\n"
;;   {:added "1.0"
;;    :go "sliceStable(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/slice.go:28:24) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/slice.go:28:42) less])

JOKER FUNC sort.Sort has:
;; (defn Sort
;;   "Sort sorts data.\nIt makes one call to data.Len to determine n, and O(n*log(n)) calls to\ndata.Less and data.Swap. The sort is not guaranteed to be stable.\n"
;;   {:added "1.0"
;;    :go "sort(data)"}
;;   [data])

JOKER FUNC sort.Stable has:
;; (defn Stable
;;   "Stable sorts data while keeping the original order of equal elements.\n\nIt makes one call to data.Len to determine n, O(n*log(n)) calls to\ndata.Less and O(n*log(n)*log(n)) calls to data.Swap.\n"
;;   {:added "1.0"
;;    :go "stable(data)"}
;;   [data])

JOKER FUNC sort.Strings has:
;; (defn Strings
;;   "Strings sorts a slice of strings in increasing order.\n"
;;   {:added "1.0"
;;    :go "strings(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:314:16) a])

JOKER FUNC sort.StringsAreSorted has:
;; (defn ^ABEND042(cannot find typename sort.bool) StringsAreSorted
;;   "StringsAreSorted tests whether a slice of strings is sorted in increasing order.\n"
;;   {:added "1.0"
;;    :go "stringsAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:324:25) a])

JOKER FUNC sql.Drivers has:
(defn ^[String] Drivers
  "Drivers returns a sorted list of the names of the registered drivers.\n"
  {:added "1.0"
   :go "drivers()"}
  [])

JOKER FUNC sql.Named has:
;; (defn ^{:_named_fields_required ^ABEND881(unrecognized Expr type *ast.StructType at: ../GOSRC/database/sql/sql.go:82:25) _Named_Fields_Required, :name ^String Name, :value ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/database/sql/sql.go:95:8) Value} Named
;;   "Named provides a more concise way to create NamedArg values.\n\nExample usage:\n\n    db.ExecContext(ctx, `\n        delete from Invoice\n        where\n            TimeCreated < @end\n            and TimeCreated >= @start;`,\n        sql.Named(\"start\", startTime),\n        sql.Named(\"end\", endTime),\n    )\n"
;;   {:added "1.0"
;;    :go "named(name, value)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/database/sql/sql.go:110:31) value])

JOKER FUNC sql.Open has:
;; (defn ^[{:waitduration waitDuration, :connector ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:354:12) connector, :numclosed numClosed, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:360:15) mu, :freeconn ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/database/sql/sql.go:361:15) freeConn, :connrequests ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:362:15) connRequests, :nextrequest nextRequest, :numopen ^Int numOpen, :openerch ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:370:20) openerCh, :resetterch ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:371:20) resetterCh, :closed closed, :dep ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:373:20) dep, :lastput ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:374:20) lastPut, :maxidle ^Int maxIdle, :maxopen ^Int maxOpen, :maxlifetime ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:377:20) maxLifetime, :cleanerch ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:378:20) cleanerCh, :waitcount waitCount, :maxidleclosed maxIdleClosed, :maxlifetimeclosed maxLifetimeClosed, :stop ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/database/sql/sql.go:383:7) stop} Error] Open
;;   "Open opens a database specified by its database driver name and a\ndriver-specific data source name, usually consisting of at least a\ndatabase name and connection information.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpen may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the Open\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n"
;;   {:added "1.0"
;;    :go "open(driverName, dataSourceName)"}
;;   [^String driverName, ^String dataSourceName])

JOKER FUNC sql.OpenDB has:
;; (defn ^{:waitduration waitDuration, :connector ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:354:12) connector, :numclosed numClosed, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:360:15) mu, :freeconn ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/database/sql/sql.go:361:15) freeConn, :connrequests ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:362:15) connRequests, :nextrequest nextRequest, :numopen ^Int numOpen, :openerch ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:370:20) openerCh, :resetterch ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:371:20) resetterCh, :closed closed, :dep ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:373:20) dep, :lastput ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/database/sql/sql.go:374:20) lastPut, :maxidle ^Int maxIdle, :maxopen ^Int maxOpen, :maxlifetime ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:377:20) maxLifetime, :cleanerch ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/database/sql/sql.go:378:20) cleanerCh, :waitcount waitCount, :maxidleclosed maxIdleClosed, :maxlifetimeclosed maxLifetimeClosed, :stop ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/database/sql/sql.go:383:7) stop} OpenDB
;;   "OpenDB opens a database using a Connector, allowing drivers to\nbypass a string based data source name.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpenDB may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the OpenDB\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n"
;;   {:added "1.0"
;;    :go "openDB(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:660:15) c])

JOKER FUNC sql.Register has:
;; (defn Register
;;   "Register makes a database driver available by the provided name.\nIf Register is called twice with the same name or if driver is nil,\nit panics.\n"
;;   {:added "1.0"
;;    :go "register(name, driver)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:44:35) driver])

JOKER FUNC strconv.AppendBool has:
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendBool
;;   "AppendBool appends \"true\" or \"false\", according to the value of b,\nto dst and returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendBool(dst, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/atob.go:30:21) dst, b])

JOKER FUNC strconv.AppendFloat has:
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendFloat
;;   "AppendFloat appends the string form of the floating-point number f,\nas generated by FormatFloat, to dst and returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendFloat(dst, f, fmt, prec, bitSize)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/ftoa.go:51:22) dst, f, fmt, ^Int prec, ^Int bitSize])

JOKER FUNC strconv.AppendInt has:
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendInt
;;   "AppendInt appends the string form of the integer i,\nas generated by FormatInt, to dst and returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendInt(dst, i, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/itoa.go:40:20) dst, i, ^Int base])

JOKER FUNC strconv.AppendQuote has:
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuote
;;   "AppendQuote appends a double-quoted Go string literal representing s,\nas generated by Quote, to dst and returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendQuote(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:117:22) dst, ^String s])

JOKER FUNC strconv.AppendQuoteRune has:
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuoteRune
;;   "AppendQuoteRune appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRune, to dst and returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendQuoteRune(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:156:26) dst, r])

JOKER FUNC strconv.AppendQuoteRuneToASCII has:
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuoteRuneToASCII
;;   "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToASCII, to dst and returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendQuoteRuneToASCII(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:170:33) dst, r])

JOKER FUNC strconv.AppendQuoteRuneToGraphic has:
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuoteRuneToGraphic
;;   "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToGraphic, to dst and returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendQuoteRuneToGraphic(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:184:35) dst, r])

JOKER FUNC strconv.AppendQuoteToASCII has:
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuoteToASCII
;;   "AppendQuoteToASCII appends a double-quoted Go string literal representing s,\nas generated by QuoteToASCII, to dst and returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendQuoteToASCII(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:130:29) dst, ^String s])

JOKER FUNC strconv.AppendQuoteToGraphic has:
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuoteToGraphic
;;   "AppendQuoteToGraphic appends a double-quoted Go string literal representing s,\nas generated by QuoteToGraphic, to dst and returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendQuoteToGraphic(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/quote.go:143:31) dst, ^String s])

JOKER FUNC strconv.AppendUint has:
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendUint
;;   "AppendUint appends the string form of the unsigned integer i,\nas generated by FormatUint, to dst and returns the extended buffer.\n"
;;   {:added "1.0"
;;    :go "appendUint(dst, i, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strconv/itoa.go:50:21) dst, i, ^Int base])

JOKER FUNC strconv.Atoi has:
(defn ^[Int Error] Atoi
  "Atoi returns the result of ParseInt(s, 10, 0) converted to type int.\n"
  {:added "1.0"
   :go "atoi(s)"}
  [^String s])

JOKER FUNC strconv.CanBackquote has:
;; (defn ^ABEND042(cannot find typename strconv.bool) CanBackquote
;;   "CanBackquote reports whether the string s can be represented\nunchanged as a single-line backquoted string without control\ncharacters other than tab.\n"
;;   {:added "1.0"
;;    :go "canBackquote(s)"}
;;   [^String s])

JOKER FUNC strconv.FormatBool has:
(defn ^String FormatBool
  "FormatBool returns \"true\" or \"false\" according to the value of b.\n"
  {:added "1.0"
   :go "formatBool(b)"}
  [b])

JOKER FUNC strconv.FormatFloat has:
(defn ^String FormatFloat
  "FormatFloat converts the floating-point number f to a string,\naccording to the format fmt and precision prec. It rounds the\nresult assuming that the original was obtained from a floating-point\nvalue of bitSize bits (32 for float32, 64 for float64).\n\nThe format fmt is one of\n'b' (-ddddpddd, a binary exponent),\n'e' (-d.ddddedd, a decimal exponent),\n'E' (-d.ddddEdd, a decimal exponent),\n'f' (-ddd.dddd, no exponent),\n'g' ('e' for large exponents, 'f' otherwise), or\n'G' ('E' for large exponents, 'f' otherwise).\n\nThe precision prec controls the number of digits (excluding the exponent)\nprinted by the 'e', 'E', 'f', 'g', and 'G' formats.\nFor 'e', 'E', and 'f' it is the number of digits after the decimal point.\nFor 'g' and 'G' it is the maximum number of significant digits (trailing\nzeros are removed).\nThe special precision -1 uses the smallest number of digits\nnecessary such that ParseFloat will return f exactly.\n"
  {:added "1.0"
   :go "formatFloat(f, fmt, prec, bitSize)"}
  [f, fmt, ^Int prec, ^Int bitSize])

JOKER FUNC strconv.FormatInt has:
(defn ^String FormatInt
  "FormatInt returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n"
  {:added "1.0"
   :go "formatInt(i, base)"}
  [i, ^Int base])

JOKER FUNC strconv.FormatUint has:
(defn ^String FormatUint
  "FormatUint returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n"
  {:added "1.0"
   :go "formatUint(i, base)"}
  [i, ^Int base])

JOKER FUNC strconv.IsGraphic has:
;; (defn ^ABEND042(cannot find typename strconv.bool) IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, and Zs.\n"
;;   {:added "1.0"
;;    :go "isGraphic(r)"}
;;   [r])

JOKER FUNC strconv.IsPrint has:
;; (defn ^ABEND042(cannot find typename strconv.bool) IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go, with\nthe same definition as unicode.IsPrint: letters, numbers, punctuation,\nsymbols and ASCII space.\n"
;;   {:added "1.0"
;;    :go "isPrint(r)"}
;;   [r])

JOKER FUNC strconv.Itoa has:
(defn ^String Itoa
  "Itoa is shorthand for FormatInt(int64(i), 10).\n"
  {:added "1.0"
   :go "itoa(i)"}
  [^Int i])

JOKER FUNC strconv.ParseBool has:
;; (defn ^[ABEND042(cannot find typename strconv.bool) Error] ParseBool
;;   "ParseBool returns the boolean value represented by the string.\nIt accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\nAny other value returns an error.\n"
;;   {:added "1.0"
;;    :go "parseBool(str)"}
;;   [^String str])

JOKER FUNC strconv.ParseFloat has:
;; (defn ^[ABEND042(cannot find typename strconv.float64) Error] ParseFloat
;;   "ParseFloat converts the string s to a floating-point number\nwith the precision specified by bitSize: 32 for float32, or 64 for float64.\nWhen bitSize=32, the result still has type float64, but it will be\nconvertible to float32 without changing its value.\n\nIf s is well-formed and near a valid floating point number,\nParseFloat returns the nearest floating point number rounded\nusing IEEE754 unbiased rounding.\n\nThe errors that ParseFloat returns have concrete type *NumError\nand include err.Num = s.\n\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but is more than 1/2 ULP\naway from the largest floating point number of the given size,\nParseFloat returns f = Inf, err.Err = ErrRange.\n"
;;   {:added "1.0"
;;    :go "parseFloat(s, bitSize)"}
;;   [^String s, ^Int bitSize])

JOKER FUNC strconv.ParseInt has:
(defn ^[i err] ParseInt
  "ParseInt interprets a string s in the given base (0, 2 to 36) and\nbit size (0 to 64) and returns the corresponding value i.\n\nIf base == 0, the base is implied by the string's prefix:\nbase 16 for \"0x\", base 8 for \"0\", and base 10 otherwise.\nFor bases 1, below 0 or above 36 an error is returned.\n\nThe bitSize argument specifies the integer type\nthat the result must fit into. Bit sizes 0, 8, 16, 32, and 64\ncorrespond to int, int8, int16, int32, and int64.\nFor a bitSize below 0 or above 64 an error is returned.\n\nThe errors that ParseInt returns have concrete type *NumError\nand include err.Num = s. If s is empty or contains invalid\ndigits, err.Err = ErrSyntax and the returned value is 0;\nif the value corresponding to s cannot be represented by a\nsigned integer of the given size, err.Err = ErrRange and the\nreturned value is the maximum magnitude integer of the\nappropriate bitSize and sign.\n"
  {:added "1.0"
   :go "parseInt(s, base, bitSize)"}
  [^String s, ^Int base, ^Int bitSize])

JOKER FUNC strconv.ParseUint has:
;; (defn ^[ABEND042(cannot find typename strconv.uint64) Error] ParseUint
;;   "ParseUint is like ParseInt but for unsigned numbers.\n"
;;   {:added "1.0"
;;    :go "parseUint(s, base, bitSize)"}
;;   [^String s, ^Int base, ^Int bitSize])

JOKER FUNC strconv.Quote has:
(defn ^String Quote
  "Quote returns a double-quoted Go string literal representing s. The\nreturned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\ncontrol characters and non-printable characters as defined by\nIsPrint.\n"
  {:added "1.0"
   :go "quote(s)"}
  [^String s])

JOKER FUNC strconv.QuoteRune has:
(defn ^String QuoteRune
  "QuoteRune returns a single-quoted Go character literal representing the\nrune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\nfor control characters and non-printable characters as defined by IsPrint.\n"
  {:added "1.0"
   :go "quoteRune(r)"}
  [r])

JOKER FUNC strconv.QuoteRuneToASCII has:
(defn ^String QuoteRuneToASCII
  "QuoteRuneToASCII returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsPrint.\n"
  {:added "1.0"
   :go "quoteRuneToASCII(r)"}
  [r])

JOKER FUNC strconv.QuoteRuneToGraphic has:
(defn ^String QuoteRuneToGraphic
  "QuoteRuneToGraphic returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsGraphic.\n"
  {:added "1.0"
   :go "quoteRuneToGraphic(r)"}
  [r])

JOKER FUNC strconv.QuoteToASCII has:
(defn ^String QuoteToASCII
  "QuoteToASCII returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsPrint.\n"
  {:added "1.0"
   :go "quoteToASCII(s)"}
  [^String s])

JOKER FUNC strconv.QuoteToGraphic has:
(defn ^String QuoteToGraphic
  "QuoteToGraphic returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsGraphic.\n"
  {:added "1.0"
   :go "quoteToGraphic(s)"}
  [^String s])

JOKER FUNC strconv.Unquote has:
(defn ^[String Error] Unquote
  "Unquote interprets s as a single-quoted, double-quoted,\nor backquoted Go string literal, returning the string value\nthat s quotes.  (If s is single-quoted, it would be a Go\ncharacter literal; Unquote returns the corresponding\none-character string.)\n"
  {:added "1.0"
   :go "unquote(s)"}
  [^String s])

JOKER FUNC strconv.UnquoteChar has:
(defn ^[value multibyte tail err] UnquoteChar
  "UnquoteChar decodes the first character or byte in the escaped string\nor character literal represented by the string s.\nIt returns four values:\n\n\t1) value, the decoded Unicode code point or byte value;\n\t2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n\t3) tail, the remainder of the string after the character; and\n\t4) an error that will be nil if the character is syntactically valid.\n\nThe second argument, quote, specifies the type of literal being parsed\nand therefore which escaped quote character is permitted.\nIf set to a single quote, it permits the sequence \\' and disallows unescaped '.\nIf set to a double quote, it permits \\\" and disallows unescaped \".\nIf set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\n"
  {:added "1.0"
   :go "unquoteChar(s, quote)"}
  [^String s, quote])

JOKER FUNC strings.Compare has:
(defn ^Int Compare
  "Compare returns an integer comparing two strings lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n\nCompare is included only for symmetry with package bytes.\nIt is usually clearer and always faster to use the built-in\nstring comparison operators ==, <, >, and so on.\n"
  {:added "1.0"
   :go "compare(a, b)"}
  [^String a, ^String b])

JOKER FUNC strings.Contains has:
;; (defn ^ABEND042(cannot find typename strings.bool) Contains
;;   "Contains reports whether substr is within s.\n"
;;   {:added "1.0"
;;    :go "contains(s, substr)"}
;;   [^String s, ^String substr])

JOKER FUNC strings.ContainsAny has:
;; (defn ^ABEND042(cannot find typename strings.bool) ContainsAny
;;   "ContainsAny reports whether any Unicode code points in chars are within s.\n"
;;   {:added "1.0"
;;    :go "containsAny(s, chars)"}
;;   [^String s, ^String chars])

JOKER FUNC strings.ContainsRune has:
;; (defn ^ABEND042(cannot find typename strings.bool) ContainsRune
;;   "ContainsRune reports whether the Unicode code point r is within s.\n"
;;   {:added "1.0"
;;    :go "containsRune(s, r)"}
;;   [^String s, r])

JOKER FUNC strings.Count has:
(defn ^Int Count
  "Count counts the number of non-overlapping instances of substr in s.\nIf substr is an empty string, Count returns 1 + the number of Unicode code points in s.\n"
  {:added "1.0"
   :go "count(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.EqualFold has:
;; (defn ^ABEND042(cannot find typename strings.bool) EqualFold
;;   "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n"
;;   {:added "1.0"
;;    :go "equalFold(s, t)"}
;;   [^String s, ^String t])

JOKER FUNC strings.Fields has:
(defn ^[String] Fields
  "Fields splits the string s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of substrings of s or an\nempty slice if s contains only white space.\n"
  {:added "1.0"
   :go "fields(s)"}
  [^String s])

JOKER FUNC strings.FieldsFunc has:
;; (defn ^[String] FieldsFunc
;;   "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\nand returns an array of slices of s. If all code points in s satisfy f(c) or the\nstring is empty, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n"
;;   {:added "1.0"
;;    :go "fieldsFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:378:29) f])

JOKER FUNC strings.HasPrefix has:
;; (defn ^ABEND042(cannot find typename strings.bool) HasPrefix
;;   "HasPrefix tests whether the string s begins with prefix.\n"
;;   {:added "1.0"
;;    :go "hasPrefix(s, prefix)"}
;;   [^String s, ^String prefix])

JOKER FUNC strings.HasSuffix has:
;; (defn ^ABEND042(cannot find typename strings.bool) HasSuffix
;;   "HasSuffix tests whether the string s ends with suffix.\n"
;;   {:added "1.0"
;;    :go "hasSuffix(s, suffix)"}
;;   [^String s, ^String suffix])

JOKER FUNC strings.Index has:
(defn ^Int Index
  "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.\n"
  {:added "1.0"
   :go "index(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.IndexAny has:
(defn ^Int IndexAny
  "IndexAny returns the index of the first instance of any Unicode code point\nfrom chars in s, or -1 if no Unicode code point from chars is present in s.\n"
  {:added "1.0"
   :go "indexAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.IndexByte has:
(defn ^Int IndexByte
  "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\n"
  {:added "1.0"
   :go "indexByte(s, c)"}
  [^String s, c])

JOKER FUNC strings.IndexFunc has:
;; (defn ^Int IndexFunc
;;   "IndexFunc returns the index into s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n"
;;   {:added "1.0"
;;    :go "indexFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:713:28) f])

JOKER FUNC strings.IndexRune has:
(defn ^Int IndexRune
  "IndexRune returns the index of the first instance of the Unicode code point\nr, or -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n"
  {:added "1.0"
   :go "indexRune(s, r)"}
  [^String s, r])

JOKER FUNC strings.Join has:
;; (defn ^String Join
;;   "Join concatenates the elements of a to create a single string. The separator string\nsep is placed between elements in the resulting string.\n"
;;   {:added "1.0"
;;    :go "join(a, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/strings/strings.go:420:13) a, ^String sep])

JOKER FUNC strings.LastIndex has:
(defn ^Int LastIndex
  "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.\n"
  {:added "1.0"
   :go "lastIndex(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.LastIndexAny has:
(defn ^Int LastIndexAny
  "LastIndexAny returns the index of the last instance of any Unicode code\npoint from chars in s, or -1 if no Unicode code point from chars is\npresent in s.\n"
  {:added "1.0"
   :go "lastIndexAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.LastIndexByte has:
(defn ^Int LastIndexByte
  "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n"
  {:added "1.0"
   :go "lastIndexByte(s, c)"}
  [^String s, c])

JOKER FUNC strings.LastIndexFunc has:
;; (defn ^Int LastIndexFunc
;;   "LastIndexFunc returns the index into s of the last\nUnicode code point satisfying f(c), or -1 if none do.\n"
;;   {:added "1.0"
;;    :go "lastIndexFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:719:32) f])

JOKER FUNC strings.Map has:
;; (defn ^String Map
;;   "Map returns a copy of the string s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the string with no replacement.\n"
;;   {:added "1.0"
;;    :go "map(mapping, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:462:18) mapping, ^String s])

JOKER FUNC strings.NewReader has:
(defn ^{:s ^String s, :i i, :prevrune ^Int prevRune} NewReader
  "NewReader returns a new Reader reading from s.\nIt is similar to bytes.NewBufferString but more efficient and read-only.\n"
  {:added "1.0"
   :go "newReader(s)"}
  [^String s])

JOKER FUNC strings.NewReplacer has:
;; (defn ^{:r r} NewReplacer
;;   "NewReplacer returns a new Replacer from a list of old, new string\npairs. Replacements are performed in the order they appear in the\ntarget string, without overlapping matches.\n"
;;   {:added "1.0"
;;    :go "newReplacer(oldnew)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/strings/replace.go:24:25) oldnew])

JOKER FUNC strings.Repeat has:
(defn ^String Repeat
  "Repeat returns a new string consisting of count copies of the string s.\n\nIt panics if count is negative or if\nthe result of (len(s) * count) overflows.\n"
  {:added "1.0"
   :go "repeat(s, count)"}
  [^String s, ^Int count])

JOKER FUNC strings.Replace has:
(defn ^String Replace
  "Replace returns a copy of the string s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the string\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune string.\nIf n < 0, there is no limit on the number of replacements.\n"
  {:added "1.0"
   :go "replace(s, old, new, n)"}
  [^String s, ^String old, ^String new, ^Int n])

JOKER FUNC strings.Split has:
(defn ^[String] Split
  "Split slices s into all substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nIf s does not contain sep and sep is not empty, Split returns a\nslice of length 1 whose only element is s.\n\nIf sep is empty, Split splits after each UTF-8 sequence. If both s\nand sep are empty, Split returns an empty slice.\n\nIt is equivalent to SplitN with a count of -1.\n"
  {:added "1.0"
   :go "split(s, sep)"}
  [^String s, ^String sep])

JOKER FUNC strings.SplitAfter has:
(defn ^[String] SplitAfter
  "SplitAfter slices s into all substrings after each instance of sep and\nreturns a slice of those substrings.\n\nIf s does not contain sep and sep is not empty, SplitAfter returns\na slice of length 1 whose only element is s.\n\nIf sep is empty, SplitAfter splits after each UTF-8 sequence. If\nboth s and sep are empty, SplitAfter returns an empty slice.\n\nIt is equivalent to SplitAfterN with a count of -1.\n"
  {:added "1.0"
   :go "splitAfter(s, sep)"}
  [^String s, ^String sep])

JOKER FUNC strings.SplitAfterN has:
(defn ^[String] SplitAfterN
  "SplitAfterN slices s into substrings after each instance of sep and\nreturns a slice of those substrings.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for SplitAfter.\n"
  {:added "1.0"
   :go "splitAfterN(s, sep, n)"}
  [^String s, ^String sep, ^Int n])

JOKER FUNC strings.SplitN has:
(defn ^[String] SplitN
  "SplitN slices s into substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for Split.\n"
  {:added "1.0"
   :go "splitN(s, sep, n)"}
  [^String s, ^String sep, ^Int n])

JOKER FUNC strings.Title has:
(defn ^String Title
  "Title returns a copy of the string s with all Unicode letters that begin words\nmapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n"
  {:added "1.0"
   :go "title(s)"}
  [^String s])

JOKER FUNC strings.ToLower has:
(defn ^String ToLower
  "ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.\n"
  {:added "1.0"
   :go "toLower(s)"}
  [^String s])

JOKER FUNC strings.ToLowerSpecial has:
;; (defn ^String ToLowerSpecial
;;   "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n"
;;   {:added "1.0"
;;    :go "toLowerSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/strings/strings.go:626:23) c, ^String s])

JOKER FUNC strings.ToTitle has:
(defn ^String ToTitle
  "ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.\n"
  {:added "1.0"
   :go "toTitle(s)"}
  [^String s])

JOKER FUNC strings.ToTitleSpecial has:
;; (defn ^String ToTitleSpecial
;;   "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n"
;;   {:added "1.0"
;;    :go "toTitleSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/strings/strings.go:632:23) c, ^String s])

JOKER FUNC strings.ToUpper has:
(defn ^String ToUpper
  "ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.\n"
  {:added "1.0"
   :go "toUpper(s)"}
  [^String s])

JOKER FUNC strings.ToUpperSpecial has:
;; (defn ^String ToUpperSpecial
;;   "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n"
;;   {:added "1.0"
;;    :go "toUpperSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/strings/strings.go:620:23) c, ^String s])

JOKER FUNC strings.Trim has:
(defn ^String Trim
  "Trim returns a slice of the string s with all leading and\ntrailing Unicode code points contained in cutset removed.\n"
  {:added "1.0"
   :go "trim(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimFunc has:
;; (defn ^String TrimFunc
;;   "TrimFunc returns a slice of the string s with all leading\nand trailing Unicode code points c satisfying f(c) removed.\n"
;;   {:added "1.0"
;;    :go "trimFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:707:27) f])

JOKER FUNC strings.TrimLeft has:
(defn ^String TrimLeft
  "TrimLeft returns a slice of the string s with all leading\nUnicode code points contained in cutset removed.\n\nTo remove a prefix, use TrimPrefix instead.\n"
  {:added "1.0"
   :go "trimLeft(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimLeftFunc has:
;; (defn ^String TrimLeftFunc
;;   "TrimLeftFunc returns a slice of the string s with all leading\nUnicode code points c satisfying f(c) removed.\n"
;;   {:added "1.0"
;;    :go "trimLeftFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:684:31) f])

JOKER FUNC strings.TrimPrefix has:
(defn ^String TrimPrefix
  "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n"
  {:added "1.0"
   :go "trimPrefix(s, prefix)"}
  [^String s, ^String prefix])

JOKER FUNC strings.TrimRight has:
(defn ^String TrimRight
  "TrimRight returns a slice of the string s, with all trailing\nUnicode code points contained in cutset removed.\n\nTo remove a suffix, use TrimSuffix instead.\n"
  {:added "1.0"
   :go "trimRight(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimRightFunc has:
;; (defn ^String TrimRightFunc
;;   "TrimRightFunc returns a slice of the string s with all trailing\nUnicode code points c satisfying f(c) removed.\n"
;;   {:added "1.0"
;;    :go "trimRightFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/strings/strings.go:694:32) f])

JOKER FUNC strings.TrimSpace has:
(defn ^String TrimSpace
  "TrimSpace returns a slice of the string s, with all leading\nand trailing white space removed, as defined by Unicode.\n"
  {:added "1.0"
   :go "trimSpace(s)"}
  [^String s])

JOKER FUNC strings.TrimSuffix has:
(defn ^String TrimSuffix
  "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n"
  {:added "1.0"
   :go "trimSuffix(s, suffix)"}
  [^String s, ^String suffix])

JOKER FUNC subtle.ConstantTimeByteEq has:
(defn ^Int ConstantTimeByteEq
  "ConstantTimeByteEq returns 1 if x == y and 0 otherwise.\n"
  {:added "1.0"
   :go "constantTimeByteEq(x, y)"}
  [x, y])

JOKER FUNC subtle.ConstantTimeCompare has:
;; (defn ^Int ConstantTimeCompare
;;   "ConstantTimeCompare returns 1 if and only if the two slices, x\nand y, have equal contents. The time taken is a function of the length of\nthe slices and is independent of the contents.\n"
;;   {:added "1.0"
;;    :go "constantTimeCompare(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:12:31) x, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:12:31) y])

JOKER FUNC subtle.ConstantTimeCopy has:
;; (defn ConstantTimeCopy
;;   "ConstantTimeCopy copies the contents of y into x (a slice of equal length)\nif v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v\ntakes any other value.\n"
;;   {:added "1.0"
;;    :go "constantTimeCopy(v, x, y)"}
;;   [^Int v, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:43:35) x, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:43:35) y])

JOKER FUNC subtle.ConstantTimeEq has:
(defn ^Int ConstantTimeEq
  "ConstantTimeEq returns 1 if x == y and 0 otherwise.\n"
  {:added "1.0"
   :go "constantTimeEq(x, y)"}
  [x, y])

JOKER FUNC subtle.ConstantTimeLessOrEq has:
(defn ^Int ConstantTimeLessOrEq
  "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise.\nIts behavior is undefined if x or y are negative or > 2**31 - 1.\n"
  {:added "1.0"
   :go "constantTimeLessOrEq(x, y)"}
  [^Int x, ^Int y])

JOKER FUNC subtle.ConstantTimeSelect has:
(defn ^Int ConstantTimeSelect
  "ConstantTimeSelect returns x if v is 1 and y if v is 0.\nIts behavior is undefined if v takes any other value.\n"
  {:added "1.0"
   :go "constantTimeSelect(v, x, y)"}
  [^Int v, ^Int x, ^Int y])

JOKER FUNC suffixarray.New has:
;; (defn ^{:data ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/index/suffixarray/suffixarray.go:29:7) data, :sa ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/index/suffixarray/suffixarray.go:30:7) sa} New
;;   "New creates a new Index for data.\nIndex creation time is O(N*log(N)) for N = len(data).\n"
;;   {:added "1.0"
;;    :go "new(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/index/suffixarray/suffixarray.go:35:15) data])

JOKER FUNC sync.NewCond has:
(defn ^{:nocopy noCopy, :l L, :notify notify, :checker checker} NewCond
  "NewCond returns a new Cond with Locker l.\n"
  {:added "1.0"
   :go "newCond(l)"}
  [l])

JOKER FUNC syntax.Compile has:
;; (defn ^[{:inst ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/syntax/prog.go:18:9) Inst, :start ^Int Start, :numcap ^Int NumCap} Error] Compile
;;   "Compile compiles the regexp into a program to be executed.\nThe regexp should have been simplified already (returned from re.Simplify).\n"
;;   {:added "1.0"
;;    :go "compile(re)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/regexp/syntax/compile.go:80:17) re])

JOKER FUNC syntax.EmptyOpContext has:
;; (defn ^ABEND042(cannot find typename syntax.uint8) EmptyOpContext
;;   "EmptyOpContext returns the zero-width assertions\nsatisfied at the position between the runes r1 and r2.\nPassing r1 == -1 indicates that the position is\nat the beginning of the text.\nPassing r2 == -1 indicates that the position is\nat the end of the text.\n"
;;   {:added "1.0"
;;    :go "emptyOpContext(r1, r2)"}
;;   [r1, r2])

JOKER FUNC syntax.IsWordChar has:
;; (defn ^ABEND042(cannot find typename syntax.bool) IsWordChar
;;   "IsWordChar reports whether r is consider a ``word character''\nduring the evaluation of the \\b and \\B zero-width assertions.\nThese assertions are ASCII-only: the word characters are [A-Za-z0-9_].\n"
;;   {:added "1.0"
;;    :go "isWordChar(r)"}
;;   [r])

JOKER FUNC syntax.Parse has:
;; (defn ^[{:op Op, :flags Flags, :sub ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/syntax/regexp.go:20:11) Sub, :sub0 ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/syntax/regexp.go:21:11) Sub0, :rune ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/syntax/regexp.go:22:11) Rune, :rune0 ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/regexp/syntax/regexp.go:23:11) Rune0, :min ^Int Min, :max ^Int Max, :cap ^Int Cap, :name ^String Name} Error] Parse
;;   "Parse parses a regular expression string s, controlled by the specified\nFlags, and returns a regular expression parse tree. The syntax is\ndescribed in the top-level comment.\n"
;;   {:added "1.0"
;;    :go "parse(s, flags)"}
;;   [^String s, flags])

JOKER FUNC syscall.Accept has:
(defn ^[nfd sa err] Accept
  {:added "1.0"
   :go "accept(fd)"}
  [^Int fd])

JOKER FUNC syscall.Access has:
(defn ^err Access
  {:added "1.0"
   :go "access(path, mode)"}
  [^String path, mode])

JOKER FUNC syscall.Adjtime has:
;; (defn ^err Adjtime
;;   {:added "1.0"
;;    :go "adjtime(delta, olddelta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:311:20) delta, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:311:39) olddelta])

JOKER FUNC syscall.Bind has:
(defn ^err Bind
  {:added "1.0"
   :go "bind(fd, sa)"}
  [^Int fd, sa])

JOKER FUNC syscall.BpfBuflen has:
(defn ^[Int Error] BpfBuflen
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "bpfBuflen(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfDatalink has:
(defn ^[Int Error] BpfDatalink
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "bpfDatalink(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfHeadercmpl has:
(defn ^[Int Error] BpfHeadercmpl
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "bpfHeadercmpl(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfInterface has:
(defn ^[String Error] BpfInterface
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "bpfInterface(fd, name)"}
  [^Int fd, ^String name])

JOKER FUNC syscall.BpfJump has:
(defn ^{:code ^Int Code, :jt Jt, :jf Jf, :k K} BpfJump
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "bpfJump(code, k, jt, jf)"}
  [^Int code, ^Int k, ^Int jt, ^Int jf])

JOKER FUNC syscall.BpfStats has:
(defn ^[{:recv Recv, :drop Drop} Error] BpfStats
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "bpfStats(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfStmt has:
(defn ^{:code ^Int Code, :jt Jt, :jf Jf, :k K} BpfStmt
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "bpfStmt(code, k)"}
  [^Int code, ^Int k])

JOKER FUNC syscall.BpfTimeout has:
;; (defn ^[{:sec Sec, :usec Usec, :pad_cgo_0 ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/ztypes_darwin_amd64.go:31:12) Pad_cgo_0} Error] BpfTimeout
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n"
;;   {:added "1.0"
;;    :go "bpfTimeout(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.BytePtrFromString has:
;; (defn ^[ABEND042(cannot find typename syscall.byte) Error] BytePtrFromString
;;   "BytePtrFromString returns a pointer to a NUL-terminated array of\nbytes containing the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n"
;;   {:added "1.0"
;;    :go "bytePtrFromString(s)"}
;;   [^String s])

JOKER FUNC syscall.ByteSliceFromString has:
;; (defn ^[[ABEND042(cannot find typename syscall.byte)] Error] ByteSliceFromString
;;   "ByteSliceFromString returns a NUL-terminated slice of bytes\ncontaining the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n"
;;   {:added "1.0"
;;    :go "byteSliceFromString(s)"}
;;   [^String s])

JOKER FUNC syscall.Chdir has:
(defn ^err Chdir
  {:added "1.0"
   :go "chdir(path)"}
  [^String path])

JOKER FUNC syscall.CheckBpfVersion has:
(defn ^Error CheckBpfVersion
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "checkBpfVersion(fd)"}
  [^Int fd])

JOKER FUNC syscall.Chflags has:
(defn ^err Chflags
  {:added "1.0"
   :go "chflags(path, flags)"}
  [^String path, ^Int flags])

JOKER FUNC syscall.Chmod has:
(defn ^err Chmod
  {:added "1.0"
   :go "chmod(path, mode)"}
  [^String path, mode])

JOKER FUNC syscall.Chown has:
(defn ^err Chown
  {:added "1.0"
   :go "chown(path, uid, gid)"}
  [^String path, ^Int uid, ^Int gid])

JOKER FUNC syscall.Chroot has:
(defn ^err Chroot
  {:added "1.0"
   :go "chroot(path)"}
  [^String path])

JOKER FUNC syscall.Clearenv has:
;; (defn Clearenv
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])

JOKER FUNC syscall.Close has:
(defn ^err Close
  {:added "1.0"
   :go "close(fd)"}
  [^Int fd])

JOKER FUNC syscall.CloseOnExec has:
;; (defn CloseOnExec
;;   {:added "1.0"
;;    :go "closeOnExec(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.CmsgLen has:
(defn ^Int CmsgLen
  "CmsgLen returns the value to store in the Len field of the Cmsghdr\nstructure, taking into account any necessary alignment.\n"
  {:added "1.0"
   :go "cmsgLen(datalen)"}
  [^Int datalen])

JOKER FUNC syscall.CmsgSpace has:
(defn ^Int CmsgSpace
  "CmsgSpace returns the number of bytes an ancillary element with\npayload of the passed data length occupies.\n"
  {:added "1.0"
   :go "cmsgSpace(datalen)"}
  [^Int datalen])

JOKER FUNC syscall.Connect has:
(defn ^err Connect
  {:added "1.0"
   :go "connect(fd, sa)"}
  [^Int fd, sa])

JOKER FUNC syscall.Dup has:
(defn ^[nfd err] Dup
  {:added "1.0"
   :go "dup(fd)"}
  [^Int fd])

JOKER FUNC syscall.Dup2 has:
(defn ^err Dup2
  {:added "1.0"
   :go "dup2(from, to)"}
  [^Int from, ^Int to])

JOKER FUNC syscall.Environ has:
(defn ^[String] Environ
  {:added "1.0"
   :go "environ()"}
  [])

JOKER FUNC syscall.Exchangedata has:
(defn ^err Exchangedata
  {:added "1.0"
   :go "exchangedata(path1, path2, options)"}
  [^String path1, ^String path2, ^Int options])

JOKER FUNC syscall.Exec has:
;; (defn ^err Exec
;;   "Exec invokes the execve(2) system call.\n"
;;   {:added "1.0"
;;    :go "exec(argv0, argv, envv)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:254:30) argv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:254:45) envv])

JOKER FUNC syscall.Exit has:
;; (defn Exit
;;   {:added "1.0"
;;    :go "exit(code)"}
;;   [^Int code])

JOKER FUNC syscall.Fchdir has:
(defn ^err Fchdir
  {:added "1.0"
   :go "fchdir(fd)"}
  [^Int fd])

JOKER FUNC syscall.Fchflags has:
(defn ^err Fchflags
  {:added "1.0"
   :go "fchflags(fd, flags)"}
  [^Int fd, ^Int flags])

JOKER FUNC syscall.Fchmod has:
(defn ^err Fchmod
  {:added "1.0"
   :go "fchmod(fd, mode)"}
  [^Int fd, mode])

JOKER FUNC syscall.Fchown has:
(defn ^err Fchown
  {:added "1.0"
   :go "fchown(fd, uid, gid)"}
  [^Int fd, ^Int uid, ^Int gid])

JOKER FUNC syscall.FcntlFlock has:
;; (defn ^Error FcntlFlock
;;   "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.\n"
;;   {:added "1.0"
;;    :go "fcntlFlock(fd, cmd, lk)"}
;;   [fd, ^Int cmd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/flock.go:16:41) lk])

JOKER FUNC syscall.Flock has:
(defn ^err Flock
  {:added "1.0"
   :go "flock(fd, how)"}
  [^Int fd, ^Int how])

JOKER FUNC syscall.FlushBpf has:
(defn ^Error FlushBpf
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "flushBpf(fd)"}
  [^Int fd])

JOKER FUNC syscall.ForkExec has:
;; (defn ^[pid err] ForkExec
;;   "Combination of fork and exec, careful to be thread safe.\n"
;;   {:added "1.0"
;;    :go "forkExec(argv0, argv, attr)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:235:34) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/exec_unix.go:235:49) attr])

JOKER FUNC syscall.Fpathconf has:
(defn ^[val err] Fpathconf
  {:added "1.0"
   :go "fpathconf(fd, name)"}
  [^Int fd, ^Int name])

JOKER FUNC syscall.Fstat has:
;; (defn ^err Fstat
;;   {:added "1.0"
;;    :go "fstat(fd, stat)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:508:25) stat])

JOKER FUNC syscall.Fstatfs has:
;; (defn ^err Fstatfs
;;   {:added "1.0"
;;    :go "fstatfs(fd, stat)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:518:27) stat])

JOKER FUNC syscall.Fsync has:
(defn ^err Fsync
  {:added "1.0"
   :go "fsync(fd)"}
  [^Int fd])

JOKER FUNC syscall.Ftruncate has:
(defn ^err Ftruncate
  {:added "1.0"
   :go "ftruncate(fd, length)"}
  [^Int fd, length])

JOKER FUNC syscall.Futimes has:
;; (defn ^err Futimes
;;   {:added "1.0"
;;    :go "futimes(fd, tv)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:533:25) tv])

JOKER FUNC syscall.Getdirentries has:
;; (defn ^[n err] Getdirentries
;;   {:added "1.0"
;;    :go "getdirentries(fd, buf, basep)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:548:32) buf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:548:46) basep])

JOKER FUNC syscall.Getdtablesize has:
(defn ^size Getdtablesize
  {:added "1.0"
   :go "getdtablesize()"}
  [])

JOKER FUNC syscall.Getegid has:
(defn ^egid Getegid
  {:added "1.0"
   :go "getegid()"}
  [])

JOKER FUNC syscall.Getenv has:
(defn ^[value found] Getenv
  {:added "1.0"
   :go "getenv(key)"}
  [^String key])

JOKER FUNC syscall.Geteuid has:
(defn ^uid Geteuid
  {:added "1.0"
   :go "geteuid()"}
  [])

JOKER FUNC syscall.Getfsstat has:
;; (defn ^[n err] Getfsstat
;;   {:added "1.0"
;;    :go "getfsstat(buf, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_darwin.go:176:20) buf, ^Int flags])

JOKER FUNC syscall.Getgid has:
(defn ^gid Getgid
  {:added "1.0"
   :go "getgid()"}
  [])

JOKER FUNC syscall.Getgroups has:
(defn ^[gids err] Getgroups
  {:added "1.0"
   :go "getgroups()"}
  [])

JOKER FUNC syscall.Getpagesize has:
(defn ^Int Getpagesize
  {:added "1.0"
   :go "getpagesize()"}
  [])

JOKER FUNC syscall.Getpeername has:
(defn ^[sa err] Getpeername
  {:added "1.0"
   :go "getpeername(fd)"}
  [^Int fd])

JOKER FUNC syscall.Getpgid has:
(defn ^[pgid err] Getpgid
  {:added "1.0"
   :go "getpgid(pid)"}
  [^Int pid])

JOKER FUNC syscall.Getpgrp has:
(defn ^pgrp Getpgrp
  {:added "1.0"
   :go "getpgrp()"}
  [])

JOKER FUNC syscall.Getpid has:
(defn ^pid Getpid
  {:added "1.0"
   :go "getpid()"}
  [])

JOKER FUNC syscall.Getppid has:
(defn ^ppid Getppid
  {:added "1.0"
   :go "getppid()"}
  [])

JOKER FUNC syscall.Getpriority has:
(defn ^[prio err] Getpriority
  {:added "1.0"
   :go "getpriority(which, who)"}
  [^Int which, ^Int who])

JOKER FUNC syscall.Getrlimit has:
;; (defn ^err Getrlimit
;;   {:added "1.0"
;;    :go "getrlimit(which, lim)"}
;;   [^Int which, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:643:31) lim])

JOKER FUNC syscall.Getrusage has:
;; (defn ^err Getrusage
;;   {:added "1.0"
;;    :go "getrusage(who, rusage)"}
;;   [^Int who, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:653:32) rusage])

JOKER FUNC syscall.Getsid has:
(defn ^[sid err] Getsid
  {:added "1.0"
   :go "getsid(pid)"}
  [^Int pid])

JOKER FUNC syscall.Getsockname has:
(defn ^[sa err] Getsockname
  {:added "1.0"
   :go "getsockname(fd)"}
  [^Int fd])

JOKER FUNC syscall.GetsockoptByte has:
(defn ^[value err] GetsockoptByte
  {:added "1.0"
   :go "getsockoptByte(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptICMPv6Filter has:
;; (defn ^[{:filt ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/ztypes_darwin_amd64.go:256:7) Filt} Error] GetsockoptICMPv6Filter
;;   {:added "1.0"
;;    :go "getsockoptICMPv6Filter(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPMreq has:
;; (defn ^[{:multiaddr ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/ztypes_darwin_amd64.go:212:12) Multiaddr, :interface ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/ztypes_darwin_amd64.go:213:12) Interface} Error] GetsockoptIPMreq
;;   {:added "1.0"
;;    :go "getsockoptIPMreq(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPv6MTUInfo has:
(defn ^[{:addr Addr, :mtu Mtu} Error] GetsockoptIPv6MTUInfo
  {:added "1.0"
   :go "getsockoptIPv6MTUInfo(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPv6Mreq has:
;; (defn ^[{:multiaddr ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/ztypes_darwin_amd64.go:217:12) Multiaddr, :interface Interface} Error] GetsockoptIPv6Mreq
;;   {:added "1.0"
;;    :go "getsockoptIPv6Mreq(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptInet4Addr has:
(defn ^[value err] GetsockoptInet4Addr
  {:added "1.0"
   :go "getsockoptInet4Addr(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptInt has:
(defn ^[value err] GetsockoptInt
  {:added "1.0"
   :go "getsockoptInt(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.Gettimeofday has:
;; (defn ^Error Gettimeofday
;;   "sysnb\tgettimeofday(tp *Timeval) (sec int64, usec int32, err error)\n"
;;   {:added "1.0"
;;    :go "gettimeofday(tv)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_darwin_amd64.go:18:22) tv])

JOKER FUNC syscall.Getuid has:
(defn ^uid Getuid
  {:added "1.0"
   :go "getuid()"}
  [])

JOKER FUNC syscall.Getwd has:
(defn ^[String Error] Getwd
  {:added "1.0"
   :go "getwd()"}
  [])

JOKER FUNC syscall.Issetugid has:
(defn ^tainted Issetugid
  {:added "1.0"
   :go "issetugid()"}
  [])

JOKER FUNC syscall.Kevent has:
;; (defn ^[n err] Kevent
;;   {:added "1.0"
;;    :go "kevent(kq, changes, events, timeout)"}
;;   [^Int kq, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:439:37) changes, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:439:37) events, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_bsd.go:439:57) timeout])

JOKER FUNC syscall.Kill has:
(defn ^err Kill
  {:added "1.0"
   :go "kill(pid, signum)"}
  [^Int pid, signum])

JOKER FUNC syscall.Kqueue has:
(defn ^[fd err] Kqueue
  {:added "1.0"
   :go "kqueue()"}
  [])

JOKER FUNC syscall.Lchown has:
(defn ^err Lchown
  {:added "1.0"
   :go "lchown(path, uid, gid)"}
  [^String path, ^Int uid, ^Int gid])

JOKER FUNC syscall.Link has:
(defn ^err Link
  {:added "1.0"
   :go "link(path, link)"}
  [^String path, ^String link])

JOKER FUNC syscall.Listen has:
(defn ^err Listen
  {:added "1.0"
   :go "listen(s, backlog)"}
  [^Int s, ^Int backlog])

JOKER FUNC syscall.Lstat has:
;; (defn ^err Lstat
;;   {:added "1.0"
;;    :go "lstat(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:746:30) stat])

JOKER FUNC syscall.Mkdir has:
(defn ^err Mkdir
  {:added "1.0"
   :go "mkdir(path, mode)"}
  [^String path, mode])

JOKER FUNC syscall.Mkfifo has:
(defn ^err Mkfifo
  {:added "1.0"
   :go "mkfifo(path, mode)"}
  [^String path, mode])

JOKER FUNC syscall.Mknod has:
(defn ^err Mknod
  {:added "1.0"
   :go "mknod(path, mode, dev)"}
  [^String path, mode, ^Int dev])

JOKER FUNC syscall.Mlock has:
;; (defn ^err Mlock
;;   {:added "1.0"
;;    :go "mlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:806:14) b])

JOKER FUNC syscall.Mlockall has:
(defn ^err Mlockall
  {:added "1.0"
   :go "mlockall(flags)"}
  [^Int flags])

JOKER FUNC syscall.Mmap has:
(defn ^[data err] Mmap
  {:added "1.0"
   :go "mmap(fd, offset, length, prot, flags)"}
  [^Int fd, offset, ^Int length, ^Int prot, ^Int flags])

JOKER FUNC syscall.Mprotect has:
;; (defn ^err Mprotect
;;   {:added "1.0"
;;    :go "mprotect(b, prot)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:832:17) b, ^Int prot])

JOKER FUNC syscall.Munlock has:
;; (defn ^err Munlock
;;   {:added "1.0"
;;    :go "munlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:848:16) b])

JOKER FUNC syscall.Munlockall has:
(defn ^err Munlockall
  {:added "1.0"
   :go "munlockall()"}
  [])

JOKER FUNC syscall.Munmap has:
;; (defn ^err Munmap
;;   {:added "1.0"
;;    :go "munmap(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:552:15) b])

JOKER FUNC syscall.NsecToTimespec has:
(defn ^{:sec Sec, :nsec Nsec} NsecToTimespec
  "NsecToTimespec takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timespec value.\n"
  {:added "1.0"
   :go "nsecToTimespec(nsec)"}
  [nsec])

JOKER FUNC syscall.NsecToTimeval has:
;; (defn ^{:sec Sec, :usec Usec, :pad_cgo_0 ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/ztypes_darwin_amd64.go:31:12) Pad_cgo_0} NsecToTimeval
;;   "NsecToTimeval takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timeval value.\n"
;;   {:added "1.0"
;;    :go "nsecToTimeval(nsec)"}
;;   [nsec])

JOKER FUNC syscall.Open has:
(defn ^[fd err] Open
  {:added "1.0"
   :go "open(path, mode, perm)"}
  [^String path, ^Int mode, perm])

JOKER FUNC syscall.ParseDirent has:
;; (defn ^[consumed count newnames] ParseDirent
;;   "ParseDirent parses up to max directory entries in buf,\nappending the names to names. It returns the number of\nbytes consumed from buf, the number of entries added\nto names, and the new names slice.\n"
;;   {:added "1.0"
;;    :go "parseDirent(buf, max, names)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/dirent.go:64:22) buf, ^Int max, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/dirent.go:64:45) names])

JOKER FUNC syscall.ParseRoutingMessage has:
;; (defn ^[msgs err] ParseRoutingMessage
;;   "ParseRoutingMessage parses b as routing messages and returns the\nslice containing the RoutingMessage interfaces.\n\nDeprecated: Use golang.org/x/net/route instead.\n"
;;   {:added "1.0"
;;    :go "parseRoutingMessage(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/route_bsd.go:331:28) b])

JOKER FUNC syscall.ParseRoutingSockaddr has:
;; (defn ^[[ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/syscall/syscall_unix.go:205:15)] Error] ParseRoutingSockaddr
;;   "ParseRoutingSockaddr parses msg's payload as raw sockaddrs and\nreturns the slice containing the Sockaddr interfaces.\n\nDeprecated: Use golang.org/x/net/route instead.\n"
;;   {:added "1.0"
;;    :go "parseRoutingSockaddr(msg)"}
;;   [msg])

JOKER FUNC syscall.ParseSocketControlMessage has:
;; (defn ^[[{:header Header, :data ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/sockcmsg_unix.go:44:9) Data}] Error] ParseSocketControlMessage
;;   "ParseSocketControlMessage parses b as an array of socket control\nmessages.\n"
;;   {:added "1.0"
;;    :go "parseSocketControlMessage(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/sockcmsg_unix.go:49:34) b])

JOKER FUNC syscall.ParseUnixRights has:
;; (defn ^[[Int] Error] ParseUnixRights
;;   "ParseUnixRights decodes a socket control message that contains an\ninteger array of open file descriptors from another process.\n"
;;   {:added "1.0"
;;    :go "parseUnixRights(m)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/sockcmsg_unix.go:91:24) m])

JOKER FUNC syscall.Pathconf has:
(defn ^[val err] Pathconf
  {:added "1.0"
   :go "pathconf(path, name)"}
  [^String path, ^Int name])

JOKER FUNC syscall.Pipe has:
;; (defn ^err Pipe
;;   {:added "1.0"
;;    :go "pipe(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_darwin.go:168:13) p])

JOKER FUNC syscall.Pread has:
;; (defn ^[n err] Pread
;;   {:added "1.0"
;;    :go "pread(fd, p, offset)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:906:22) p, offset])

JOKER FUNC syscall.PtraceAttach has:
(defn ^err PtraceAttach
  "sys   ptrace(request int, pid int, addr uintptr, data uintptr) (err error)\n"
  {:added "1.0"
   :go "ptraceAttach(pid)"}
  [^Int pid])

JOKER FUNC syscall.PtraceDetach has:
(defn ^err PtraceDetach
  {:added "1.0"
   :go "ptraceDetach(pid)"}
  [^Int pid])

JOKER FUNC syscall.Pwrite has:
;; (defn ^[n err] Pwrite
;;   {:added "1.0"
;;    :go "pwrite(fd, p, offset)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:923:23) p, offset])

JOKER FUNC syscall.RawSyscall has:
(defn ^[r1 r2 err] RawSyscall
  {:added "1.0"
   :go "rawSyscall(trap, a1, a2, a3)"}
  [trap, a1, a2, a3])

JOKER FUNC syscall.RawSyscall6 has:
(defn ^[r1 r2 err] RawSyscall6
  {:added "1.0"
   :go "rawSyscall6(trap, a1, a2, a3, a4, a5, a6)"}
  [trap, a1, a2, a3, a4, a5, a6])

JOKER FUNC syscall.Read has:
;; (defn ^[n err] Read
;;   {:added "1.0"
;;    :go "read(fd, p)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:171:21) p])

JOKER FUNC syscall.ReadDirent has:
;; (defn ^[n err] ReadDirent
;;   {:added "1.0"
;;    :go "readDirent(fd, buf)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:65:29) buf])

JOKER FUNC syscall.Readlink has:
;; (defn ^[n err] Readlink
;;   {:added "1.0"
;;    :go "readlink(path, buf)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:957:32) buf])

JOKER FUNC syscall.Recvfrom has:
;; (defn ^[n from err] Recvfrom
;;   {:added "1.0"
;;    :go "recvfrom(fd, p, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:259:25) p, ^Int flags])

JOKER FUNC syscall.Recvmsg has:
;; (defn ^[n oobn recvflags from err] Recvmsg
;;   {:added "1.0"
;;    :go "recvmsg(fd, p, oob, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:358:29) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:358:29) oob, ^Int flags])

JOKER FUNC syscall.Rename has:
(defn ^err Rename
  {:added "1.0"
   :go "rename(from, to)"}
  [^String from, ^String to])

JOKER FUNC syscall.Revoke has:
(defn ^err Revoke
  {:added "1.0"
   :go "revoke(path)"}
  [^String path])

JOKER FUNC syscall.Rmdir has:
(defn ^err Rmdir
  {:added "1.0"
   :go "rmdir(path)"}
  [^String path])

JOKER FUNC syscall.RouteRIB has:
;; (defn ^[[ABEND042(cannot find typename syscall.byte)] Error] RouteRIB
;;   "RouteRIB returns routing information base, as known as RIB,\nwhich consists of network facility information, states and\nparameters.\n\nDeprecated: Use golang.org/x/net/route instead.\n"
;;   {:added "1.0"
;;    :go "routeRIB(facility, param)"}
;;   [^Int facility, ^Int param])

JOKER FUNC syscall.Seek has:
(defn ^[newoffset err] Seek
  {:added "1.0"
   :go "seek(fd, offset, whence)"}
  [^Int fd, offset, ^Int whence])

JOKER FUNC syscall.Select has:
;; (defn ^err Select
;;   {:added "1.0"
;;    :go "select(n, r, w, e, timeout)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:22) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:32) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:42) e, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1040:58) timeout])

JOKER FUNC syscall.Sendfile has:
;; (defn ^[written err] Sendfile
;;   {:added "1.0"
;;    :go "sendfile(outfd, infd, offset, count)"}
;;   [^Int outfd, ^Int infd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:334:43) offset, ^Int count])

JOKER FUNC syscall.Sendmsg has:
;; (defn ^err Sendmsg
;;   {:added "1.0"
;;    :go "sendmsg(fd, p, oob, to, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:394:29) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:394:29) oob, to, ^Int flags])

JOKER FUNC syscall.SendmsgN has:
;; (defn ^[n err] SendmsgN
;;   {:added "1.0"
;;    :go "sendmsgN(fd, p, oob, to, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:399:30) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:399:30) oob, to, ^Int flags])

JOKER FUNC syscall.Sendto has:
;; (defn ^err Sendto
;;   {:added "1.0"
;;    :go "sendto(fd, p, flags, to)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:271:23) p, ^Int flags, to])

JOKER FUNC syscall.SetBpf has:
;; (defn ^Error SetBpf
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n"
;;   {:added "1.0"
;;    :go "setBpf(fd, i)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/bpf_bsd.go:146:23) i])

JOKER FUNC syscall.SetBpfBuflen has:
(defn ^[Int Error] SetBpfBuflen
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "setBpfBuflen(fd, l)"}
  [^Int fd, ^Int l])

JOKER FUNC syscall.SetBpfDatalink has:
(defn ^[Int Error] SetBpfDatalink
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "setBpfDatalink(fd, t)"}
  [^Int fd, ^Int t])

JOKER FUNC syscall.SetBpfHeadercmpl has:
(defn ^Error SetBpfHeadercmpl
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "setBpfHeadercmpl(fd, f)"}
  [^Int fd, ^Int f])

JOKER FUNC syscall.SetBpfImmediate has:
(defn ^Error SetBpfImmediate
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "setBpfImmediate(fd, m)"}
  [^Int fd, ^Int m])

JOKER FUNC syscall.SetBpfInterface has:
(defn ^Error SetBpfInterface
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "setBpfInterface(fd, name)"}
  [^Int fd, ^String name])

JOKER FUNC syscall.SetBpfPromisc has:
(defn ^Error SetBpfPromisc
  "Deprecated: Use golang.org/x/net/bpf instead.\n"
  {:added "1.0"
   :go "setBpfPromisc(fd, m)"}
  [^Int fd, ^Int m])

JOKER FUNC syscall.SetBpfTimeout has:
;; (defn ^Error SetBpfTimeout
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n"
;;   {:added "1.0"
;;    :go "setBpfTimeout(fd, tv)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/bpf_bsd.go:118:31) tv])

JOKER FUNC syscall.SetKevent has:
;; (defn SetKevent
;;   {:added "1.0"
;;    :go "setKevent(k, fd, mode, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_darwin_amd64.go:35:18) k, ^Int fd, ^Int mode, ^Int flags])

JOKER FUNC syscall.SetNonblock has:
(defn ^err SetNonblock
  {:added "1.0"
   :go "setNonblock(fd, nonblocking)"}
  [^Int fd, nonblocking])

JOKER FUNC syscall.Setegid has:
(defn ^err Setegid
  {:added "1.0"
   :go "setegid(egid)"}
  [^Int egid])

JOKER FUNC syscall.Setenv has:
(defn ^Error Setenv
  {:added "1.0"
   :go "setenv(key, value)"}
  [^String key, ^String value])

JOKER FUNC syscall.Seteuid has:
(defn ^err Seteuid
  {:added "1.0"
   :go "seteuid(euid)"}
  [^Int euid])

JOKER FUNC syscall.Setgid has:
(defn ^err Setgid
  {:added "1.0"
   :go "setgid(gid)"}
  [^Int gid])

JOKER FUNC syscall.Setgroups has:
;; (defn ^err Setgroups
;;   {:added "1.0"
;;    :go "setgroups(gids)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:53:21) gids])

JOKER FUNC syscall.Setlogin has:
(defn ^err Setlogin
  {:added "1.0"
   :go "setlogin(name)"}
  [^String name])

JOKER FUNC syscall.Setpgid has:
(defn ^err Setpgid
  {:added "1.0"
   :go "setpgid(pid, pgid)"}
  [^Int pid, ^Int pgid])

JOKER FUNC syscall.Setpriority has:
(defn ^err Setpriority
  {:added "1.0"
   :go "setpriority(which, who, prio)"}
  [^Int which, ^Int who, ^Int prio])

JOKER FUNC syscall.Setprivexec has:
(defn ^err Setprivexec
  {:added "1.0"
   :go "setprivexec(flag)"}
  [^Int flag])

JOKER FUNC syscall.Setregid has:
(defn ^err Setregid
  {:added "1.0"
   :go "setregid(rgid, egid)"}
  [^Int rgid, ^Int egid])

JOKER FUNC syscall.Setreuid has:
(defn ^err Setreuid
  {:added "1.0"
   :go "setreuid(ruid, euid)"}
  [^Int ruid, ^Int euid])

JOKER FUNC syscall.Setrlimit has:
;; (defn ^err Setrlimit
;;   {:added "1.0"
;;    :go "setrlimit(which, lim)"}
;;   [^Int which, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1145:31) lim])

JOKER FUNC syscall.Setsid has:
(defn ^[pid err] Setsid
  {:added "1.0"
   :go "setsid()"}
  [])

JOKER FUNC syscall.SetsockoptByte has:
(defn ^err SetsockoptByte
  {:added "1.0"
   :go "setsockoptByte(fd, level, opt, value)"}
  [^Int fd, ^Int level, ^Int opt, value])

JOKER FUNC syscall.SetsockoptICMPv6Filter has:
;; (defn ^Error SetsockoptICMPv6Filter
;;   {:added "1.0"
;;    :go "setsockoptICMPv6Filter(fd, level, opt, filter)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:300:56) filter])

JOKER FUNC syscall.SetsockoptIPMreq has:
;; (defn ^err SetsockoptIPMreq
;;   {:added "1.0"
;;    :go "setsockoptIPMreq(fd, level, opt, mreq)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:292:48) mreq])

JOKER FUNC syscall.SetsockoptIPv6Mreq has:
;; (defn ^err SetsockoptIPv6Mreq
;;   {:added "1.0"
;;    :go "setsockoptIPv6Mreq(fd, level, opt, mreq)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:296:50) mreq])

JOKER FUNC syscall.SetsockoptInet4Addr has:
;; (defn ^err SetsockoptInet4Addr
;;   {:added "1.0"
;;    :go "setsockoptInet4Addr(fd, level, opt, value)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:288:52) value])

JOKER FUNC syscall.SetsockoptInt has:
(defn ^err SetsockoptInt
  {:added "1.0"
   :go "setsockoptInt(fd, level, opt, value)"}
  [^Int fd, ^Int level, ^Int opt, ^Int value])

JOKER FUNC syscall.SetsockoptLinger has:
;; (defn ^err SetsockoptLinger
;;   {:added "1.0"
;;    :go "setsockoptLinger(fd, level, opt, l)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:304:45) l])

JOKER FUNC syscall.SetsockoptString has:
(defn ^err SetsockoptString
  {:added "1.0"
   :go "setsockoptString(fd, level, opt, s)"}
  [^Int fd, ^Int level, ^Int opt, ^String s])

JOKER FUNC syscall.SetsockoptTimeval has:
;; (defn ^err SetsockoptTimeval
;;   {:added "1.0"
;;    :go "setsockoptTimeval(fd, level, opt, tv)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_unix.go:312:47) tv])

JOKER FUNC syscall.Settimeofday has:
;; (defn ^err Settimeofday
;;   {:added "1.0"
;;    :go "settimeofday(tp)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1166:22) tp])

JOKER FUNC syscall.Setuid has:
(defn ^err Setuid
  {:added "1.0"
   :go "setuid(uid)"}
  [^Int uid])

JOKER FUNC syscall.Shutdown has:
(defn ^err Shutdown
  {:added "1.0"
   :go "shutdown(s, how)"}
  [^Int s, ^Int how])

JOKER FUNC syscall.SlicePtrFromStrings has:
;; (defn ^[[ABEND042(cannot find typename syscall.byte)] Error] SlicePtrFromStrings
;;   "SlicePtrFromStrings converts a slice of strings to a slice of\npointers to NUL-terminated byte arrays. If any string contains\na NUL byte, it returns (nil, EINVAL).\n"
;;   {:added "1.0"
;;    :go "slicePtrFromStrings(ss)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:83:29) ss])

JOKER FUNC syscall.Socket has:
(defn ^[fd err] Socket
  {:added "1.0"
   :go "socket(domain, typ, proto)"}
  [^Int domain, ^Int typ, ^Int proto])

JOKER FUNC syscall.Socketpair has:
(defn ^[fd err] Socketpair
  {:added "1.0"
   :go "socketpair(domain, typ, proto)"}
  [^Int domain, ^Int typ, ^Int proto])

JOKER FUNC syscall.StartProcess has:
;; (defn ^[pid handle err] StartProcess
;;   "StartProcess wraps ForkExec for package os.\n"
;;   {:added "1.0"
;;    :go "startProcess(argv0, argv, attr)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:240:38) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/exec_unix.go:240:53) attr])

JOKER FUNC syscall.Stat has:
;; (defn ^err Stat
;;   {:added "1.0"
;;    :go "stat(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1186:29) stat])

JOKER FUNC syscall.Statfs has:
;; (defn ^err Statfs
;;   {:added "1.0"
;;    :go "statfs(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/zsyscall_darwin_amd64.go:1201:31) stat])

JOKER FUNC syscall.StringBytePtr has:
;; (defn ^ABEND042(cannot find typename syscall.byte) StringBytePtr
;;   "StringBytePtr returns a pointer to a NUL-terminated array of bytes.\nIf s contains a NUL byte this function panics instead of returning\nan error.\n\nDeprecated: Use BytePtrFromString instead.\n"
;;   {:added "1.0"
;;    :go "stringBytePtr(s)"}
;;   [^String s])

JOKER FUNC syscall.StringByteSlice has:
;; (defn ^[ABEND042(cannot find typename syscall.byte)] StringByteSlice
;;   "StringByteSlice converts a string to a NUL-terminated []byte,\nIf s contains a NUL byte this function panics instead of\nreturning an error.\n\nDeprecated: Use ByteSliceFromString instead.\n"
;;   {:added "1.0"
;;    :go "stringByteSlice(s)"}
;;   [^String s])

JOKER FUNC syscall.StringSlicePtr has:
;; (defn ^[ABEND042(cannot find typename syscall.byte)] StringSlicePtr
;;   "StringSlicePtr converts a slice of strings to a slice of pointers\nto NUL-terminated byte arrays. If any string contains a NUL byte\nthis function panics instead of returning an error.\n\nDeprecated: Use SlicePtrFromStrings instead.\n"
;;   {:added "1.0"
;;    :go "stringSlicePtr(ss)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/exec_unix.go:71:24) ss])

JOKER FUNC syscall.Symlink has:
(defn ^err Symlink
  {:added "1.0"
   :go "symlink(path, link)"}
  [^String path, ^String link])

JOKER FUNC syscall.Sync has:
(defn ^err Sync
  {:added "1.0"
   :go "sync()"}
  [])

JOKER FUNC syscall.Syscall has:
(defn ^[r1 r2 err] Syscall
  {:added "1.0"
   :go "syscall(trap, a1, a2, a3)"}
  [trap, a1, a2, a3])

JOKER FUNC syscall.Syscall6 has:
(defn ^[r1 r2 err] Syscall6
  {:added "1.0"
   :go "syscall6(trap, a1, a2, a3, a4, a5, a6)"}
  [trap, a1, a2, a3, a4, a5, a6])

JOKER FUNC syscall.Syscall9 has:
(defn ^[r1 r2 err] Syscall9
  {:added "1.0"
   :go "syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9)"}
  [trap, a1, a2, a3, a4, a5, a6, a7, a8, a9])

JOKER FUNC syscall.Sysctl has:
(defn ^[value err] Sysctl
  {:added "1.0"
   :go "sysctl(name)"}
  [^String name])

JOKER FUNC syscall.SysctlUint32 has:
(defn ^[value err] SysctlUint32
  {:added "1.0"
   :go "sysctlUint32(name)"}
  [^String name])

JOKER FUNC syscall.TimespecToNsec has:
;; (defn ^ABEND042(cannot find typename syscall.int64) TimespecToNsec
;;   "TimespecToNsec converts a Timespec value into a number of\nnanoseconds since the Unix epoch.\n"
;;   {:added "1.0"
;;    :go "timespecToNsec(ts)"}
;;   [ts])

JOKER FUNC syscall.TimevalToNsec has:
;; (defn ^ABEND042(cannot find typename syscall.int64) TimevalToNsec
;;   "TimevalToNsec converts a Timeval value into a number of nanoseconds\nsince the Unix epoch.\n"
;;   {:added "1.0"
;;    :go "timevalToNsec(tv)"}
;;   [tv])

JOKER FUNC syscall.Truncate has:
(defn ^err Truncate
  {:added "1.0"
   :go "truncate(path, length)"}
  [^String path, length])

JOKER FUNC syscall.Umask has:
(defn ^oldmask Umask
  {:added "1.0"
   :go "umask(newmask)"}
  [^Int newmask])

JOKER FUNC syscall.Undelete has:
(defn ^err Undelete
  {:added "1.0"
   :go "undelete(path)"}
  [^String path])

JOKER FUNC syscall.UnixRights has:
;; (defn ^[ABEND042(cannot find typename syscall.byte)] UnixRights
;;   "UnixRights encodes a set of open file descriptors into a socket\ncontrol message for sending to another process.\n"
;;   {:added "1.0"
;;    :go "unixRights(fds)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/syscall/sockcmsg_unix.go:74:21) fds])

JOKER FUNC syscall.Unlink has:
(defn ^err Unlink
  {:added "1.0"
   :go "unlink(path)"}
  [^String path])

JOKER FUNC syscall.Unmount has:
(defn ^err Unmount
  {:added "1.0"
   :go "unmount(path, flags)"}
  [^String path, ^Int flags])

JOKER FUNC syscall.Unsetenv has:
(defn ^Error Unsetenv
  {:added "1.0"
   :go "unsetenv(key)"}
  [^String key])

JOKER FUNC syscall.Utimes has:
;; (defn ^err Utimes
;;   {:added "1.0"
;;    :go "utimes(path, tv)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:502:29) tv])

JOKER FUNC syscall.UtimesNano has:
;; (defn ^Error UtimesNano
;;   {:added "1.0"
;;    :go "utimesNano(path, ts)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_bsd.go:509:33) ts])

JOKER FUNC syscall.Wait4 has:
;; (defn ^[wpid err] Wait4
;;   {:added "1.0"
;;    :go "wait4(pid, wstatus, options, rusage)"}
;;   [^Int pid, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_bsd.go:127:29) wstatus, ^Int options, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_bsd.go:127:62) rusage])

JOKER FUNC syscall.Write has:
;; (defn ^[n err] Write
;;   {:added "1.0"
;;    :go "write(fd, p)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/syscall/syscall_unix.go:187:22) p])

JOKER FUNC syslog.Dial has:
;; (defn ^[{:priority priority, :tag ^String tag, :hostname ^String hostname, :network ^String network, :raddr ^String raddr, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/syslog/syslog.go:83:7) mu, :conn conn} Error] Dial
;;   "Dial establishes a connection to a log daemon by connecting to\naddress raddr on the specified network. Each write to the returned\nwriter sends a log message with the facility and severity\n(from priority) and tag. If tag is empty, the os.Args[0] is used.\nIf network is empty, Dial will connect to the local syslog server.\nOtherwise, see the documentation for net.Dial for valid values\nof network and raddr.\n"
;;   {:added "1.0"
;;    :go "dial(network, raddr, priority, tag)"}
;;   [^String network, ^String raddr, priority, ^String tag])

JOKER FUNC syslog.New has:
;; (defn ^[{:priority priority, :tag ^String tag, :hostname ^String hostname, :network ^String network, :raddr ^String raddr, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/syslog/syslog.go:83:7) mu, :conn conn} Error] New
;;   "New establishes a new connection to the system log daemon. Each\nwrite to the returned writer sends a log message with the given\npriority (a combination of the syslog facility and severity) and\nprefix tag. If tag is empty, the os.Args[0] is used.\n"
;;   {:added "1.0"
;;    :go "new(priority, tag)"}
;;   [priority, ^String tag])

JOKER FUNC syslog.NewLogger has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/syslog/syslog.go:309:43) Error] NewLogger
;;   "NewLogger creates a log.Logger whose output is written to the\nsystem log service with the specified priority, a combination of\nthe syslog facility and severity. The logFlag argument is the flag\nset passed through to log.New to create the Logger.\n"
;;   {:added "1.0"
;;    :go "newLogger(p, logFlag)"}
;;   [p, ^Int logFlag])

JOKER FUNC tabwriter.NewWriter has:
;; (defn ^{:output ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/text/tabwriter/tabwriter.go:93:11) output, :minwidth ^Int minwidth, :tabwidth ^Int tabwidth, :padding ^Int padding, :padbytes ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/text/tabwriter/tabwriter.go:97:11) padbytes, :flags ^Int flags, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/text/tabwriter/tabwriter.go:101:10) buf, :pos ^Int pos, :cell cell, :endchar endChar, :lines ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/text/tabwriter/tabwriter.go:105:10) lines, :widths ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/text/tabwriter/tabwriter.go:106:10) widths} NewWriter
;;   "NewWriter allocates and initializes a new tabwriter.Writer.\nThe parameters are the same as for the Init function.\n"
;;   {:added "1.0"
;;    :go "newWriter(output, minwidth, tabwidth, padding, padchar, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/text/tabwriter/tabwriter.go:597:23) output, ^Int minwidth, ^Int tabwidth, ^Int padding, padchar, ^Int flags])

JOKER FUNC tar.FileInfoHeader has:
;; (defn ^[{:typeflag Typeflag, :name ^String Name, :linkname ^String Linkname, :size Size, :mode Mode, :uid ^Int Uid, :gid ^Int Gid, :uname ^String Uname, :gname ^String Gname, :modtime ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:161:13) ModTime, :accesstime ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:162:13) AccessTime, :changetime ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:163:13) ChangeTime, :devmajor Devmajor, :devminor Devminor, :xattrs ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/archive/tar/common.go:179:9) Xattrs, :paxrecords ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/archive/tar/common.go:191:13) PAXRecords, :format Format} Error] FileInfoHeader
;;   "FileInfoHeader creates a partially-populated Header from fi.\nIf fi describes a symlink, FileInfoHeader records link as the link target.\nIf fi describes a directory, a slash is appended to the name.\n\nSince os.FileInfo's Name method only returns the base name of\nthe file it describes, it may be necessary to modify Header.Name\nto provide the full path name of the file.\n"
;;   {:added "1.0"
;;    :go "fileInfoHeader(fi, link)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/common.go:629:24) fi, ^String link])

JOKER FUNC tar.NewReader has:
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/reader.go:20:7) r, :pad pad, :curr curr, :blk blk, :err err} NewReader
;;   "NewReader creates a new Reader reading from r.\n"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/reader.go:39:18) r])

JOKER FUNC tar.NewWriter has:
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/writer.go:20:7) w, :pad pad, :curr curr, :hdr hdr, :blk blk, :err err} NewWriter
;;   "NewWriter creates a new Writer writing to w.\n"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/tar/writer.go:33:18) w])

JOKER FUNC testing.AllocsPerRun has:
;; (defn ^avg AllocsPerRun
;;   "AllocsPerRun returns the average number of allocations during calls to f.\nAlthough the return value has type float64, it will always be an integral value.\n\nTo compute the number of allocations, the function will first be run once as\na warm-up. The average number of allocations over the specified number of\nruns will then be measured and returned.\n\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore\nit before returning.\n"
;;   {:added "1.0"
;;    :go "allocsPerRun(runs, f)"}
;;   [^Int runs, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/allocs.go:20:31) f])

JOKER FUNC testing.Benchmark has:
;; (defn ^{:n ^Int N, :t ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/benchmark.go:298:12) T, :bytes Bytes, :memallocs MemAllocs, :membytes MemBytes} Benchmark
;;   "Benchmark benchmarks a single function. Useful for creating\ncustom benchmarks that do not use the \"go test\" command.\n\nIf f calls Run, the result will be an estimate of running all its\nsubbenchmarks that don't call Run in sequence in a single benchmark.\n"
;;   {:added "1.0"
;;    :go "benchmark(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/benchmark.go:649:18) f])

JOKER FUNC testing.CoverMode has:
(defn ^String CoverMode
  "CoverMode reports what the test coverage mode is set to. The\nvalues are \"set\", \"count\", or \"atomic\". The return value will be\nempty if test coverage is not enabled.\n"
  {:added "1.0"
   :go "coverMode()"}
  [])

JOKER FUNC testing.Coverage has:
;; (defn ^ABEND042(cannot find typename testing.float64) Coverage
;;   "Coverage reports the current code coverage as a fraction in the range [0, 1].\nIf coverage is not enabled, Coverage returns 0.\n\nWhen running a large set of sequential test cases, checking Coverage after each one\ncan be useful for identifying which test cases exercise new code paths.\nIt is not a replacement for the reports generated by 'go test -cover' and\n'go tool cover'.\n"
;;   {:added "1.0"
;;    :go "coverage()"}
;;   [])

JOKER FUNC testing.Main has:
;; (defn Main
;;   "Main is an internal function, part of the implementation of the \"go test\" command.\nIt was exported because it is cross-package and predates \"internal\" packages.\nIt is no longer used by \"go test\" but preserved, as much as possible, for other\nsystems that simulate \"go test\" using Main, but Main sometimes cannot be updated as\nnew functionality is added to the testing package.\nSystems simulating \"go test\" should be updated to use MainStart.\n"
;;   {:added "1.0"
;;    :go "main(matchString, tests, benchmarks, examples)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/testing.go:961:23) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:66) tests, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:93) benchmarks, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:123) examples])

JOKER FUNC testing.MainStart has:
;; (defn ^{:deps deps, :tests ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:968:13) tests, :benchmarks ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:969:13) benchmarks, :examples ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:970:13) examples, :timer ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/testing/testing.go:972:12) timer, :afteronce ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/testing/testing.go:973:12) afterOnce, :numrun ^Int numRun} MainStart
;;   "MainStart is meant for use by tests generated by 'go test'.\nIt is not meant to be called directly and is not subject to the Go 1 compatibility document.\nIt may change signature from release to release.\n"
;;   {:added "1.0"
;;    :go "mainStart(deps, tests, benchmarks, examples)"}
;;   [deps, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:995:37) tests, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:995:64) benchmarks, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:995:94) examples])

JOKER FUNC testing.RegisterCover has:
;; (defn RegisterCover
;;   "RegisterCover records the coverage data accumulators for the tests.\nNOTE: This function is internal to the testing infrastructure and may change.\nIt is not covered (yet) by the Go 1 compatibility guidelines.\n"
;;   {:added "1.0"
;;    :go "registerCover(c)"}
;;   [c])

JOKER FUNC testing.RunBenchmarks has:
;; (defn RunBenchmarks
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n"
;;   {:added "1.0"
;;    :go "runBenchmarks(matchString, benchmarks)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/benchmark.go:377:32) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/benchmark.go:377:80) benchmarks])

JOKER FUNC testing.RunExamples has:
;; (defn ^ok RunExamples
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n"
;;   {:added "1.0"
;;    :go "runExamples(matchString, examples)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/example.go:25:30) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/example.go:25:76) examples])

JOKER FUNC testing.RunTests has:
;; (defn ^ok RunTests
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n"
;;   {:added "1.0"
;;    :go "runTests(matchString, tests)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/testing.go:1091:27) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:1091:70) tests])

JOKER FUNC testing.Short has:
;; (defn ^ABEND042(cannot find typename testing.bool) Short
;;   "Short reports whether the -test.short flag is set.\n"
;;   {:added "1.0"
;;    :go "short()"}
;;   [])

JOKER FUNC testing.Verbose has:
;; (defn ^ABEND042(cannot find typename testing.bool) Verbose
;;   "Verbose reports whether the -test.v flag is set.\n"
;;   {:added "1.0"
;;    :go "verbose()"}
;;   [])

JOKER FUNC textproto.CanonicalMIMEHeaderKey has:
(defn ^String CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n"
  {:added "1.0"
   :go "canonicalMIMEHeaderKey(s)"}
  [^String s])

JOKER FUNC textproto.Dial has:
;; (defn ^[{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/textproto/textproto.go:62:7) conn} Error] Dial
;;   "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n"
;;   {:added "1.0"
;;    :go "dial(network, addr)"}
;;   [^String network, ^String addr])

JOKER FUNC textproto.NewConn has:
;; (defn ^{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/textproto/textproto.go:62:7) conn} NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n"
;;   {:added "1.0"
;;    :go "newConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/textproto/textproto.go:66:19) conn])

JOKER FUNC textproto.NewReader has:
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/textproto/reader.go:19:6) R, :dot ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/textproto/reader.go:20:6) dot, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/textproto/reader.go:21:6) buf} NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/textproto/reader.go:29:18) r])

JOKER FUNC textproto.NewWriter has:
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/textproto/writer.go:16:6) W, :dot ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/textproto/writer.go:17:6) dot} NewWriter
;;   "NewWriter returns a new Writer writing to w.\n"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/textproto/writer.go:21:18) w])

JOKER FUNC textproto.TrimBytes has:
;; (defn ^[ABEND042(cannot find typename textproto.byte)] TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\n"
;;   {:added "1.0"
;;    :go "trimBytes(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/net/textproto/textproto.go:137:18) b])

JOKER FUNC textproto.TrimString has:
(defn ^String TrimString
  "TrimString returns s without leading and trailing ASCII space.\n"
  {:added "1.0"
   :go "trimString(s)"}
  [^String s])

JOKER FUNC time.After has:
;; (defn ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/time/sleep.go:152:24) After
;;   "After waits for the duration to elapse and then sends the current time\non the returned channel.\nIt is equivalent to NewTimer(d).C.\nThe underlying Timer is not recovered by the garbage collector\nuntil the timer fires. If efficiency is a concern, use NewTimer\ninstead and call Timer.Stop if the timer is no longer needed.\n"
;;   {:added "1.0"
;;    :go "after(d)"}
;;   [d])

JOKER FUNC time.AfterFunc has:
;; (defn ^{:c ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/time/sleep.go:50:4) C, :r r} AfterFunc
;;   "AfterFunc waits for the duration to elapse and then calls f\nin its own goroutine. It returns a Timer that can\nbe used to cancel the call using its Stop method.\n"
;;   {:added "1.0"
;;    :go "afterFunc(d, f)"}
;;   [d, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/time/sleep.go:159:30) f])

JOKER FUNC time.Date has:
;; (defn ^{:wall wall, :ext ext, :loc ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/time.go:140:6) loc} Date
;;   "Date returns the Time corresponding to\n\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside\ntheir usual ranges and will be normalized during the conversion.\nFor example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times.\nFor example, in the United States, March 13, 2011 2:15am never occurred,\nwhile November 6, 2011 1:15am occurred twice. In such cases, the\nchoice of time zone, and therefore the time, is not well-defined.\nDate returns a time that is correct in one of the two zones involved\nin the transition, but it does not guarantee which.\n\nDate panics if loc is nil.\n"
;;   {:added "1.0"
;;    :go "date(year, month, day, hour, min, sec, nsec, loc)"}
;;   [^Int year, month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/time.go:1326:69) loc])

JOKER FUNC time.FixedZone has:
;; (defn ^{:name ^String name, :zone ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/time/zoneinfo.go:20:7) zone, :tx ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/time/zoneinfo.go:21:7) tx, :cachestart cacheStart, :cacheend cacheEnd, :cachezone ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/zoneinfo.go:34:13) cacheZone} FixedZone
;;   "FixedZone returns a Location that always uses\nthe given zone name and offset (seconds east of UTC).\n"
;;   {:added "1.0"
;;    :go "fixedZone(name, offset)"}
;;   [^String name, ^Int offset])

JOKER FUNC time.LoadLocation has:
;; (defn ^[{:name ^String name, :zone ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/time/zoneinfo.go:20:7) zone, :tx ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/time/zoneinfo.go:21:7) tx, :cachestart cacheStart, :cacheend cacheEnd, :cachezone ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/zoneinfo.go:34:13) cacheZone} Error] LoadLocation
;;   "LoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC.\nIf the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file\nin the IANA Time Zone database, such as \"America/New_York\".\n\nThe time zone database needed by LoadLocation may not be\npresent on all systems, especially non-Unix systems.\nLoadLocation looks in the directory or uncompressed zip file\nnamed by the ZONEINFO environment variable, if any, then looks in\nknown installation locations on Unix systems,\nand finally looks in $GOROOT/lib/time/zoneinfo.zip.\n"
;;   {:added "1.0"
;;    :go "loadLocation(name)"}
;;   [^String name])

JOKER FUNC time.LoadLocationFromTZData has:
;; (defn ^[{:name ^String name, :zone ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/time/zoneinfo.go:20:7) zone, :tx ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/time/zoneinfo.go:21:7) tx, :cachestart cacheStart, :cacheend cacheEnd, :cachezone ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/zoneinfo.go:34:13) cacheZone} Error] LoadLocationFromTZData
;;   "LoadLocationFromTZData returns a Location with the given name\ninitialized from the IANA Time Zone database-formatted data.\nThe data should be in the format of a standard IANA time zone file\n(for example, the content of /etc/localtime on Unix systems).\n"
;;   {:added "1.0"
;;    :go "loadLocationFromTZData(name, data)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/time/zoneinfo_read.go:86:47) data])

JOKER FUNC time.NewTicker has:
;; (defn ^{:c ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/time/tick.go:12:4) C, :r r} NewTicker
;;   "NewTicker returns a new Ticker containing a channel that will send the\ntime with a period specified by the duration argument.\nIt adjusts the intervals or drops ticks to make up for slow receivers.\nThe duration d must be greater than zero; if not, NewTicker will panic.\nStop the ticker to release associated resources.\n"
;;   {:added "1.0"
;;    :go "newTicker(d)"}
;;   [d])

JOKER FUNC time.NewTimer has:
;; (defn ^{:c ^ABEND881(unrecognized Expr type *ast.ChanType at: ../GOSRC/time/sleep.go:50:4) C, :r r} NewTimer
;;   "NewTimer creates a new Timer that will send\nthe current time on its channel after at least duration d.\n"
;;   {:added "1.0"
;;    :go "newTimer(d)"}
;;   [d])

JOKER FUNC time.Now has:
;; (defn ^{:wall wall, :ext ext, :loc ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/time.go:140:6) loc} Now
;;   "Now returns the current local time.\n"
;;   {:added "1.0"
;;    :go "now()"}
;;   [])

JOKER FUNC time.Parse has:
;; (defn ^[{:wall wall, :ext ext, :loc ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/time.go:140:6) loc} Error] Parse
;;   "Parse parses a formatted string and returns the time value it represents.\nThe layout defines the format by showing how the reference time,\ndefined to be\n\tMon Jan 2 15:04:05 -0700 MST 2006\nwould be interpreted if it were the value; it serves as an example of\nthe input format. The same interpretation will then be made to the\ninput string.\n\nPredefined layouts ANSIC, UnixDate, RFC3339 and others describe standard\nand convenient representations of the reference time. For more information\nabout the formats and the definition of the reference time, see the\ndocumentation for ANSIC and the other constants defined by this package.\nAlso, the executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nElements omitted from the value are assumed to be zero or, when\nzero is impossible, one, so parsing \"3:04pm\" returns the time\ncorresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is\n0, this time is before the zero Time).\nYears must be in the range 0000..9999. The day of the week is checked\nfor syntax but it is otherwise ignored.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds\nto a time zone used by the current location (Local), then Parse uses that\nlocation and zone in the returned time. Otherwise it records the time as\nbeing in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation\nhas a defined offset in the current location, then that offset is used.\nThe zone abbreviation \"UTC\" is recognized as UTC regardless of location.\nIf the zone abbreviation is unknown, Parse records the time as being\nin a fabricated location with the given zone abbreviation and a zero offset.\nThis choice means that such a time can be parsed and reformatted with the\nsame layout losslessly, but the exact instant used in the representation will\ndiffer by the actual zone offset. To avoid such problems, prefer time layouts\nthat use a numeric zone offset, or use ParseInLocation.\n"
;;   {:added "1.0"
;;    :go "parse(layout, value)"}
;;   [^String layout, ^String value])

JOKER FUNC time.ParseDuration has:
;; (defn ^[ABEND042(cannot find typename time.int64) Error] ParseDuration
;;   "ParseDuration parses a duration string.\nA duration string is a possibly signed sequence of\ndecimal numbers, each with optional fraction and a unit suffix,\nsuch as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"s\"), \"ms\", \"s\", \"m\", \"h\".\n"
;;   {:added "1.0"
;;    :go "parseDuration(s)"}
;;   [^String s])

JOKER FUNC time.ParseInLocation has:
;; (defn ^[{:wall wall, :ext ext, :loc ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/time.go:140:6) loc} Error] ParseInLocation
;;   "ParseInLocation is like Parse but differs in two important ways.\nFirst, in the absence of time zone information, Parse interprets a time as UTC;\nParseInLocation interprets the time as in the given location.\nSecond, when given a zone offset or abbreviation, Parse tries to match it\nagainst the Local location; ParseInLocation uses the given location.\n"
;;   {:added "1.0"
;;    :go "parseInLocation(layout, value, loc)"}
;;   [^String layout, ^String value, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/format.go:782:48) loc])

JOKER FUNC time.Since has:
;; (defn ^ABEND042(cannot find typename time.int64) Since
;;   "Since returns the time elapsed since t.\nIt is shorthand for time.Now().Sub(t).\n"
;;   {:added "1.0"
;;    :go "since(t)"}
;;   [t])

JOKER FUNC time.Sleep has:
;; (defn Sleep
;;   "Sleep pauses the current goroutine for at least the duration d.\nA negative or zero duration causes Sleep to return immediately.\n"
;;   {:added "1.0"
;;    :go "sleep(d)"}
;;   [d])

JOKER FUNC time.Tick has:
;; (defn ^ABEND883(unrecognized Expr type *ast.ChanType at: ../GOSRC/time/tick.go:54:23) Tick
;;   "Tick is a convenience wrapper for NewTicker providing access to the ticking\nchannel only. While Tick is useful for clients that have no need to shut down\nthe Ticker, be aware that without a way to shut it down the underlying\nTicker cannot be recovered by the garbage collector; it \"leaks\".\nUnlike NewTicker, Tick will return nil if d <= 0.\n"
;;   {:added "1.0"
;;    :go "tick(d)"}
;;   [d])

JOKER FUNC time.Unix has:
;; (defn ^{:wall wall, :ext ext, :loc ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/time/time.go:140:6) loc} Unix
;;   "Unix returns the local Time corresponding to the given Unix time,\nsec seconds and nsec nanoseconds since January 1, 1970 UTC.\nIt is valid to pass nsec outside the range [0, 999999999].\nNot all sec values have a corresponding time value. One such\nvalue is 1<<63-1 (the largest int64 value).\n"
;;   {:added "1.0"
;;    :go "unix(sec, nsec)"}
;;   [sec, nsec])

JOKER FUNC time.Until has:
;; (defn ^ABEND042(cannot find typename time.int64) Until
;;   "Until returns the duration until t.\nIt is shorthand for t.Sub(time.Now()).\n"
;;   {:added "1.0"
;;    :go "until(t)"}
;;   [t])

JOKER FUNC tls.Client has:
;; (defn ^{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:27:11) conn, :isclient isClient, :handshakestatus handshakeStatus, :handshakemutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:35:17) handshakeMutex, :handshakeerr handshakeErr, :vers ^Int vers, :havevers haveVers, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:39:17) config, :handshakes ^Int handshakes, :didresume didResume, :ciphersuite ^Int cipherSuite, :ocspresponse ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:46:19) ocspResponse, :scts ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:47:19) scts, :peercertificates ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:48:19) peerCertificates, :verifiedchains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:51:17) verifiedChains, :servername ^String serverName, :securerenegotiation secureRenegotiation, :ekm ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/conn.go:59:6) ekm, :clientfinishedisfirst clientFinishedIsFirst, :closenotifyerr closeNotifyErr, :closenotifysent closeNotifySent, :clientfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:77:17) clientFinished, :serverfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:78:17) serverFinished, :clientprotocol ^String clientProtocol, :clientprotocolfallback clientProtocolFallback, :in in, :out out, :rawinput ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:85:12) rawInput, :input ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:86:12) input, :hand ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:87:12) hand, :buffering buffering, :sendbuf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:89:12) sendBuf, :bytessent bytesSent, :packetssent packetsSent, :warncount ^Int warnCount, :activecall activeCall, :tmp ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:105:6) tmp} Client
;;   "Client returns a new TLS client side connection\nusing conn as the underlying transport.\nThe config cannot be nil: users must set either ServerName or\nInsecureSkipVerify in the config.\n"
;;   {:added "1.0"
;;    :go "client(conn, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:39:18) conn, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:39:35) config])

JOKER FUNC tls.Dial has:
;; (defn ^[{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:27:11) conn, :isclient isClient, :handshakestatus handshakeStatus, :handshakemutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:35:17) handshakeMutex, :handshakeerr handshakeErr, :vers ^Int vers, :havevers haveVers, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:39:17) config, :handshakes ^Int handshakes, :didresume didResume, :ciphersuite ^Int cipherSuite, :ocspresponse ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:46:19) ocspResponse, :scts ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:47:19) scts, :peercertificates ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:48:19) peerCertificates, :verifiedchains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:51:17) verifiedChains, :servername ^String serverName, :securerenegotiation secureRenegotiation, :ekm ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/conn.go:59:6) ekm, :clientfinishedisfirst clientFinishedIsFirst, :closenotifyerr closeNotifyErr, :closenotifysent closeNotifySent, :clientfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:77:17) clientFinished, :serverfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:78:17) serverFinished, :clientprotocol ^String clientProtocol, :clientprotocolfallback clientProtocolFallback, :in in, :out out, :rawinput ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:85:12) rawInput, :input ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:86:12) input, :hand ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:87:12) hand, :buffering buffering, :sendbuf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:89:12) sendBuf, :bytessent bytesSent, :packetssent packetsSent, :warncount ^Int warnCount, :activecall activeCall, :tmp ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:105:6) tmp} Error] Dial
;;   "Dial connects to the given network address using net.Dial\nand then initiates a TLS handshake, returning the resulting\nTLS connection.\nDial interprets a nil configuration as equivalent to\nthe zero configuration; see the documentation of Config\nfor the defaults.\n"
;;   {:added "1.0"
;;    :go "dial(network, addr, config)"}
;;   [^String network, ^String addr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:169:40) config])

JOKER FUNC tls.DialWithDialer has:
;; (defn ^[{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:27:11) conn, :isclient isClient, :handshakestatus handshakeStatus, :handshakemutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:35:17) handshakeMutex, :handshakeerr handshakeErr, :vers ^Int vers, :havevers haveVers, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:39:17) config, :handshakes ^Int handshakes, :didresume didResume, :ciphersuite ^Int cipherSuite, :ocspresponse ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:46:19) ocspResponse, :scts ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:47:19) scts, :peercertificates ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:48:19) peerCertificates, :verifiedchains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:51:17) verifiedChains, :servername ^String serverName, :securerenegotiation secureRenegotiation, :ekm ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/conn.go:59:6) ekm, :clientfinishedisfirst clientFinishedIsFirst, :closenotifyerr closeNotifyErr, :closenotifysent closeNotifySent, :clientfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:77:17) clientFinished, :serverfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:78:17) serverFinished, :clientprotocol ^String clientProtocol, :clientprotocolfallback clientProtocolFallback, :in in, :out out, :rawinput ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:85:12) rawInput, :input ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:86:12) input, :hand ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:87:12) hand, :buffering buffering, :sendbuf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:89:12) sendBuf, :bytessent bytesSent, :packetssent packetsSent, :warncount ^Int warnCount, :activecall activeCall, :tmp ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:105:6) tmp} Error] DialWithDialer
;;   "DialWithDialer connects to the given network address using dialer.Dial and\nthen initiates a TLS handshake, returning the resulting TLS connection. Any\ntimeout or deadline given in the dialer apply to connection and TLS\nhandshake as a whole.\n\nDialWithDialer interprets a nil configuration as equivalent to the zero\nconfiguration; see the documentation of Config for the defaults.\n"
;;   {:added "1.0"
;;    :go "dialWithDialer(dialer, network, addr, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:98:28) dialer, ^String network, ^String addr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:98:70) config])

JOKER FUNC tls.Listen has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:74:53) Error] Listen
;;   "Listen creates a TLS listener accepting connections on the\ngiven network address using net.Listen.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n"
;;   {:added "1.0"
;;    :go "listen(network, laddr, config)"}
;;   [^String network, ^String laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:74:43) config])

JOKER FUNC tls.LoadX509KeyPair has:
;; (defn ^[{:certificate ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/common.go:807:14) Certificate, :privatekey ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:813:13) PrivateKey, :ocspstaple ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/common.go:816:13) OCSPStaple, :signedcertificatetimestamps ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/common.go:819:30) SignedCertificateTimestamps, :leaf ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/common.go:824:7) Leaf} Error] LoadX509KeyPair
;;   "LoadX509KeyPair reads and parses a public/private key pair from a pair\nof files. The files must contain PEM encoded data. The certificate file\nmay contain intermediate certificates following the leaf certificate to\nform a certificate chain. On successful return, Certificate.Leaf will\nbe nil because the parsed form of the certificate is not retained.\n"
;;   {:added "1.0"
;;    :go "loadX509KeyPair(certFile, keyFile)"}
;;   [^String certFile, ^String keyFile])

JOKER FUNC tls.NewLRUClientSessionCache has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/tls/common.go:215:25) NewLRUClientSessionCache
;;   "NewLRUClientSessionCache returns a ClientSessionCache with the given\ncapacity that uses an LRU strategy. If capacity is < 1, a default capacity\nis used instead.\n"
;;   {:added "1.0"
;;    :go "newLRUClientSessionCache(capacity)"}
;;   [^Int capacity])

JOKER FUNC tls.NewListener has:
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:63:54) NewListener
;;   "NewListener creates a Listener which accepts connections from an inner\nListener and wraps each connection with Server.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n"
;;   {:added "1.0"
;;    :go "newListener(inner, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:63:24) inner, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:63:45) config])

JOKER FUNC tls.Server has:
;; (defn ^{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:27:11) conn, :isclient isClient, :handshakestatus handshakeStatus, :handshakemutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:35:17) handshakeMutex, :handshakeerr handshakeErr, :vers ^Int vers, :havevers haveVers, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:39:17) config, :handshakes ^Int handshakes, :didresume didResume, :ciphersuite ^Int cipherSuite, :ocspresponse ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:46:19) ocspResponse, :scts ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:47:19) scts, :peercertificates ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:48:19) peerCertificates, :verifiedchains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:51:17) verifiedChains, :servername ^String serverName, :securerenegotiation secureRenegotiation, :ekm ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/tls/conn.go:59:6) ekm, :clientfinishedisfirst clientFinishedIsFirst, :closenotifyerr closeNotifyErr, :closenotifysent closeNotifySent, :clientfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:77:17) clientFinished, :serverfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:78:17) serverFinished, :clientprotocol ^String clientProtocol, :clientprotocolfallback clientProtocolFallback, :in in, :out out, :rawinput ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:85:12) rawInput, :input ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/conn.go:86:12) input, :hand ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/conn.go:87:12) hand, :buffering buffering, :sendbuf ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:89:12) sendBuf, :bytessent bytesSent, :packetssent packetsSent, :warncount ^Int warnCount, :activecall activeCall, :tmp ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/conn.go:105:6) tmp} Server
;;   "Server returns a new TLS server side connection\nusing conn as the underlying transport.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n"
;;   {:added "1.0"
;;    :go "server(conn, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/tls.go:31:18) conn, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/tls.go:31:35) config])

JOKER FUNC tls.X509KeyPair has:
;; (defn ^[{:certificate ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/common.go:807:14) Certificate, :privatekey ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/tls/common.go:813:13) PrivateKey, :ocspstaple ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/common.go:816:13) OCSPStaple, :signedcertificatetimestamps ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/common.go:819:30) SignedCertificateTimestamps, :leaf ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/tls/common.go:824:7) Leaf} Error] X509KeyPair
;;   "X509KeyPair parses a public/private key pair from a pair of\nPEM encoded data. On successful return, Certificate.Leaf will be nil because\nthe parsed form of the certificate is not retained.\n"
;;   {:added "1.0"
;;    :go "x509KeyPair(certPEMBlock, keyPEMBlock)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/tls.go:193:44) certPEMBlock, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/tls/tls.go:193:44) keyPEMBlock])

JOKER FUNC token.Lookup has:
(defn ^Int Lookup
  "Lookup maps an identifier to its keyword token or IDENT (if not a keyword).\n"
  {:added "1.0"
   :go "lookup(ident)"}
  [^String ident])

JOKER FUNC token.NewFileSet has:
;; (defn ^{:mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/token/position.go:353:8) mutex, :base ^Int base, :files ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/token/position.go:355:8) files, :last ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/token/position.go:356:8) last} NewFileSet
;;   "NewFileSet creates a new file set.\n"
;;   {:added "1.0"
;;    :go "newFileSet()"}
;;   [])

JOKER FUNC trace.IsEnabled has:
;; (defn ^ABEND042(cannot find typename trace.bool) IsEnabled
;;   "IsEnabled returns whether tracing is enabled.\nThe information is advisory only. The tracing status\nmay have changed by the time this function returns.\n"
;;   {:added "1.0"
;;    :go "isEnabled()"}
;;   [])

JOKER FUNC trace.Log has:
;; (defn Log
;;   "Log emits a one-off event with the given category and message.\nCategory can be empty and the API assumes there are only a handful of\nunique categories in the system.\n"
;;   {:added "1.0"
;;    :go "log(ctx, category, message)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:91:14) ctx, ^String category, ^String message])

JOKER FUNC trace.Logf has:
;; (defn Logf
;;   "Logf is like Log, but the value is formatted using the specified format spec.\n"
;;   {:added "1.0"
;;    :go "logf(ctx, category, format, args)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:97:15) ctx, ^String category, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/runtime/trace/annotation.go:97:62) args])

JOKER FUNC trace.NewTask has:
;; (defn ^[ctx task] NewTask
;;   "NewTask creates a task instance with the type taskType and returns\nit along with a Context that carries the task.\nIf the input context contains a task, the new task is its subtask.\n\nThe taskType is used to classify task instances. Analysis tools\nlike the Go execution tracer may assume there are only a bounded\nnumber of unique task types in the system.\n\nThe returned end function is used to mark the task's end.\nThe trace tool measures task latency as the time between task creation\nand when the end function is called, and provides the latency\ndistribution per task type.\nIf the end function is called multiple times, only the first\ncall is used in the latency measurement.\n\n  ctx, task := trace.NewTask(ctx, \"awesomeTask\")\n  trace.WithRegion(ctx, \"preparation\", prepWork)\n  // preparation of the task\n  go func() {  // continue processing the task in a separate goroutine.\n      defer task.End()\n      trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n  }()\n"
;;   {:added "1.0"
;;    :go "newTask(pctx, taskType)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:34:19) pctx, ^String taskType])

JOKER FUNC trace.Start has:
;; (defn ^Error Start
;;   "Start enables tracing for the current program.\nWhile tracing, the trace will be buffered and written to w.\nStart returns an error if tracing is already enabled.\n"
;;   {:added "1.0"
;;    :go "start(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/trace.go:120:14) w])

JOKER FUNC trace.StartRegion has:
;; (defn ^{:id id, :regiontype ^String regionType} StartRegion
;;   "StartRegion starts a region and returns a function for marking the\nend of the region. The returned Region's End function must be called\nfrom the same goroutine where the region was started.\nWithin each goroutine, regions must nest. That is, regions started\nafter this region must be ended before this region can be ended.\nRecommended usage is\n\n    defer trace.StartRegion(ctx, \"myTracedRegion\").End()\n"
;;   {:added "1.0"
;;    :go "startRegion(ctx, regionType)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:149:22) ctx, ^String regionType])

JOKER FUNC trace.Stop has:
;; (defn Stop
;;   "Stop stops the current tracing, if any.\nStop only returns after all the writes for the trace have completed.\n"
;;   {:added "1.0"
;;    :go "stop()"}
;;   [])

JOKER FUNC trace.WithRegion has:
;; (defn WithRegion
;;   "WithRegion starts a region associated with its calling goroutine, runs fn,\nand then ends the region. If the context carries a task, the region is\nassociated with the task. Otherwise, the region is attached to the background\ntask.\n\nThe regionType is used to classify regions, so there should be only a\nhandful of unique region types.\n"
;;   {:added "1.0"
;;    :go "withRegion(ctx, regionType, fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:118:21) ctx, ^String regionType, ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/trace/annotation.go:118:60) fn])

JOKER FUNC transform.Append has:
;; (defn ^[result n err] Append
;;   "Append appends the result of converting src[:n] using t to dst, where\nn <= len(src), If err == nil, n will be len(src). It calls Reset on t.\n"
;;   {:added "1.0"
;;    :go "append(t, dst, src)"}
;;   [t, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:681:37) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:681:37) src])

JOKER FUNC transform.Bytes has:
;; (defn ^[result n err] Bytes
;;   "Bytes returns a new byte slice with the result of converting b[:n] using t,\nwhere n <= len(b). If err == nil, n will be len(b). It calls Reset on t.\n"
;;   {:added "1.0"
;;    :go "bytes(t, b)"}
;;   [t, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:675:29) b])

JOKER FUNC transform.Chain has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:43:18) Chain
;;   "Chain returns a Transformer that applies t in sequence.\n"
;;   {:added "1.0"
;;    :go "chain(t)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:380:14) t])

JOKER FUNC transform.NewReader has:
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:113:6) r, :t t, :err err, :dst ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:119:13) dst, :dst0 ^Int dst0, :dst1 ^Int dst1, :src ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:124:13) src, :src0 ^Int src0, :src1 ^Int src1, :transformcomplete transformComplete} NewReader
;;   "NewReader returns a new Reader that wraps r by transforming the bytes read\nvia t. It calls Reset on t.\n"
;;   {:added "1.0"
;;    :go "newReader(r, t)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:136:18) r, t])

JOKER FUNC transform.NewWriter has:
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:212:6) w, :t t, :dst ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:214:6) dst, :src ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:217:6) src, :n ^Int n} NewWriter
;;   "NewWriter returns a new Writer that wraps w by transforming the bytes written\nvia t. It calls Reset on t.\n"
;;   {:added "1.0"
;;    :go "newWriter(w, t)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:223:18) w, t])

JOKER FUNC transform.RemoveFunc has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:43:18) RemoveFunc
;;   "Deprecated: use runes.Remove instead.\n"
;;   {:added "1.0"
;;    :go "removeFunc(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/vendor/golang_org/x/text/transform/transform.go:499:19) f])

JOKER FUNC transform.String has:
(defn ^[result n err] String
  "String returns a string with the result of converting s[:n] using t, where\nn <= len(s). If err == nil, n will be len(s). It calls Reset on t.\n"
  {:added "1.0"
   :go "string(t, s)"}
  [t, ^String s])

JOKER FUNC types.AssertableTo has:
;; (defn ^ABEND042(cannot find typename types.bool) AssertableTo
;;   "AssertableTo reports whether a value of type V can be asserted to have type T.\n"
;;   {:added "1.0"
;;    :go "assertableTo(V, T)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/api.go:355:21) V, T])

JOKER FUNC types.AssignableTo has:
;; (defn ^ABEND042(cannot find typename types.bool) AssignableTo
;;   "AssignableTo reports whether a value of type V is assignable to a variable of type T.\n"
;;   {:added "1.0"
;;    :go "assignableTo(V, T)"}
;;   [V, T])

JOKER FUNC types.Comparable has:
;; (defn ^ABEND042(cannot find typename types.bool) Comparable
;;   "Comparable reports whether values of type T are comparable.\n"
;;   {:added "1.0"
;;    :go "comparable(T)"}
;;   [T])

JOKER FUNC types.ConvertibleTo has:
;; (defn ^ABEND042(cannot find typename types.bool) ConvertibleTo
;;   "ConvertibleTo reports whether a value of type V is convertible to a value of type T.\n"
;;   {:added "1.0"
;;    :go "convertibleTo(V, T)"}
;;   [V, T])

JOKER FUNC types.DefPredeclaredTestFuncs has:
;; (defn DefPredeclaredTestFuncs
;;   "DefPredeclaredTestFuncs defines the assert and trace built-ins.\nThese built-ins are intended for debugging and testing of this\npackage only.\n"
;;   {:added "1.0"
;;    :go "defPredeclaredTestFuncs()"}
;;   [])

JOKER FUNC types.Default has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/type.go:11:11) Default
;;   "Default returns the default \"typed\" type for an \"untyped\" type;\nit returns the incoming type for all other types. The default type\nfor untyped nil is untyped nil.\n"
;;   {:added "1.0"
;;    :go "default(typ)"}
;;   [typ])

JOKER FUNC types.Eval has:
;; (defn ^[_ err] Eval
;;   "Eval returns the type and, if constant, the value for the\nexpression expr, evaluated at position pos of package pkg,\nwhich must have been derived from type-checking an AST with\ncomplete position information relative to the provided file\nset.\n\nIf pkg == nil, the Universe scope is used and the provided\nposition pos is ignored. If pkg != nil, and pos is invalid,\nthe package scope is used. Otherwise, pos must belong to the\npackage.\n\nAn error is returned if pos is not within the package or\nif the node cannot be evaluated.\n\nNote: Eval should not be used instead of running Check to compute\ntypes and values, but in addition to Check. Eval will re-evaluate\nits argument each time, and it also does not know about the context\nin which an expression is used (e.g., an assignment). Thus, top-\nlevel untyped constants will return an untyped type rather then the\nrespective context-specific type.\n"
;;   {:added "1.0"
;;    :go "eval(fset, pkg, pos, expr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/eval.go:34:16) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/eval.go:34:36) pkg, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/eval.go:34:50) pos, ^String expr])

JOKER FUNC types.ExprString has:
;; (defn ^String ExprString
;;   "ExprString returns the (possibly shortened) string representation for x.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n"
;;   {:added "1.0"
;;    :go "exprString(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/exprstring.go:17:19) x])

JOKER FUNC types.Id has:
;; (defn ^String Id
;;   "Id returns name if it is exported, otherwise it\nreturns the name qualified with the package path.\n"
;;   {:added "1.0"
;;    :go "id(pkg, name)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:61:13) pkg, ^String name])

JOKER FUNC types.Identical has:
;; (defn ^ABEND042(cannot find typename types.bool) Identical
;;   "Identical reports whether x and y are identical types.\nReceivers of Signature types are ignored.\n"
;;   {:added "1.0"
;;    :go "identical(x, y)"}
;;   [x, y])

JOKER FUNC types.IdenticalIgnoreTags has:
;; (defn ^ABEND042(cannot find typename types.bool) IdenticalIgnoreTags
;;   "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.\nReceivers of Signature types are ignored.\n"
;;   {:added "1.0"
;;    :go "identicalIgnoreTags(x, y)"}
;;   [x, y])

JOKER FUNC types.Implements has:
;; (defn ^ABEND042(cannot find typename types.bool) Implements
;;   "Implements reports whether type V implements interface T.\n"
;;   {:added "1.0"
;;    :go "implements(V, T)"}
;;   [V, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/api.go:373:27) T])

JOKER FUNC types.IsInterface has:
;; (defn ^ABEND042(cannot find typename types.bool) IsInterface
;;   "IsInterface reports whether typ is an interface type.\n"
;;   {:added "1.0"
;;    :go "isInterface(typ)"}
;;   [typ])

JOKER FUNC types.LookupFieldOrMethod has:
;; (defn ^[obj index indirect] LookupFieldOrMethod
;;   "LookupFieldOrMethod looks up a field or method with given package and name\nin T and returns the corresponding *Var or *Func, an index sequence, and a\nbool indicating if there were any pointer indirections on the path to the\nfield or method. If addressable is set, T is the type of an addressable\nvariable (only matters for method lookups).\n\nThe last index entry is the field or method index in the (possibly embedded)\ntype where the entry was found, either:\n\n\t1) the list of declared methods of a named type; or\n\t2) the list of all methods (method set) of an interface type; or\n\t3) the list of fields of a struct type.\n\nThe earlier index entries are the indices of the embedded struct fields\ntraversed to get to the found entry, starting at depth 0.\n\nIf no entry is found, a nil object is returned. In this case, the returned\nindex and indirect values have the following meaning:\n\n\t- If index != nil, the index sequence points to an ambiguous entry\n\t(the same name appeared more than once at the same embedding level).\n\n\t- If indirect is set, a method with a pointer receiver type was found\n     but there was no pointer on the path from the actual receiver type to\n\tthe method's formal receiver base type, nor was the receiver addressable.\n"
;;   {:added "1.0"
;;    :go "lookupFieldOrMethod(T, addressable, pkg, name)"}
;;   [T, addressable, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/lookup.go:35:56) pkg, ^String name])

JOKER FUNC types.MissingMethod has:
;; (defn ^[method wrongType] MissingMethod
;;   "MissingMethod returns (nil, false) if V implements T, otherwise it\nreturns a missing method required by T and whether it is missing or\njust has the wrong type.\n\nFor non-interface types V, or if static is set, V implements T if all\nmethods of T are present in V. Otherwise (V is an interface and static\nis not set), MissingMethod only checks that methods of T which are also\npresent in V have matching types (e.g., for a type assertion x.(T) where\nx is of interface type V).\n"
;;   {:added "1.0"
;;    :go "missingMethod(V, T, static)"}
;;   [V, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/lookup.go:250:30) T, static])

JOKER FUNC types.NewArray has:
(defn ^{:len len, :elem elem} NewArray
  "NewArray returns a new array type for the given element type and length.\nA negative length indicates an unknown length.\n"
  {:added "1.0"
   :go "newArray(elem, len)"}
  [elem, len])

JOKER FUNC types.NewChan has:
(defn ^{:dir dir, :elem elem} NewChan
  "NewChan returns a new channel type for the given direction and element type.\n"
  {:added "1.0"
   :go "newChan(dir, elem)"}
  [dir, elem])

JOKER FUNC types.NewChecker has:
;; (defn ^{:conf ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:75:7) conf, :fset ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:76:7) fset, :pkg ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:77:7) pkg, :objmap ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:79:9) objMap, :impmap ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:80:9) impMap, :files ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/check.go:85:19) files, :unuseddotimports ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:86:19) unusedDotImports, :firsterr firstErr, :methods ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:89:13) methods, :interfaces ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:90:13) interfaces, :untyped ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/check.go:91:13) untyped, :delayed ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/check.go:92:13) delayed, :objpath ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/check.go:93:13) objPath, :indent ^Int indent} NewChecker
;;   "NewChecker returns a new Checker instance for a given package.\nPackage files may be added incrementally via checker.Files.\n"
;;   {:added "1.0"
;;    :go "newChecker(conf, fset, pkg, info)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:22) conf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:36) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:56) pkg, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/check.go:170:71) info])

JOKER FUNC types.NewConst has:
;; (defn ^{:val ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:200:6) val} NewConst
;;   "NewConst returns a new constant with value val.\nThe remaining arguments set the attributes found with all Objects.\n"
;;   {:added "1.0"
;;    :go "newConst(pos, pkg, name, typ, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:205:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:205:34) pkg, ^String name, typ, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:205:71) val])

JOKER FUNC types.NewField has:
;; (defn ^{:embedded embedded, :isfield isField, :used used} NewField
;;   "NewField returns a new variable representing a struct field.\nFor embedded fields, the name is the unqualified type name\n/ under which the field is accessible.\n"
;;   {:added "1.0"
;;    :go "newField(pos, pkg, name, typ, embedded)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:276:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:276:34) pkg, ^String name, typ, embedded])

JOKER FUNC types.NewFunc has:
;; (defn ^{} NewFunc
;;   "NewFunc returns a new function with the given signature, representing\nthe function's type.\n"
;;   {:added "1.0"
;;    :go "newFunc(pos, pkg, name, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:301:18) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:301:33) pkg, ^String name, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:301:60) sig])

JOKER FUNC types.NewInterface has:
;; (defn ^{:methods ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:245:12) methods, :embeddeds ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:246:12) embeddeds, :allmethods ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:248:13) allMethods} NewInterface
;;   "NewInterface returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type.\nNewInterface takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nDeprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types\nto be embedded. This is necessary for interfaces that embed alias type names referring to\nnon-defined (literal) interface types.\n"
;;   {:added "1.0"
;;    :go "newInterface(methods, embeddeds)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:266:27) methods, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:266:46) embeddeds])

JOKER FUNC types.NewInterfaceType has:
;; (defn ^{:methods ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:245:12) methods, :embeddeds ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:246:12) embeddeds, :allmethods ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:248:13) allMethods} NewInterfaceType
;;   "NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type (this property is not\nverified for defined types, which may be in the process of being set up and which don't\nhave a valid underlying type yet).\nNewInterfaceType takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n"
;;   {:added "1.0"
;;    :go "newInterfaceType(methods, embeddeds)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:280:31) methods, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:280:50) embeddeds])

JOKER FUNC types.NewLabel has:
;; (defn ^{:used used} NewLabel
;;   "NewLabel returns a new label.\n"
;;   {:added "1.0"
;;    :go "newLabel(pos, pkg, name)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:331:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:331:34) pkg, ^String name])

JOKER FUNC types.NewMap has:
(defn ^{:key key, :elem elem} NewMap
  "NewMap returns a new map for the given key and element types.\n"
  {:added "1.0"
   :go "newMap(key, elem)"}
  [key, elem])

JOKER FUNC types.NewMethodSet has:
;; (defn ^{:list ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/methodset.go:19:7) list} NewMethodSet
;;   "NewMethodSet returns the method set for the given type T.\nIt always returns a non-nil method set, even if it is empty.\n"
;;   {:added "1.0"
;;    :go "newMethodSet(T)"}
;;   [T])

JOKER FUNC types.NewNamed has:
;; (defn ^{:obj ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:425:13) obj, :underlying underlying, :methods ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:427:13) methods} NewNamed
;;   "NewNamed returns a new named type for the given type name, underlying type, and associated methods.\nIf the given type name obj doesn't have a type yet, its type is set to the returned named type.\nThe underlying type must not be a *Named.\n"
;;   {:added "1.0"
;;    :go "newNamed(obj, underlying, methods)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:433:19) obj, underlying, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:433:55) methods])

JOKER FUNC types.NewPackage has:
;; (defn ^{:path ^String path, :name ^String name, :scope ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/package.go:16:11) scope, :complete complete, :imports ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/package.go:18:11) imports, :fake fake} NewPackage
;;   "NewPackage returns a new Package for the given package path and name.\nThe package is not complete and contains no explicit imports.\n"
;;   {:added "1.0"
;;    :go "newPackage(path, name)"}
;;   [^String path, ^String name])

JOKER FUNC types.NewParam has:
;; (defn ^{:embedded embedded, :isfield isField, :used used} NewParam
;;   "NewParam returns a new variable representing a function parameter.\n"
;;   {:added "1.0"
;;    :go "newParam(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:269:19) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:269:34) pkg, ^String name, typ])

JOKER FUNC types.NewPkgName has:
;; (defn ^{:imported ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:183:11) imported, :used used} NewPkgName
;;   "NewPkgName returns a new PkgName object representing an imported package.\nThe remaining arguments set the attributes found with all Objects.\n"
;;   {:added "1.0"
;;    :go "newPkgName(pos, pkg, name, imported)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:189:21) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:189:36) pkg, ^String name, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:189:68) imported])

JOKER FUNC types.NewPointer has:
(defn ^{:base base} NewPointer
  "NewPointer returns a new pointer type for the given element (base) type.\n"
  {:added "1.0"
   :go "newPointer(elem)"}
  [elem])

JOKER FUNC types.NewScope has:
;; (defn ^{:parent ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/scope.go:26:11) parent, :children ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/scope.go:27:11) children, :elems ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/go/types/scope.go:28:11) elems, :pos ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11) pos, :end ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:29:11) end, :comment ^String comment, :isfunc isFunc} NewScope
;;   "NewScope returns a new, empty scope contained in the given parent\nscope, if any. The comment is for debugging only.\n"
;;   {:added "1.0"
;;    :go "newScope(parent, pos, end, comment)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/scope.go:36:22) parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:36:39) pos, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/scope.go:36:39) end, ^String comment])

JOKER FUNC types.NewSignature has:
;; (defn ^{:scope ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:202:11) scope, :recv ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:203:11) recv, :params ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:204:11) params, :results ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:205:11) results, :variadic variadic} NewSignature
;;   "NewSignature returns a new function type for the given receiver, parameters,\nand results, either of which may be nil. If variadic is set, the function\nis variadic, it must have at least one parameter, and the last parameter\nmust be of unnamed slice type.\n"
;;   {:added "1.0"
;;    :go "newSignature(recv, params, results, variadic)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:213:24) recv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:213:46) params, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/type.go:213:46) results, variadic])

JOKER FUNC types.NewSlice has:
(defn ^{:elem elem} NewSlice
  "NewSlice returns a new slice type for the given element type.\n"
  {:added "1.0"
   :go "newSlice(elem)"}
  [elem])

JOKER FUNC types.NewStruct has:
;; (defn ^{:fields ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:123:9) fields, :tags ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:124:9) tags} NewStruct
;;   "NewStruct returns a new struct with the given fields and corresponding field tags.\nIf a field with index i has a tag, tags[i] must be that tag, but len(tags) may be\nonly as long as required to hold the tag with the largest index i. Consequently,\nif no field has a tag, tags may be nil.\n"
;;   {:added "1.0"
;;    :go "newStruct(fields, tags)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:131:23) fields, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:131:36) tags])

JOKER FUNC types.NewTuple has:
;; (defn ^{:vars ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/go/types/type.go:173:7) vars} NewTuple
;;   "NewTuple returns a new tuple for the given variables.\n"
;;   {:added "1.0"
;;    :go "newTuple(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/go/types/type.go:177:17) x])

JOKER FUNC types.NewTypeName has:
;; (defn ^{} NewTypeName
;;   "NewTypeName returns a new type name denoting the given typ.\nThe remaining arguments set the attributes found with all Objects.\n\nThe typ argument may be a defined (Named) type or an alias type.\nIt may also be nil such that the returned TypeName can be used as\nargument for NewNamed, which will set the TypeName's type as a side-\neffect.\n"
;;   {:added "1.0"
;;    :go "newTypeName(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:226:22) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:226:37) pkg, ^String name, typ])

JOKER FUNC types.NewVar has:
;; (defn ^{:embedded embedded, :isfield isField, :used used} NewVar
;;   "NewVar returns a new variable.\nThe arguments set the attributes found with all Objects.\n"
;;   {:added "1.0"
;;    :go "newVar(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/object.go:264:17) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/object.go:264:32) pkg, ^String name, typ])

JOKER FUNC types.ObjectString has:
(defn ^String ObjectString
  "ObjectString returns the string form of obj.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n"
  {:added "1.0"
   :go "objectString(obj, qf)"}
  [obj, qf])

JOKER FUNC types.RelativeTo has:
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/types/typestring.go:25:16) RelativeTo
;;   "RelativeTo(pkg) returns a Qualifier that fully qualifies members of\nall packages other than pkg.\n"
;;   {:added "1.0"
;;    :go "relativeTo(pkg)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:29:21) pkg])

JOKER FUNC types.SelectionString has:
;; (defn ^String SelectionString
;;   "SelectionString returns the string form of s.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nExamples:\n\t\"field (T) f int\"\n\t\"method (T) f(X) Y\"\n\t\"method expr (T) f(X) Y\"\n"
;;   {:added "1.0"
;;    :go "selectionString(s, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/selection.go:119:24) s, qf])

JOKER FUNC types.SizesFor has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/go/types/sizes.go:10:12) SizesFor
;;   "SizesFor returns the Sizes used by a compiler for an architecture.\nThe result is nil if a compiler/architecture pair is not known.\n\nSupported architectures for compiler \"gc\":\n\"386\", \"arm\", \"arm64\", \"amd64\", \"amd64p32\", \"mips\", \"mipsle\",\n\"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"wasm\".\n"
;;   {:added "1.0"
;;    :go "sizesFor(compiler, arch)"}
;;   [^String compiler, ^String arch])

JOKER FUNC types.TypeString has:
(defn ^String TypeString
  "TypeString returns the string representation of typ.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n"
  {:added "1.0"
   :go "typeString(typ, qf)"}
  [typ, qf])

JOKER FUNC types.WriteExpr has:
;; (defn WriteExpr
;;   "WriteExpr writes the (possibly shortened) string representation for x to buf.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n"
;;   {:added "1.0"
;;    :go "writeExpr(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/exprstring.go:26:20) buf, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/exprstring.go:26:37) x])

JOKER FUNC types.WriteSignature has:
;; (defn WriteSignature
;;   "WriteSignature writes the representation of the signature sig to buf,\nwithout a leading \"func\" keyword.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n"
;;   {:added "1.0"
;;    :go "writeSignature(buf, sig, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:285:25) buf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:285:44) sig, qf])

JOKER FUNC types.WriteType has:
;; (defn WriteType
;;   "WriteType writes the string representation of typ to buf.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n"
;;   {:added "1.0"
;;    :go "writeType(buf, typ, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:74:20) buf, typ, qf])

JOKER FUNC unicode.In has:
;; (defn ^ABEND042(cannot find typename unicode.bool) In
;;   "In reports whether the rune is a member of one of the ranges.\n"
;;   {:added "1.0"
;;    :go "in(r, ranges)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/unicode/graphic.go:69:24) ranges])

JOKER FUNC unicode.Is has:
;; (defn ^ABEND042(cannot find typename unicode.bool) Is
;;   "Is reports whether the rune is in the specified table of ranges.\n"
;;   {:added "1.0"
;;    :go "is(rangeTab, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/unicode/letter.go:158:18) rangeTab, r])

JOKER FUNC unicode.IsControl has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsControl
;;   "IsControl reports whether the rune is a control character.\nThe C (Other) Unicode category includes more code points\nsuch as surrogates; use Is(C, r) to test for them.\n"
;;   {:added "1.0"
;;    :go "isControl(r)"}
;;   [r])

JOKER FUNC unicode.IsDigit has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsDigit
;;   "IsDigit reports whether the rune is a decimal digit.\n"
;;   {:added "1.0"
;;    :go "isDigit(r)"}
;;   [r])

JOKER FUNC unicode.IsGraphic has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode.\nSuch characters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, Zs.\n"
;;   {:added "1.0"
;;    :go "isGraphic(r)"}
;;   [r])

JOKER FUNC unicode.IsLetter has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsLetter
;;   "IsLetter reports whether the rune is a letter (category L).\n"
;;   {:added "1.0"
;;    :go "isLetter(r)"}
;;   [r])

JOKER FUNC unicode.IsLower has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsLower
;;   "IsLower reports whether the rune is a lower case letter.\n"
;;   {:added "1.0"
;;    :go "isLower(r)"}
;;   [r])

JOKER FUNC unicode.IsMark has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsMark
;;   "IsMark reports whether the rune is a mark character (category M).\n"
;;   {:added "1.0"
;;    :go "isMark(r)"}
;;   [r])

JOKER FUNC unicode.IsNumber has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsNumber
;;   "IsNumber reports whether the rune is a number (category N).\n"
;;   {:added "1.0"
;;    :go "isNumber(r)"}
;;   [r])

JOKER FUNC unicode.IsOneOf has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsOneOf
;;   "IsOneOf reports whether the rune is a member of one of the ranges.\nThe function \"In\" provides a nicer signature and should be used in preference to IsOneOf.\n"
;;   {:added "1.0"
;;    :go "isOneOf(ranges, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/graphic.go:59:21) ranges, r])

JOKER FUNC unicode.IsPrint has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and the\nASCII space character, from categories L, M, N, P, S and the ASCII space\ncharacter. This categorization is the same as IsGraphic except that the\nonly spacing character is ASCII space, U+0020.\n"
;;   {:added "1.0"
;;    :go "isPrint(r)"}
;;   [r])

JOKER FUNC unicode.IsPunct has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsPunct
;;   "IsPunct reports whether the rune is a Unicode punctuation character\n(category P).\n"
;;   {:added "1.0"
;;    :go "isPunct(r)"}
;;   [r])

JOKER FUNC unicode.IsSpace has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsSpace
;;   "IsSpace reports whether the rune is a space character as defined\nby Unicode's White Space property; in the Latin-1 space\nthis is\n\t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\nOther definitions of spacing characters are set by category\nZ and property Pattern_White_Space.\n"
;;   {:added "1.0"
;;    :go "isSpace(r)"}
;;   [r])

JOKER FUNC unicode.IsSymbol has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsSymbol
;;   "IsSymbol reports whether the rune is a symbolic character.\n"
;;   {:added "1.0"
;;    :go "isSymbol(r)"}
;;   [r])

JOKER FUNC unicode.IsTitle has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsTitle
;;   "IsTitle reports whether the rune is a title case letter.\n"
;;   {:added "1.0"
;;    :go "isTitle(r)"}
;;   [r])

JOKER FUNC unicode.IsUpper has:
;; (defn ^ABEND042(cannot find typename unicode.bool) IsUpper
;;   "IsUpper reports whether the rune is an upper case letter.\n"
;;   {:added "1.0"
;;    :go "isUpper(r)"}
;;   [r])

JOKER FUNC unicode.SimpleFold has:
;; (defn ^ABEND042(cannot find typename unicode.rune) SimpleFold
;;   "SimpleFold iterates over Unicode code points equivalent under\nthe Unicode-defined simple case folding. Among the code points\nequivalent to rune (including rune itself), SimpleFold returns the\nsmallest rune > r if one exists, or else the smallest rune >= 0.\nIf r is not a valid Unicode code point, SimpleFold(r) returns r.\n\nFor example:\n\tSimpleFold('A') = 'a'\n\tSimpleFold('a') = 'A'\n\n\tSimpleFold('K') = 'k'\n\tSimpleFold('k') = '\\u212A' (Kelvin symbol, )\n\tSimpleFold('\\u212A') = 'K'\n\n\tSimpleFold('1') = '1'\n\n\tSimpleFold(-2) = -2\n"
;;   {:added "1.0"
;;    :go "simpleFold(r)"}
;;   [r])

JOKER FUNC unicode.To has:
;; (defn ^ABEND042(cannot find typename unicode.rune) To
;;   "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.\n"
;;   {:added "1.0"
;;    :go "to(_case, r)"}
;;   [^Int _case, r])

JOKER FUNC unicode.ToLower has:
;; (defn ^ABEND042(cannot find typename unicode.rune) ToLower
;;   "ToLower maps the rune to lower case.\n"
;;   {:added "1.0"
;;    :go "toLower(r)"}
;;   [r])

JOKER FUNC unicode.ToTitle has:
;; (defn ^ABEND042(cannot find typename unicode.rune) ToTitle
;;   "ToTitle maps the rune to title case.\n"
;;   {:added "1.0"
;;    :go "toTitle(r)"}
;;   [r])

JOKER FUNC unicode.ToUpper has:
;; (defn ^ABEND042(cannot find typename unicode.rune) ToUpper
;;   "ToUpper maps the rune to upper case.\n"
;;   {:added "1.0"
;;    :go "toUpper(r)"}
;;   [r])

JOKER FUNC unsafe.Alignof has:
;; (defn ^ABEND042(cannot find typename unsafe.uintptr) Alignof
;;   "Alignof takes an expression x of any type and returns the required alignment\nof a hypothetical variable v as if v was declared via var v = x.\nIt is the largest value m such that the address of v is always zero mod m.\nIt is the same as the value returned by reflect.TypeOf(x).Align().\nAs a special case, if a variable s is of struct type and f is a field\nwithin that struct, then Alignof(s.f) will return the required alignment\nof a field of that type within a struct. This case is the same as the\nvalue returned by reflect.TypeOf(s.f).FieldAlign().\n"
;;   {:added "1.0"
;;    :go "alignof(x)"}
;;   [x])

JOKER FUNC unsafe.Offsetof has:
;; (defn ^ABEND042(cannot find typename unsafe.uintptr) Offsetof
;;   "Offsetof returns the offset within the struct of the field represented by x,\nwhich must be of the form structValue.field. In other words, it returns the\nnumber of bytes between the start of the struct and the start of the field.\n"
;;   {:added "1.0"
;;    :go "offsetof(x)"}
;;   [x])

JOKER FUNC unsafe.Sizeof has:
;; (defn ^ABEND042(cannot find typename unsafe.uintptr) Sizeof
;;   "Sizeof takes an expression x of any type and returns the size in bytes\nof a hypothetical variable v as if v was declared via var v = x.\nThe size does not include any memory possibly referenced by x.\nFor instance, if x is a slice, Sizeof returns the size of the slice\ndescriptor, not the size of the memory referenced by the slice.\n"
;;   {:added "1.0"
;;    :go "sizeof(x)"}
;;   [x])

JOKER FUNC url.Parse has:
;; (defn ^[{:scheme ^String Scheme, :opaque ^String Opaque, :user ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/url/url.go:347:13) User, :host ^String Host, :path ^String Path, :rawpath ^String RawPath, :forcequery ForceQuery, :rawquery ^String RawQuery, :fragment ^String Fragment} Error] Parse
;;   "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n"
;;   {:added "1.0"
;;    :go "parse(rawurl)"}
;;   [^String rawurl])

JOKER FUNC url.ParseQuery has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.MapType at: ../GOSRC/net/url/url.go:804:13) Error] ParseQuery
;;   "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n"
;;   {:added "1.0"
;;    :go "parseQuery(query)"}
;;   [^String query])

JOKER FUNC url.ParseRequestURI has:
;; (defn ^[{:scheme ^String Scheme, :opaque ^String Opaque, :user ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/url/url.go:347:13) User, :host ^String Host, :path ^String Path, :rawpath ^String RawPath, :forcequery ForceQuery, :rawquery ^String RawQuery, :fragment ^String Fragment} Error] ParseRequestURI
;;   "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n"
;;   {:added "1.0"
;;    :go "parseRequestURI(rawurl)"}
;;   [^String rawurl])

JOKER FUNC url.PathEscape has:
(defn ^String PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n"
  {:added "1.0"
   :go "pathEscape(s)"}
  [^String s])

JOKER FUNC url.PathUnescape has:
(defn ^[String Error] PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n"
  {:added "1.0"
   :go "pathUnescape(s)"}
  [^String s])

JOKER FUNC url.QueryEscape has:
(defn ^String QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n"
  {:added "1.0"
   :go "queryEscape(s)"}
  [^String s])

JOKER FUNC url.QueryUnescape has:
(defn ^[String Error] QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n"
  {:added "1.0"
   :go "queryUnescape(s)"}
  [^String s])

JOKER FUNC url.User has:
(defn ^{:username ^String username, :password ^String password, :passwordset passwordSet} User
  "User returns a Userinfo containing the provided username\nand no password set.\n"
  {:added "1.0"
   :go "user(username)"}
  [^String username])

JOKER FUNC url.UserPassword has:
(defn ^{:username ^String username, :password ^String password, :passwordset passwordSet} UserPassword
  "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n"
  {:added "1.0"
   :go "userPassword(username, password)"}
  [^String username, ^String password])

JOKER FUNC user.Current has:
(defn ^[{:uid ^String Uid, :gid ^String Gid, :username ^String Username, :name ^String Name, :homedir ^String HomeDir} Error] Current
  "Current returns the current user.\n"
  {:added "1.0"
   :go "current()"}
  [])

JOKER FUNC user.Lookup has:
(defn ^[{:uid ^String Uid, :gid ^String Gid, :username ^String Username, :name ^String Name, :homedir ^String HomeDir} Error] Lookup
  "Lookup looks up a user by username. If the user cannot be found, the\nreturned error is of type UnknownUserError.\n"
  {:added "1.0"
   :go "lookup(username)"}
  [^String username])

JOKER FUNC user.LookupGroup has:
(defn ^[{:gid ^String Gid, :name ^String Name} Error] LookupGroup
  "LookupGroup looks up a group by name. If the group cannot be found, the\nreturned error is of type UnknownGroupError.\n"
  {:added "1.0"
   :go "lookupGroup(name)"}
  [^String name])

JOKER FUNC user.LookupGroupId has:
(defn ^[{:gid ^String Gid, :name ^String Name} Error] LookupGroupId
  "LookupGroupId looks up a group by groupid. If the group cannot be found, the\nreturned error is of type UnknownGroupIdError.\n"
  {:added "1.0"
   :go "lookupGroupId(gid)"}
  [^String gid])

JOKER FUNC user.LookupId has:
(defn ^[{:uid ^String Uid, :gid ^String Gid, :username ^String Username, :name ^String Name, :homedir ^String HomeDir} Error] LookupId
  "LookupId looks up a user by userid. If the user cannot be found, the\nreturned error is of type UnknownUserIdError.\n"
  {:added "1.0"
   :go "lookupId(uid)"}
  [^String uid])

JOKER FUNC utf16.Decode has:
;; (defn ^[ABEND042(cannot find typename utf16.rune)] Decode
;;   "Decode returns the Unicode code point sequence represented\nby the UTF-16 encoding s.\n"
;;   {:added "1.0"
;;    :go "decode(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf16/utf16.go:88:15) s])

JOKER FUNC utf16.DecodeRune has:
;; (defn ^ABEND042(cannot find typename utf16.rune) DecodeRune
;;   "DecodeRune returns the UTF-16 decoding of a surrogate pair.\nIf the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\nthe Unicode replacement code point U+FFFD.\n"
;;   {:added "1.0"
;;    :go "decodeRune(r1, r2)"}
;;   [r1, r2])

JOKER FUNC utf16.Encode has:
;; (defn ^[Int] Encode
;;   "Encode returns the UTF-16 encoding of the Unicode code point sequence s.\n"
;;   {:added "1.0"
;;    :go "encode(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf16/utf16.go:56:15) s])

JOKER FUNC utf16.EncodeRune has:
(defn ^[r1 r2] EncodeRune
  "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\nIf the rune is not a valid Unicode code point or does not need encoding,\nEncodeRune returns U+FFFD, U+FFFD.\n"
  {:added "1.0"
   :go "encodeRune(r)"}
  [r])

JOKER FUNC utf16.IsSurrogate has:
;; (defn ^ABEND042(cannot find typename utf16.bool) IsSurrogate
;;   "IsSurrogate reports whether the specified Unicode code point\ncan appear in a surrogate pair.\n"
;;   {:added "1.0"
;;    :go "isSurrogate(r)"}
;;   [r])

JOKER FUNC utf8.DecodeLastRune has:
;; (defn ^[r size] DecodeLastRune
;;   "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n"
;;   {:added "1.0"
;;    :go "decodeLastRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:245:23) p])

JOKER FUNC utf8.DecodeLastRuneInString has:
(defn ^[r size] DecodeLastRuneInString
  "DecodeLastRuneInString is like DecodeLastRune but its input is a string. If\ns is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\nit returns (RuneError, 1). Both are impossible results for correct,\nnon-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n"
  {:added "1.0"
   :go "decodeLastRuneInString(s)"}
  [^String s])

JOKER FUNC utf8.DecodeRune has:
;; (defn ^[r size] DecodeRune
;;   "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n"
;;   {:added "1.0"
;;    :go "decodeRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:149:19) p])

JOKER FUNC utf8.DecodeRuneInString has:
(defn ^[r size] DecodeRuneInString
  "DecodeRuneInString is like DecodeRune but its input is a string. If s is\nempty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it\nreturns (RuneError, 1). Both are impossible results for correct, non-empty\nUTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n"
  {:added "1.0"
   :go "decodeRuneInString(s)"}
  [^String s])

JOKER FUNC utf8.EncodeRune has:
;; (defn ^Int EncodeRune
;;   "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\nIt returns the number of bytes written.\n"
;;   {:added "1.0"
;;    :go "encodeRune(p, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:339:19) p, r])

JOKER FUNC utf8.FullRune has:
;; (defn ^ABEND042(cannot find typename utf8.bool) FullRune
;;   "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.\nAn invalid encoding is considered a full Rune since it will convert as a width-1 error rune.\n"
;;   {:added "1.0"
;;    :go "fullRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:102:17) p])

JOKER FUNC utf8.FullRuneInString has:
;; (defn ^ABEND042(cannot find typename utf8.bool) FullRuneInString
;;   "FullRuneInString is like FullRune but its input is a string.\n"
;;   {:added "1.0"
;;    :go "fullRuneInString(s)"}
;;   [^String s])

JOKER FUNC utf8.RuneCount has:
;; (defn ^Int RuneCount
;;   "RuneCount returns the number of runes in p. Erroneous and short\nencodings are treated as single runes of width 1 byte.\n"
;;   {:added "1.0"
;;    :go "runeCount(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:371:18) p])

JOKER FUNC utf8.RuneCountInString has:
(defn ^n RuneCountInString
  "RuneCountInString is like RuneCount but its input is a string.\n"
  {:added "1.0"
   :go "runeCountInString(s)"}
  [^String s])

JOKER FUNC utf8.RuneLen has:
(defn ^Int RuneLen
  "RuneLen returns the number of bytes required to encode the rune.\nIt returns -1 if the rune is not a valid value to encode in UTF-8.\n"
  {:added "1.0"
   :go "runeLen(r)"}
  [r])

JOKER FUNC utf8.RuneStart has:
;; (defn ^ABEND042(cannot find typename utf8.bool) RuneStart
;;   "RuneStart reports whether the byte could be the first byte of an encoded,\npossibly invalid rune. Second and subsequent bytes always have the top two\nbits set to 10.\n"
;;   {:added "1.0"
;;    :go "runeStart(b)"}
;;   [b])

JOKER FUNC utf8.Valid has:
;; (defn ^ABEND042(cannot find typename utf8.bool) Valid
;;   "Valid reports whether p consists entirely of valid UTF-8-encoded runes.\n"
;;   {:added "1.0"
;;    :go "valid(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/unicode/utf8/utf8.go:448:14) p])

JOKER FUNC utf8.ValidRune has:
;; (defn ^ABEND042(cannot find typename utf8.bool) ValidRune
;;   "ValidRune reports whether r can be legally encoded as UTF-8.\nCode points that are out of range or a surrogate half are illegal.\n"
;;   {:added "1.0"
;;    :go "validRune(r)"}
;;   [r])

JOKER FUNC utf8.ValidString has:
;; (defn ^ABEND042(cannot find typename utf8.bool) ValidString
;;   "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\n"
;;   {:added "1.0"
;;    :go "validString(s)"}
;;   [^String s])

JOKER FUNC x509.CreateCertificate has:
;; (defn ^[cert err] CreateCertificate
;;   "CreateCertificate creates a new X.509v3 certificate based on a template.\nThe following members of template are used:\n\n - AuthorityKeyId\n - BasicConstraintsValid\n - CRLDistributionPoints\n - DNSNames\n - EmailAddresses\n - ExcludedDNSDomains\n - ExcludedEmailAddresses\n - ExcludedIPRanges\n - ExcludedURIDomains\n - ExtKeyUsage\n - ExtraExtensions\n - IsCA\n - IssuingCertificateURL\n - KeyUsage\n - MaxPathLen\n - MaxPathLenZero\n - NotAfter\n - NotBefore\n - OCSPServer\n - PermittedDNSDomains\n - PermittedDNSDomainsCritical\n - PermittedEmailAddresses\n - PermittedIPRanges\n - PermittedURIDomains\n - PolicyIdentifiers\n - SerialNumber\n - SignatureAlgorithm\n - Subject\n - SubjectKeyId\n - URIs\n - UnknownExtKeyUsage\n\nThe certificate is signed by parent. If parent is equal to template then the\ncertificate is self-signed. The parameter pub is the public key of the\nsignee and priv is the private key of the signer.\n\nThe returned slice is the certificate in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nThe AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,\nunless the resulting certificate is self-signed. Otherwise the value from\ntemplate will be used.\n"
;;   {:added "1.0"
;;    :go "createCertificate(rand, template, parent, pub, priv)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2082:29) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:2082:57) template, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:2082:57) parent, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2082:81) pub, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2082:81) priv])

JOKER FUNC x509.CreateCertificateRequest has:
;; (defn ^[csr err] CreateCertificateRequest
;;   "CreateCertificateRequest creates a new certificate request based on a\ntemplate. The following members of template are used:\n\n - Attributes\n - DNSNames\n - EmailAddresses\n - ExtraExtensions\n - IPAddresses\n - URIs\n - SignatureAlgorithm\n - Subject\n\nThe private key is the private key of the signer.\n\nThe returned slice is the certificate request in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n"
;;   {:added "1.0"
;;    :go "createCertificateRequest(rand, template, priv)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2407:36) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:2407:56) template, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2407:82) priv])

JOKER FUNC x509.DecryptPEMBlock has:
;; (defn ^[[ABEND042(cannot find typename x509.byte)] Error] DecryptPEMBlock
;;   "DecryptPEMBlock takes a password encrypted PEM block and the password used to\nencrypt it and returns a slice of decrypted DER encoded bytes. It inspects\nthe DEK-Info header to determine the algorithm used for decryption. If no\nDEK-Info header is present, an error is returned. If an incorrect password\nis detected an IncorrectPasswordError is returned. Because of deficiencies\nin the encrypted-PEM format, it's not always possible to detect an incorrect\npassword. In these cases no error will be returned but the decrypted DER\nbytes will be random noise.\n"
;;   {:added "1.0"
;;    :go "decryptPEMBlock(b, password)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pem_decrypt.go:115:24) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pem_decrypt.go:115:45) password])

JOKER FUNC x509.EncryptPEMBlock has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/pem_decrypt.go:183:96) Error] EncryptPEMBlock
;;   "EncryptPEMBlock returns a PEM block of the specified type holding the\ngiven DER-encoded data encrypted with the specified algorithm and\npassword.\n"
;;   {:added "1.0"
;;    :go "encryptPEMBlock(rand, blockType, data, password, alg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/pem_decrypt.go:183:27) rand, ^String blockType, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pem_decrypt.go:183:71) data, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pem_decrypt.go:183:71) password, alg])

JOKER FUNC x509.IsEncryptedPEMBlock has:
;; (defn ^ABEND042(cannot find typename x509.bool) IsEncryptedPEMBlock
;;   "IsEncryptedPEMBlock returns if the PEM block is password encrypted.\n"
;;   {:added "1.0"
;;    :go "isEncryptedPEMBlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pem_decrypt.go:99:28) b])

JOKER FUNC x509.MarshalECPrivateKey has:
;; (defn ^[[ABEND042(cannot find typename x509.byte)] Error] MarshalECPrivateKey
;;   "MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.\n"
;;   {:added "1.0"
;;    :go "marshalECPrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/sec1.go:37:30) key])

JOKER FUNC x509.MarshalPKCS1PrivateKey has:
;; (defn ^[ABEND042(cannot find typename x509.byte)] MarshalPKCS1PrivateKey
;;   "MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n"
;;   {:added "1.0"
;;    :go "marshalPKCS1PrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pkcs1.go:92:33) key])

JOKER FUNC x509.MarshalPKCS1PublicKey has:
;; (defn ^[ABEND042(cannot find typename x509.byte)] MarshalPKCS1PublicKey
;;   "MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.\n"
;;   {:added "1.0"
;;    :go "marshalPKCS1PublicKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/pkcs1.go:148:32) key])

JOKER FUNC x509.MarshalPKCS8PrivateKey has:
;; (defn ^[[ABEND042(cannot find typename x509.byte)] Error] MarshalPKCS8PrivateKey
;;   "MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form.\nThe following key types are supported: *rsa.PrivateKey, *ecdsa.PrivateKey.\nUnsupported key types result in an error.\n\nSee RFC 5208.\n"
;;   {:added "1.0"
;;    :go "marshalPKCS8PrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/pkcs8.go:63:33) key])

JOKER FUNC x509.MarshalPKIXPublicKey has:
;; (defn ^[[ABEND042(cannot find typename x509.byte)] Error] MarshalPKIXPublicKey
;;   "MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n"
;;   {:added "1.0"
;;    :go "marshalPKIXPublicKey(pub)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:104:31) pub])

JOKER FUNC x509.NewCertPool has:
;; (defn ^{:bysubjectkeyid ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/x509/cert_pool.go:15:17) bySubjectKeyId, :byname ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/x509/cert_pool.go:16:17) byName, :certs ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/cert_pool.go:17:17) certs} NewCertPool
;;   "NewCertPool returns a new, empty CertPool.\n"
;;   {:added "1.0"
;;    :go "newCertPool()"}
;;   [])

JOKER FUNC x509.ParseCRL has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2179:34) Error] ParseCRL
;;   "ParseCRL parses a CRL from the given bytes. It's often the case that PEM\nencoded CRLs will appear where they should be DER encoded, so this function\nwill transparently handle PEM encoding as long as there isn't any leading\ngarbage.\n"
;;   {:added "1.0"
;;    :go "parseCRL(crlBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2179:24) crlBytes])

JOKER FUNC x509.ParseCertificate has:
;; (defn ^[{:raw ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:634:26) Raw, :rawtbscertificate ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:635:26) RawTBSCertificate, :rawsubjectpublickeyinfo ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:636:26) RawSubjectPublicKeyInfo, :rawsubject ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:637:26) RawSubject, :rawissuer ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:638:26) RawIssuer, :signature ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:640:21) Signature, :signaturealgorithm SignatureAlgorithm, :publickeyalgorithm PublicKeyAlgorithm, :publickey ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:644:21) PublicKey, :version ^Int Version, :serialnumber ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:647:22) SerialNumber, :issuer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:648:22) Issuer, :subject ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:649:22) Subject, :notbefore ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22) NotBefore, :notafter ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22) NotAfter, :keyusage KeyUsage, :extensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:657:13) Extensions, :extraextensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:663:18) ExtraExtensions, :unhandledcriticalextensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:673:30) UnhandledCriticalExtensions, :extkeyusage ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:675:21) ExtKeyUsage, :unknownextkeyusage ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:676:21) UnknownExtKeyUsage, :basicconstraintsvalid BasicConstraintsValid, :isca IsCA, :maxpathlen ^Int MaxPathLen, :maxpathlenzero MaxPathLenZero, :subjectkeyid ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:702:17) SubjectKeyId, :authoritykeyid ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:703:17) AuthorityKeyId, :ocspserver ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:706:24) OCSPServer, :issuingcertificateurl ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:707:24) IssuingCertificateURL, :dnsnames ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:712:17) DNSNames, :emailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:713:17) EmailAddresses, :ipaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:714:17) IPAddresses, :uris ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:715:17) URIs, :permitteddnsdomainscritical PermittedDNSDomainsCritical, :permitteddnsdomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:719:30) PermittedDNSDomains, :excludeddnsdomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:720:30) ExcludedDNSDomains, :permittedipranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:721:30) PermittedIPRanges, :excludedipranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:722:30) ExcludedIPRanges, :permittedemailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:723:30) PermittedEmailAddresses, :excludedemailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:724:30) ExcludedEmailAddresses, :permitteduridomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:725:30) PermittedURIDomains, :excludeduridomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:726:30) ExcludedURIDomains, :crldistributionpoints ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:729:24) CRLDistributionPoints, :policyidentifiers ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:731:20) PolicyIdentifiers} Error] ParseCertificate
;;   "ParseCertificate parses a single certificate from the given ASN.1 DER data.\n"
;;   {:added "1.0"
;;    :go "parseCertificate(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:1562:32) asn1Data])

JOKER FUNC x509.ParseCertificateRequest has:
;; (defn ^[{:raw ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2264:27) Raw, :rawtbscertificaterequest ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2265:27) RawTBSCertificateRequest, :rawsubjectpublickeyinfo ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2266:27) RawSubjectPublicKeyInfo, :rawsubject ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2267:27) RawSubject, :version ^Int Version, :signature ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2270:21) Signature, :signaturealgorithm SignatureAlgorithm, :publickeyalgorithm PublicKeyAlgorithm, :publickey ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:2274:21) PublicKey, :subject ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2276:10) Subject, :attributes ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2279:13) Attributes, :extensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2284:13) Extensions, :extraextensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2293:18) ExtraExtensions, :dnsnames ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2296:17) DNSNames, :emailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2297:17) EmailAddresses, :ipaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2298:17) IPAddresses, :uris ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2299:17) URIs} Error] ParseCertificateRequest
;;   "ParseCertificateRequest parses a single certificate request from the\ngiven ASN.1 DER data.\n"
;;   {:added "1.0"
;;    :go "parseCertificateRequest(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2575:39) asn1Data])

JOKER FUNC x509.ParseCertificates has:
;; (defn ^[[{:raw ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:634:26) Raw, :rawtbscertificate ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:635:26) RawTBSCertificate, :rawsubjectpublickeyinfo ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:636:26) RawSubjectPublicKeyInfo, :rawsubject ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:637:26) RawSubject, :rawissuer ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:638:26) RawIssuer, :signature ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:640:21) Signature, :signaturealgorithm SignatureAlgorithm, :publickeyalgorithm PublicKeyAlgorithm, :publickey ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/crypto/x509/x509.go:644:21) PublicKey, :version ^Int Version, :serialnumber ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/crypto/x509/x509.go:647:22) SerialNumber, :issuer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:648:22) Issuer, :subject ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:649:22) Subject, :notbefore ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22) NotBefore, :notafter ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:650:22) NotAfter, :keyusage KeyUsage, :extensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:657:13) Extensions, :extraextensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:663:18) ExtraExtensions, :unhandledcriticalextensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:673:30) UnhandledCriticalExtensions, :extkeyusage ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:675:21) ExtKeyUsage, :unknownextkeyusage ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:676:21) UnknownExtKeyUsage, :basicconstraintsvalid BasicConstraintsValid, :isca IsCA, :maxpathlen ^Int MaxPathLen, :maxpathlenzero MaxPathLenZero, :subjectkeyid ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:702:17) SubjectKeyId, :authoritykeyid ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:703:17) AuthorityKeyId, :ocspserver ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:706:24) OCSPServer, :issuingcertificateurl ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:707:24) IssuingCertificateURL, :dnsnames ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:712:17) DNSNames, :emailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:713:17) EmailAddresses, :ipaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:714:17) IPAddresses, :uris ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:715:17) URIs, :permitteddnsdomainscritical PermittedDNSDomainsCritical, :permitteddnsdomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:719:30) PermittedDNSDomains, :excludeddnsdomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:720:30) ExcludedDNSDomains, :permittedipranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:721:30) PermittedIPRanges, :excludedipranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:722:30) ExcludedIPRanges, :permittedemailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:723:30) PermittedEmailAddresses, :excludedemailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:724:30) ExcludedEmailAddresses, :permitteduridomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:725:30) PermittedURIDomains, :excludeduridomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:726:30) ExcludedURIDomains, :crldistributionpoints ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:729:24) CRLDistributionPoints, :policyidentifiers ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:731:20) PolicyIdentifiers}] Error] ParseCertificates
;;   "ParseCertificates parses one or more certificates from the given ASN.1 DER\ndata. The certificates must be concatenated with no intermediate padding.\n"
;;   {:added "1.0"
;;    :go "parseCertificates(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:1577:33) asn1Data])

JOKER FUNC x509.ParseDERCRL has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/x509.go:2190:37) Error] ParseDERCRL
;;   "ParseDERCRL parses a DER encoded CRL from the given bytes.\n"
;;   {:added "1.0"
;;    :go "parseDERCRL(derBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:2190:27) derBytes])

JOKER FUNC x509.ParseECPrivateKey has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/sec1.go:32:38) Error] ParseECPrivateKey
;;   "ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\n"
;;   {:added "1.0"
;;    :go "parseECPrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/sec1.go:32:28) der])

JOKER FUNC x509.ParsePKCS1PrivateKey has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/pkcs1.go:45:41) Error] ParsePKCS1PrivateKey
;;   "ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n"
;;   {:added "1.0"
;;    :go "parsePKCS1PrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pkcs1.go:45:31) der])

JOKER FUNC x509.ParsePKCS1PublicKey has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/crypto/x509/pkcs1.go:124:40) Error] ParsePKCS1PublicKey
;;   "ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.\n"
;;   {:added "1.0"
;;    :go "parsePKCS1PublicKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pkcs1.go:124:30) der])

JOKER FUNC x509.ParsePKCS8PrivateKey has:
;; (defn ^[key err] ParsePKCS8PrivateKey
;;   "ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key.\nSee RFC 5208.\n"
;;   {:added "1.0"
;;    :go "parsePKCS8PrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/pkcs8.go:28:31) der])

JOKER FUNC x509.ParsePKIXPublicKey has:
;; (defn ^[pub err] ParsePKIXPublicKey
;;   "ParsePKIXPublicKey parses a DER encoded public key. These values are\ntypically found in PEM blocks with \"BEGIN PUBLIC KEY\".\n\nSupported key types include RSA, DSA, and ECDSA. Unknown key\ntypes result in an error.\n\nOn success, pub will be of type *rsa.PublicKey, *dsa.PublicKey,\nor *ecdsa.PublicKey.\n"
;;   {:added "1.0"
;;    :go "parsePKIXPublicKey(derBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/x509.go:55:34) derBytes])

JOKER FUNC x509.SystemCertPool has:
;; (defn ^[{:bysubjectkeyid ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/x509/cert_pool.go:15:17) bySubjectKeyId, :byname ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/crypto/x509/cert_pool.go:16:17) byName, :certs ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/x509/cert_pool.go:17:17) certs} Error] SystemCertPool
;;   "SystemCertPool returns a copy of the system cert pool.\n\nAny mutations to the returned pool are not written to disk and do\nnot affect any other pool.\n\nNew changes in the the system cert pool might not be reflected\nin subsequent calls.\n"
;;   {:added "1.0"
;;    :go "systemCertPool()"}
;;   [])

JOKER FUNC xml.CopyToken has:
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/xml.go:55:12) CopyToken
;;   "CopyToken returns a copy of a Token.\n"
;;   {:added "1.0"
;;    :go "copyToken(t)"}
;;   [t])

JOKER FUNC xml.Escape has:
;; (defn Escape
;;   "Escape is like EscapeText but omits the error return value.\nIt is provided for backwards compatibility with Go 1.0.\nCode targeting Go 1.1 or later should use EscapeText.\n"
;;   {:added "1.0"
;;    :go "escape(w, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:1985:15) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/xml/xml.go:1985:28) s])

JOKER FUNC xml.EscapeText has:
;; (defn ^Error EscapeText
;;   "EscapeText writes to w the properly escaped XML equivalent\nof the plain text data s.\n"
;;   {:added "1.0"
;;    :go "escapeText(w, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:1891:19) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/xml/xml.go:1891:32) s])

JOKER FUNC xml.Marshal has:
;; (defn ^[[ABEND042(cannot find typename xml.byte)] Error] Marshal
;;   "Marshal returns the XML encoding of v.\n\nMarshal handles an array or slice by marshaling each of the elements.\nMarshal handles a pointer by marshaling the value it points at or, if the\npointer is nil, by writing nothing. Marshal handles an interface value by\nmarshaling the value it contains or, if the interface value is nil, by\nwriting nothing. Marshal handles all other data by writing one or more XML\nelements containing the data.\n\nThe name for the XML elements is taken from, in order of preference:\n    - the tag on the XMLName field, if the data is a struct\n    - the value of the XMLName field of type Name\n    - the tag of the struct field used to obtain the data\n    - the name of the struct field used to obtain the data\n    - the name of the marshaled type\n\nThe XML element for a struct contains marshaled elements for each of the\nexported fields of the struct, with these exceptions:\n    - the XMLName field, described above, is omitted.\n    - a field with tag \"-\" is omitted.\n    - a field with tag \"name,attr\" becomes an attribute with\n      the given name in the XML element.\n    - a field with tag \",attr\" becomes an attribute with the\n      field name in the XML element.\n    - a field with tag \",chardata\" is written as character data,\n      not as an XML element.\n    - a field with tag \",cdata\" is written as character data\n      wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.\n    - a field with tag \",innerxml\" is written verbatim, not subject\n      to the usual marshaling procedure.\n    - a field with tag \",comment\" is written as an XML comment, not\n      subject to the usual marshaling procedure. It must not contain\n      the \"--\" string within it.\n    - a field with a tag including the \"omitempty\" option is omitted\n      if the field value is empty. The empty values are false, 0, any\n      nil pointer or interface value, and any array, slice, map, or\n      string of length zero.\n    - an anonymous struct field is handled as if the fields of its\n      value were part of the outer struct.\n\nIf a field uses a tag \"a>b>c\", then the element c will be nested inside\nparent elements a and b. Fields that appear next to each other that name\nthe same parent will be enclosed in one XML element.\n\nIf the XML name for a struct field is defined by both the field tag and the\nstruct's XMLName field, the names must match.\n\nSee MarshalIndent for an example.\n\nMarshal will return an error if asked to marshal a channel, function, or map.\n"
;;   {:added "1.0"
;;    :go "marshal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/marshal.go:75:16) v])

JOKER FUNC xml.MarshalIndent has:
;; (defn ^[[ABEND042(cannot find typename xml.byte)] Error] MarshalIndent
;;   "MarshalIndent works like Marshal, but each XML element begins on a new\nindented line that starts with prefix and is followed by one or more\ncopies of indent according to the nesting depth.\n"
;;   {:added "1.0"
;;    :go "marshalIndent(v, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/marshal.go:121:22) v, ^String prefix, ^String indent])

JOKER FUNC xml.NewDecoder has:
;; (defn ^{:strict Strict, :autoclose ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/xml/xml.go:184:12) AutoClose, :entity ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/xml/xml.go:195:9) Entity, :charsetreader ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/encoding/xml/xml.go:202:16) CharsetReader, :defaultspace ^String DefaultSpace, :r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:209:17) r, :t t, :buf ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:211:17) buf, :saved ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/xml/xml.go:212:17) saved, :stk ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/xml/xml.go:213:17) stk, :free ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/xml/xml.go:214:17) free, :needclose needClose, :toclose toClose, :nexttoken nextToken, :nextbyte ^Int nextByte, :ns ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/xml/xml.go:219:17) ns, :err err, :line ^Int line, :offset offset, :unmarshaldepth ^Int unmarshalDepth} NewDecoder
;;   "NewDecoder creates a new XML parser reading from r.\nIf r does not implement io.ByteReader, NewDecoder will\ndo its own buffering.\n"
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:229:19) r])

JOKER FUNC xml.NewEncoder has:
;; (defn ^{:p p} NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n"
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/marshal.go:137:19) w])

JOKER FUNC xml.NewTokenDecoder has:
;; (defn ^{:strict Strict, :autoclose ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/xml/xml.go:184:12) AutoClose, :entity ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/xml/xml.go:195:9) Entity, :charsetreader ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/encoding/xml/xml.go:202:16) CharsetReader, :defaultspace ^String DefaultSpace, :r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:209:17) r, :t t, :buf ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:211:17) buf, :saved ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/xml/xml.go:212:17) saved, :stk ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/xml/xml.go:213:17) stk, :free ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/xml/xml.go:214:17) free, :needclose needClose, :toclose toClose, :nexttoken nextToken, :nextbyte ^Int nextByte, :ns ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/encoding/xml/xml.go:219:17) ns, :err err, :line ^Int line, :offset offset, :unmarshaldepth ^Int unmarshalDepth} NewTokenDecoder
;;   "NewTokenDecoder creates a new XML parser using an underlying token stream.\n"
;;   {:added "1.0"
;;    :go "newTokenDecoder(t)"}
;;   [t])

JOKER FUNC xml.Unmarshal has:
;; (defn ^Error Unmarshal
;;   "Unmarshal parses the XML-encoded data and stores the result in\nthe value pointed to by v, which must be an arbitrary struct,\nslice, or string. Well-formed data that does not fit into v is\ndiscarded.\n\nBecause Unmarshal uses the reflect package, it can only assign\nto exported (upper case) fields. Unmarshal uses a case-sensitive\ncomparison to match XML element names to tag values and struct\nfield names.\n\nUnmarshal maps an XML element to a struct using the following rules.\nIn the rules, the tag of a field refers to the value associated with the\nkey 'xml' in the struct field's tag (see the example above).\n\n  * If the struct has a field of type []byte or string with tag\n     \",innerxml\", Unmarshal accumulates the raw XML nested inside the\n     element in that field. The rest of the rules still apply.\n\n  * If the struct has a field named XMLName of type Name,\n     Unmarshal records the element name in that field.\n\n  * If the XMLName field has an associated tag of the form\n     \"name\" or \"namespace-URL name\", the XML element must have\n     the given name (and, optionally, name space) or else Unmarshal\n     returns an error.\n\n  * If the XML element has an attribute whose name matches a\n     struct field name with an associated tag containing \",attr\" or\n     the explicit name in a struct field tag of the form \"name,attr\",\n     Unmarshal records the attribute value in that field.\n\n  * If the XML element has an attribute not handled by the previous\n     rule and the struct has a field with an associated tag containing\n     \",any,attr\", Unmarshal records the attribute value in the first\n     such field.\n\n  * If the XML element contains character data, that data is\n     accumulated in the first struct field that has tag \",chardata\".\n     The struct field may have type []byte or string.\n     If there is no such field, the character data is discarded.\n\n  * If the XML element contains comments, they are accumulated in\n     the first struct field that has tag \",comment\".  The struct\n     field may have type []byte or string. If there is no such\n     field, the comments are discarded.\n\n  * If the XML element contains a sub-element whose name matches\n     the prefix of a tag formatted as \"a\" or \"a>b>c\", unmarshal\n     will descend into the XML structure looking for elements with the\n     given names, and will map the innermost elements to that struct\n     field. A tag starting with \">\" is equivalent to one starting\n     with the field name followed by \">\".\n\n  * If the XML element contains a sub-element whose name matches\n     a struct field's XMLName tag and the struct field has no\n     explicit name tag as per the previous rule, unmarshal maps\n     the sub-element to that struct field.\n\n  * If the XML element contains a sub-element whose name matches a\n     field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal\n     maps the sub-element to that struct field.\n\n  * If the XML element contains a sub-element that hasn't matched any\n     of the above rules and the struct has a field with tag \",any\",\n     unmarshal maps the sub-element to that struct field.\n\n  * An anonymous struct field is handled as if the fields of its\n     value were part of the outer struct.\n\n  * A struct field with tag \"-\" is never unmarshaled into.\n\nUnmarshal maps an XML element to a string or []byte by saving the\nconcatenation of that element's character data in the string or\n[]byte. The saved []byte is never nil.\n\nUnmarshal maps an attribute value to a string or []byte by saving\nthe value in the string or slice.\n\nUnmarshal maps an attribute value to an Attr by saving the attribute,\nincluding its name, in the Attr.\n\nUnmarshal maps an XML element or attribute value to a slice by\nextending the length of the slice and mapping the element or attribute\nto the newly created value.\n\nUnmarshal maps an XML element or attribute value to a bool by\nsetting it to the boolean value represented by the string. Whitespace\nis trimmed and ignored.\n\nUnmarshal maps an XML element or attribute value to an integer or\nfloating-point field by setting the field to the result of\ninterpreting the string value in decimal. There is no check for\noverflow. Whitespace is trimmed and ignored.\n\nUnmarshal maps an XML element to a Name by recording the element\nname.\n\nUnmarshal maps an XML element to a pointer by setting the pointer\nto a freshly allocated value and then mapping the element to that value.\n\nA missing element or empty attribute value will be unmarshaled as a zero value.\nIf the field is a slice, a zero value will be appended to the field. Otherwise, the\nfield will be set to its zero value.\n"
;;   {:added "1.0"
;;    :go "unmarshal(data, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/xml/read.go:127:21) data, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/xml/read.go:127:31) v])

JOKER FUNC zip.FileInfoHeader has:
;; (defn ^[{:name ^String Name, :comment ^String Comment, :nonutf8 NonUTF8, :creatorversion ^Int CreatorVersion, :readerversion ^Int ReaderVersion, :flags ^Int Flags, :method ^Int Method, :modified ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/struct.go:127:15) Modified, :modifiedtime ^Int ModifiedTime, :modifieddate ^Int ModifiedDate, :crc32 CRC32, :compressedsize CompressedSize, :uncompressedsize UncompressedSize, :compressedsize64 CompressedSize64, :uncompressedsize64 UncompressedSize64, :extra ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/archive/zip/struct.go:136:21) Extra, :externalattrs ExternalAttrs} Error] FileInfoHeader
;;   "FileInfoHeader creates a partially-populated FileHeader from an\nos.FileInfo.\nBecause os.FileInfo's Name method returns only the base name of\nthe file it describes, it may be necessary to modify the Name field\nof the returned header to provide the full path name of the file.\nIf compression is desired, callers should set the FileHeader.Method\nfield; it is unset by default.\n"
;;   {:added "1.0"
;;    :go "fileInfoHeader(fi)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/struct.go:169:24) fi])

JOKER FUNC zip.NewReader has:
;; (defn ^[{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/reader.go:26:16) r, :file ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/archive/zip/reader.go:27:16) File, :comment ^String Comment, :decompressors ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/archive/zip/reader.go:29:16) decompressors} Error] NewReader
;;   "NewReader returns a new Reader reading from r, which is assumed to\nhave the given size in bytes.\n"
;;   {:added "1.0"
;;    :go "newReader(r, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/reader.go:71:18) r, size])

JOKER FUNC zip.NewWriter has:
;; (defn ^{:cw ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/archive/zip/writer.go:25:14) cw, :dir ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/archive/zip/writer.go:26:14) dir, :last ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/archive/zip/writer.go:27:14) last, :closed closed, :compressors ^ABEND881(unrecognized Expr type *ast.MapType at: ../GOSRC/archive/zip/writer.go:29:14) compressors, :comment ^String comment, :testhookclosesizeoffset ^ABEND881(unrecognized Expr type *ast.FuncType at: ../GOSRC/archive/zip/writer.go:34:26) testHookCloseSizeOffset} NewWriter
;;   "NewWriter returns a new Writer writing a zip file to w.\n"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/archive/zip/writer.go:43:18) w])

JOKER FUNC zip.OpenReader has:
;; (defn ^[{:f ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/archive/zip/reader.go:33:4) f} Error] OpenReader
;;   "OpenReader will open the Zip file specified by name and return a ReadCloser.\n"
;;   {:added "1.0"
;;    :go "openReader(name)"}
;;   [^String name])

JOKER FUNC zip.RegisterCompressor has:
;; (defn RegisterCompressor
;;   "RegisterCompressor registers custom compressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n"
;;   {:added "1.0"
;;    :go "registerCompressor(method, comp)"}
;;   [^Int method, comp])

JOKER FUNC zip.RegisterDecompressor has:
;; (defn RegisterDecompressor
;;   "RegisterDecompressor allows custom decompressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n"
;;   {:added "1.0"
;;    :go "registerDecompressor(method, dcomp)"}
;;   [^Int method, dcomp])

JOKER FUNC zlib.NewReader has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/reader.go:70:30) Error] NewReader
;;   "NewReader creates a new ReadCloser.\nReads from the returned ReadCloser read and decompress data from r.\nIf r does not implement io.ByteReader, the decompressor may read more\ndata than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when done.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n"
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/reader.go:70:18) r])

JOKER FUNC zlib.NewReaderDict has:
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/reader.go:79:47) Error] NewReaderDict
;;   "NewReaderDict is like NewReader but uses a preset dictionary.\nNewReaderDict ignores the dictionary if the compressed data does not refer to it.\nIf the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.\n\nThe ReadCloser returned by NewReaderDict also implements Resetter.\n"
;;   {:added "1.0"
;;    :go "newReaderDict(r, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/reader.go:79:22) r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/reader.go:79:38) dict])

JOKER FUNC zlib.NewWriter has:
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:28:14) w, :level ^Int level, :dict ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/writer.go:30:14) dict, :compressor ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/compress/zlib/writer.go:31:14) compressor, :digest ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:32:14) digest, :err err, :scratch ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/writer.go:34:14) scratch, :wroteheader wroteHeader} NewWriter
;;   "NewWriter creates a new Writer.\nWrites to the returned Writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n"
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:43:18) w])

JOKER FUNC zlib.NewWriterLevel has:
;; (defn ^[{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:28:14) w, :level ^Int level, :dict ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/writer.go:30:14) dict, :compressor ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/compress/zlib/writer.go:31:14) compressor, :digest ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:32:14) digest, :err err, :scratch ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/writer.go:34:14) scratch, :wroteheader wroteHeader} Error] NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n"
;;   {:added "1.0"
;;    :go "newWriterLevel(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:54:23) w, ^Int level])

JOKER FUNC zlib.NewWriterLevelDict has:
;; (defn ^[{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:28:14) w, :level ^Int level, :dict ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/writer.go:30:14) dict, :compressor ^ABEND881(unrecognized Expr type *ast.StarExpr at: ../GOSRC/compress/zlib/writer.go:31:14) compressor, :digest ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:32:14) digest, :err err, :scratch ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/writer.go:34:14) scratch, :wroteheader wroteHeader} Error] NewWriterLevelDict
;;   "NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to\ncompress with.\n\nThe dictionary may be nil. If not, its contents should not be modified until\nthe Writer is closed.\n"
;;   {:added "1.0"
;;    :go "newWriterLevelDict(w, level, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/compress/zlib/writer.go:63:27) w, ^Int level, ^ABEND881(unrecognized Expr type *ast.ArrayType at: ../GOSRC/compress/zlib/writer.go:63:54) dict])

GO FUNC ast.Inspect has:
// func inspect(node Object, f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/go/ast/walk.go:384:27))  {
// 	 := ast.Inspect(node, f)
// 	...ABEND: TODO...
// }

GO FUNC ast.SortImports has:
// func sortImports(fset ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/import.go:15:23), f ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/ast/import.go:15:41))  {
// 	 := ast.SortImports(fset, f)
// 	...ABEND: TODO...
// }

GO FUNC ast.Walk has:
// func walk(v Object, node Object)  {
// 	 := ast.Walk(v, node)
// 	...ABEND: TODO...
// }

GO FUNC atomic.StoreInt32 has:
// func storeInt32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:129:22), val Object)  {
// 	 := atomic.StoreInt32(addr, val)
// 	...ABEND: TODO...
// }

GO FUNC atomic.StoreInt64 has:
// func storeInt64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:132:22), val Object)  {
// 	 := atomic.StoreInt64(addr, val)
// 	...ABEND: TODO...
// }

GO FUNC atomic.StorePointer has:
// func storePointer(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:144:24), val ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/sync/atomic/doc.go:144:45))  {
// 	 := atomic.StorePointer(addr, val)
// 	...ABEND: TODO...
// }

GO FUNC atomic.StoreUint32 has:
// func storeUint32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:135:23), val Object)  {
// 	 := atomic.StoreUint32(addr, val)
// 	...ABEND: TODO...
// }

GO FUNC atomic.StoreUint64 has:
// func storeUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:138:23), val Object)  {
// 	 := atomic.StoreUint64(addr, val)
// 	...ABEND: TODO...
// }

GO FUNC atomic.StoreUintptr has:
// func storeUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/sync/atomic/doc.go:141:24), val Object)  {
// 	 := atomic.StoreUintptr(addr, val)
// 	...ABEND: TODO...
// }

GO FUNC cgo._cgo_panic has:
// func _cgo_panic(a ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/cgo/callbacks.go:45:19), n Object)  {
// 	 := cgo._cgo_panic(a, n)
// 	...ABEND: TODO...
// }

GO FUNC cgo._runtime_cgocallback has:
// func _runtime_cgocallback()  {
// 	 := cgo._runtime_cgocallback()
// 	...ABEND: TODO...
// }

GO FUNC crypto.RegisterHash has:
// func registerHash(h Object, f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/crypto/crypto.go:100:29))  {
// 	 := crypto.RegisterHash(h, f)
// 	...ABEND: TODO...
// }

GO FUNC curve25519.ScalarBaseMult has:
// func scalarBaseMult(dst ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:21:29), in ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:21:29))  {
// 	 := curve25519.ScalarBaseMult(dst, in)
// 	...ABEND: TODO...
// }

GO FUNC curve25519.ScalarMult has:
// func scalarMult(dst ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31), in ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31), base ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/curve25519/doc.go:14:31))  {
// 	 := curve25519.ScalarMult(dst, in, base)
// 	...ABEND: TODO...
// }

GO FUNC debug.FreeOSMemory has:
// func freeOSMemory()  {
// 	 := debug.FreeOSMemory()
// 	...ABEND: TODO...
// }

GO FUNC debug.PrintStack has:
// func printStack()  {
// 	 := debug.PrintStack()
// 	...ABEND: TODO...
// }

GO FUNC debug.ReadGCStats has:
// func readGCStats(stats ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/debug/garbage.go:31:24))  {
// 	 := debug.ReadGCStats(stats)
// 	...ABEND: TODO...
// }

GO FUNC debug.SetTraceback has:
// func setTraceback(level string)  {
// 	 := debug.SetTraceback(level)
// 	...ABEND: TODO...
// }

GO FUNC debug.WriteHeapDump has:
// func writeHeapDump(fd Object)  {
// 	 := debug.WriteHeapDump(fd)
// 	...ABEND: TODO...
// }

GO FUNC doc.ToHTML has:
// func toHTML(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/comment.go:308:15), text string, words ABEND882(unrecognized Expr type *ast.MapType at: ../GOSRC/go/doc/comment.go:308:45))  {
// 	 := doc.ToHTML(w, text, words)
// 	...ABEND: TODO...
// }

GO FUNC doc.ToText has:
// func toText(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/doc/comment.go:422:15), text string, indent string, preIndent string, width int)  {
// 	 := doc.ToText(w, text, indent, preIndent, width)
// 	...ABEND: TODO...
// }

GO FUNC draw.Draw has:
// func draw(dst Object, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:24), src ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:45), sp ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:100:61), op Object)  {
// 	 := draw.Draw(dst, r, src, sp, op)
// 	...ABEND: TODO...
// }

GO FUNC draw.DrawMask has:
// func drawMask(dst Object, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:28), src ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:49), sp ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:65), mask ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:83), mp ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/image/draw/draw.go:106:99), op Object)  {
// 	 := draw.DrawMask(dst, r, src, sp, mask, mp, op)
// 	...ABEND: TODO...
// }

GO FUNC expvar.Do has:
// func do(f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/expvar/expvar.go:306:11))  {
// 	 := expvar.Do(f)
// 	...ABEND: TODO...
// }

GO FUNC expvar.Publish has:
// func publish(name string, v Object)  {
// 	 := expvar.Publish(name, v)
// 	...ABEND: TODO...
// }

GO FUNC flag.BoolVar has:
// func boolVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:583:16), name string, value Object, usage string)  {
// 	 := flag.BoolVar(p, name, value, usage)
// 	...ABEND: TODO...
// }

GO FUNC flag.DurationVar has:
// func durationVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:767:20), name string, value ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/flag/flag.go:767:55), usage string)  {
// 	 := flag.DurationVar(p, name, value, usage)
// 	...ABEND: TODO...
// }

GO FUNC flag.Float64Var has:
// func float64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:739:19), name string, value Object, usage string)  {
// 	 := flag.Float64Var(p, name, value, usage)
// 	...ABEND: TODO...
// }

GO FUNC flag.Int64Var has:
// func int64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:635:17), name string, value Object, usage string)  {
// 	 := flag.Int64Var(p, name, value, usage)
// 	...ABEND: TODO...
// }

GO FUNC flag.IntVar has:
// func intVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:609:15), name string, value int, usage string)  {
// 	 := flag.IntVar(p, name, value, usage)
// 	...ABEND: TODO...
// }

GO FUNC flag.Parse has:
// func parse()  {
// 	 := flag.Parse()
// 	...ABEND: TODO...
// }

GO FUNC flag.PrintDefaults has:
// func printDefaults()  {
// 	 := flag.PrintDefaults()
// 	...ABEND: TODO...
// }

GO FUNC flag.StringVar has:
// func stringVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:713:18), name string, value string, usage string)  {
// 	 := flag.StringVar(p, name, value, usage)
// 	...ABEND: TODO...
// }

GO FUNC flag.Uint64Var has:
// func uint64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:687:18), name string, value Object, usage string)  {
// 	 := flag.Uint64Var(p, name, value, usage)
// 	...ABEND: TODO...
// }

GO FUNC flag.UintVar has:
// func uintVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/flag/flag.go:661:16), name string, value Object, usage string)  {
// 	 := flag.UintVar(p, name, value, usage)
// 	...ABEND: TODO...
// }

GO FUNC flag.Var has:
// func var(value Object, name string, usage string)  {
// 	 := flag.Var(value, name, usage)
// 	...ABEND: TODO...
// }

GO FUNC flag.Visit has:
// func visit(fn ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/flag/flag.go:364:15))  {
// 	 := flag.Visit(fn)
// 	...ABEND: TODO...
// }

GO FUNC flag.VisitAll has:
// func visitAll(fn ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/flag/flag.go:350:18))  {
// 	 := flag.VisitAll(fn)
// 	...ABEND: TODO...
// }

GO FUNC gob.Register has:
// func register(value ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/gob/type.go:836:21))  {
// 	 := gob.Register(value)
// 	...ABEND: TODO...
// }

GO FUNC gob.RegisterName has:
// func registerName(name string, value ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/encoding/gob/type.go:807:38))  {
// 	 := gob.RegisterName(name, value)
// 	...ABEND: TODO...
// }

GO FUNC heap.Fix has:
// func fix(h Object, i int)  {
// 	 := heap.Fix(h, i)
// 	...ABEND: TODO...
// }

GO FUNC heap.Init has:
// func init(h Object)  {
// 	 := heap.Init(h)
// 	...ABEND: TODO...
// }

GO FUNC heap.Push has:
// func push(h Object, x ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/container/heap/heap.go:53:26))  {
// 	 := heap.Push(h, x)
// 	...ABEND: TODO...
// }

GO FUNC http.Error has:
// func error(w Object, error string, code int)  {
// 	 := http.Error(w, error, code)
// 	...ABEND: TODO...
// }

GO FUNC http.Handle has:
// func handle(pattern string, handler Object)  {
// 	 := http.Handle(pattern, handler)
// 	...ABEND: TODO...
// }

GO FUNC http.HandleFunc has:
// func handleFunc(pattern string, handler ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/net/http/server.go:2406:41))  {
// 	 := http.HandleFunc(pattern, handler)
// 	...ABEND: TODO...
// }

GO FUNC http.NotFound has:
// func notFound(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/server.go:1981:35))  {
// 	 := http.NotFound(w, r)
// 	...ABEND: TODO...
// }

GO FUNC http.Redirect has:
// func redirect(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/server.go:2020:35), url string, code int)  {
// 	 := http.Redirect(w, r, url, code)
// 	...ABEND: TODO...
// }

GO FUNC http.ServeContent has:
// func serveContent(w Object, req ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fs.go:151:41), name string, modtime ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fs.go:151:72), content ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/fs.go:151:91))  {
// 	 := http.ServeContent(w, req, name, modtime, content)
// 	...ABEND: TODO...
// }

GO FUNC http.ServeFile has:
// func serveFile(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/fs.go:670:36), name string)  {
// 	 := http.ServeFile(w, r, name)
// 	...ABEND: TODO...
// }

GO FUNC http.SetCookie has:
// func setCookie(w Object, cookie ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/cookie.go:157:41))  {
// 	 := http.SetCookie(w, cookie)
// 	...ABEND: TODO...
// }

GO FUNC image.RegisterFormat has:
// func registerFormat(name string, magic string, decode ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/format.go:32:48), decodeConfig ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/image/format.go:32:93))  {
// 	 := image.RegisterFormat(name, magic, decode, decodeConfig)
// 	...ABEND: TODO...
// }

GO FUNC json.HTMLEscape has:
// func hTMLEscape(dst ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/encoding/json/encode.go:194:21), src ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/json/encode.go:194:40))  {
// 	 := json.HTMLEscape(dst, src)
// 	...ABEND: TODO...
// }

GO FUNC jsonrpc.ServeConn has:
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/jsonrpc/server.go:132:21))  {
// 	 := jsonrpc.ServeConn(conn)
// 	...ABEND: TODO...
// }

GO FUNC log.Fatal has:
// func fatal(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:305:14))  {
// 	 := log.Fatal(v)
// 	...ABEND: TODO...
// }

GO FUNC log.Fatalf has:
// func fatalf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:311:30))  {
// 	 := log.Fatalf(format, v)
// 	...ABEND: TODO...
// }

GO FUNC log.Fatalln has:
// func fatalln(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:317:16))  {
// 	 := log.Fatalln(v)
// 	...ABEND: TODO...
// }

GO FUNC log.Panic has:
// func panic(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:323:14))  {
// 	 := log.Panic(v)
// 	...ABEND: TODO...
// }

GO FUNC log.Panicf has:
// func panicf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:330:30))  {
// 	 := log.Panicf(format, v)
// 	...ABEND: TODO...
// }

GO FUNC log.Panicln has:
// func panicln(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:337:16))  {
// 	 := log.Panicln(v)
// 	...ABEND: TODO...
// }

GO FUNC log.Print has:
// func print(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:288:14))  {
// 	 := log.Print(v)
// 	...ABEND: TODO...
// }

GO FUNC log.Printf has:
// func printf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:294:30))  {
// 	 := log.Printf(format, v)
// 	...ABEND: TODO...
// }

GO FUNC log.Println has:
// func println(v ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/log/log.go:300:16))  {
// 	 := log.Println(v)
// 	...ABEND: TODO...
// }

GO FUNC log.SetFlags has:
// func setFlags(flag int)  {
// 	 := log.SetFlags(flag)
// 	...ABEND: TODO...
// }

GO FUNC log.SetOutput has:
// func setOutput(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/log/log.go:258:18))  {
// 	 := log.SetOutput(w)
// 	...ABEND: TODO...
// }

GO FUNC log.SetPrefix has:
// func setPrefix(prefix string)  {
// 	 := log.SetPrefix(prefix)
// 	...ABEND: TODO...
// }

GO FUNC nettest.TestConn has:
// func testConn(t ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/net/nettest/conntest.go:37:17), mp Object)  {
// 	 := nettest.TestConn(t, mp)
// 	...ABEND: TODO...
// }

GO FUNC os.Clearenv has:
// func clearenv()  {
// 	 := os.Clearenv()
// 	...ABEND: TODO...
// }

GO FUNC os.Exit has:
// func exit(code int)  {
// 	 := os.Exit(code)
// 	...ABEND: TODO...
// }

GO FUNC poly1305.Sum has:
// func sum(out ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:14), m ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:27), key ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/vendor/golang_org/x/crypto/poly1305/sum_amd64.go:16:39))  {
// 	 := poly1305.Sum(out, m, key)
// 	...ABEND: TODO...
// }

GO FUNC pprof.Cmdline has:
// func cmdline(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:83:16), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:83:39))  {
// 	 := pprof.Cmdline(w, r)
// 	...ABEND: TODO...
// }

GO FUNC pprof.Do has:
// func do(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/runtime.go:31:13), labels Object, f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/runtime.go:31:49))  {
// 	 := pprof.Do(ctx, labels, f)
// 	...ABEND: TODO...
// }

GO FUNC pprof.ForLabels has:
// func forLabels(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/label.go:78:20), f ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/pprof/label.go:78:39))  {
// 	 := pprof.ForLabels(ctx, f)
// 	...ABEND: TODO...
// }

GO FUNC pprof.Index has:
// func index(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:264:14), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:264:37))  {
// 	 := pprof.Index(w, r)
// 	...ABEND: TODO...
// }

GO FUNC pprof.Profile has:
// func profile(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:116:16), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:116:39))  {
// 	 := pprof.Profile(w, r)
// 	...ABEND: TODO...
// }

GO FUNC pprof.SetGoroutineLabels has:
// func setGoroutineLabels(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/pprof/runtime.go:20:29))  {
// 	 := pprof.SetGoroutineLabels(ctx)
// 	...ABEND: TODO...
// }

GO FUNC pprof.StopCPUProfile has:
// func stopCPUProfile()  {
// 	 := pprof.StopCPUProfile()
// 	...ABEND: TODO...
// }

GO FUNC pprof.Symbol has:
// func symbol(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:174:15), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:174:38))  {
// 	 := pprof.Symbol(w, r)
// 	...ABEND: TODO...
// }

GO FUNC pprof.Trace has:
// func trace(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/http/pprof/pprof.go:145:14), r ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/net/http/pprof/pprof.go:145:37))  {
// 	 := pprof.Trace(w, r)
// 	...ABEND: TODO...
// }

GO FUNC rand.Seed has:
// func seed(seed Object)  {
// 	 := rand.Seed(seed)
// 	...ABEND: TODO...
// }

GO FUNC rand.Shuffle has:
// func shuffle(n int, swap ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/math/rand/rand.go:346:26))  {
// 	 := rand.Shuffle(n, swap)
// 	...ABEND: TODO...
// }

GO FUNC rpc.Accept has:
// func accept(lis ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:692:17))  {
// 	 := rpc.Accept(lis)
// 	...ABEND: TODO...
// }

GO FUNC rpc.HandleHTTP has:
// func handleHTTP()  {
// 	 := rpc.HandleHTTP()
// 	...ABEND: TODO...
// }

GO FUNC rpc.ServeCodec has:
// func serveCodec(codec Object)  {
// 	 := rpc.ServeCodec(codec)
// 	...ABEND: TODO...
// }

GO FUNC rpc.ServeConn has:
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/net/rpc/server.go:673:21))  {
// 	 := rpc.ServeConn(conn)
// 	...ABEND: TODO...
// }

GO FUNC runtime.Breakpoint has:
// func breakpoint()  {
// 	 := runtime.Breakpoint()
// 	...ABEND: TODO...
// }

GO FUNC runtime.GC has:
// func gC()  {
// 	 := runtime.GC()
// 	...ABEND: TODO...
// }

GO FUNC runtime.Goexit has:
// func goexit()  {
// 	 := runtime.Goexit()
// 	...ABEND: TODO...
// }

GO FUNC runtime.Gosched has:
// func gosched()  {
// 	 := runtime.Gosched()
// 	...ABEND: TODO...
// }

GO FUNC runtime.KeepAlive has:
// func keepAlive(x ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:446:18))  {
// 	 := runtime.KeepAlive(x)
// 	...ABEND: TODO...
// }

GO FUNC runtime.LockOSThread has:
// func lockOSThread()  {
// 	 := runtime.LockOSThread()
// 	...ABEND: TODO...
// }

GO FUNC runtime.ReadMemStats has:
// func readMemStats(m ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/mstats.go:457:21))  {
// 	 := runtime.ReadMemStats(m)
// 	...ABEND: TODO...
// }

GO FUNC runtime.SetBlockProfileRate has:
// func setBlockProfileRate(rate int)  {
// 	 := runtime.SetBlockProfileRate(rate)
// 	...ABEND: TODO...
// }

GO FUNC runtime.SetCPUProfileRate has:
// func setCPUProfileRate(hz int)  {
// 	 := runtime.SetCPUProfileRate(hz)
// 	...ABEND: TODO...
// }

GO FUNC runtime.SetCgoTraceback has:
// func setCgoTraceback(version int, traceback ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66), context ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66), symbolizer ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/traceback.go:1198:66))  {
// 	 := runtime.SetCgoTraceback(version, traceback, context, symbolizer)
// 	...ABEND: TODO...
// }

GO FUNC runtime.SetFinalizer has:
// func setFinalizer(obj ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:309:23), finalizer ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/runtime/mfinal.go:309:46))  {
// 	 := runtime.SetFinalizer(obj, finalizer)
// 	...ABEND: TODO...
// }

GO FUNC runtime.StopTrace has:
// func stopTrace()  {
// 	 := runtime.StopTrace()
// 	...ABEND: TODO...
// }

GO FUNC runtime.UnlockOSThread has:
// func unlockOSThread()  {
// 	 := runtime.UnlockOSThread()
// 	...ABEND: TODO...
// }

GO FUNC runtime._ExternalCode has:
// func _ExternalCode()  {
// 	 := runtime._ExternalCode()
// 	...ABEND: TODO...
// }

GO FUNC runtime._GC has:
// func _GC()  {
// 	 := runtime._GC()
// 	...ABEND: TODO...
// }

GO FUNC runtime._LostExternalCode has:
// func _LostExternalCode()  {
// 	 := runtime._LostExternalCode()
// 	...ABEND: TODO...
// }

GO FUNC runtime._LostSIGPROFDuringAtomic64 has:
// func _LostSIGPROFDuringAtomic64()  {
// 	 := runtime._LostSIGPROFDuringAtomic64()
// 	...ABEND: TODO...
// }

GO FUNC runtime._System has:
// func _System()  {
// 	 := runtime._System()
// 	...ABEND: TODO...
// }

GO FUNC runtime._VDSO has:
// func _VDSO()  {
// 	 := runtime._VDSO()
// 	...ABEND: TODO...
// }

GO FUNC runtime._cgo_panic_internal has:
// func _cgo_panic_internal(p ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/runtime/cgocallback.go:11:28))  {
// 	 := runtime._cgo_panic_internal(p)
// 	...ABEND: TODO...
// }

GO FUNC scanner.PrintError has:
// func printError(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/scanner/errors.go:116:19), err Object)  {
// 	 := scanner.PrintError(w, err)
// 	...ABEND: TODO...
// }

GO FUNC signal.Ignore has:
// func ignore(sig ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:85:17))  {
// 	 := signal.Ignore(sig)
// 	...ABEND: TODO...
// }

GO FUNC signal.Notify has:
// func notify(c ABEND882(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/signal/signal.go:111:15), sig ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:111:37))  {
// 	 := signal.Notify(c, sig)
// 	...ABEND: TODO...
// }

GO FUNC signal.Reset has:
// func reset(sig ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/os/signal/signal.go:155:16))  {
// 	 := signal.Reset(sig)
// 	...ABEND: TODO...
// }

GO FUNC signal.Stop has:
// func stop(c ABEND882(unrecognized Expr type *ast.ChanType at: ../GOSRC/os/signal/signal.go:162:13))  {
// 	 := signal.Stop(c)
// 	...ABEND: TODO...
// }

GO FUNC sort.Float64s has:
// func float64s(a ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:311:17))  {
// 	 := sort.Float64s(a)
// 	...ABEND: TODO...
// }

GO FUNC sort.Ints has:
// func ints(a ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:307:13))  {
// 	 := sort.Ints(a)
// 	...ABEND: TODO...
// }

GO FUNC sort.Slice has:
// func slice(slice ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/slice.go:17:18), less ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/slice.go:17:36))  {
// 	 := sort.Slice(slice, less)
// 	...ABEND: TODO...
// }

GO FUNC sort.SliceStable has:
// func sliceStable(slice ABEND882(unrecognized Expr type *ast.InterfaceType at: ../GOSRC/sort/slice.go:28:24), less ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/sort/slice.go:28:42))  {
// 	 := sort.SliceStable(slice, less)
// 	...ABEND: TODO...
// }

GO FUNC sort.Sort has:
// func sort(data Object)  {
// 	 := sort.Sort(data)
// 	...ABEND: TODO...
// }

GO FUNC sort.Stable has:
// func stable(data Object)  {
// 	 := sort.Stable(data)
// 	...ABEND: TODO...
// }

GO FUNC sort.Strings has:
// func strings(a ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/sort/sort.go:314:16))  {
// 	 := sort.Strings(a)
// 	...ABEND: TODO...
// }

GO FUNC sql.Register has:
// func register(name string, driver ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/database/sql/sql.go:44:35))  {
// 	 := sql.Register(name, driver)
// 	...ABEND: TODO...
// }

GO FUNC subtle.ConstantTimeCopy has:
// func constantTimeCopy(v int, x ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:43:35), y ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/crypto/subtle/constant_time.go:43:35))  {
// 	 := subtle.ConstantTimeCopy(v, x, y)
// 	...ABEND: TODO...
// }

GO FUNC syscall.Clearenv has:
// func clearenv()  {
// 	 := syscall.Clearenv()
// 	...ABEND: TODO...
// }

GO FUNC syscall.CloseOnExec has:
// func closeOnExec(fd int)  {
// 	 := syscall.CloseOnExec(fd)
// 	...ABEND: TODO...
// }

GO FUNC syscall.Exit has:
// func exit(code int)  {
// 	 := syscall.Exit(code)
// 	...ABEND: TODO...
// }

GO FUNC syscall.SetKevent has:
// func setKevent(k ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/syscall/syscall_darwin_amd64.go:35:18), fd int, mode int, flags int)  {
// 	 := syscall.SetKevent(k, fd, mode, flags)
// 	...ABEND: TODO...
// }

GO FUNC testing.Main has:
// func main(matchString ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/testing.go:961:23), tests ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:66), benchmarks ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:93), examples ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/testing.go:961:123))  {
// 	 := testing.Main(matchString, tests, benchmarks, examples)
// 	...ABEND: TODO...
// }

GO FUNC testing.RegisterCover has:
// func registerCover(c Object)  {
// 	 := testing.RegisterCover(c)
// 	...ABEND: TODO...
// }

GO FUNC testing.RunBenchmarks has:
// func runBenchmarks(matchString ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/testing/benchmark.go:377:32), benchmarks ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/testing/benchmark.go:377:80))  {
// 	 := testing.RunBenchmarks(matchString, benchmarks)
// 	...ABEND: TODO...
// }

GO FUNC time.Sleep has:
// func sleep(d Object)  {
// 	 := time.Sleep(d)
// 	...ABEND: TODO...
// }

GO FUNC trace.Log has:
// func log(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:91:14), category string, message string)  {
// 	 := trace.Log(ctx, category, message)
// 	...ABEND: TODO...
// }

GO FUNC trace.Logf has:
// func logf(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:97:15), category string, format string, args ABEND882(unrecognized Expr type *ast.Ellipsis at: ../GOSRC/runtime/trace/annotation.go:97:62))  {
// 	 := trace.Logf(ctx, category, format, args)
// 	...ABEND: TODO...
// }

GO FUNC trace.Stop has:
// func stop()  {
// 	 := trace.Stop()
// 	...ABEND: TODO...
// }

GO FUNC trace.WithRegion has:
// func withRegion(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/runtime/trace/annotation.go:118:21), regionType string, fn ABEND882(unrecognized Expr type *ast.FuncType at: ../GOSRC/runtime/trace/annotation.go:118:60))  {
// 	 := trace.WithRegion(ctx, regionType, fn)
// 	...ABEND: TODO...
// }

GO FUNC types.DefPredeclaredTestFuncs has:
// func defPredeclaredTestFuncs()  {
// 	 := types.DefPredeclaredTestFuncs()
// 	...ABEND: TODO...
// }

GO FUNC types.WriteExpr has:
// func writeExpr(buf ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/exprstring.go:26:20), x ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/go/types/exprstring.go:26:37))  {
// 	 := types.WriteExpr(buf, x)
// 	...ABEND: TODO...
// }

GO FUNC types.WriteSignature has:
// func writeSignature(buf ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:285:25), sig ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:285:44), qf Object)  {
// 	 := types.WriteSignature(buf, sig, qf)
// 	...ABEND: TODO...
// }

GO FUNC types.WriteType has:
// func writeType(buf ABEND882(unrecognized Expr type *ast.StarExpr at: ../GOSRC/go/types/typestring.go:74:20), typ Object, qf Object)  {
// 	 := types.WriteType(buf, typ, qf)
// 	...ABEND: TODO...
// }

GO FUNC xml.Escape has:
// func escape(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: ../GOSRC/encoding/xml/xml.go:1985:15), s ABEND882(unrecognized Expr type *ast.ArrayType at: ../GOSRC/encoding/xml/xml.go:1985:28))  {
// 	 := xml.Escape(w, s)
// 	...ABEND: TODO...
// }

GO FUNC zip.RegisterCompressor has:
// func registerCompressor(method Object, comp Object)  {
// 	 := zip.RegisterCompressor(method, comp)
// 	...ABEND: TODO...
// }

GO FUNC zip.RegisterDecompressor has:
// func registerDecompressor(method Object, dcomp Object)  {
// 	 := zip.RegisterDecompressor(method, dcomp)
// 	...ABEND: TODO...
// }

Totals: types=1034 functions=1523 receivers=6082
