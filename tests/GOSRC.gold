Default context:
{amd64 linux /usr/local/go /home/craig/.go true false gc [] [go1.1 go1.2 go1.3 go1.4 go1.5 go1.6 go1.7 go1.8 go1.9 go1.10 go1.11]  <nil> <nil> <nil> <nil> <nil> <nil> <nil>}
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/archive
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/archive/tar
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package tar:
Processing package=tar:
Excluding /home/craig/github/golang/go/src/archive/tar/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/archive/zip
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package zip:
Processing package=zip:
Excluding /home/craig/github/golang/go/src/archive/zip/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/bufio
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package bufio:
Processing package=bufio:
Excluding /home/craig/github/golang/go/src/builtin
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/bytes
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package bytes:
Processing package=bytes:
Excluding /home/craig/github/golang/go/src/cmd
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/compress
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/compress/bzip2
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package bzip2:
Processing package=bzip2:
Excluding /home/craig/github/golang/go/src/compress/bzip2/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/compress/flate
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package flate:
Processing package=flate:
Excluding /home/craig/github/golang/go/src/compress/flate/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/compress/gzip
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package gzip:
Processing package=gzip:
Excluding /home/craig/github/golang/go/src/compress/gzip/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/compress/lzw
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package lzw:
Processing package=lzw:
Excluding /home/craig/github/golang/go/src/compress/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/compress/zlib
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package zlib:
Processing package=zlib:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/container
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/container/heap
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package heap:
Processing package=heap:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/container/list
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package list:
Processing package=list:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/container/ring
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package ring:
Processing package=ring:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/context
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package context:
Processing package=context:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package crypto:
Processing package=crypto:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/aes
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package aes:
Processing package=aes:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/cipher
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package cipher:
Processing package=cipher:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/des
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package des:
Processing package=des:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/dsa
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package dsa:
Processing package=dsa:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/ecdsa
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package ecdsa:
Processing package=ecdsa:
Excluding /home/craig/github/golang/go/src/crypto/ecdsa/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/elliptic
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package elliptic:
Processing package=elliptic:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/hmac
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package hmac:
Processing package=hmac:
Excluding /home/craig/github/golang/go/src/crypto/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/md5
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package md5:
Processing package=md5:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/rand
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package rand:
Processing package=rand:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/rc4
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package rc4:
Processing package=rc4:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/rsa
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package rsa:
Processing package=rsa:
Excluding /home/craig/github/golang/go/src/crypto/rsa/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/sha1
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package sha1:
Processing package=sha1:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/sha256
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package sha256:
Processing package=sha256:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/sha512
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package sha512:
Processing package=sha512:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/subtle
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package subtle:
Processing package=subtle:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/tls
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package tls:
Processing package=tls:
Excluding /home/craig/github/golang/go/src/crypto/tls/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/x509
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package x509:
Processing package=x509:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/crypto/x509/pkix
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package pkix:
Processing package=pkix:
Excluding /home/craig/github/golang/go/src/crypto/x509/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/database
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/database/sql
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package sql:
Processing package=sql:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/database/sql/driver
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package driver:
Processing package=driver:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/debug
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/debug/dwarf
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package dwarf:
Processing package=dwarf:
Excluding /home/craig/github/golang/go/src/debug/dwarf/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/debug/elf
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package elf:
Processing package=elf:
Excluding /home/craig/github/golang/go/src/debug/elf/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/debug/gosym
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package gosym:
Processing package=gosym:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/debug/macho
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package macho:
Processing package=macho:
Excluding /home/craig/github/golang/go/src/debug/macho/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/debug/pe
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package pe:
Processing package=pe:
Excluding /home/craig/github/golang/go/src/debug/pe/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/debug/plan9obj
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package plan9obj:
Processing package=plan9obj:
Excluding /home/craig/github/golang/go/src/debug/plan9obj/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package encoding:
Processing package=encoding:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/ascii85
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package ascii85:
Processing package=ascii85:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/asn1
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package asn1:
Processing package=asn1:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/base32
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package base32:
Processing package=base32:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/base64
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package base64:
Processing package=base64:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/binary
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package binary:
Processing package=binary:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/csv
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package csv:
Processing package=csv:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/gob
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package gob:
Processing package=gob:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/hex
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package hex:
Processing package=hex:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/json
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package json:
Processing package=json:
Excluding /home/craig/github/golang/go/src/encoding/json/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/pem
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package pem:
Processing package=pem:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/encoding/xml
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package xml:
Processing package=xml:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/errors
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package errors:
Processing package=errors:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/expvar
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package expvar:
Processing package=expvar:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/flag
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package flag:
Processing package=flag:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/fmt
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package fmt:
Processing package=fmt:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/ast
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package ast:
Processing package=ast:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/build
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package build:
Processing package=build:
Excluding /home/craig/github/golang/go/src/go/build/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/constant
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package constant:
Processing package=constant:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/doc
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package doc:
Processing package=doc:
Excluding /home/craig/github/golang/go/src/go/doc/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/format
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package format:
Processing package=format:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/importer
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package importer:
Processing package=importer:
Excluding /home/craig/github/golang/go/src/go/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/parser
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package parser:
Processing package=parser:
Excluding /home/craig/github/golang/go/src/go/parser/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/printer
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package printer:
Processing package=printer:
Excluding /home/craig/github/golang/go/src/go/printer/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/scanner
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package scanner:
Processing package=scanner:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/token
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package token:
Processing package=token:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/go/types
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package types:
Processing package=types:
Excluding /home/craig/github/golang/go/src/go/types/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/hash
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package hash:
Processing package=hash:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/hash/adler32
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package adler32:
Processing package=adler32:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/hash/crc32
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package crc32:
Processing package=crc32:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/hash/crc64
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package crc64:
Processing package=crc64:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/hash/fnv
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package fnv:
Processing package=fnv:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/html
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package html:
Processing package=html:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/html/template
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package template:
Processing package=template:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/image
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package image:
Processing package=image:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/image/color
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package color:
Processing package=color:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/image/color/palette
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package palette:
Processing package=palette:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/image/draw
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package draw:
Processing package=draw:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/image/gif
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package gif:
Processing package=gif:
Excluding /home/craig/github/golang/go/src/image/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/image/jpeg
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package jpeg:
Processing package=jpeg:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/image/png
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package png:
Processing package=png:
Excluding /home/craig/github/golang/go/src/image/png/testdata
Excluding /home/craig/github/golang/go/src/image/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/index
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/index/suffixarray
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package suffixarray:
Processing package=suffixarray:
Excluding /home/craig/github/golang/go/src/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/io
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package io:
Processing package=io:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/io/ioutil
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package ioutil:
Processing package=ioutil:
Excluding /home/craig/github/golang/go/src/io/ioutil/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/log
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package log:
Processing package=log:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/log/syslog
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package syslog:
Processing package=syslog:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/math
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package math:
Processing package=math:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/math/big
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package big:
Processing package=big:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/math/bits
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package bits:
Processing package=bits:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/math/cmplx
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package cmplx:
Processing package=cmplx:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/math/rand
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package rand:
Processing package=rand:
already seen function rand.Int in /home/craig/github/golang/go/src/crypto/rand/util.go, yet again in /home/craig/github/golang/go/src/math/rand/rand.go
already seen function rand.Read in /home/craig/github/golang/go/src/crypto/rand/rand.go, yet again in /home/craig/github/golang/go/src/math/rand/rand.go
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/mime
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package mime:
Processing package=mime:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/mime/multipart
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package multipart:
Processing package=multipart:
Excluding /home/craig/github/golang/go/src/mime/multipart/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/mime/quotedprintable
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package quotedprintable:
Processing package=quotedprintable:
Excluding /home/craig/github/golang/go/src/mime/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package net:
Processing package=net:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/http
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package http:
Processing package=http:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/http/cgi
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package cgi:
Processing package=cgi:
Excluding /home/craig/github/golang/go/src/net/http/cgi/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/http/cookiejar
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package cookiejar:
Processing package=cookiejar:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/http/fcgi
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package fcgi:
Processing package=fcgi:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/http/httptest
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package httptest:
Processing package=httptest:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/http/httptrace
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package httptrace:
Processing package=httptrace:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/http/httputil
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package httputil:
Processing package=httputil:
Excluding /home/craig/github/golang/go/src/net/http/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/http/pprof
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package pprof:
Processing package=pprof:
Excluding /home/craig/github/golang/go/src/net/http/testdata
Excluding /home/craig/github/golang/go/src/net/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/mail
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package mail:
Processing package=mail:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/rpc
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package rpc:
Processing package=rpc:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/rpc/jsonrpc
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package jsonrpc:
Processing package=jsonrpc:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/smtp
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package smtp:
Processing package=smtp:
Excluding /home/craig/github/golang/go/src/net/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/textproto
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package textproto:
Processing package=textproto:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/net/url
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package url:
Processing package=url:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/os
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package os:
Processing package=os:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/os/exec
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package exec:
Processing package=exec:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/os/signal
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package signal:
Processing package=signal:
Excluding /home/craig/github/golang/go/src/os/signal/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/os/user
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package user:
Processing package=user:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/path
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package path:
Processing package=path:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/path/filepath
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package filepath:
Processing package=filepath:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/plugin
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package plugin:
Processing package=plugin:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/reflect
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package reflect:
Processing package=reflect:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/regexp
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package regexp:
Processing package=regexp:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/regexp/syntax
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package syntax:
Processing package=syntax:
Excluding /home/craig/github/golang/go/src/regexp/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/runtime
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package runtime:
Processing package=runtime:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/runtime/cgo
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package cgo:
Processing package=cgo:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/runtime/debug
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package debug:
Processing package=debug:
Excluding /home/craig/github/golang/go/src/runtime/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/runtime/msan
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/runtime/pprof
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package pprof:
Processing package=pprof:
Excluding /home/craig/github/golang/go/src/runtime/pprof/internal
Excluding /home/craig/github/golang/go/src/runtime/pprof/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/runtime/race
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package race:
Processing package=race:
Excluding /home/craig/github/golang/go/src/runtime/race/testdata
Excluding /home/craig/github/golang/go/src/runtime/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/runtime/trace
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package trace:
Processing package=trace:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/sort
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package sort:
Processing package=sort:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/strconv
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package strconv:
Processing package=strconv:
Excluding /home/craig/github/golang/go/src/strconv/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/strings
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package strings:
Processing package=strings:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/sync
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package sync:
Processing package=sync:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/sync/atomic
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package atomic:
Processing package=atomic:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/syscall
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package syscall:
Processing package=syscall:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/syscall/js
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/testing
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package testing:
Processing package=testing:
Excluding /home/craig/github/golang/go/src/testing/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/testing/iotest
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package iotest:
Processing package=iotest:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/testing/quick
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package quick:
Processing package=quick:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/text
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/text/scanner
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package scanner:
Processing package=scanner:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/text/tabwriter
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package tabwriter:
Processing package=tabwriter:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/text/template
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package template:
Processing package=template:
already seen function template.Must in /home/craig/github/golang/go/src/html/template/template.go, yet again in /home/craig/github/golang/go/src/text/template/helper.go
already seen function template.ParseFiles in /home/craig/github/golang/go/src/html/template/template.go, yet again in /home/craig/github/golang/go/src/text/template/helper.go
already seen function template.ParseGlob in /home/craig/github/golang/go/src/html/template/template.go, yet again in /home/craig/github/golang/go/src/text/template/helper.go
already seen function template.IsTrue in /home/craig/github/golang/go/src/html/template/template.go, yet again in /home/craig/github/golang/go/src/text/template/exec.go
already seen function template.HTMLEscape in /home/craig/github/golang/go/src/html/template/escape.go, yet again in /home/craig/github/golang/go/src/text/template/funcs.go
already seen function template.HTMLEscapeString in /home/craig/github/golang/go/src/html/template/escape.go, yet again in /home/craig/github/golang/go/src/text/template/funcs.go
already seen function template.HTMLEscaper in /home/craig/github/golang/go/src/html/template/escape.go, yet again in /home/craig/github/golang/go/src/text/template/funcs.go
already seen function template.JSEscape in /home/craig/github/golang/go/src/html/template/escape.go, yet again in /home/craig/github/golang/go/src/text/template/funcs.go
already seen function template.JSEscapeString in /home/craig/github/golang/go/src/html/template/escape.go, yet again in /home/craig/github/golang/go/src/text/template/funcs.go
already seen function template.JSEscaper in /home/craig/github/golang/go/src/html/template/escape.go, yet again in /home/craig/github/golang/go/src/text/template/funcs.go
already seen function template.URLQueryEscaper in /home/craig/github/golang/go/src/html/template/escape.go, yet again in /home/craig/github/golang/go/src/text/template/funcs.go
already seen function template.New in /home/craig/github/golang/go/src/html/template/template.go, yet again in /home/craig/github/golang/go/src/text/template/template.go
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/text/template/parse
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package parse:
Processing package=parse:
Excluding /home/craig/github/golang/go/src/text/template/testdata
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/time
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package time:
Processing package=time:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/unicode
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package unicode:
Processing package=unicode:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/unicode/utf16
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package utf16:
Processing package=utf16:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/unicode/utf8
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package utf8:
Processing package=utf8:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/unsafe
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package unsafe:
Processing package=unsafe:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/crypto
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/chacha20poly1305
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package chacha20poly1305:
Processing package=chacha20poly1305:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/cryptobyte
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package cryptobyte:
Processing package=cryptobyte:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/cryptobyte/asn1
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package asn1:
Processing package=asn1:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/curve25519
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package curve25519:
Processing package=curve25519:
Excluding /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/poly1305
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package poly1305:
Processing package=poly1305:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package dnsmessage:
Processing package=dnsmessage:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/http
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/http/httpguts
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package httpguts:
Processing package=httpguts:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/http/httpproxy
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package httpproxy:
Processing package=httpproxy:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/http2
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/http2/hpack
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package hpack:
Processing package=hpack:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/idna
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package idna:
Processing package=idna:
Excluding /home/craig/github/golang/go/src/vendor/golang_org/x/net/internal
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/lif
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/nettest
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package nettest:
Processing package=nettest:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/net/route
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/text
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/text/secure
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package secure:
Processing package=secure:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/text/secure/bidirule
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package bidirule:
Processing package=bidirule:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/text/transform
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package transform:
Processing package=transform:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package unicode:
Processing package=unicode:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/bidi
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package bidi:
Processing package=bidi:
Walking from /home/craig/github/golang/go/src to /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/norm
Processing sourceDir=/home/craig/github/golang/go/src dump=false:
Package norm:
Processing package=norm:
TYPE aes.KeySizeError:
  /home/craig/github/golang/go/src/crypto/aes/cipher.go
TYPE ascii85.CorruptInputError:
  /home/craig/github/golang/go/src/encoding/ascii85/ascii85.go
TYPE asn1.BitString:
  /home/craig/github/golang/go/src/encoding/asn1/asn1.go
TYPE asn1.Enumerated:
  /home/craig/github/golang/go/src/encoding/asn1/asn1.go
TYPE asn1.Flag:
  /home/craig/github/golang/go/src/encoding/asn1/asn1.go
TYPE asn1.ObjectIdentifier:
  /home/craig/github/golang/go/src/encoding/asn1/asn1.go
TYPE asn1.RawContent:
  /home/craig/github/golang/go/src/encoding/asn1/asn1.go
TYPE asn1.RawValue:
  /home/craig/github/golang/go/src/encoding/asn1/asn1.go
TYPE asn1.StructuralError:
  /home/craig/github/golang/go/src/encoding/asn1/asn1.go
TYPE asn1.SyntaxError:
  /home/craig/github/golang/go/src/encoding/asn1/asn1.go
TYPE asn1.Tag:
  /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/cryptobyte/asn1/asn1.go
TYPE ast.ArrayType:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.AssignStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.BadDecl:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.BadExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.BadStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.BasicLit:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.BinaryExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.BlockStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.BranchStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.CallExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.CaseClause:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.ChanDir:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.ChanType:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.CommClause:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Comment:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.CommentGroup:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.CommentMap:
  /home/craig/github/golang/go/src/go/ast/commentmap.go
TYPE ast.CompositeLit:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Decl:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.DeclStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.DeferStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Ellipsis:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.EmptyStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Expr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.ExprStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Field:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.FieldFilter:
  /home/craig/github/golang/go/src/go/ast/print.go
TYPE ast.FieldList:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.File:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Filter:
  /home/craig/github/golang/go/src/go/ast/filter.go
TYPE ast.ForStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.FuncDecl:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.FuncLit:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.FuncType:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.GenDecl:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.GoStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Ident:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.IfStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.ImportSpec:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Importer:
  /home/craig/github/golang/go/src/go/ast/resolve.go
TYPE ast.IncDecStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.IndexExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.InterfaceType:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.KeyValueExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.LabeledStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.MapType:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.MergeMode:
  /home/craig/github/golang/go/src/go/ast/filter.go
TYPE ast.Node:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.ObjKind:
  /home/craig/github/golang/go/src/go/ast/scope.go
TYPE ast.Object:
  /home/craig/github/golang/go/src/go/ast/scope.go
TYPE ast.Package:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.ParenExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.RangeStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.ReturnStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Scope:
  /home/craig/github/golang/go/src/go/ast/scope.go
TYPE ast.SelectStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.SelectorExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.SendStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.SliceExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Spec:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.StarExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Stmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.StructType:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.SwitchStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.TypeAssertExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.TypeSpec:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.TypeSwitchStmt:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.UnaryExpr:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.ValueSpec:
  /home/craig/github/golang/go/src/go/ast/ast.go
TYPE ast.Visitor:
  /home/craig/github/golang/go/src/go/ast/walk.go
TYPE atomic.Value:
  /home/craig/github/golang/go/src/sync/atomic/value.go
TYPE base32.CorruptInputError:
  /home/craig/github/golang/go/src/encoding/base32/base32.go
TYPE base32.Encoding:
  /home/craig/github/golang/go/src/encoding/base32/base32.go
TYPE base64.CorruptInputError:
  /home/craig/github/golang/go/src/encoding/base64/base64.go
TYPE base64.Encoding:
  /home/craig/github/golang/go/src/encoding/base64/base64.go
TYPE bidi.Class:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/bidi/trieval.go
TYPE bidi.Direction:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Option:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Ordering:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Paragraph:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidi.Properties:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/bidi/prop.go
TYPE bidi.Run:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/bidi/bidi.go
TYPE bidirule.Transformer:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/secure/bidirule/bidirule.go
TYPE big.Accuracy:
  /home/craig/github/golang/go/src/math/big/float.go
TYPE big.ErrNaN:
  /home/craig/github/golang/go/src/math/big/float.go
TYPE big.Float:
  /home/craig/github/golang/go/src/math/big/float.go
TYPE big.Int:
  /home/craig/github/golang/go/src/math/big/int.go
TYPE big.Rat:
  /home/craig/github/golang/go/src/math/big/rat.go
TYPE big.RoundingMode:
  /home/craig/github/golang/go/src/math/big/float.go
TYPE big.Word:
  /home/craig/github/golang/go/src/math/big/arith.go
TYPE binary.ByteOrder:
  /home/craig/github/golang/go/src/encoding/binary/binary.go
TYPE bufio.ReadWriter:
  /home/craig/github/golang/go/src/bufio/bufio.go
TYPE bufio.Reader:
  /home/craig/github/golang/go/src/bufio/bufio.go
TYPE bufio.Scanner:
  /home/craig/github/golang/go/src/bufio/scan.go
TYPE bufio.SplitFunc:
  /home/craig/github/golang/go/src/bufio/scan.go
TYPE bufio.Writer:
  /home/craig/github/golang/go/src/bufio/bufio.go
TYPE build.Context:
  /home/craig/github/golang/go/src/go/build/build.go
TYPE build.ImportMode:
  /home/craig/github/golang/go/src/go/build/build.go
TYPE build.MultiplePackageError:
  /home/craig/github/golang/go/src/go/build/build.go
TYPE build.NoGoError:
  /home/craig/github/golang/go/src/go/build/build.go
TYPE build.Package:
  /home/craig/github/golang/go/src/go/build/build.go
TYPE bytes.Buffer:
  /home/craig/github/golang/go/src/bytes/buffer.go
TYPE bytes.Reader:
  /home/craig/github/golang/go/src/bytes/reader.go
TYPE bzip2.StructuralError:
  /home/craig/github/golang/go/src/compress/bzip2/bzip2.go
TYPE cgi.Handler:
  /home/craig/github/golang/go/src/net/http/cgi/host.go
TYPE cipher.AEAD:
  /home/craig/github/golang/go/src/crypto/cipher/gcm.go
TYPE cipher.Block:
  /home/craig/github/golang/go/src/crypto/cipher/cipher.go
TYPE cipher.BlockMode:
  /home/craig/github/golang/go/src/crypto/cipher/cipher.go
TYPE cipher.Stream:
  /home/craig/github/golang/go/src/crypto/cipher/cipher.go
TYPE cipher.StreamReader:
  /home/craig/github/golang/go/src/crypto/cipher/io.go
TYPE cipher.StreamWriter:
  /home/craig/github/golang/go/src/crypto/cipher/io.go
TYPE color.Alpha:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.Alpha16:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.CMYK:
  /home/craig/github/golang/go/src/image/color/ycbcr.go
TYPE color.Color:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.Gray:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.Gray16:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.Model:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.NRGBA:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.NRGBA64:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.NYCbCrA:
  /home/craig/github/golang/go/src/image/color/ycbcr.go
TYPE color.Palette:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.RGBA:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.RGBA64:
  /home/craig/github/golang/go/src/image/color/color.go
TYPE color.YCbCr:
  /home/craig/github/golang/go/src/image/color/ycbcr.go
TYPE constant.Kind:
  /home/craig/github/golang/go/src/go/constant/value.go
TYPE constant.Value:
  /home/craig/github/golang/go/src/go/constant/value.go
TYPE context.CancelFunc:
  /home/craig/github/golang/go/src/context/context.go
TYPE context.Context:
  /home/craig/github/golang/go/src/context/context.go
TYPE cookiejar.Jar:
  /home/craig/github/golang/go/src/net/http/cookiejar/jar.go
TYPE cookiejar.Options:
  /home/craig/github/golang/go/src/net/http/cookiejar/jar.go
TYPE cookiejar.PublicSuffixList:
  /home/craig/github/golang/go/src/net/http/cookiejar/jar.go
TYPE crc32.Table:
  /home/craig/github/golang/go/src/hash/crc32/crc32.go
TYPE crc64.Table:
  /home/craig/github/golang/go/src/hash/crc64/crc64.go
TYPE crypto.Decrypter:
  /home/craig/github/golang/go/src/crypto/crypto.go
TYPE crypto.DecrypterOpts:
  /home/craig/github/golang/go/src/crypto/crypto.go
TYPE crypto.Hash:
  /home/craig/github/golang/go/src/crypto/crypto.go
TYPE crypto.PrivateKey:
  /home/craig/github/golang/go/src/crypto/crypto.go
TYPE crypto.PublicKey:
  /home/craig/github/golang/go/src/crypto/crypto.go
TYPE crypto.Signer:
  /home/craig/github/golang/go/src/crypto/crypto.go
TYPE crypto.SignerOpts:
  /home/craig/github/golang/go/src/crypto/crypto.go
TYPE cryptobyte.BuildError:
  /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.Builder:
  /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.BuilderContinuation:
  /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.MarshalingValue:
  /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/cryptobyte/builder.go
TYPE cryptobyte.String:
  /home/craig/github/golang/go/src/vendor/golang_org/x/crypto/cryptobyte/string.go
TYPE csv.ParseError:
  /home/craig/github/golang/go/src/encoding/csv/reader.go
TYPE csv.Reader:
  /home/craig/github/golang/go/src/encoding/csv/reader.go
TYPE csv.Writer:
  /home/craig/github/golang/go/src/encoding/csv/writer.go
TYPE debug.GCStats:
  /home/craig/github/golang/go/src/runtime/debug/garbage.go
TYPE des.KeySizeError:
  /home/craig/github/golang/go/src/crypto/des/cipher.go
TYPE dnsmessage.AAAAResource:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.AResource:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Builder:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.CNAMEResource:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Class:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Header:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.MXResource:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Message:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.NSResource:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Name:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.OpCode:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.PTRResource:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Parser:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Question:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.RCode:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Resource:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.ResourceBody:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.ResourceHeader:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.SOAResource:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.SRVResource:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.TXTResource:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE dnsmessage.Type:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/dns/dnsmessage/message.go
TYPE doc.Example:
  /home/craig/github/golang/go/src/go/doc/example.go
TYPE doc.Filter:
  /home/craig/github/golang/go/src/go/doc/filter.go
TYPE doc.Func:
  /home/craig/github/golang/go/src/go/doc/doc.go
TYPE doc.Mode:
  /home/craig/github/golang/go/src/go/doc/doc.go
TYPE doc.Note:
  /home/craig/github/golang/go/src/go/doc/doc.go
TYPE doc.Package:
  /home/craig/github/golang/go/src/go/doc/doc.go
TYPE doc.Type:
  /home/craig/github/golang/go/src/go/doc/doc.go
TYPE doc.Value:
  /home/craig/github/golang/go/src/go/doc/doc.go
TYPE draw.Drawer:
  /home/craig/github/golang/go/src/image/draw/draw.go
TYPE draw.Image:
  /home/craig/github/golang/go/src/image/draw/draw.go
TYPE draw.Op:
  /home/craig/github/golang/go/src/image/draw/draw.go
TYPE draw.Quantizer:
  /home/craig/github/golang/go/src/image/draw/draw.go
TYPE driver.ColumnConverter:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.Conn:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.ConnBeginTx:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.ConnPrepareContext:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.Connector:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.Driver:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.DriverContext:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.Execer:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.ExecerContext:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.IsolationLevel:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.NamedValue:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.NamedValueChecker:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.NotNull:
  /home/craig/github/golang/go/src/database/sql/driver/types.go
TYPE driver.Null:
  /home/craig/github/golang/go/src/database/sql/driver/types.go
TYPE driver.Pinger:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.Queryer:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.QueryerContext:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.Result:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.Rows:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.RowsAffected:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeDatabaseTypeName:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeLength:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeNullable:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.RowsColumnTypePrecisionScale:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.RowsColumnTypeScanType:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.RowsNextResultSet:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.SessionResetter:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.Stmt:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.StmtExecContext:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.StmtQueryContext:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.Tx:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.TxOptions:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.Value:
  /home/craig/github/golang/go/src/database/sql/driver/driver.go
TYPE driver.ValueConverter:
  /home/craig/github/golang/go/src/database/sql/driver/types.go
TYPE driver.Valuer:
  /home/craig/github/golang/go/src/database/sql/driver/types.go
TYPE dsa.ParameterSizes:
  /home/craig/github/golang/go/src/crypto/dsa/dsa.go
TYPE dsa.Parameters:
  /home/craig/github/golang/go/src/crypto/dsa/dsa.go
TYPE dsa.PrivateKey:
  /home/craig/github/golang/go/src/crypto/dsa/dsa.go
TYPE dsa.PublicKey:
  /home/craig/github/golang/go/src/crypto/dsa/dsa.go
TYPE dwarf.AddrType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.ArrayType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.Attr:
  /home/craig/github/golang/go/src/debug/dwarf/const.go
TYPE dwarf.BasicType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.BoolType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.CharType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.Class:
  /home/craig/github/golang/go/src/debug/dwarf/entry.go
TYPE dwarf.CommonType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.ComplexType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.Data:
  /home/craig/github/golang/go/src/debug/dwarf/open.go
TYPE dwarf.DecodeError:
  /home/craig/github/golang/go/src/debug/dwarf/buf.go
TYPE dwarf.DotDotDotType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.Entry:
  /home/craig/github/golang/go/src/debug/dwarf/entry.go
TYPE dwarf.EnumType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.EnumValue:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.Field:
  /home/craig/github/golang/go/src/debug/dwarf/entry.go
TYPE dwarf.FloatType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.FuncType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.IntType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.LineEntry:
  /home/craig/github/golang/go/src/debug/dwarf/line.go
TYPE dwarf.LineFile:
  /home/craig/github/golang/go/src/debug/dwarf/line.go
TYPE dwarf.LineReader:
  /home/craig/github/golang/go/src/debug/dwarf/line.go
TYPE dwarf.LineReaderPos:
  /home/craig/github/golang/go/src/debug/dwarf/line.go
TYPE dwarf.Offset:
  /home/craig/github/golang/go/src/debug/dwarf/entry.go
TYPE dwarf.PtrType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.QualType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.Reader:
  /home/craig/github/golang/go/src/debug/dwarf/entry.go
TYPE dwarf.StructField:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.StructType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.Tag:
  /home/craig/github/golang/go/src/debug/dwarf/const.go
TYPE dwarf.Type:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.TypedefType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.UcharType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.UintType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.UnspecifiedType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE dwarf.VoidType:
  /home/craig/github/golang/go/src/debug/dwarf/type.go
TYPE ecdsa.PrivateKey:
  /home/craig/github/golang/go/src/crypto/ecdsa/ecdsa.go
TYPE ecdsa.PublicKey:
  /home/craig/github/golang/go/src/crypto/ecdsa/ecdsa.go
TYPE elf.Chdr32:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Chdr64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Class:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.CompressionType:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Data:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Dyn32:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Dyn64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.DynFlag:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.DynTag:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.File:
  /home/craig/github/golang/go/src/debug/elf/file.go
TYPE elf.FileHeader:
  /home/craig/github/golang/go/src/debug/elf/file.go
TYPE elf.FormatError:
  /home/craig/github/golang/go/src/debug/elf/file.go
TYPE elf.Header32:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Header64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.ImportedSymbol:
  /home/craig/github/golang/go/src/debug/elf/file.go
TYPE elf.Machine:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.NType:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.OSABI:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Prog:
  /home/craig/github/golang/go/src/debug/elf/file.go
TYPE elf.Prog32:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Prog64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.ProgFlag:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.ProgHeader:
  /home/craig/github/golang/go/src/debug/elf/file.go
TYPE elf.ProgType:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_386:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_390:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_AARCH64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_ALPHA:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_ARM:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_MIPS:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_PPC:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_PPC64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_RISCV:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_SPARC:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.R_X86_64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Rel32:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Rel64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Rela32:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Rela64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Section:
  /home/craig/github/golang/go/src/debug/elf/file.go
TYPE elf.Section32:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Section64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.SectionFlag:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.SectionHeader:
  /home/craig/github/golang/go/src/debug/elf/file.go
TYPE elf.SectionIndex:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.SectionType:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Sym32:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Sym64:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.SymBind:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.SymType:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.SymVis:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Symbol:
  /home/craig/github/golang/go/src/debug/elf/file.go
TYPE elf.Type:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elf.Version:
  /home/craig/github/golang/go/src/debug/elf/elf.go
TYPE elliptic.Curve:
  /home/craig/github/golang/go/src/crypto/elliptic/elliptic.go
TYPE elliptic.CurveParams:
  /home/craig/github/golang/go/src/crypto/elliptic/elliptic.go
TYPE encoding.BinaryMarshaler:
  /home/craig/github/golang/go/src/encoding/encoding.go
TYPE encoding.BinaryUnmarshaler:
  /home/craig/github/golang/go/src/encoding/encoding.go
TYPE encoding.TextMarshaler:
  /home/craig/github/golang/go/src/encoding/encoding.go
TYPE encoding.TextUnmarshaler:
  /home/craig/github/golang/go/src/encoding/encoding.go
TYPE exec.Cmd:
  /home/craig/github/golang/go/src/os/exec/exec.go
TYPE exec.Error:
  /home/craig/github/golang/go/src/os/exec/exec.go
TYPE exec.ExitError:
  /home/craig/github/golang/go/src/os/exec/exec.go
TYPE expvar.Float:
  /home/craig/github/golang/go/src/expvar/expvar.go
TYPE expvar.Func:
  /home/craig/github/golang/go/src/expvar/expvar.go
TYPE expvar.Int:
  /home/craig/github/golang/go/src/expvar/expvar.go
TYPE expvar.KeyValue:
  /home/craig/github/golang/go/src/expvar/expvar.go
TYPE expvar.Map:
  /home/craig/github/golang/go/src/expvar/expvar.go
TYPE expvar.String:
  /home/craig/github/golang/go/src/expvar/expvar.go
TYPE expvar.Var:
  /home/craig/github/golang/go/src/expvar/expvar.go
TYPE filepath.WalkFunc:
  /home/craig/github/golang/go/src/path/filepath/path.go
TYPE flag.ErrorHandling:
  /home/craig/github/golang/go/src/flag/flag.go
TYPE flag.Flag:
  /home/craig/github/golang/go/src/flag/flag.go
TYPE flag.FlagSet:
  /home/craig/github/golang/go/src/flag/flag.go
TYPE flag.Getter:
  /home/craig/github/golang/go/src/flag/flag.go
TYPE flag.Value:
  /home/craig/github/golang/go/src/flag/flag.go
TYPE flate.CorruptInputError:
  /home/craig/github/golang/go/src/compress/flate/inflate.go
TYPE flate.InternalError:
  /home/craig/github/golang/go/src/compress/flate/inflate.go
TYPE flate.ReadError:
  /home/craig/github/golang/go/src/compress/flate/inflate.go
TYPE flate.Reader:
  /home/craig/github/golang/go/src/compress/flate/inflate.go
TYPE flate.Resetter:
  /home/craig/github/golang/go/src/compress/flate/inflate.go
TYPE flate.WriteError:
  /home/craig/github/golang/go/src/compress/flate/inflate.go
TYPE flate.Writer:
  /home/craig/github/golang/go/src/compress/flate/deflate.go
TYPE fmt.Formatter:
  /home/craig/github/golang/go/src/fmt/print.go
TYPE fmt.GoStringer:
  /home/craig/github/golang/go/src/fmt/print.go
TYPE fmt.ScanState:
  /home/craig/github/golang/go/src/fmt/scan.go
TYPE fmt.Scanner:
  /home/craig/github/golang/go/src/fmt/scan.go
TYPE fmt.State:
  /home/craig/github/golang/go/src/fmt/print.go
TYPE fmt.Stringer:
  /home/craig/github/golang/go/src/fmt/print.go
TYPE gif.GIF:
  /home/craig/github/golang/go/src/image/gif/reader.go
TYPE gif.Options:
  /home/craig/github/golang/go/src/image/gif/writer.go
TYPE gob.CommonType:
  /home/craig/github/golang/go/src/encoding/gob/type.go
TYPE gob.Decoder:
  /home/craig/github/golang/go/src/encoding/gob/decoder.go
TYPE gob.Encoder:
  /home/craig/github/golang/go/src/encoding/gob/encoder.go
TYPE gob.GobDecoder:
  /home/craig/github/golang/go/src/encoding/gob/type.go
TYPE gob.GobEncoder:
  /home/craig/github/golang/go/src/encoding/gob/type.go
TYPE gosym.DecodingError:
  /home/craig/github/golang/go/src/debug/gosym/symtab.go
TYPE gosym.Func:
  /home/craig/github/golang/go/src/debug/gosym/symtab.go
TYPE gosym.LineTable:
  /home/craig/github/golang/go/src/debug/gosym/pclntab.go
TYPE gosym.Obj:
  /home/craig/github/golang/go/src/debug/gosym/symtab.go
TYPE gosym.Sym:
  /home/craig/github/golang/go/src/debug/gosym/symtab.go
TYPE gosym.Table:
  /home/craig/github/golang/go/src/debug/gosym/symtab.go
TYPE gosym.UnknownFileError:
  /home/craig/github/golang/go/src/debug/gosym/symtab.go
TYPE gosym.UnknownLineError:
  /home/craig/github/golang/go/src/debug/gosym/symtab.go
TYPE gzip.Header:
  /home/craig/github/golang/go/src/compress/gzip/gunzip.go
TYPE gzip.Reader:
  /home/craig/github/golang/go/src/compress/gzip/gunzip.go
TYPE gzip.Writer:
  /home/craig/github/golang/go/src/compress/gzip/gzip.go
TYPE hash.Hash:
  /home/craig/github/golang/go/src/hash/hash.go
TYPE hash.Hash32:
  /home/craig/github/golang/go/src/hash/hash.go
TYPE hash.Hash64:
  /home/craig/github/golang/go/src/hash/hash.go
TYPE heap.Interface:
  /home/craig/github/golang/go/src/container/heap/heap.go
TYPE hex.InvalidByteError:
  /home/craig/github/golang/go/src/encoding/hex/hex.go
TYPE hpack.Decoder:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE hpack.DecodingError:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE hpack.Encoder:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/http2/hpack/encode.go
TYPE hpack.HeaderField:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE hpack.InvalidIndexError:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/http2/hpack/hpack.go
TYPE http.Client:
  /home/craig/github/golang/go/src/net/http/client.go
TYPE http.CloseNotifier:
  /home/craig/github/golang/go/src/net/http/server.go
TYPE http.ConnState:
  /home/craig/github/golang/go/src/net/http/server.go
TYPE http.Cookie:
  /home/craig/github/golang/go/src/net/http/cookie.go
TYPE http.CookieJar:
  /home/craig/github/golang/go/src/net/http/jar.go
TYPE http.Dir:
  /home/craig/github/golang/go/src/net/http/fs.go
TYPE http.File:
  /home/craig/github/golang/go/src/net/http/fs.go
TYPE http.FileSystem:
  /home/craig/github/golang/go/src/net/http/fs.go
TYPE http.Flusher:
  /home/craig/github/golang/go/src/net/http/server.go
TYPE http.Handler:
  /home/craig/github/golang/go/src/net/http/server.go
TYPE http.HandlerFunc:
  /home/craig/github/golang/go/src/net/http/server.go
TYPE http.Header:
  /home/craig/github/golang/go/src/net/http/header.go
TYPE http.Hijacker:
  /home/craig/github/golang/go/src/net/http/server.go
TYPE http.ProtocolError:
  /home/craig/github/golang/go/src/net/http/request.go
TYPE http.PushOptions:
  /home/craig/github/golang/go/src/net/http/http.go
TYPE http.Pusher:
  /home/craig/github/golang/go/src/net/http/http.go
TYPE http.Request:
  /home/craig/github/golang/go/src/net/http/request.go
TYPE http.Response:
  /home/craig/github/golang/go/src/net/http/response.go
TYPE http.ResponseWriter:
  /home/craig/github/golang/go/src/net/http/server.go
TYPE http.RoundTripper:
  /home/craig/github/golang/go/src/net/http/client.go
TYPE http.SameSite:
  /home/craig/github/golang/go/src/net/http/cookie.go
TYPE http.ServeMux:
  /home/craig/github/golang/go/src/net/http/server.go
TYPE http.Server:
  /home/craig/github/golang/go/src/net/http/server.go
TYPE http.Transport:
  /home/craig/github/golang/go/src/net/http/transport.go
TYPE httpproxy.Config:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/http/httpproxy/proxy.go
TYPE httptest.ResponseRecorder:
  /home/craig/github/golang/go/src/net/http/httptest/recorder.go
TYPE httptest.Server:
  /home/craig/github/golang/go/src/net/http/httptest/server.go
TYPE httptrace.ClientTrace:
  /home/craig/github/golang/go/src/net/http/httptrace/trace.go
TYPE httptrace.DNSDoneInfo:
  /home/craig/github/golang/go/src/net/http/httptrace/trace.go
TYPE httptrace.DNSStartInfo:
  /home/craig/github/golang/go/src/net/http/httptrace/trace.go
TYPE httptrace.GotConnInfo:
  /home/craig/github/golang/go/src/net/http/httptrace/trace.go
TYPE httptrace.WroteRequestInfo:
  /home/craig/github/golang/go/src/net/http/httptrace/trace.go
TYPE httputil.BufferPool:
  /home/craig/github/golang/go/src/net/http/httputil/reverseproxy.go
TYPE httputil.ClientConn:
  /home/craig/github/golang/go/src/net/http/httputil/persist.go
TYPE httputil.ReverseProxy:
  /home/craig/github/golang/go/src/net/http/httputil/reverseproxy.go
TYPE httputil.ServerConn:
  /home/craig/github/golang/go/src/net/http/httputil/persist.go
TYPE idna.Option:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/idna/idna.go
TYPE idna.Profile:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/idna/idna.go
TYPE image.Alpha:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.Alpha16:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.CMYK:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.Config:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.Gray:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.Gray16:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.Image:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.NRGBA:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.NRGBA64:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.NYCbCrA:
  /home/craig/github/golang/go/src/image/ycbcr.go
TYPE image.Paletted:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.PalettedImage:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.Point:
  /home/craig/github/golang/go/src/image/geom.go
TYPE image.RGBA:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.RGBA64:
  /home/craig/github/golang/go/src/image/image.go
TYPE image.Rectangle:
  /home/craig/github/golang/go/src/image/geom.go
TYPE image.Uniform:
  /home/craig/github/golang/go/src/image/names.go
TYPE image.YCbCr:
  /home/craig/github/golang/go/src/image/ycbcr.go
TYPE image.YCbCrSubsampleRatio:
  /home/craig/github/golang/go/src/image/ycbcr.go
TYPE importer.Lookup:
  /home/craig/github/golang/go/src/go/importer/importer.go
TYPE io.ByteReader:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.ByteScanner:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.ByteWriter:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.Closer:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.LimitedReader:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.PipeReader:
  /home/craig/github/golang/go/src/io/pipe.go
TYPE io.PipeWriter:
  /home/craig/github/golang/go/src/io/pipe.go
TYPE io.ReadCloser:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.ReadSeeker:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.ReadWriteCloser:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.ReadWriteSeeker:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.ReadWriter:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.Reader:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.ReaderAt:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.ReaderFrom:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.RuneReader:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.RuneScanner:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.SectionReader:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.Seeker:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.WriteCloser:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.WriteSeeker:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.Writer:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.WriterAt:
  /home/craig/github/golang/go/src/io/io.go
TYPE io.WriterTo:
  /home/craig/github/golang/go/src/io/io.go
TYPE jpeg.FormatError:
  /home/craig/github/golang/go/src/image/jpeg/reader.go
TYPE jpeg.Options:
  /home/craig/github/golang/go/src/image/jpeg/writer.go
TYPE jpeg.Reader:
  /home/craig/github/golang/go/src/image/jpeg/reader.go
TYPE jpeg.UnsupportedError:
  /home/craig/github/golang/go/src/image/jpeg/reader.go
TYPE json.Decoder:
  /home/craig/github/golang/go/src/encoding/json/stream.go
TYPE json.Delim:
  /home/craig/github/golang/go/src/encoding/json/stream.go
TYPE json.Encoder:
  /home/craig/github/golang/go/src/encoding/json/stream.go
TYPE json.InvalidUTF8Error:
  /home/craig/github/golang/go/src/encoding/json/encode.go
TYPE json.InvalidUnmarshalError:
  /home/craig/github/golang/go/src/encoding/json/decode.go
TYPE json.Marshaler:
  /home/craig/github/golang/go/src/encoding/json/encode.go
TYPE json.MarshalerError:
  /home/craig/github/golang/go/src/encoding/json/encode.go
TYPE json.Number:
  /home/craig/github/golang/go/src/encoding/json/decode.go
TYPE json.RawMessage:
  /home/craig/github/golang/go/src/encoding/json/stream.go
TYPE json.SyntaxError:
  /home/craig/github/golang/go/src/encoding/json/scanner.go
TYPE json.Token:
  /home/craig/github/golang/go/src/encoding/json/stream.go
TYPE json.UnmarshalFieldError:
  /home/craig/github/golang/go/src/encoding/json/decode.go
TYPE json.UnmarshalTypeError:
  /home/craig/github/golang/go/src/encoding/json/decode.go
TYPE json.Unmarshaler:
  /home/craig/github/golang/go/src/encoding/json/decode.go
TYPE json.UnsupportedTypeError:
  /home/craig/github/golang/go/src/encoding/json/encode.go
TYPE json.UnsupportedValueError:
  /home/craig/github/golang/go/src/encoding/json/encode.go
TYPE list.Element:
  /home/craig/github/golang/go/src/container/list/list.go
TYPE list.List:
  /home/craig/github/golang/go/src/container/list/list.go
TYPE log.Logger:
  /home/craig/github/golang/go/src/log/log.go
TYPE lzw.Order:
  /home/craig/github/golang/go/src/compress/lzw/reader.go
TYPE macho.Cpu:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Dylib:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.DylibCmd:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Dysymtab:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.DysymtabCmd:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.FatArch:
  /home/craig/github/golang/go/src/debug/macho/fat.go
TYPE macho.FatArchHeader:
  /home/craig/github/golang/go/src/debug/macho/fat.go
TYPE macho.FatFile:
  /home/craig/github/golang/go/src/debug/macho/fat.go
TYPE macho.File:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.FileHeader:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.FormatError:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.Load:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.LoadBytes:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.LoadCmd:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Nlist32:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Nlist64:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Regs386:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.RegsAMD64:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Reloc:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.RelocTypeARM:
  /home/craig/github/golang/go/src/debug/macho/reloctype.go
TYPE macho.RelocTypeARM64:
  /home/craig/github/golang/go/src/debug/macho/reloctype.go
TYPE macho.RelocTypeGeneric:
  /home/craig/github/golang/go/src/debug/macho/reloctype.go
TYPE macho.RelocTypeX86_64:
  /home/craig/github/golang/go/src/debug/macho/reloctype.go
TYPE macho.Rpath:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.RpathCmd:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Section:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.Section32:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Section64:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.SectionHeader:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.Segment:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.Segment32:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Segment64:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.SegmentHeader:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.Symbol:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.Symtab:
  /home/craig/github/golang/go/src/debug/macho/file.go
TYPE macho.SymtabCmd:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Thread:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE macho.Type:
  /home/craig/github/golang/go/src/debug/macho/macho.go
TYPE mail.Address:
  /home/craig/github/golang/go/src/net/mail/message.go
TYPE mail.AddressParser:
  /home/craig/github/golang/go/src/net/mail/message.go
TYPE mail.Header:
  /home/craig/github/golang/go/src/net/mail/message.go
TYPE mail.Message:
  /home/craig/github/golang/go/src/net/mail/message.go
TYPE mime.WordDecoder:
  /home/craig/github/golang/go/src/mime/encodedword.go
TYPE mime.WordEncoder:
  /home/craig/github/golang/go/src/mime/encodedword.go
TYPE multipart.File:
  /home/craig/github/golang/go/src/mime/multipart/formdata.go
TYPE multipart.FileHeader:
  /home/craig/github/golang/go/src/mime/multipart/formdata.go
TYPE multipart.Form:
  /home/craig/github/golang/go/src/mime/multipart/formdata.go
TYPE multipart.Part:
  /home/craig/github/golang/go/src/mime/multipart/multipart.go
TYPE multipart.Reader:
  /home/craig/github/golang/go/src/mime/multipart/multipart.go
TYPE multipart.Writer:
  /home/craig/github/golang/go/src/mime/multipart/writer.go
TYPE net.Addr:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.AddrError:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.Buffers:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.Conn:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.DNSConfigError:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.DNSError:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.Dialer:
  /home/craig/github/golang/go/src/net/dial.go
TYPE net.Error:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.Flags:
  /home/craig/github/golang/go/src/net/interface.go
TYPE net.HardwareAddr:
  /home/craig/github/golang/go/src/net/mac.go
TYPE net.IP:
  /home/craig/github/golang/go/src/net/ip.go
TYPE net.IPAddr:
  /home/craig/github/golang/go/src/net/iprawsock.go
TYPE net.IPConn:
  /home/craig/github/golang/go/src/net/iprawsock.go
TYPE net.IPMask:
  /home/craig/github/golang/go/src/net/ip.go
TYPE net.IPNet:
  /home/craig/github/golang/go/src/net/ip.go
TYPE net.Interface:
  /home/craig/github/golang/go/src/net/interface.go
TYPE net.InvalidAddrError:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.ListenConfig:
  /home/craig/github/golang/go/src/net/dial.go
TYPE net.Listener:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.MX:
  /home/craig/github/golang/go/src/net/dnsclient.go
TYPE net.NS:
  /home/craig/github/golang/go/src/net/dnsclient.go
TYPE net.OpError:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.PacketConn:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.ParseError:
  /home/craig/github/golang/go/src/net/net.go
TYPE net.Resolver:
  /home/craig/github/golang/go/src/net/lookup.go
TYPE net.SRV:
  /home/craig/github/golang/go/src/net/dnsclient.go
TYPE net.TCPAddr:
  /home/craig/github/golang/go/src/net/tcpsock.go
TYPE net.TCPConn:
  /home/craig/github/golang/go/src/net/tcpsock.go
TYPE net.TCPListener:
  /home/craig/github/golang/go/src/net/tcpsock.go
TYPE net.UDPAddr:
  /home/craig/github/golang/go/src/net/udpsock.go
TYPE net.UDPConn:
  /home/craig/github/golang/go/src/net/udpsock.go
TYPE net.UnixAddr:
  /home/craig/github/golang/go/src/net/unixsock.go
TYPE net.UnixConn:
  /home/craig/github/golang/go/src/net/unixsock.go
TYPE net.UnixListener:
  /home/craig/github/golang/go/src/net/unixsock.go
TYPE net.UnknownNetworkError:
  /home/craig/github/golang/go/src/net/net.go
TYPE nettest.MakePipe:
  /home/craig/github/golang/go/src/vendor/golang_org/x/net/nettest/conntest.go
TYPE norm.Form:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/norm/normalize.go
TYPE norm.Iter:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/norm/iter.go
TYPE norm.Properties:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/unicode/norm/forminfo.go
TYPE os.File:
  /home/craig/github/golang/go/src/os/types.go
TYPE os.FileInfo:
  /home/craig/github/golang/go/src/os/types.go
TYPE os.FileMode:
  /home/craig/github/golang/go/src/os/types.go
TYPE os.LinkError:
  /home/craig/github/golang/go/src/os/file.go
TYPE os.PathError:
  /home/craig/github/golang/go/src/os/error.go
TYPE os.ProcAttr:
  /home/craig/github/golang/go/src/os/exec.go
TYPE os.Process:
  /home/craig/github/golang/go/src/os/exec.go
TYPE os.ProcessState:
  /home/craig/github/golang/go/src/os/exec_posix.go
TYPE os.Signal:
  /home/craig/github/golang/go/src/os/exec.go
TYPE os.SyscallError:
  /home/craig/github/golang/go/src/os/error.go
TYPE parse.ActionNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.BoolNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.BranchNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.ChainNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.CommandNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.DotNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.FieldNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.IdentifierNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.IfNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.ListNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.NilNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.Node:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.NodeType:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.NumberNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.PipeNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.Pos:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.RangeNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.StringNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.TemplateNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.TextNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.Tree:
  /home/craig/github/golang/go/src/text/template/parse/parse.go
TYPE parse.VariableNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parse.WithNode:
  /home/craig/github/golang/go/src/text/template/parse/node.go
TYPE parser.Mode:
  /home/craig/github/golang/go/src/go/parser/interface.go
TYPE pe.COFFSymbol:
  /home/craig/github/golang/go/src/debug/pe/symbol.go
TYPE pe.DataDirectory:
  /home/craig/github/golang/go/src/debug/pe/pe.go
TYPE pe.File:
  /home/craig/github/golang/go/src/debug/pe/file.go
TYPE pe.FileHeader:
  /home/craig/github/golang/go/src/debug/pe/pe.go
TYPE pe.FormatError:
  /home/craig/github/golang/go/src/debug/pe/file.go
TYPE pe.ImportDirectory:
  /home/craig/github/golang/go/src/debug/pe/file.go
TYPE pe.OptionalHeader32:
  /home/craig/github/golang/go/src/debug/pe/pe.go
TYPE pe.OptionalHeader64:
  /home/craig/github/golang/go/src/debug/pe/pe.go
TYPE pe.Reloc:
  /home/craig/github/golang/go/src/debug/pe/section.go
TYPE pe.Section:
  /home/craig/github/golang/go/src/debug/pe/section.go
TYPE pe.SectionHeader:
  /home/craig/github/golang/go/src/debug/pe/section.go
TYPE pe.SectionHeader32:
  /home/craig/github/golang/go/src/debug/pe/section.go
TYPE pe.StringTable:
  /home/craig/github/golang/go/src/debug/pe/string.go
TYPE pe.Symbol:
  /home/craig/github/golang/go/src/debug/pe/symbol.go
TYPE pem.Block:
  /home/craig/github/golang/go/src/encoding/pem/pem.go
TYPE pkix.AlgorithmIdentifier:
  /home/craig/github/golang/go/src/crypto/x509/pkix/pkix.go
TYPE pkix.AttributeTypeAndValue:
  /home/craig/github/golang/go/src/crypto/x509/pkix/pkix.go
TYPE pkix.AttributeTypeAndValueSET:
  /home/craig/github/golang/go/src/crypto/x509/pkix/pkix.go
TYPE pkix.CertificateList:
  /home/craig/github/golang/go/src/crypto/x509/pkix/pkix.go
TYPE pkix.Extension:
  /home/craig/github/golang/go/src/crypto/x509/pkix/pkix.go
TYPE pkix.Name:
  /home/craig/github/golang/go/src/crypto/x509/pkix/pkix.go
TYPE pkix.RDNSequence:
  /home/craig/github/golang/go/src/crypto/x509/pkix/pkix.go
TYPE pkix.RelativeDistinguishedNameSET:
  /home/craig/github/golang/go/src/crypto/x509/pkix/pkix.go
TYPE pkix.RevokedCertificate:
  /home/craig/github/golang/go/src/crypto/x509/pkix/pkix.go
TYPE pkix.TBSCertificateList:
  /home/craig/github/golang/go/src/crypto/x509/pkix/pkix.go
TYPE plan9obj.File:
  /home/craig/github/golang/go/src/debug/plan9obj/file.go
TYPE plan9obj.FileHeader:
  /home/craig/github/golang/go/src/debug/plan9obj/file.go
TYPE plan9obj.Section:
  /home/craig/github/golang/go/src/debug/plan9obj/file.go
TYPE plan9obj.SectionHeader:
  /home/craig/github/golang/go/src/debug/plan9obj/file.go
TYPE plan9obj.Sym:
  /home/craig/github/golang/go/src/debug/plan9obj/file.go
TYPE plugin.Plugin:
  /home/craig/github/golang/go/src/plugin/plugin.go
TYPE plugin.Symbol:
  /home/craig/github/golang/go/src/plugin/plugin.go
TYPE png.CompressionLevel:
  /home/craig/github/golang/go/src/image/png/writer.go
TYPE png.Encoder:
  /home/craig/github/golang/go/src/image/png/writer.go
TYPE png.EncoderBuffer:
  /home/craig/github/golang/go/src/image/png/writer.go
TYPE png.EncoderBufferPool:
  /home/craig/github/golang/go/src/image/png/writer.go
TYPE png.FormatError:
  /home/craig/github/golang/go/src/image/png/reader.go
TYPE png.UnsupportedError:
  /home/craig/github/golang/go/src/image/png/reader.go
TYPE pprof.LabelSet:
  /home/craig/github/golang/go/src/runtime/pprof/label.go
TYPE pprof.Profile:
  /home/craig/github/golang/go/src/runtime/pprof/pprof.go
TYPE printer.CommentedNode:
  /home/craig/github/golang/go/src/go/printer/printer.go
TYPE printer.Config:
  /home/craig/github/golang/go/src/go/printer/printer.go
TYPE printer.Mode:
  /home/craig/github/golang/go/src/go/printer/printer.go
TYPE quick.CheckEqualError:
  /home/craig/github/golang/go/src/testing/quick/quick.go
TYPE quick.CheckError:
  /home/craig/github/golang/go/src/testing/quick/quick.go
TYPE quick.Config:
  /home/craig/github/golang/go/src/testing/quick/quick.go
TYPE quick.Generator:
  /home/craig/github/golang/go/src/testing/quick/quick.go
TYPE quick.SetupError:
  /home/craig/github/golang/go/src/testing/quick/quick.go
TYPE quotedprintable.Reader:
  /home/craig/github/golang/go/src/mime/quotedprintable/reader.go
TYPE quotedprintable.Writer:
  /home/craig/github/golang/go/src/mime/quotedprintable/writer.go
TYPE rand.Rand:
  /home/craig/github/golang/go/src/math/rand/rand.go
TYPE rand.Source:
  /home/craig/github/golang/go/src/math/rand/rand.go
TYPE rand.Source64:
  /home/craig/github/golang/go/src/math/rand/rand.go
TYPE rand.Zipf:
  /home/craig/github/golang/go/src/math/rand/zipf.go
TYPE rc4.Cipher:
  /home/craig/github/golang/go/src/crypto/rc4/rc4.go
TYPE rc4.KeySizeError:
  /home/craig/github/golang/go/src/crypto/rc4/rc4.go
TYPE reflect.ChanDir:
  /home/craig/github/golang/go/src/reflect/type.go
TYPE reflect.Kind:
  /home/craig/github/golang/go/src/reflect/type.go
TYPE reflect.Method:
  /home/craig/github/golang/go/src/reflect/type.go
TYPE reflect.SelectCase:
  /home/craig/github/golang/go/src/reflect/value.go
TYPE reflect.SelectDir:
  /home/craig/github/golang/go/src/reflect/value.go
TYPE reflect.SliceHeader:
  /home/craig/github/golang/go/src/reflect/value.go
TYPE reflect.StringHeader:
  /home/craig/github/golang/go/src/reflect/value.go
TYPE reflect.StructField:
  /home/craig/github/golang/go/src/reflect/type.go
TYPE reflect.StructTag:
  /home/craig/github/golang/go/src/reflect/type.go
TYPE reflect.Type:
  /home/craig/github/golang/go/src/reflect/type.go
TYPE reflect.Value:
  /home/craig/github/golang/go/src/reflect/value.go
TYPE reflect.ValueError:
  /home/craig/github/golang/go/src/reflect/value.go
TYPE regexp.Regexp:
  /home/craig/github/golang/go/src/regexp/regexp.go
TYPE ring.Ring:
  /home/craig/github/golang/go/src/container/ring/ring.go
TYPE rpc.Call:
  /home/craig/github/golang/go/src/net/rpc/client.go
TYPE rpc.Client:
  /home/craig/github/golang/go/src/net/rpc/client.go
TYPE rpc.ClientCodec:
  /home/craig/github/golang/go/src/net/rpc/client.go
TYPE rpc.Request:
  /home/craig/github/golang/go/src/net/rpc/server.go
TYPE rpc.Response:
  /home/craig/github/golang/go/src/net/rpc/server.go
TYPE rpc.Server:
  /home/craig/github/golang/go/src/net/rpc/server.go
TYPE rpc.ServerCodec:
  /home/craig/github/golang/go/src/net/rpc/server.go
TYPE rpc.ServerError:
  /home/craig/github/golang/go/src/net/rpc/client.go
TYPE rsa.CRTValue:
  /home/craig/github/golang/go/src/crypto/rsa/rsa.go
TYPE rsa.OAEPOptions:
  /home/craig/github/golang/go/src/crypto/rsa/rsa.go
TYPE rsa.PKCS1v15DecryptOptions:
  /home/craig/github/golang/go/src/crypto/rsa/pkcs1v15.go
TYPE rsa.PSSOptions:
  /home/craig/github/golang/go/src/crypto/rsa/pss.go
TYPE rsa.PrecomputedValues:
  /home/craig/github/golang/go/src/crypto/rsa/rsa.go
TYPE rsa.PrivateKey:
  /home/craig/github/golang/go/src/crypto/rsa/rsa.go
TYPE rsa.PublicKey:
  /home/craig/github/golang/go/src/crypto/rsa/rsa.go
TYPE runtime.BlockProfileRecord:
  /home/craig/github/golang/go/src/runtime/mprof.go
TYPE runtime.Error:
  /home/craig/github/golang/go/src/runtime/error.go
TYPE runtime.Frame:
  /home/craig/github/golang/go/src/runtime/symtab.go
TYPE runtime.Frames:
  /home/craig/github/golang/go/src/runtime/symtab.go
TYPE runtime.Func:
  /home/craig/github/golang/go/src/runtime/symtab.go
TYPE runtime.MemProfileRecord:
  /home/craig/github/golang/go/src/runtime/mprof.go
TYPE runtime.MemStats:
  /home/craig/github/golang/go/src/runtime/mstats.go
TYPE runtime.StackRecord:
  /home/craig/github/golang/go/src/runtime/mprof.go
TYPE runtime.TypeAssertionError:
  /home/craig/github/golang/go/src/runtime/error.go
TYPE runtime._defer:
  /home/craig/github/golang/go/src/runtime/runtime2.go
TYPE runtime._func:
  /home/craig/github/golang/go/src/runtime/runtime2.go
TYPE runtime._panic:
  /home/craig/github/golang/go/src/runtime/runtime2.go
TYPE runtime._type:
  /home/craig/github/golang/go/src/runtime/type.go
TYPE runtime._typePair:
  /home/craig/github/golang/go/src/runtime/type.go
TYPE scanner.Error:
  /home/craig/github/golang/go/src/go/scanner/errors.go
TYPE scanner.ErrorHandler:
  /home/craig/github/golang/go/src/go/scanner/scanner.go
TYPE scanner.ErrorList:
  /home/craig/github/golang/go/src/go/scanner/errors.go
TYPE scanner.Mode:
  /home/craig/github/golang/go/src/go/scanner/scanner.go
TYPE scanner.Position:
  /home/craig/github/golang/go/src/text/scanner/scanner.go
TYPE scanner.Scanner:
  /home/craig/github/golang/go/src/text/scanner/scanner.go
TYPE smtp.Auth:
  /home/craig/github/golang/go/src/net/smtp/auth.go
TYPE smtp.Client:
  /home/craig/github/golang/go/src/net/smtp/smtp.go
TYPE smtp.ServerInfo:
  /home/craig/github/golang/go/src/net/smtp/auth.go
TYPE sort.Float64Slice:
  /home/craig/github/golang/go/src/sort/sort.go
TYPE sort.IntSlice:
  /home/craig/github/golang/go/src/sort/sort.go
TYPE sort.Interface:
  /home/craig/github/golang/go/src/sort/sort.go
TYPE sort.StringSlice:
  /home/craig/github/golang/go/src/sort/sort.go
TYPE sql.ColumnType:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.Conn:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.DB:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.DBStats:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.IsolationLevel:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.NamedArg:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.NullBool:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.NullFloat64:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.NullInt64:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.NullString:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.Out:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.RawBytes:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.Result:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.Row:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.Rows:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.Scanner:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.Stmt:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.Tx:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE sql.TxOptions:
  /home/craig/github/golang/go/src/database/sql/sql.go
TYPE strconv.NumError:
  /home/craig/github/golang/go/src/strconv/atoi.go
TYPE strings.Builder:
  /home/craig/github/golang/go/src/strings/builder.go
TYPE strings.Reader:
  /home/craig/github/golang/go/src/strings/reader.go
TYPE strings.Replacer:
  /home/craig/github/golang/go/src/strings/replace.go
TYPE suffixarray.Index:
  /home/craig/github/golang/go/src/index/suffixarray/suffixarray.go
TYPE sync.Cond:
  /home/craig/github/golang/go/src/sync/cond.go
TYPE sync.Locker:
  /home/craig/github/golang/go/src/sync/mutex.go
TYPE sync.Map:
  /home/craig/github/golang/go/src/sync/map.go
TYPE sync.Mutex:
  /home/craig/github/golang/go/src/sync/mutex.go
TYPE sync.Once:
  /home/craig/github/golang/go/src/sync/once.go
TYPE sync.Pool:
  /home/craig/github/golang/go/src/sync/pool.go
TYPE sync.RWMutex:
  /home/craig/github/golang/go/src/sync/rwmutex.go
TYPE sync.WaitGroup:
  /home/craig/github/golang/go/src/sync/waitgroup.go
TYPE syntax.EmptyOp:
  /home/craig/github/golang/go/src/regexp/syntax/prog.go
TYPE syntax.Error:
  /home/craig/github/golang/go/src/regexp/syntax/parse.go
TYPE syntax.ErrorCode:
  /home/craig/github/golang/go/src/regexp/syntax/parse.go
TYPE syntax.Flags:
  /home/craig/github/golang/go/src/regexp/syntax/parse.go
TYPE syntax.Inst:
  /home/craig/github/golang/go/src/regexp/syntax/prog.go
TYPE syntax.InstOp:
  /home/craig/github/golang/go/src/regexp/syntax/prog.go
TYPE syntax.Op:
  /home/craig/github/golang/go/src/regexp/syntax/regexp.go
TYPE syntax.Prog:
  /home/craig/github/golang/go/src/regexp/syntax/prog.go
TYPE syntax.Regexp:
  /home/craig/github/golang/go/src/regexp/syntax/regexp.go
TYPE syscall.Cmsghdr:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Conn:
  /home/craig/github/golang/go/src/syscall/net.go
TYPE syscall.Credential:
  /home/craig/github/golang/go/src/syscall/exec_unix.go
TYPE syscall.Dirent:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.EpollEvent:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Errno:
  /home/craig/github/golang/go/src/syscall/syscall_unix.go
TYPE syscall.FdSet:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Flock_t:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Fsid:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.ICMPv6Filter:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IPMreq:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IPMreqn:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IPv6MTUInfo:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IPv6Mreq:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IfAddrmsg:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IfInfomsg:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Inet4Pktinfo:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Inet6Pktinfo:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.InotifyEvent:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Iovec:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Linger:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Msghdr:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.NetlinkMessage:
  /home/craig/github/golang/go/src/syscall/netlink_linux.go
TYPE syscall.NetlinkRouteAttr:
  /home/craig/github/golang/go/src/syscall/netlink_linux.go
TYPE syscall.NetlinkRouteRequest:
  /home/craig/github/golang/go/src/syscall/netlink_linux.go
TYPE syscall.NlAttr:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.NlMsgerr:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.NlMsghdr:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.ProcAttr:
  /home/craig/github/golang/go/src/syscall/exec_unix.go
TYPE syscall.PtraceRegs:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawConn:
  /home/craig/github/golang/go/src/syscall/net.go
TYPE syscall.RawSockaddr:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrAny:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrInet4:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrInet6:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrLinklayer:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrNetlink:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrUnix:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Rlimit:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RtAttr:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RtGenmsg:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RtMsg:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RtNexthop:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Rusage:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Signal:
  /home/craig/github/golang/go/src/syscall/syscall_unix.go
TYPE syscall.SockFilter:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.SockFprog:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Sockaddr:
  /home/craig/github/golang/go/src/syscall/syscall_unix.go
TYPE syscall.SockaddrInet4:
  /home/craig/github/golang/go/src/syscall/syscall_unix.go
TYPE syscall.SockaddrInet6:
  /home/craig/github/golang/go/src/syscall/syscall_unix.go
TYPE syscall.SockaddrLinklayer:
  /home/craig/github/golang/go/src/syscall/syscall_linux.go
TYPE syscall.SockaddrNetlink:
  /home/craig/github/golang/go/src/syscall/syscall_linux.go
TYPE syscall.SockaddrUnix:
  /home/craig/github/golang/go/src/syscall/syscall_unix.go
TYPE syscall.SocketControlMessage:
  /home/craig/github/golang/go/src/syscall/sockcmsg_unix.go
TYPE syscall.Stat_t:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Statfs_t:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.SysProcAttr:
  /home/craig/github/golang/go/src/syscall/exec_linux.go
TYPE syscall.SysProcIDMap:
  /home/craig/github/golang/go/src/syscall/exec_linux.go
TYPE syscall.Sysinfo_t:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.TCPInfo:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Termios:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Time_t:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Timespec:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Timeval:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Timex:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Tms:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Ucred:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Ustat_t:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Utimbuf:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Utsname:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall.WaitStatus:
  /home/craig/github/golang/go/src/syscall/syscall_linux.go
TYPE syscall._C_int:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall._C_long:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall._C_long_long:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall._C_short:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall._Gid_t:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syscall._Socklen:
  /home/craig/github/golang/go/src/syscall/ztypes_linux_amd64.go
TYPE syslog.Priority:
  /home/craig/github/golang/go/src/log/syslog/syslog.go
TYPE syslog.Writer:
  /home/craig/github/golang/go/src/log/syslog/syslog.go
TYPE tabwriter.Writer:
  /home/craig/github/golang/go/src/text/tabwriter/tabwriter.go
TYPE tar.Format:
  /home/craig/github/golang/go/src/archive/tar/format.go
TYPE tar.Header:
  /home/craig/github/golang/go/src/archive/tar/common.go
TYPE tar.Reader:
  /home/craig/github/golang/go/src/archive/tar/reader.go
TYPE tar.Writer:
  /home/craig/github/golang/go/src/archive/tar/writer.go
TYPE template.CSS:
  /home/craig/github/golang/go/src/html/template/content.go
TYPE template.Error:
  /home/craig/github/golang/go/src/html/template/error.go
TYPE template.ErrorCode:
  /home/craig/github/golang/go/src/html/template/error.go
TYPE template.ExecError:
  /home/craig/github/golang/go/src/text/template/exec.go
TYPE template.FuncMap:
  /home/craig/github/golang/go/src/text/template/funcs.go
TYPE template.HTML:
  /home/craig/github/golang/go/src/html/template/content.go
TYPE template.HTMLAttr:
  /home/craig/github/golang/go/src/html/template/content.go
TYPE template.JS:
  /home/craig/github/golang/go/src/html/template/content.go
TYPE template.JSStr:
  /home/craig/github/golang/go/src/html/template/content.go
TYPE template.Srcset:
  /home/craig/github/golang/go/src/html/template/content.go
TYPE template.Template:
  /home/craig/github/golang/go/src/text/template/template.go
TYPE template.URL:
  /home/craig/github/golang/go/src/html/template/content.go
TYPE testing.B:
  /home/craig/github/golang/go/src/testing/benchmark.go
TYPE testing.BenchmarkResult:
  /home/craig/github/golang/go/src/testing/benchmark.go
TYPE testing.Cover:
  /home/craig/github/golang/go/src/testing/cover.go
TYPE testing.CoverBlock:
  /home/craig/github/golang/go/src/testing/cover.go
TYPE testing.InternalBenchmark:
  /home/craig/github/golang/go/src/testing/benchmark.go
TYPE testing.InternalExample:
  /home/craig/github/golang/go/src/testing/example.go
TYPE testing.InternalTest:
  /home/craig/github/golang/go/src/testing/testing.go
TYPE testing.M:
  /home/craig/github/golang/go/src/testing/testing.go
TYPE testing.PB:
  /home/craig/github/golang/go/src/testing/benchmark.go
TYPE testing.T:
  /home/craig/github/golang/go/src/testing/testing.go
TYPE testing.TB:
  /home/craig/github/golang/go/src/testing/testing.go
TYPE textproto.Conn:
  /home/craig/github/golang/go/src/net/textproto/textproto.go
TYPE textproto.Error:
  /home/craig/github/golang/go/src/net/textproto/textproto.go
TYPE textproto.MIMEHeader:
  /home/craig/github/golang/go/src/net/textproto/header.go
TYPE textproto.Pipeline:
  /home/craig/github/golang/go/src/net/textproto/pipeline.go
TYPE textproto.ProtocolError:
  /home/craig/github/golang/go/src/net/textproto/textproto.go
TYPE textproto.Reader:
  /home/craig/github/golang/go/src/net/textproto/reader.go
TYPE textproto.Writer:
  /home/craig/github/golang/go/src/net/textproto/writer.go
TYPE time.Duration:
  /home/craig/github/golang/go/src/time/time.go
TYPE time.Location:
  /home/craig/github/golang/go/src/time/zoneinfo.go
TYPE time.Month:
  /home/craig/github/golang/go/src/time/time.go
TYPE time.ParseError:
  /home/craig/github/golang/go/src/time/format.go
TYPE time.Ticker:
  /home/craig/github/golang/go/src/time/tick.go
TYPE time.Time:
  /home/craig/github/golang/go/src/time/time.go
TYPE time.Timer:
  /home/craig/github/golang/go/src/time/sleep.go
TYPE time.Weekday:
  /home/craig/github/golang/go/src/time/time.go
TYPE tls.Certificate:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE tls.CertificateRequestInfo:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE tls.ClientAuthType:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE tls.ClientHelloInfo:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE tls.ClientSessionCache:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE tls.ClientSessionState:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE tls.Config:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE tls.Conn:
  /home/craig/github/golang/go/src/crypto/tls/conn.go
TYPE tls.ConnectionState:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE tls.CurveID:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE tls.RecordHeaderError:
  /home/craig/github/golang/go/src/crypto/tls/conn.go
TYPE tls.RenegotiationSupport:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE tls.SignatureScheme:
  /home/craig/github/golang/go/src/crypto/tls/common.go
TYPE token.File:
  /home/craig/github/golang/go/src/go/token/position.go
TYPE token.FileSet:
  /home/craig/github/golang/go/src/go/token/position.go
TYPE token.Pos:
  /home/craig/github/golang/go/src/go/token/position.go
TYPE token.Position:
  /home/craig/github/golang/go/src/go/token/position.go
TYPE token.Token:
  /home/craig/github/golang/go/src/go/token/token.go
TYPE trace.Region:
  /home/craig/github/golang/go/src/runtime/trace/annotation.go
TYPE trace.Task:
  /home/craig/github/golang/go/src/runtime/trace/annotation.go
TYPE transform.NopResetter:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/transform/transform.go
TYPE transform.Reader:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/transform/transform.go
TYPE transform.SpanningTransformer:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/transform/transform.go
TYPE transform.Transformer:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/transform/transform.go
TYPE transform.Writer:
  /home/craig/github/golang/go/src/vendor/golang_org/x/text/transform/transform.go
TYPE types.Array:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.Basic:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.BasicInfo:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.BasicKind:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.Builtin:
  /home/craig/github/golang/go/src/go/types/object.go
TYPE types.Chan:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.ChanDir:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.Checker:
  /home/craig/github/golang/go/src/go/types/check.go
TYPE types.Config:
  /home/craig/github/golang/go/src/go/types/api.go
TYPE types.Const:
  /home/craig/github/golang/go/src/go/types/object.go
TYPE types.Error:
  /home/craig/github/golang/go/src/go/types/api.go
TYPE types.Func:
  /home/craig/github/golang/go/src/go/types/object.go
TYPE types.ImportMode:
  /home/craig/github/golang/go/src/go/types/api.go
TYPE types.Importer:
  /home/craig/github/golang/go/src/go/types/api.go
TYPE types.ImporterFrom:
  /home/craig/github/golang/go/src/go/types/api.go
TYPE types.Info:
  /home/craig/github/golang/go/src/go/types/api.go
TYPE types.Initializer:
  /home/craig/github/golang/go/src/go/types/api.go
TYPE types.Interface:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.Label:
  /home/craig/github/golang/go/src/go/types/object.go
TYPE types.Map:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.MethodSet:
  /home/craig/github/golang/go/src/go/types/methodset.go
TYPE types.Named:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.Nil:
  /home/craig/github/golang/go/src/go/types/object.go
TYPE types.Object:
  /home/craig/github/golang/go/src/go/types/object.go
TYPE types.Package:
  /home/craig/github/golang/go/src/go/types/package.go
TYPE types.PkgName:
  /home/craig/github/golang/go/src/go/types/object.go
TYPE types.Pointer:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.Qualifier:
  /home/craig/github/golang/go/src/go/types/typestring.go
TYPE types.Scope:
  /home/craig/github/golang/go/src/go/types/scope.go
TYPE types.Selection:
  /home/craig/github/golang/go/src/go/types/selection.go
TYPE types.SelectionKind:
  /home/craig/github/golang/go/src/go/types/selection.go
TYPE types.Signature:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.Sizes:
  /home/craig/github/golang/go/src/go/types/sizes.go
TYPE types.Slice:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.StdSizes:
  /home/craig/github/golang/go/src/go/types/sizes.go
TYPE types.Struct:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.Tuple:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.Type:
  /home/craig/github/golang/go/src/go/types/type.go
TYPE types.TypeAndValue:
  /home/craig/github/golang/go/src/go/types/api.go
TYPE types.TypeName:
  /home/craig/github/golang/go/src/go/types/object.go
TYPE types.Var:
  /home/craig/github/golang/go/src/go/types/object.go
TYPE unicode.CaseRange:
  /home/craig/github/golang/go/src/unicode/letter.go
TYPE unicode.Range16:
  /home/craig/github/golang/go/src/unicode/letter.go
TYPE unicode.Range32:
  /home/craig/github/golang/go/src/unicode/letter.go
TYPE unicode.RangeTable:
  /home/craig/github/golang/go/src/unicode/letter.go
TYPE unicode.SpecialCase:
  /home/craig/github/golang/go/src/unicode/letter.go
TYPE unsafe.ArbitraryType:
  /home/craig/github/golang/go/src/unsafe/unsafe.go
TYPE unsafe.Pointer:
  /home/craig/github/golang/go/src/unsafe/unsafe.go
TYPE url.Error:
  /home/craig/github/golang/go/src/net/url/url.go
TYPE url.EscapeError:
  /home/craig/github/golang/go/src/net/url/url.go
TYPE url.InvalidHostError:
  /home/craig/github/golang/go/src/net/url/url.go
TYPE url.URL:
  /home/craig/github/golang/go/src/net/url/url.go
TYPE url.Userinfo:
  /home/craig/github/golang/go/src/net/url/url.go
TYPE url.Values:
  /home/craig/github/golang/go/src/net/url/url.go
TYPE user.Group:
  /home/craig/github/golang/go/src/os/user/user.go
TYPE user.UnknownGroupError:
  /home/craig/github/golang/go/src/os/user/user.go
TYPE user.UnknownGroupIdError:
  /home/craig/github/golang/go/src/os/user/user.go
TYPE user.UnknownUserError:
  /home/craig/github/golang/go/src/os/user/user.go
TYPE user.UnknownUserIdError:
  /home/craig/github/golang/go/src/os/user/user.go
TYPE user.User:
  /home/craig/github/golang/go/src/os/user/user.go
TYPE x509.CertPool:
  /home/craig/github/golang/go/src/crypto/x509/cert_pool.go
TYPE x509.Certificate:
  /home/craig/github/golang/go/src/crypto/x509/x509.go
TYPE x509.CertificateInvalidError:
  /home/craig/github/golang/go/src/crypto/x509/verify.go
TYPE x509.CertificateRequest:
  /home/craig/github/golang/go/src/crypto/x509/x509.go
TYPE x509.ConstraintViolationError:
  /home/craig/github/golang/go/src/crypto/x509/x509.go
TYPE x509.ExtKeyUsage:
  /home/craig/github/golang/go/src/crypto/x509/x509.go
TYPE x509.HostnameError:
  /home/craig/github/golang/go/src/crypto/x509/verify.go
TYPE x509.InsecureAlgorithmError:
  /home/craig/github/golang/go/src/crypto/x509/x509.go
TYPE x509.InvalidReason:
  /home/craig/github/golang/go/src/crypto/x509/verify.go
TYPE x509.KeyUsage:
  /home/craig/github/golang/go/src/crypto/x509/x509.go
TYPE x509.PEMCipher:
  /home/craig/github/golang/go/src/crypto/x509/pem_decrypt.go
TYPE x509.PublicKeyAlgorithm:
  /home/craig/github/golang/go/src/crypto/x509/x509.go
TYPE x509.SignatureAlgorithm:
  /home/craig/github/golang/go/src/crypto/x509/x509.go
TYPE x509.SystemRootsError:
  /home/craig/github/golang/go/src/crypto/x509/verify.go
TYPE x509.UnhandledCriticalExtension:
  /home/craig/github/golang/go/src/crypto/x509/x509.go
TYPE x509.UnknownAuthorityError:
  /home/craig/github/golang/go/src/crypto/x509/verify.go
TYPE x509.VerifyOptions:
  /home/craig/github/golang/go/src/crypto/x509/verify.go
TYPE xml.Attr:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.CharData:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.Comment:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.Decoder:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.Directive:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.Encoder:
  /home/craig/github/golang/go/src/encoding/xml/marshal.go
TYPE xml.EndElement:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.Marshaler:
  /home/craig/github/golang/go/src/encoding/xml/marshal.go
TYPE xml.MarshalerAttr:
  /home/craig/github/golang/go/src/encoding/xml/marshal.go
TYPE xml.Name:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.ProcInst:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.StartElement:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.SyntaxError:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.TagPathError:
  /home/craig/github/golang/go/src/encoding/xml/typeinfo.go
TYPE xml.Token:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.TokenReader:
  /home/craig/github/golang/go/src/encoding/xml/xml.go
TYPE xml.UnmarshalError:
  /home/craig/github/golang/go/src/encoding/xml/read.go
TYPE xml.Unmarshaler:
  /home/craig/github/golang/go/src/encoding/xml/read.go
TYPE xml.UnmarshalerAttr:
  /home/craig/github/golang/go/src/encoding/xml/read.go
TYPE xml.UnsupportedTypeError:
  /home/craig/github/golang/go/src/encoding/xml/marshal.go
TYPE zip.Compressor:
  /home/craig/github/golang/go/src/archive/zip/register.go
TYPE zip.Decompressor:
  /home/craig/github/golang/go/src/archive/zip/register.go
TYPE zip.File:
  /home/craig/github/golang/go/src/archive/zip/reader.go
TYPE zip.FileHeader:
  /home/craig/github/golang/go/src/archive/zip/struct.go
TYPE zip.ReadCloser:
  /home/craig/github/golang/go/src/archive/zip/reader.go
TYPE zip.Reader:
  /home/craig/github/golang/go/src/archive/zip/reader.go
TYPE zip.Writer:
  /home/craig/github/golang/go/src/archive/zip/writer.go
TYPE zlib.Resetter:
  /home/craig/github/golang/go/src/compress/zlib/reader.go
TYPE zlib.Writer:
  /home/craig/github/golang/go/src/compress/zlib/writer.go
JOKER FUNC adler32.Checksum has: 
;; (defn ^ABEND042(cannot find typename adler32.uint32) Checksum
;;   "Checksum returns the Adler-32 checksum of data."
;;   {:added "1.0"
;;    :go "checksum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2937249 <nil> byte}) data])
;; 
JOKER FUNC adler32.New has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash32}) New
;;   "New returns a new hash.Hash32 computing the Adler-32 checksum. Its
;; Sum method will lay the value out in big-endian byte order. The
;; returned Hash32 also implements encoding.BinaryMarshaler and
;; encoding.BinaryUnmarshaler to marshal and unmarshal the internal
;; state of the hash."
;;   {:added "1.0"
;;    :go "new()"}
;;   [])
;; 
JOKER FUNC aes.NewCipher has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{cipher Block}) Error] NewCipher
;;   "NewCipher creates and returns a new cipher.Block.
;; The key argument should be the AES key,
;; either 16, 24, or 32 bytes to select
;; AES-128, AES-192, or AES-256."
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{407924 <nil> byte}) key])
;; 
JOKER FUNC ascii85.Decode has: 
;; (defn ^[ndst nsrc err] Decode
;;   "Decode decodes src into dst, returning both the number
;; of bytes written to dst and the number consumed from src.
;; If src contains invalid ascii85 data, Decode will return the
;; number of bytes successfully written and a CorruptInputError.
;; Decode ignores space and control characters in src.
;; Often, ascii85-encoded data is wrapped in <~ and ~> symbols.
;; Decode expects these to have been stripped by the caller.
;; 
;; If flush is true, Decode assumes that src represents the
;; end of the input stream and processes it completely rather
;; than wait for the completion of another 32-bit block.
;; 
;; NewDecoder wraps an io.Reader interface around Decode."
;;   {:added "1.0"
;;    :go "decode(dst, src, flush)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1492002 <nil> byte}) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1492002 <nil> byte}) src, flush])
;; 
JOKER FUNC ascii85.Encode has: 
;; (defn ^Int Encode
;;   "Encode encodes src into at most MaxEncodedLen(len(src))
;; bytes of dst, returning the actual number of bytes written.
;; 
;; The encoding handles 4-byte chunks, using a special encoding
;; for the last fragment, so Encode is not appropriate for use on
;; individual blocks of a large data stream. Use NewEncoder() instead.
;; 
;; Often, ascii85-encoded data is wrapped in <~ and ~> symbols.
;; Encode does not add these."
;;   {:added "1.0"
;;    :go "encode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1488372 <nil> byte}) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1488372 <nil> byte}) src])
;; 
JOKER FUNC ascii85.MaxEncodedLen has: 
(defn ^Int MaxEncodedLen
  "MaxEncodedLen returns the maximum length of an encoding of n source bytes."
  {:added "1.0"
   :go "maxEncodedLen(n)"}
  [^Int n])

JOKER FUNC ascii85.NewDecoder has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) NewDecoder
;;   "NewDecoder constructs a new ascii85 stream decoder."
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC ascii85.NewEncoder has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io WriteCloser}) NewEncoder
;;   "NewEncoder returns a new ascii85 stream encoder. Data written to
;; the returned writer will be encoded and then written to w.
;; Ascii85 encodings operate in 32-bit blocks; when finished
;; writing, the caller must Close the returned encoder to flush any
;; trailing partial block."
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC asn1.Marshal has: 
;; (defn ^[[ABEND042(cannot find typename asn1.byte)] Error] Marshal
;;   "Marshal returns the ASN.1 encoding of val.
;; 
;; In addition to the struct tags recognised by Unmarshal, the following can be
;; used:
;; 
;; 	ia5:         causes strings to be marshaled as ASN.1, IA5String values
;; 	omitempty:   causes empty slices to be skipped
;; 	printable:   causes strings to be marshaled as ASN.1, PrintableString values
;; 	utf8:        causes strings to be marshaled as ASN.1, UTF8String values
;; 	utc:         causes time.Time to be marshaled as ASN.1, UTCTime values
;; 	generalized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values"
;;   {:added "1.0"
;;    :go "marshal(val)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1545892 0xc0005595f0 false}) val])
;; 
JOKER FUNC asn1.MarshalWithParams has: 
;; (defn ^[[ABEND042(cannot find typename asn1.byte)] Error] MarshalWithParams
;;   "MarshalWithParams allows field parameters to be specified for the
;; top-level element. The form of the params is the same as the field tags."
;;   {:added "1.0"
;;    :go "marshalWithParams(val, params)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1546133 0xc000559770 false}) val, ^String params])
;; 
JOKER FUNC asn1.Unmarshal has: 
;; (defn ^[rest err] Unmarshal
;;   "Unmarshal parses the DER-encoded ASN.1 data structure b
;; and uses the reflect package to fill in an arbitrary value pointed at by val.
;; Because Unmarshal uses the reflect package, the structs
;; being written to must use upper case field names.
;; 
;; An ASN.1 INTEGER can be written to an int, int32, int64,
;; or *big.Int (from the math/big package).
;; If the encoded value does not fit in the Go type,
;; Unmarshal returns a parse error.
;; 
;; An ASN.1 BIT STRING can be written to a BitString.
;; 
;; An ASN.1 OCTET STRING can be written to a []byte.
;; 
;; An ASN.1 OBJECT IDENTIFIER can be written to an
;; ObjectIdentifier.
;; 
;; An ASN.1 ENUMERATED can be written to an Enumerated.
;; 
;; An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.
;; 
;; An ASN.1 PrintableString, IA5String, or NumericString can be written to a string.
;; 
;; Any of the above ASN.1 values can be written to an interface{}.
;; The value stored in the interface has the corresponding Go type.
;; For integers, that type is int64.
;; 
;; An ASN.1 SEQUENCE OF x or SET OF x can be written
;; to a slice if an x can be written to the slice's element type.
;; 
;; An ASN.1 SEQUENCE or SET can be written to a struct
;; if each of the elements in the sequence can be
;; written to the corresponding element in the struct.
;; 
;; The following tags on struct fields have special meaning to Unmarshal:
;; 
;; 	application specifies that an APPLICATION tag is used
;; 	private     specifies that a PRIVATE tag is used
;; 	default:x   sets the default value for optional integer fields (only used if optional is also present)
;; 	explicit    specifies that an additional, explicit tag wraps the implicit one
;; 	optional    marks the field as ASN.1 OPTIONAL
;; 	set         causes a SET, rather than a SEQUENCE type to be expected
;; 	tag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC
;; 
;; If the type of the first field of a structure is RawContent then the raw
;; ASN1 contents of the struct will be stored in it.
;; 
;; If the type name of a slice element ends with "SET" then it's treated as if
;; the "set" tag was set on it. This can be used with nested slices where a
;; struct tag cannot be given.
;; 
;; Other ASN.1 types are not supported; if it encounters them,
;; Unmarshal returns a parse error."
;;   {:added "1.0"
;;    :go "unmarshal(b, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1529947 <nil> byte}) b, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1529959 0xc000747fb0 false}) val])
;; 
JOKER FUNC asn1.UnmarshalWithParams has: 
;; (defn ^[rest err] UnmarshalWithParams
;;   "UnmarshalWithParams allows field parameters to be specified for the
;; top-level element. The form of the params is the same as the field tags."
;;   {:added "1.0"
;;    :go "unmarshalWithParams(b, val, params)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1530216 <nil> byte}) b, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1530228 0xc000764180 false}) val, ^String params])
;; 
JOKER FUNC ast.FileExports has: 
;; (defn ^ABEND042(cannot find typename ast.bool) FileExports
;;   "FileExports trims the AST for a Go source file in place such that
;; only exported nodes remain: all top-level identifiers which are not exported
;; and their associated information (such as type, initial value, or function
;; body) are removed. Non-exported fields and methods of exported types are
;; stripped. The File.Comments list is not changed.
;; 
;; FileExports reports whether there are exported declarations."
;;   {:added "1.0"
;;    :go "fileExports(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2149237 File}) src])
;; 
JOKER FUNC ast.FilterDecl has: 
;; (defn ^ABEND042(cannot find typename ast.bool) FilterDecl
;;   "FilterDecl trims the AST for a Go declaration in place by removing
;; all names (including struct field and interface method names, but
;; not from parameter lists) that don't pass through the filter f.
;; 
;; FilterDecl reports whether there are any declared names left after
;; filtering."
;;   {:added "1.0"
;;    :go "filterDecl(decl, f)"}
;;   [decl, f])
;; 
JOKER FUNC ast.FilterFile has: 
;; (defn ^ABEND042(cannot find typename ast.bool) FilterFile
;;   "FilterFile trims the AST for a Go file in place by removing all
;; names from top-level declarations (including struct field and
;; interface method names, but not from parameter lists) that don't
;; pass through the filter f. If the declaration is empty afterwards,
;; the declaration is removed from the AST. Import declarations are
;; always removed. The File.Comments list is not changed.
;; 
;; FilterFile reports whether there are any top-level declarations
;; left after filtering."
;;   {:added "1.0"
;;    :go "filterFile(src, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2154679 File}) src, f])
;; 
JOKER FUNC ast.FilterPackage has: 
;; (defn ^ABEND042(cannot find typename ast.bool) FilterPackage
;;   "FilterPackage trims the AST for a Go package in place by removing
;; all names from top-level declarations (including struct field and
;; interface method names, but not from parameter lists) that don't
;; pass through the filter f. If the declaration is empty afterwards,
;; the declaration is removed from the AST. The pkg.Files list is not
;; changed, so that file names and top-level package comments don't get
;; lost.
;; 
;; FilterPackage reports whether there are any top-level declarations
;; left after filtering."
;;   {:added "1.0"
;;    :go "filterPackage(pkg, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2155498 Package}) pkg, f])
;; 
JOKER FUNC ast.Fprint has: 
;; (defn ^Error Fprint
;;   "Fprint prints the (sub-)tree starting at AST node x to w.
;; If fset != nil, position information is interpreted relative
;; to that file set. Otherwise positions are printed as integer
;; values (file set specific offsets).
;; 
;; A non-nil FieldFilter f may be provided to control the output:
;; struct fields for which f(fieldname, fieldvalue) is true are
;; printed; all others are filtered from the output. Unexported
;; struct fields are never printed."
;;   {:added "1.0"
;;    :go "fprint(w, fset, x, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2128105 0xc0009f0120}) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{2128123 0xc0009ee0c0 false}) x, f])
;; 
JOKER FUNC ast.Inspect has: 
;; (defn Inspect
;;   "Inspect traverses an AST in depth-first order: It starts by calling
;; f(node); node must not be nil. If f returns true, Inspect invokes f
;; recursively for each of the non-nil children of node, followed by a
;; call of f(nil)."
;;   {:added "1.0"
;;    :go "inspect(node, f)"}
;;   [node, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{2148299 0xc000a41440 0xc000a41470}) f])
;; 
JOKER FUNC ast.IsExported has: 
;; (defn ^ABEND042(cannot find typename ast.bool) IsExported
;;   "IsExported reports whether name is an exported Go symbol
;; (that is, whether it begins with an upper-case letter)."
;;   {:added "1.0"
;;    :go "isExported(name)"}
;;   [^String name])
;; 
JOKER FUNC ast.MergePackageFiles has: 
;; (defn ^{:doc ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2202460 CommentGroup}) Doc, :package ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) Package, :name ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2202585 Ident}) Name, :decls ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2202629 <nil> Decl}) Decls, :scope ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2202691 Scope}) Scope, :imports ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2202753 <nil> 0xc000b64fa0}) Imports, :unresolved ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2202805 <nil> 0xc000b65040}) Unresolved, :comments ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2202872 <nil> 0xc000b650e0}) Comments} MergePackageFiles
;;   "MergePackageFiles creates a file AST by merging the ASTs of the
;; files belonging to a package. The mode flags control merging behavior."
;;   {:added "1.0"
;;    :go "mergePackageFiles(pkg, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2157262 Package}) pkg, mode])
;; 
JOKER FUNC ast.NewCommentMap has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.MapType at: &{2133900 Node 0xc0009fea80}) NewCommentMap
;;   "NewCommentMap creates a new comment map by associating comment groups
;; of the comments list with the nodes of the AST specified by node.
;; 
;; A comment group g is associated with a node n if:
;; 
;;   - g starts on the same line as n ends
;;   - g starts on the line immediately following n, and there is
;;     at least one empty line after g and before the next node
;;   - g starts before n and is not associated to the node before n
;;     via the previous rules
;; 
;; NewCommentMap tries to associate a comment group to the "largest"
;; node possible: For instance, if the comment is a line comment
;; trailing an assignment, the comment is associated with the entire
;; assignment rather than just the last operand in the assignment."
;;   {:added "1.0"
;;    :go "newCommentMap(fset, node, comments)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2136940 0xc000a13240}) fset, node, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2136976 <nil> 0xc000a13300}) comments])
;; 
JOKER FUNC ast.NewIdent has: 
;; (defn ^{:namepos ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) NamePos, :name ^String Name, :obj ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2177762 Object}) Obj} NewIdent
;;   "NewIdent creates a new Ident without position.
;; Useful for ASTs generated by code other than the Go parser."
;;   {:added "1.0"
;;    :go "newIdent(name)"}
;;   [^String name])
;; 
JOKER FUNC ast.NewObj has: 
;; (defn ^{:kind Kind, :name ^String Name, :decl ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{2169134 0xc000a9e7e0 false}) Decl, :data ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{2169234 0xc000a9e810 false}) Data, :type ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{2169284 0xc000a9e840 false}) Type} NewObj
;;   "NewObj creates a new object of a given kind and name."
;;   {:added "1.0"
;;    :go "newObj(kind, name)"}
;;   [kind, ^String name])
;; 
JOKER FUNC ast.NewPackage has: 
;; (defn ^[{:name ^String Name, :scope ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2203273 Scope}) Scope, :imports ^ABEND881(unrecognized Expr type *ast.MapType at: &{2203335 string 0xc000b658e0}) Imports, :files ^ABEND881(unrecognized Expr type *ast.MapType at: &{2203402 string 0xc000b659c0}) Files} Error] NewPackage
;;   "NewPackage creates a new Package node from a set of File nodes. It resolves
;; unresolved identifiers across files and updates each file's Unresolved list
;; accordingly. If a non-nil importer and universe scope are provided, they are
;; used to resolve identifiers not declared in any of the package files. Any
;; remaining unresolved identifiers are reported as undeclared. If the files
;; belong to different packages, one package name is selected and files with
;; different package names are reported and then ignored.
;; The result is a package node and a scanner.ErrorList if there were errors."
;;   {:added "1.0"
;;    :go "newPackage(fset, files, importer, universe)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2164163 0xc000a88d60}) fset, ^ABEND881(unrecognized Expr type *ast.MapType at: &{2164185 string 0xc000a88e00}) files, importer, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2164231 Scope}) universe])
;; 
JOKER FUNC ast.NewScope has: 
;; (defn ^{:outer ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2167502 Scope}) Outer, :objects ^ABEND881(unrecognized Expr type *ast.MapType at: &{2167518 string 0xc000a8d900}) Objects} NewScope
;;   "NewScope creates a new scope nested in the outer scope."
;;   {:added "1.0"
;;    :go "newScope(outer)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2167619 Scope}) outer])
;; 
JOKER FUNC ast.NotNilFilter has: 
;; (defn ^ABEND042(cannot find typename ast.bool) NotNilFilter
;;   "NotNilFilter returns true for field values that are not nil;
;; it returns false otherwise."
;;   {:added "1.0"
;;    :go "notNilFilter(_, v)"}
;;   [^String _, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{reflect Value}) v])
;; 
JOKER FUNC ast.PackageExports has: 
;; (defn ^ABEND042(cannot find typename ast.bool) PackageExports
;;   "PackageExports trims the AST for a Go package in place such that
;; only exported nodes remain. The pkg.Files list is not changed, so that
;; file names and top-level package comments don't get lost.
;; 
;; PackageExports reports whether there are exported declarations;
;; it returns false otherwise."
;;   {:added "1.0"
;;    :go "packageExports(pkg)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2149629 Package}) pkg])
;; 
JOKER FUNC ast.Print has: 
;; (defn ^Error Print
;;   "Print prints x to standard output, skipping nil fields.
;; Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter)."
;;   {:added "1.0"
;;    :go "print(fset, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2128877 0xc0009f0d40}) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{2128895 0xc0009ee750 false}) x])
;; 
JOKER FUNC ast.SortImports has: 
;; (defn SortImports
;;   "SortImports sorts runs of consecutive import lines in import blocks in f.
;; It also removes duplicate imports when it is possible to do so without data loss."
;;   {:added "1.0"
;;    :go "sortImports(fset, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2122700 0xc0009d0a20}) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2122718 File}) f])
;; 
JOKER FUNC ast.Walk has: 
;; (defn Walk
;;   "Walk traverses an AST in depth-first order: It starts by calling
;; v.Visit(node); node must not be nil. If the visitor w returned by
;; v.Visit(node) is not nil, Walk is invoked recursively with visitor
;; w for each of the non-nil children of node, followed by a call of
;; w.Visit(nil)."
;;   {:added "1.0"
;;    :go "walk(v, node)"}
;;   [v, node])
;; 
JOKER FUNC atomic.AddInt32 has: 
;; (defn ^new AddInt32
;;   "AddInt32 atomically adds delta to *addr and returns the new value."
;;   {:added "1.0"
;;    :go "addInt32(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7343336 int32}) addr, delta])
;; 
JOKER FUNC atomic.AddInt64 has: 
;; (defn ^new AddInt64
;;   "AddInt64 atomically adds delta to *addr and returns the new value."
;;   {:added "1.0"
;;    :go "addInt64(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7343741 int64}) addr, delta])
;; 
JOKER FUNC atomic.AddUint32 has: 
;; (defn ^new AddUint32
;;   "AddUint32 atomically adds delta to *addr and returns the new value.
;; To subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)).
;; In particular, to decrement x, do AddUint32(&x, ^uint32(0))."
;;   {:added "1.0"
;;    :go "addUint32(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7343615 uint32}) addr, delta])
;; 
JOKER FUNC atomic.AddUint64 has: 
;; (defn ^new AddUint64
;;   "AddUint64 atomically adds delta to *addr and returns the new value.
;; To subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)).
;; In particular, to decrement x, do AddUint64(&x, ^uint64(0))."
;;   {:added "1.0"
;;    :go "addUint64(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344020 uint64}) addr, delta])
;; 
JOKER FUNC atomic.AddUintptr has: 
;; (defn ^new AddUintptr
;;   "AddUintptr atomically adds delta to *addr and returns the new value."
;;   {:added "1.0"
;;    :go "addUintptr(addr, delta)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344150 uintptr}) addr, delta])
;; 
JOKER FUNC atomic.CompareAndSwapInt32 has: 
;; (defn ^swapped CompareAndSwapInt32
;;   "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value."
;;   {:added "1.0"
;;    :go "compareAndSwapInt32(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7342395 int32}) addr, old, new])
;; 
JOKER FUNC atomic.CompareAndSwapInt64 has: 
;; (defn ^swapped CompareAndSwapInt64
;;   "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value."
;;   {:added "1.0"
;;    :go "compareAndSwapInt64(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7342548 int64}) addr, old, new])
;; 
JOKER FUNC atomic.CompareAndSwapPointer has: 
;; (defn ^swapped CompareAndSwapPointer
;;   "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value."
;;   {:added "1.0"
;;    :go "compareAndSwapPointer(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7343189 0xc001ef5100}) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) old, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) new])
;; 
JOKER FUNC atomic.CompareAndSwapUint32 has: 
;; (defn ^swapped CompareAndSwapUint32
;;   "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value."
;;   {:added "1.0"
;;    :go "compareAndSwapUint32(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7342703 uint32}) addr, old, new])
;; 
JOKER FUNC atomic.CompareAndSwapUint64 has: 
;; (defn ^swapped CompareAndSwapUint64
;;   "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value."
;;   {:added "1.0"
;;    :go "compareAndSwapUint64(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7342860 uint64}) addr, old, new])
;; 
JOKER FUNC atomic.CompareAndSwapUintptr has: 
;; (defn ^swapped CompareAndSwapUintptr
;;   "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value."
;;   {:added "1.0"
;;    :go "compareAndSwapUintptr(addr, old, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7343020 uintptr}) addr, old, new])
;; 
JOKER FUNC atomic.LoadInt32 has: 
;; (defn ^val LoadInt32
;;   "LoadInt32 atomically loads *addr."
;;   {:added "1.0"
;;    :go "loadInt32(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344247 int32}) addr])
;; 
JOKER FUNC atomic.LoadInt64 has: 
;; (defn ^val LoadInt64
;;   "LoadInt64 atomically loads *addr."
;;   {:added "1.0"
;;    :go "loadInt64(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344325 int64}) addr])
;; 
JOKER FUNC atomic.LoadPointer has: 
;; (defn ^val LoadPointer
;;   "LoadPointer atomically loads *addr."
;;   {:added "1.0"
;;    :go "loadPointer(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344657 0xc001efa040}) addr])
;; 
JOKER FUNC atomic.LoadUint32 has: 
;; (defn ^val LoadUint32
;;   "LoadUint32 atomically loads *addr."
;;   {:added "1.0"
;;    :go "loadUint32(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344405 uint32}) addr])
;; 
JOKER FUNC atomic.LoadUint64 has: 
;; (defn ^val LoadUint64
;;   "LoadUint64 atomically loads *addr."
;;   {:added "1.0"
;;    :go "loadUint64(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344487 uint64}) addr])
;; 
JOKER FUNC atomic.LoadUintptr has: 
;; (defn ^val LoadUintptr
;;   "LoadUintptr atomically loads *addr."
;;   {:added "1.0"
;;    :go "loadUintptr(addr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344571 uintptr}) addr])
;; 
JOKER FUNC atomic.StoreInt32 has: 
;; (defn StoreInt32
;;   "StoreInt32 atomically stores val into *addr."
;;   {:added "1.0"
;;    :go "storeInt32(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344765 int32}) addr, val])
;; 
JOKER FUNC atomic.StoreInt64 has: 
;; (defn StoreInt64
;;   "StoreInt64 atomically stores val into *addr."
;;   {:added "1.0"
;;    :go "storeInt64(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344854 int64}) addr, val])
;; 
JOKER FUNC atomic.StorePointer has: 
;; (defn StorePointer
;;   "StorePointer atomically stores val into *addr."
;;   {:added "1.0"
;;    :go "storePointer(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7345230 0xc001efa780}) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) val])
;; 
JOKER FUNC atomic.StoreUint32 has: 
;; (defn StoreUint32
;;   "StoreUint32 atomically stores val into *addr."
;;   {:added "1.0"
;;    :go "storeUint32(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7344945 uint32}) addr, val])
;; 
JOKER FUNC atomic.StoreUint64 has: 
;; (defn StoreUint64
;;   "StoreUint64 atomically stores val into *addr."
;;   {:added "1.0"
;;    :go "storeUint64(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7345038 uint64}) addr, val])
;; 
JOKER FUNC atomic.StoreUintptr has: 
;; (defn StoreUintptr
;;   "StoreUintptr atomically stores val into *addr."
;;   {:added "1.0"
;;    :go "storeUintptr(addr, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7345133 uintptr}) addr, val])
;; 
JOKER FUNC atomic.SwapInt32 has: 
;; (defn ^old SwapInt32
;;   "SwapInt32 atomically stores new into *addr and returns the previous *addr value."
;;   {:added "1.0"
;;    :go "swapInt32(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7341519 int32}) addr, new])
;; 
JOKER FUNC atomic.SwapInt64 has: 
;; (defn ^old SwapInt64
;;   "SwapInt64 atomically stores new into *addr and returns the previous *addr value."
;;   {:added "1.0"
;;    :go "swapInt64(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7341655 int64}) addr, new])
;; 
JOKER FUNC atomic.SwapPointer has: 
;; (defn ^old SwapPointer
;;   "SwapPointer atomically stores new into *addr and returns the previous *addr value."
;;   {:added "1.0"
;;    :go "swapPointer(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7342223 0xc001ef4760}) addr, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) new])
;; 
JOKER FUNC atomic.SwapUint32 has: 
;; (defn ^old SwapUint32
;;   "SwapUint32 atomically stores new into *addr and returns the previous *addr value."
;;   {:added "1.0"
;;    :go "swapUint32(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7341793 uint32}) addr, new])
;; 
JOKER FUNC atomic.SwapUint64 has: 
;; (defn ^old SwapUint64
;;   "SwapUint64 atomically stores new into *addr and returns the previous *addr value."
;;   {:added "1.0"
;;    :go "swapUint64(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7341934 uint64}) addr, new])
;; 
JOKER FUNC atomic.SwapUintptr has: 
;; (defn ^old SwapUintptr
;;   "SwapUintptr atomically stores new into *addr and returns the previous *addr value."
;;   {:added "1.0"
;;    :go "swapUintptr(addr, new)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7342077 uintptr}) addr, new])
;; 
JOKER FUNC base32.NewDecoder has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) NewDecoder
;;   "NewDecoder constructs a new base32 stream decoder."
;;   {:added "1.0"
;;    :go "newDecoder(enc, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1559005 Encoding}) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC base32.NewEncoder has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io WriteCloser}) NewEncoder
;;   "NewEncoder returns a new base32 stream encoder. Data written to
;; the returned writer will be encoded using enc and then written to w.
;; Base32 encodings operate in 5-byte blocks; when finished
;; writing, the caller must Close the returned encoder to flush any
;; partially written blocks."
;;   {:added "1.0"
;;    :go "newEncoder(enc, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1552365 Encoding}) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC base32.NewEncoding has: 
;; (defn ^{:encode ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1546952 0xc0007c7e80 byte}) encode, :decodemap ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1546972 0xc0007c7ee0 byte}) decodeMap, :padchar padChar} NewEncoding
;;   "NewEncoding returns a new Encoding defined by the given alphabet,
;; which must be a 32-byte string."
;;   {:added "1.0"
;;    :go "newEncoding(encoder)"}
;;   [^String encoder])
;; 
JOKER FUNC base64.NewDecoder has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) NewDecoder
;;   "NewDecoder constructs a new base64 stream decoder."
;;   {:added "1.0"
;;    :go "newDecoder(enc, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1573768 Encoding}) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC base64.NewEncoder has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io WriteCloser}) NewEncoder
;;   "NewEncoder returns a new base64 stream encoder. Data written to
;; the returned writer will be encoded using enc and then written to w.
;; Base64 encodings operate in 4-byte blocks; when finished
;; writing, the caller must Close the returned encoder to flush any
;; partially written blocks."
;;   {:added "1.0"
;;    :go "newEncoder(enc, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1565892 Encoding}) enc, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC base64.NewEncoding has: 
;; (defn ^{:encode ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1560030 0xc0006ad7c0 byte}) encode, :decodemap ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1560050 0xc0006ad820 byte}) decodeMap, :padchar padChar, :strict strict} NewEncoding
;;   "NewEncoding returns a new padded Encoding defined by the given alphabet,
;; which must be a 64-byte string that does not contain the padding character
;; or CR / LF ('\r', '\n').
;; The resulting Encoding uses the default padding character ('='),
;; which may be changed or disabled via WithPadding."
;;   {:added "1.0"
;;    :go "newEncoding(encoder)"}
;;   [^String encoder])
;; 
JOKER FUNC bidi.AppendReverse has: 
;; (defn ^[ABEND042(cannot find typename bidi.byte)] AppendReverse
;;   "AppendReverse reverses the order of characters of in, appends them to out,
;; and returns the result. Modifiers will still follow the runes they modify.
;; Brackets are replaced with their counterparts."
;;   {:added "1.0"
;;    :go "appendReverse(out, in)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8851061 <nil> byte}) out, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8851061 <nil> byte}) in])
;; 
JOKER FUNC bidi.DefaultDirection has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{8846510 0xc0017f5c80 <nil>}) DefaultDirection
;;   "DefaultDirection sets the default direction for a Paragraph. The direction is
;; overridden if the text contains directional characters."
;;   {:added "1.0"
;;    :go "defaultDirection(d)"}
;;   [d])
;; 
JOKER FUNC bidi.Lookup has: 
;; (defn ^[p sz] Lookup
;;   "Lookup returns properties for the first rune in s and the width in bytes of
;; its encoding. The size will be 0 if s does not hold enough bytes to complete
;; the encoding."
;;   {:added "1.0"
;;    :go "lookup(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8696483 <nil> byte}) s])
;; 
JOKER FUNC bidi.LookupRune has: 
(defn ^[p size] LookupRune
  "LookupRune returns properties for r."
  {:added "1.0"
   :go "lookupRune(r)"}
  [r])

JOKER FUNC bidi.LookupString has: 
(defn ^[p sz] LookupString
  "LookupString returns properties for the first rune in s and the width in
bytes of its encoding. The size will be 0 if s does not hold enough bytes to
complete the encoding."
  {:added "1.0"
   :go "lookupString(s)"}
  [^String s])

JOKER FUNC bidi.ReverseString has: 
(defn ^String ReverseString
  "ReverseString reverses the order of characters in s and returns a new string.
Modifiers will still follow the runes they modify. Brackets are replaced with
their counterparts."
  {:added "1.0"
   :go "reverseString(s)"}
  [^String s])

JOKER FUNC bidirule.Direction has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{bidi Direction}) Direction
;;   "Direction reports the direction of the given label as defined by RFC 5893.
;; The Bidi Rule does not have to be applied to labels of the category
;; LeftToRight."
;;   {:added "1.0"
;;    :go "direction(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8654262 <nil> byte}) b])
;; 
JOKER FUNC bidirule.DirectionString has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{bidi Direction}) DirectionString
;;   "DirectionString reports the direction of the given label as defined by RFC
;; 5893. The Bidi Rule does not have to be applied to labels of the category
;; LeftToRight."
;;   {:added "1.0"
;;    :go "directionString(s)"}
;;   [^String s])
;; 
JOKER FUNC bidirule.New has: 
(defn ^{:state state, :hasrtl hasRTL, :seen ^Int seen} New
  "New returns a Transformer that verifies that input adheres to the Bidi Rule."
  {:added "1.0"
   :go "new()"}
  [])

JOKER FUNC bidirule.Valid has: 
;; (defn ^ABEND042(cannot find typename bidirule.bool) Valid
;;   "Valid reports whether b conforms to the BiDi rule."
;;   {:added "1.0"
;;    :go "valid(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8655037 <nil> byte}) b])
;; 
JOKER FUNC bidirule.ValidString has: 
;; (defn ^ABEND042(cannot find typename bidirule.bool) ValidString
;;   "ValidString reports whether s conforms to the BiDi rule."
;;   {:added "1.0"
;;    :go "validString(s)"}
;;   [^String s])
;; 
JOKER FUNC big.Jacobi has: 
;; (defn ^Int Jacobi
;;   "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.
;; The y argument must be an odd integer."
;;   {:added "1.0"
;;    :go "jacobi(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{3885271 Int}) x, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{3885271 Int}) y])
;; 
JOKER FUNC big.NewFloat has: 
(defn ^{:prec prec, :mode mode, :acc acc, :form form, :neg neg, :mant mant, :exp exp} NewFloat
  "NewFloat allocates and returns a new Float set to x,
with precision 53 and rounding mode ToNearestEven.
NewFloat panics with ErrNaN if x is a NaN."
  {:added "1.0"
   :go "newFloat(x)"}
  [x])

JOKER FUNC big.NewInt has: 
(defn ^{:neg neg, :abs abs} NewInt
  "NewInt allocates and returns a new Int set to x."
  {:added "1.0"
   :go "newInt(x)"}
  [x])

JOKER FUNC big.NewRat has: 
(defn ^{:a a, :b b} NewRat
  "NewRat creates a new Rat with numerator a and denominator b."
  {:added "1.0"
   :go "newRat(a, b)"}
  [a, b])

JOKER FUNC big.ParseFloat has: 
(defn ^[f b err] ParseFloat
  "ParseFloat is like f.Parse(s, base) with f set to the given precision
and rounding mode."
  {:added "1.0"
   :go "parseFloat(s, base, prec, mode)"}
  [^String s, ^Int base, ^Int prec, mode])

JOKER FUNC binary.PutUvarint has: 
;; (defn ^Int PutUvarint
;;   "PutUvarint encodes a uint64 into buf and returns the number of bytes written.
;; If the buffer is too small, PutUvarint will panic."
;;   {:added "1.0"
;;    :go "putUvarint(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1575875 <nil> byte}) buf, x])
;; 
JOKER FUNC binary.PutVarint has: 
;; (defn ^Int PutVarint
;;   "PutVarint encodes an int64 into buf and returns the number of bytes written.
;; If the buffer is too small, PutVarint will panic."
;;   {:added "1.0"
;;    :go "putVarint(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1576740 <nil> byte}) buf, x])
;; 
JOKER FUNC binary.Read has: 
;; (defn ^Error Read
;;   "Read reads structured binary data from r into data.
;; Data must be a pointer to a fixed-size value or a slice
;; of fixed-size values.
;; Bytes read from r are decoded using the specified byte order
;; and written to successive fields of the data.
;; When decoding boolean values, a zero byte is decoded as false, and
;; any other non-zero byte is decoded as true.
;; When reading into structs, the field data for fields with
;; blank (_) field names is skipped; i.e., blank field names
;; may be used for padding.
;; When reading into a struct, all non-blank fields must be exported
;; or Read may panic.
;; 
;; The error is EOF only if no bytes were read.
;; If an EOF happens after reading some but not all the bytes,
;; Read returns ErrUnexpectedEOF."
;;   {:added "1.0"
;;    :go "read(r, order, data)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, order, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1583299 0xc0008a8720 false}) data])
;; 
JOKER FUNC binary.ReadUvarint has: 
;; (defn ^[ABEND042(cannot find typename binary.uint64) Error] ReadUvarint
;;   "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64."
;;   {:added "1.0"
;;    :go "readUvarint(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ByteReader}) r])
;; 
JOKER FUNC binary.ReadVarint has: 
;; (defn ^[ABEND042(cannot find typename binary.int64) Error] ReadVarint
;;   "ReadVarint reads an encoded signed integer from r and returns it as an int64."
;;   {:added "1.0"
;;    :go "readVarint(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ByteReader}) r])
;; 
JOKER FUNC binary.Size has: 
;; (defn ^Int Size
;;   "Size returns how many bytes Write would generate to encode the value v, which
;; must be a fixed-size value or a slice of fixed-size values, or a pointer to such data.
;; If v is neither of these, Size returns -1."
;;   {:added "1.0"
;;    :go "size(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1587990 0xc0008b5410 false}) v])
;; 
JOKER FUNC binary.Uvarint has: 
;; (defn ^[ABEND042(cannot find typename binary.uint64) Int] Uvarint
;;   "Uvarint decodes a uint64 from buf and returns that value and the
;; number of bytes read (> 0). If an error occurred, the value is 0
;; and the number of bytes n is <= 0 meaning:
;; 
;; 	n == 0: buf too small
;; 	n  < 0: value larger than 64 bits (overflow)
;; 	        and -n is the number of bytes read"
;;   {:added "1.0"
;;    :go "uvarint(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1576331 <nil> byte}) buf])
;; 
JOKER FUNC binary.Varint has: 
;; (defn ^[ABEND042(cannot find typename binary.int64) Int] Varint
;;   "Varint decodes an int64 from buf and returns that value and the
;; number of bytes read (> 0). If an error occurred, the value is 0
;; and the number of bytes n is <= 0 with the following meaning:
;; 
;; 	n == 0: buf too small
;; 	n  < 0: value larger than 64 bits (overflow)
;; 	        and -n is the number of bytes read"
;;   {:added "1.0"
;;    :go "varint(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1577186 <nil> byte}) buf])
;; 
JOKER FUNC binary.Write has: 
;; (defn ^Error Write
;;   "Write writes the binary representation of data into w.
;; Data must be a fixed-size value or a slice of fixed-size
;; values, or a pointer to such data.
;; Boolean values encode as one byte: 1 for true, and 0 for false.
;; Bytes written to w are encoded using the specified byte order
;; and read from successive fields of the data.
;; When writing structs, zero values are written for fields
;; with blank (_) field names."
;;   {:added "1.0"
;;    :go "write(w, order, data)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, order, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1585665 0xc0008a9cb0 false}) data])
;; 
JOKER FUNC bits.LeadingZeros has: 
(defn ^Int LeadingZeros
  "LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0."
  {:added "1.0"
   :go "leadingZeros(x)"}
  [^Int x])

JOKER FUNC bits.LeadingZeros16 has: 
(defn ^Int LeadingZeros16
  "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0."
  {:added "1.0"
   :go "leadingZeros16(x)"}
  [^Int x])

JOKER FUNC bits.LeadingZeros32 has: 
(defn ^Int LeadingZeros32
  "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0."
  {:added "1.0"
   :go "leadingZeros32(x)"}
  [x])

JOKER FUNC bits.LeadingZeros64 has: 
(defn ^Int LeadingZeros64
  "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0."
  {:added "1.0"
   :go "leadingZeros64(x)"}
  [x])

JOKER FUNC bits.LeadingZeros8 has: 
(defn ^Int LeadingZeros8
  "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0."
  {:added "1.0"
   :go "leadingZeros8(x)"}
  [x])

JOKER FUNC bits.Len has: 
(defn ^Int Len
  "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0."
  {:added "1.0"
   :go "len(x)"}
  [^Int x])

JOKER FUNC bits.Len16 has: 
(defn ^n Len16
  "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0."
  {:added "1.0"
   :go "len16(x)"}
  [^Int x])

JOKER FUNC bits.Len32 has: 
(defn ^n Len32
  "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0."
  {:added "1.0"
   :go "len32(x)"}
  [x])

JOKER FUNC bits.Len64 has: 
(defn ^n Len64
  "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0."
  {:added "1.0"
   :go "len64(x)"}
  [x])

JOKER FUNC bits.Len8 has: 
(defn ^Int Len8
  "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0."
  {:added "1.0"
   :go "len8(x)"}
  [x])

JOKER FUNC bits.OnesCount has: 
(defn ^Int OnesCount
  "OnesCount returns the number of one bits ("population count") in x."
  {:added "1.0"
   :go "onesCount(x)"}
  [^Int x])

JOKER FUNC bits.OnesCount16 has: 
(defn ^Int OnesCount16
  "OnesCount16 returns the number of one bits ("population count") in x."
  {:added "1.0"
   :go "onesCount16(x)"}
  [^Int x])

JOKER FUNC bits.OnesCount32 has: 
(defn ^Int OnesCount32
  "OnesCount32 returns the number of one bits ("population count") in x."
  {:added "1.0"
   :go "onesCount32(x)"}
  [x])

JOKER FUNC bits.OnesCount64 has: 
(defn ^Int OnesCount64
  "OnesCount64 returns the number of one bits ("population count") in x."
  {:added "1.0"
   :go "onesCount64(x)"}
  [x])

JOKER FUNC bits.OnesCount8 has: 
(defn ^Int OnesCount8
  "OnesCount8 returns the number of one bits ("population count") in x."
  {:added "1.0"
   :go "onesCount8(x)"}
  [x])

JOKER FUNC bits.Reverse has: 
(defn ^Int Reverse
  "Reverse returns the value of x with its bits in reversed order."
  {:added "1.0"
   :go "reverse(x)"}
  [^Int x])

JOKER FUNC bits.Reverse16 has: 
(defn ^Int Reverse16
  "Reverse16 returns the value of x with its bits in reversed order."
  {:added "1.0"
   :go "reverse16(x)"}
  [^Int x])

JOKER FUNC bits.Reverse32 has: 
;; (defn ^ABEND042(cannot find typename bits.uint32) Reverse32
;;   "Reverse32 returns the value of x with its bits in reversed order."
;;   {:added "1.0"
;;    :go "reverse32(x)"}
;;   [x])
;; 
JOKER FUNC bits.Reverse64 has: 
;; (defn ^ABEND042(cannot find typename bits.uint64) Reverse64
;;   "Reverse64 returns the value of x with its bits in reversed order."
;;   {:added "1.0"
;;    :go "reverse64(x)"}
;;   [x])
;; 
JOKER FUNC bits.Reverse8 has: 
;; (defn ^ABEND042(cannot find typename bits.uint8) Reverse8
;;   "Reverse8 returns the value of x with its bits in reversed order."
;;   {:added "1.0"
;;    :go "reverse8(x)"}
;;   [x])
;; 
JOKER FUNC bits.ReverseBytes has: 
(defn ^Int ReverseBytes
  "ReverseBytes returns the value of x with its bytes in reversed order."
  {:added "1.0"
   :go "reverseBytes(x)"}
  [^Int x])

JOKER FUNC bits.ReverseBytes16 has: 
(defn ^Int ReverseBytes16
  "ReverseBytes16 returns the value of x with its bytes in reversed order."
  {:added "1.0"
   :go "reverseBytes16(x)"}
  [^Int x])

JOKER FUNC bits.ReverseBytes32 has: 
;; (defn ^ABEND042(cannot find typename bits.uint32) ReverseBytes32
;;   "ReverseBytes32 returns the value of x with its bytes in reversed order."
;;   {:added "1.0"
;;    :go "reverseBytes32(x)"}
;;   [x])
;; 
JOKER FUNC bits.ReverseBytes64 has: 
;; (defn ^ABEND042(cannot find typename bits.uint64) ReverseBytes64
;;   "ReverseBytes64 returns the value of x with its bytes in reversed order."
;;   {:added "1.0"
;;    :go "reverseBytes64(x)"}
;;   [x])
;; 
JOKER FUNC bits.RotateLeft has: 
(defn ^Int RotateLeft
  "RotateLeft returns the value of x rotated left by (k mod UintSize) bits.
To rotate x right by k bits, call RotateLeft(x, -k)."
  {:added "1.0"
   :go "rotateLeft(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC bits.RotateLeft16 has: 
(defn ^Int RotateLeft16
  "RotateLeft16 returns the value of x rotated left by (k mod 16) bits.
To rotate x right by k bits, call RotateLeft16(x, -k)."
  {:added "1.0"
   :go "rotateLeft16(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC bits.RotateLeft32 has: 
;; (defn ^ABEND042(cannot find typename bits.uint32) RotateLeft32
;;   "RotateLeft32 returns the value of x rotated left by (k mod 32) bits.
;; To rotate x right by k bits, call RotateLeft32(x, -k)."
;;   {:added "1.0"
;;    :go "rotateLeft32(x, k)"}
;;   [x, ^Int k])
;; 
JOKER FUNC bits.RotateLeft64 has: 
;; (defn ^ABEND042(cannot find typename bits.uint64) RotateLeft64
;;   "RotateLeft64 returns the value of x rotated left by (k mod 64) bits.
;; To rotate x right by k bits, call RotateLeft64(x, -k)."
;;   {:added "1.0"
;;    :go "rotateLeft64(x, k)"}
;;   [x, ^Int k])
;; 
JOKER FUNC bits.RotateLeft8 has: 
;; (defn ^ABEND042(cannot find typename bits.uint8) RotateLeft8
;;   "RotateLeft8 returns the value of x rotated left by (k mod 8) bits.
;; To rotate x right by k bits, call RotateLeft8(x, -k)."
;;   {:added "1.0"
;;    :go "rotateLeft8(x, k)"}
;;   [x, ^Int k])
;; 
JOKER FUNC bits.TrailingZeros has: 
(defn ^Int TrailingZeros
  "TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0."
  {:added "1.0"
   :go "trailingZeros(x)"}
  [^Int x])

JOKER FUNC bits.TrailingZeros16 has: 
(defn ^n TrailingZeros16
  "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0."
  {:added "1.0"
   :go "trailingZeros16(x)"}
  [^Int x])

JOKER FUNC bits.TrailingZeros32 has: 
(defn ^Int TrailingZeros32
  "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0."
  {:added "1.0"
   :go "trailingZeros32(x)"}
  [x])

JOKER FUNC bits.TrailingZeros64 has: 
(defn ^Int TrailingZeros64
  "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0."
  {:added "1.0"
   :go "trailingZeros64(x)"}
  [x])

JOKER FUNC bits.TrailingZeros8 has: 
(defn ^Int TrailingZeros8
  "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0."
  {:added "1.0"
   :go "trailingZeros8(x)"}
  [x])

JOKER FUNC bufio.NewReadWriter has: 
;; (defn ^{} NewReadWriter
;;   "NewReadWriter allocates a new ReadWriter that dispatches to r and w."
;;   {:added "1.0"
;;    :go "newReadWriter(r, w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{161100 Reader}) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{161111 Writer}) w])
;; 
JOKER FUNC bufio.NewReader has: 
;; (defn ^{:buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{143725 <nil> byte}) buf, :rd ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rd, :r ^Int r, :w ^Int w, :err err, :lastbyte ^Int lastByte, :lastrunesize ^Int lastRuneSize} NewReader
;;   "NewReader returns a new Reader whose buffer has the default size."
;;   {:added "1.0"
;;    :go "newReader(rd)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rd])
;; 
JOKER FUNC bufio.NewReaderSize has: 
;; (defn ^{:buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{143725 <nil> byte}) buf, :rd ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rd, :r ^Int r, :w ^Int w, :err err, :lastbyte ^Int lastByte, :lastrunesize ^Int lastRuneSize} NewReaderSize
;;   "NewReaderSize returns a new Reader whose buffer has at least the specified
;; size. If the argument io.Reader is already a Reader with large enough
;; size, it returns the underlying Reader."
;;   {:added "1.0"
;;    :go "newReaderSize(rd, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rd, ^Int size])
;; 
JOKER FUNC bufio.NewScanner has: 
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, :split split, :maxtokensize ^Int maxTokenSize, :token ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{162577 <nil> byte}) token, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{162634 <nil> byte}) buf, :start ^Int start, :end ^Int end, :err err, :empties ^Int empties, :scancalled scanCalled, :done done} NewScanner
;;   "NewScanner returns a new Scanner to read from r.
;; The split function defaults to ScanLines."
;;   {:added "1.0"
;;    :go "newScanner(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC bufio.NewWriter has: 
;; (defn ^{:err err, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{156447 <nil> byte}) buf, :n ^Int n, :wr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) wr} NewWriter
;;   "NewWriter returns a new Writer whose buffer has the default size."
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC bufio.NewWriterSize has: 
;; (defn ^{:err err, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{156447 <nil> byte}) buf, :n ^Int n, :wr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) wr} NewWriterSize
;;   "NewWriterSize returns a new Writer whose buffer has at least the specified
;; size. If the argument io.Writer is already a Writer with large enough
;; size, it returns the underlying Writer."
;;   {:added "1.0"
;;    :go "newWriterSize(w, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^Int size])
;; 
JOKER FUNC bufio.ScanBytes has: 
;; (defn ^[advance token err] ScanBytes
;;   "ScanBytes is a split function for a Scanner that returns each byte as a token."
;;   {:added "1.0"
;;    :go "scanBytes(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{170776 <nil> byte}) data, atEOF])
;; 
JOKER FUNC bufio.ScanLines has: 
;; (defn ^[advance token err] ScanLines
;;   "ScanLines is a split function for a Scanner that returns each line of
;; text, stripped of any trailing end-of-line marker. The returned line may
;; be empty. The end-of-line marker is one optional carriage return followed
;; by one mandatory newline. In regular expression notation, it is `\r?\n`.
;; The last non-empty line of input will be returned even if it has no
;; newline."
;;   {:added "1.0"
;;    :go "scanLines(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{172982 <nil> byte}) data, atEOF])
;; 
JOKER FUNC bufio.ScanRunes has: 
;; (defn ^[advance token err] ScanRunes
;;   "ScanRunes is a split function for a Scanner that returns each
;; UTF-8-encoded rune as a token. The sequence of runes returned is
;; equivalent to that from a range loop over the input as a string, which
;; means that erroneous UTF-8 encodings translate to U+FFFD = "\xef\xbf\xbd".
;; Because of the Scan interface, this makes it impossible for the client to
;; distinguish correctly encoded replacement runes from encoding errors."
;;   {:added "1.0"
;;    :go "scanRunes(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{171423 <nil> byte}) data, atEOF])
;; 
JOKER FUNC bufio.ScanWords has: 
;; (defn ^[advance token err] ScanWords
;;   "ScanWords is a split function for a Scanner that returns each
;; space-separated word of text, with surrounding spaces deleted. It will
;; never return an empty string. The definition of space is set by
;; unicode.IsSpace."
;;   {:added "1.0"
;;    :go "scanWords(data, atEOF)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{174276 <nil> byte}) data, atEOF])
;; 
JOKER FUNC build.ArchChar has: 
(defn ^[String Error] ArchChar
  "ArchChar returns "?" and an error.
In earlier versions of Go, the returned string was used to derive
the compiler and linker tool names, the default object file suffix,
and the default linker output name. As of Go 1.5, those strings
no longer vary by architecture; they are compile, link, .o, and a.out, respectively."
  {:added "1.0"
   :go "archChar(goarch)"}
  [^String goarch])

JOKER FUNC build.Import has: 
;; (defn ^[{:dir ^String Dir, :name ^String Name, :importcomment ^String ImportComment, :doc ^String Doc, :importpath ^String ImportPath, :root ^String Root, :srcroot ^String SrcRoot, :pkgroot ^String PkgRoot, :pkgtargetroot ^String PkgTargetRoot, :bindir ^String BinDir, :goroot Goroot, :pkgobj ^String PkgObj, :alltags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216396 <nil> string}) AllTags, :conflictdir ^String ConflictDir, :binaryonly BinaryOnly, :gofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216660 <nil> string}) GoFiles, :cgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216753 <nil> string}) CgoFiles, :ignoredgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216814 <nil> string}) IgnoredGoFiles, :invalidgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216882 <nil> string}) InvalidGoFiles, :cfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216995 <nil> string}) CFiles, :cxxfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217039 <nil> string}) CXXFiles, :mfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217099 <nil> string}) MFiles, :hfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217157 <nil> string}) HFiles, :ffiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217221 <nil> string}) FFiles, :sfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217292 <nil> string}) SFiles, :swigfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217336 <nil> string}) SwigFiles, :swigcxxfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217376 <nil> string}) SwigCXXFiles, :sysofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217419 <nil> string}) SysoFiles, :cgocflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217509 <nil> string}) CgoCFLAGS, :cgocppflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217557 <nil> string}) CgoCPPFLAGS, :cgocxxflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217607 <nil> string}) CgoCXXFLAGS, :cgofflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217657 <nil> string}) CgoFFLAGS, :cgoldflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217705 <nil> string}) CgoLDFLAGS, :cgopkgconfig ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217754 <nil> string}) CgoPkgConfig, :imports ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217831 <nil> string}) Imports, :importpos ^ABEND881(unrecognized Expr type *ast.MapType at: &{2217909 string 0xc000bb4c30}) ImportPos, :testgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2218007 <nil> string}) TestGoFiles, :testimports ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2218080 <nil> string}) TestImports, :testimportpos ^ABEND881(unrecognized Expr type *ast.MapType at: &{2218157 string 0xc000bb4cf0}) TestImportPos, :xtestgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2218237 <nil> string}) XTestGoFiles, :xtestimports ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2218315 <nil> string}) XTestImports, :xtestimportpos ^ABEND881(unrecognized Expr type *ast.MapType at: &{2218393 string 0xc000bb4db0}) XTestImportPos} Error] Import
;;   "Import is shorthand for Default.Import."
;;   {:added "1.0"
;;    :go "import(path, srcDir, mode)"}
;;   [^String path, ^String srcDir, mode])
;; 
JOKER FUNC build.ImportDir has: 
;; (defn ^[{:dir ^String Dir, :name ^String Name, :importcomment ^String ImportComment, :doc ^String Doc, :importpath ^String ImportPath, :root ^String Root, :srcroot ^String SrcRoot, :pkgroot ^String PkgRoot, :pkgtargetroot ^String PkgTargetRoot, :bindir ^String BinDir, :goroot Goroot, :pkgobj ^String PkgObj, :alltags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216396 <nil> string}) AllTags, :conflictdir ^String ConflictDir, :binaryonly BinaryOnly, :gofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216660 <nil> string}) GoFiles, :cgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216753 <nil> string}) CgoFiles, :ignoredgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216814 <nil> string}) IgnoredGoFiles, :invalidgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216882 <nil> string}) InvalidGoFiles, :cfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2216995 <nil> string}) CFiles, :cxxfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217039 <nil> string}) CXXFiles, :mfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217099 <nil> string}) MFiles, :hfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217157 <nil> string}) HFiles, :ffiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217221 <nil> string}) FFiles, :sfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217292 <nil> string}) SFiles, :swigfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217336 <nil> string}) SwigFiles, :swigcxxfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217376 <nil> string}) SwigCXXFiles, :sysofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217419 <nil> string}) SysoFiles, :cgocflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217509 <nil> string}) CgoCFLAGS, :cgocppflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217557 <nil> string}) CgoCPPFLAGS, :cgocxxflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217607 <nil> string}) CgoCXXFLAGS, :cgofflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217657 <nil> string}) CgoFFLAGS, :cgoldflags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217705 <nil> string}) CgoLDFLAGS, :cgopkgconfig ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217754 <nil> string}) CgoPkgConfig, :imports ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2217831 <nil> string}) Imports, :importpos ^ABEND881(unrecognized Expr type *ast.MapType at: &{2217909 string 0xc000bb4c30}) ImportPos, :testgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2218007 <nil> string}) TestGoFiles, :testimports ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2218080 <nil> string}) TestImports, :testimportpos ^ABEND881(unrecognized Expr type *ast.MapType at: &{2218157 string 0xc000bb4cf0}) TestImportPos, :xtestgofiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2218237 <nil> string}) XTestGoFiles, :xtestimports ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2218315 <nil> string}) XTestImports, :xtestimportpos ^ABEND881(unrecognized Expr type *ast.MapType at: &{2218393 string 0xc000bb4db0}) XTestImportPos} Error] ImportDir
;;   "ImportDir is shorthand for Default.ImportDir."
;;   {:added "1.0"
;;    :go "importDir(dir, mode)"}
;;   [^String dir, mode])
;; 
JOKER FUNC build.IsLocalImport has: 
;; (defn ^ABEND042(cannot find typename build.bool) IsLocalImport
;;   "IsLocalImport reports whether the import path is
;; a local import path, like ".", "..", "./foo", or "../foo"."
;;   {:added "1.0"
;;    :go "isLocalImport(path)"}
;;   [^String path])
;; 
JOKER FUNC bytes.Compare has: 
;; (defn ^Int Compare
;;   "Compare returns an integer comparing two byte slices lexicographically.
;; The result will be 0 if a==b, -1 if a < b, and +1 if a > b.
;; A nil argument is equivalent to an empty slice."
;;   {:added "1.0"
;;    :go "compare(a, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{194287 <nil> byte}) a, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{194287 <nil> byte}) b])
;; 
JOKER FUNC bytes.Contains has: 
;; (defn ^ABEND042(cannot find typename bytes.bool) Contains
;;   "Contains reports whether subslice is within b."
;;   {:added "1.0"
;;    :go "contains(b, subslice)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{195837 <nil> byte}) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{195837 <nil> byte}) subslice])
;; 
JOKER FUNC bytes.ContainsAny has: 
;; (defn ^ABEND042(cannot find typename bytes.bool) ContainsAny
;;   "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b."
;;   {:added "1.0"
;;    :go "containsAny(b, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{195998 <nil> byte}) b, ^String chars])
;; 
JOKER FUNC bytes.ContainsRune has: 
;; (defn ^ABEND042(cannot find typename bytes.bool) ContainsRune
;;   "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b."
;;   {:added "1.0"
;;    :go "containsRune(b, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{196171 <nil> byte}) b, r])
;; 
JOKER FUNC bytes.Count has: 
;; (defn ^Int Count
;;   "Count counts the number of non-overlapping instances of sep in s.
;; If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s."
;;   {:added "1.0"
;;    :go "count(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{195519 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{195519 <nil> byte}) sep])
;; 
JOKER FUNC bytes.Equal has: 
;; (defn ^ABEND042(cannot find typename bytes.bool) Equal
;;   "Equal returns a boolean reporting whether a and b
;; are the same length and contain the same bytes.
;; A nil argument is equivalent to an empty slice."
;;   {:added "1.0"
;;    :go "equal(a, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{194028 <nil> byte}) a, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{194028 <nil> byte}) b])
;; 
JOKER FUNC bytes.EqualFold has: 
;; (defn ^ABEND042(cannot find typename bytes.bool) EqualFold
;;   "EqualFold reports whether s and t, interpreted as UTF-8 strings,
;; are equal under Unicode case-folding."
;;   {:added "1.0"
;;    :go "equalFold(s, t)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{215463 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{215463 <nil> byte}) t])
;; 
JOKER FUNC bytes.Fields has: 
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] Fields
;;   "Fields interprets s as a sequence of UTF-8-encoded code points.
;; It splits the slice s around each instance of one or more consecutive white space
;; characters, as defined by unicode.IsSpace, returning a slice of subslices of s or an
;; empty slice if s contains only white space."
;;   {:added "1.0"
;;    :go "fields(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{201493 <nil> byte}) s])
;; 
JOKER FUNC bytes.FieldsFunc has: 
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] FieldsFunc
;;   "FieldsFunc interprets s as a sequence of UTF-8-encoded code points.
;; It splits the slice s at each run of code points c satisfying f(c) and
;; returns a slice of subslices of s. If all code points in s satisfy f(c), or
;; len(s) == 0, an empty slice is returned.
;; FieldsFunc makes no guarantees about the order in which it calls f(c).
;; If f does not return consistent results for a given c, FieldsFunc may crash."
;;   {:added "1.0"
;;    :go "fieldsFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{202957 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{202967 0xc0003eaae0 0xc0003eab10}) f])
;; 
JOKER FUNC bytes.HasPrefix has: 
;; (defn ^ABEND042(cannot find typename bytes.bool) HasPrefix
;;   "HasPrefix tests whether the byte slice s begins with prefix."
;;   {:added "1.0"
;;    :go "hasPrefix(s, prefix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{204484 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{204484 <nil> byte}) prefix])
;; 
JOKER FUNC bytes.HasSuffix has: 
;; (defn ^ABEND042(cannot find typename bytes.bool) HasSuffix
;;   "HasSuffix tests whether the byte slice s ends with suffix."
;;   {:added "1.0"
;;    :go "hasSuffix(s, suffix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{204654 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{204654 <nil> byte}) suffix])
;; 
JOKER FUNC bytes.Index has: 
;; (defn ^Int Index
;;   "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s."
;;   {:added "1.0"
;;    :go "index(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{216626 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{216626 <nil> byte}) sep])
;; 
JOKER FUNC bytes.IndexAny has: 
;; (defn ^Int IndexAny
;;   "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.
;; It returns the byte index of the first occurrence in s of any of the Unicode
;; code points in chars. It returns -1 if chars is empty or if there is no code
;; point in common."
;;   {:added "1.0"
;;    :go "indexAny(s, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{197865 <nil> byte}) s, ^String chars])
;; 
JOKER FUNC bytes.IndexByte has: 
;; (defn ^Int IndexByte
;;   "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b."
;;   {:added "1.0"
;;    :go "indexByte(b, c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{193798 <nil> byte}) b, c])
;; 
JOKER FUNC bytes.IndexFunc has: 
;; (defn ^Int IndexFunc
;;   "IndexFunc interprets s as a sequence of UTF-8-encoded code points.
;; It returns the byte index in s of the first Unicode
;; code point satisfying f(c), or -1 if none do."
;;   {:added "1.0"
;;    :go "indexFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{210735 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{210745 0xc000400ab0 0xc000400ae0}) f])
;; 
JOKER FUNC bytes.IndexRune has: 
;; (defn ^Int IndexRune
;;   "IndexRune interprets s as a sequence of UTF-8-encoded code points.
;; It returns the byte index of the first occurrence in s of the given rune.
;; It returns -1 if rune is not present in s.
;; If r is utf8.RuneError, it returns the first instance of any
;; invalid UTF-8 byte sequence."
;;   {:added "1.0"
;;    :go "indexRune(s, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{197194 <nil> byte}) s, r])
;; 
JOKER FUNC bytes.Join has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Join
;;   "Join concatenates the elements of s to create a new byte slice. The separator
;; sep is placed between elements in the resulting slice."
;;   {:added "1.0"
;;    :go "join(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{204034 <nil> 0xc0003eb320}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{204048 <nil> byte}) sep])
;; 
JOKER FUNC bytes.LastIndex has: 
;; (defn ^Int LastIndex
;;   "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s."
;;   {:added "1.0"
;;    :go "lastIndex(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{196464 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{196464 <nil> byte}) sep])
;; 
JOKER FUNC bytes.LastIndexAny has: 
;; (defn ^Int LastIndexAny
;;   "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code
;; points. It returns the byte index of the last occurrence in s of any of
;; the Unicode code points in chars. It returns -1 if chars is empty or if
;; there is no code point in common."
;;   {:added "1.0"
;;    :go "lastIndexAny(s, chars)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{198643 <nil> byte}) s, ^String chars])
;; 
JOKER FUNC bytes.LastIndexByte has: 
;; (defn ^Int LastIndexByte
;;   "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s."
;;   {:added "1.0"
;;    :go "lastIndexByte(s, c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{196780 <nil> byte}) s, c])
;; 
JOKER FUNC bytes.LastIndexFunc has: 
;; (defn ^Int LastIndexFunc
;;   "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.
;; It returns the byte index in s of the last Unicode
;; code point satisfying f(c), or -1 if none do."
;;   {:added "1.0"
;;    :go "lastIndexFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{211001 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{211011 0xc000400c90 0xc000400cc0}) f])
;; 
JOKER FUNC bytes.Map has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Map
;;   "Map returns a copy of the byte slice s with all its characters modified
;; according to the mapping function. If mapping returns a negative value, the character is
;; dropped from the byte slice with no replacement. The characters in s and the
;; output are interpreted as UTF-8-encoded code points."
;;   {:added "1.0"
;;    :go "map(mapping, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{205063 0xc0003ebcb0 0xc0003ebce0}) mapping, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{205084 <nil> byte}) s])
;; 
JOKER FUNC bytes.NewBuffer has: 
;; (defn ^{:buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{179153 <nil> byte}) buf, :off ^Int off, :bootstrap ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{179285 0xc0003936c0 byte}) bootstrap, :lastread lastRead} NewBuffer
;;   "NewBuffer creates and initializes a new Buffer using buf as its
;; initial contents. The new Buffer takes ownership of buf, and the
;; caller should not use buf after this call. NewBuffer is intended to
;; prepare a Buffer to read existing data. It can also be used to size
;; the internal buffer for writing. To do that, buf should have the
;; desired capacity but a length of zero.
;; 
;; In most cases, new(Buffer) (or just declaring a Buffer variable) is
;; sufficient to initialize a Buffer."
;;   {:added "1.0"
;;    :go "newBuffer(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{193096 <nil> byte}) buf])
;; 
JOKER FUNC bytes.NewBufferString has: 
;; (defn ^{:buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{179153 <nil> byte}) buf, :off ^Int off, :bootstrap ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{179285 0xc0003936c0 byte}) bootstrap, :lastread lastRead} NewBufferString
;;   "NewBufferString creates and initializes a new Buffer using string s as its
;; initial contents. It is intended to prepare a buffer to read an existing
;; string.
;; 
;; In most cases, new(Buffer) (or just declaring a Buffer variable) is
;; sufficient to initialize a Buffer."
;;   {:added "1.0"
;;    :go "newBufferString(s)"}
;;   [^String s])
;; 
JOKER FUNC bytes.NewReader has: 
;; (defn ^{:s ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{175409 <nil> byte}) s, :i i, :prevrune ^Int prevRune} NewReader
;;   "NewReader returns a new Reader reading from b."
;;   {:added "1.0"
;;    :go "newReader(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{178673 <nil> byte}) b])
;; 
JOKER FUNC bytes.Repeat has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Repeat
;;   "Repeat returns a new byte slice consisting of count copies of b.
;; 
;; It panics if count is negative or if
;; the result of (len(b) * count) overflows."
;;   {:added "1.0"
;;    :go "repeat(b, count)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{206071 <nil> byte}) b, ^Int count])
;; 
JOKER FUNC bytes.Replace has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Replace
;;   "Replace returns a copy of the slice s with the first n
;; non-overlapping instances of old replaced by new.
;; If old is empty, it matches at the beginning of the slice
;; and after each UTF-8 sequence, yielding up to k+1 replacements
;; for a k-rune slice.
;; If n < 0, there is no limit on the number of replacements."
;;   {:added "1.0"
;;    :go "replace(s, old, new, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{214711 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{214711 <nil> byte}) old, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{214711 <nil> byte}) new, ^Int n])
;; 
JOKER FUNC bytes.Runes has: 
;; (defn ^[ABEND042(cannot find typename bytes.rune)] Runes
;;   "Runes interprets s as a sequence of UTF-8-encoded code points.
;; It returns a slice of runes (Unicode code points) equivalent to s."
;;   {:added "1.0"
;;    :go "runes(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{214208 <nil> byte}) s])
;; 
JOKER FUNC bytes.Split has: 
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] Split
;;   "Split slices s into all subslices separated by sep and returns a slice of
;; the subslices between those separators.
;; If sep is empty, Split splits after each UTF-8 sequence.
;; It is equivalent to SplitN with a count of -1."
;;   {:added "1.0"
;;    :go "split(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{200741 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{200741 <nil> byte}) sep])
;; 
JOKER FUNC bytes.SplitAfter has: 
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] SplitAfter
;;   "SplitAfter slices s into all subslices after each instance of sep and
;; returns a slice of those subslices.
;; If sep is empty, SplitAfter splits after each UTF-8 sequence.
;; It is equivalent to SplitAfterN with a count of -1."
;;   {:added "1.0"
;;    :go "splitAfter(s, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{201049 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{201049 <nil> byte}) sep])
;; 
JOKER FUNC bytes.SplitAfterN has: 
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] SplitAfterN
;;   "SplitAfterN slices s into subslices after each instance of sep and
;; returns a slice of those subslices.
;; If sep is empty, SplitAfterN splits after each UTF-8 sequence.
;; The count determines the number of subslices to return:
;;   n > 0: at most n subslices; the last subslice will be the unsplit remainder.
;;   n == 0: the result is nil (zero subslices)
;;   n < 0: all subslices"
;;   {:added "1.0"
;;    :go "splitAfterN(s, sep, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{200426 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{200426 <nil> byte}) sep, ^Int n])
;; 
JOKER FUNC bytes.SplitN has: 
;; (defn ^[[ABEND042(cannot find typename bytes.byte)]] SplitN
;;   "SplitN slices s into subslices separated by sep and returns a slice of
;; the subslices between those separators.
;; If sep is empty, SplitN splits after each UTF-8 sequence.
;; The count determines the number of subslices to return:
;;   n > 0: at most n subslices; the last subslice will be the unsplit remainder.
;;   n == 0: the result is nil (zero subslices)
;;   n < 0: all subslices"
;;   {:added "1.0"
;;    :go "splitN(s, sep, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{199953 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{199953 <nil> byte}) sep, ^Int n])
;; 
JOKER FUNC bytes.Title has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Title
;;   "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin
;; words mapped to their title case.
;; 
;; BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly."
;;   {:added "1.0"
;;    :go "title(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{208892 <nil> byte}) s])
;; 
JOKER FUNC bytes.ToLower has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToLower
;;   "ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case."
;;   {:added "1.0"
;;    :go "toLower(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{206867 <nil> byte}) s])
;; 
JOKER FUNC bytes.ToLowerSpecial has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToLowerSpecial
;;   "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
;; lower case, giving priority to the special casing rules."
;;   {:added "1.0"
;;    :go "toLowerSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unicode SpecialCase}) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{207619 <nil> byte}) s])
;; 
JOKER FUNC bytes.ToTitle has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToTitle
;;   "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case."
;;   {:added "1.0"
;;    :go "toTitle(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{207052 <nil> byte}) s])
;; 
JOKER FUNC bytes.ToTitleSpecial has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToTitleSpecial
;;   "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
;; title case, giving priority to the special casing rules."
;;   {:added "1.0"
;;    :go "toTitleSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unicode SpecialCase}) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{207916 <nil> byte}) s])
;; 
JOKER FUNC bytes.ToUpper has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToUpper
;;   "ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case."
;;   {:added "1.0"
;;    :go "toUpper(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{206682 <nil> byte}) s])
;; 
JOKER FUNC bytes.ToUpperSpecial has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] ToUpperSpecial
;;   "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
;; upper case, giving priority to the special casing rules."
;;   {:added "1.0"
;;    :go "toUpperSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unicode SpecialCase}) c, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{207322 <nil> byte}) s])
;; 
JOKER FUNC bytes.Trim has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] Trim
;;   "Trim returns a subslice of s by slicing off all leading and
;; trailing UTF-8-encoded code points contained in cutset."
;;   {:added "1.0"
;;    :go "trim(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{213353 <nil> byte}) s, ^String cutset])
;; 
JOKER FUNC bytes.TrimFunc has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimFunc
;;   "TrimFunc returns a subslice of s by slicing off all leading and trailing
;; UTF-8-encoded code points c that satisfy f(c)."
;;   {:added "1.0"
;;    :go "trimFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{209974 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{209984 0xc000400450 0xc000400480}) f])
;; 
JOKER FUNC bytes.TrimLeft has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimLeft
;;   "TrimLeft returns a subslice of s by slicing off all leading
;; UTF-8-encoded code points contained in cutset."
;;   {:added "1.0"
;;    :go "trimLeft(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{213561 <nil> byte}) s, ^String cutset])
;; 
JOKER FUNC bytes.TrimLeftFunc has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimLeftFunc
;;   "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off
;; all leading UTF-8-encoded code points c that satisfy f(c)."
;;   {:added "1.0"
;;    :go "trimLeftFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{209386 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{209396 0xc0003f5da0 0xc0003f5dd0}) f])
;; 
JOKER FUNC bytes.TrimPrefix has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimPrefix
;;   "TrimPrefix returns s without the provided leading prefix string.
;; If s doesn't start with prefix, s is returned unchanged."
;;   {:added "1.0"
;;    :go "trimPrefix(s, prefix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{210214 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{210214 <nil> byte}) prefix])
;; 
JOKER FUNC bytes.TrimRight has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimRight
;;   "TrimRight returns a subslice of s by slicing off all trailing
;; UTF-8-encoded code points that are contained in cutset."
;;   {:added "1.0"
;;    :go "trimRight(s, cutset)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{213785 <nil> byte}) s, ^String cutset])
;; 
JOKER FUNC bytes.TrimRightFunc has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimRightFunc
;;   "TrimRightFunc returns a subslice of s by slicing off all trailing
;; UTF-8-encoded code points c that satisfy f(c)."
;;   {:added "1.0"
;;    :go "trimRightFunc(s, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{209640 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{209650 0xc000400090 0xc0004000c0}) f])
;; 
JOKER FUNC bytes.TrimSpace has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimSpace
;;   "TrimSpace returns a subslice of s by slicing off all leading and
;; trailing white space, as defined by Unicode."
;;   {:added "1.0"
;;    :go "trimSpace(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{214002 <nil> byte}) s])
;; 
JOKER FUNC bytes.TrimSuffix has: 
;; (defn ^[ABEND042(cannot find typename bytes.byte)] TrimSuffix
;;   "TrimSuffix returns s without the provided trailing suffix string.
;; If s doesn't end with suffix, s is returned unchanged."
;;   {:added "1.0"
;;    :go "trimSuffix(s, suffix)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{210452 <nil> byte}) s, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{210452 <nil> byte}) suffix])
;; 
JOKER FUNC bzip2.NewReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) NewReader
;;   "NewReader returns an io.Reader which decompresses bzip2 data from r.
;; If r does not also implement io.ByteReader,
;; the decompressor may read more data than necessary from r."
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC cgi.Request has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{http Request}) Error] Request
;;   "Request returns the HTTP request as represented in the current
;; environment. This assumes the current program is being run
;; by a web server in a CGI environment.
;; The returned Request's Body is populated, if applicable."
;;   {:added "1.0"
;;    :go "request()"}
;;   [])
;; 
JOKER FUNC cgi.RequestFromMap has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{http Request}) Error] RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.
;; The returned Request's Body field is not populated."
;;   {:added "1.0"
;;    :go "requestFromMap(params)"}
;;   [^ABEND881(unrecognized Expr type *ast.MapType at: &{5032544 string string}) params])
;; 
JOKER FUNC cgi.Serve has: 
;; (defn ^Error Serve
;;   "Serve executes the provided Handler on the currently active CGI
;; request, if any. If there's no current CGI environment
;; an error is returned. The provided handler may be nil to use
;; http.DefaultServeMux."
;;   {:added "1.0"
;;    :go "serve(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http Handler}) handler])
;; 
JOKER FUNC cgo._cgo_panic has: 
;; (defn _cgo_panic
;;   "go:linkname _cgo_panic _cgo_panic
;; go:cgo_export_static _cgo_panic
;; go:cgo_export_dynamic _cgo_panic
;; go:nosplit
;; go:norace"
;;   {:added "1.0"
;;    :go "_cgo_panic(a, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) a, n])
;; 
JOKER FUNC cgo._runtime_cgocallback has: 
;; (defn _runtime_cgocallback
;;   "cgocallback is defined in runtime
;; go:linkname _runtime_cgocallback runtime.cgocallback"
;;   {:added "1.0"
;;    :go "_runtime_cgocallback()"}
;;   [])
;; 
JOKER FUNC chacha20poly1305.New has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{cipher AEAD}) Error] New
;;   "New returns a ChaCha20-Poly1305 AEAD that uses the given, 256-bit key."
;;   {:added "1.0"
;;    :go "new(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8166163 <nil> byte}) key])
;; 
JOKER FUNC cipher.NewCBCDecrypter has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{470341 0xc000364240 false}) NewCBCDecrypter
;;   "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining
;; mode, using the given Block. The length of iv must be the same as the
;; Block's block size and must match the iv used to encrypt the data."
;;   {:added "1.0"
;;    :go "newCBCDecrypter(b, iv)"}
;;   [b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{457542 <nil> byte}) iv])
;; 
JOKER FUNC cipher.NewCBCEncrypter has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{470341 0xc000364240 false}) NewCBCEncrypter
;;   "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining
;; mode, using the given Block. The length of iv must be the same as the
;; Block's block size."
;;   {:added "1.0"
;;    :go "newCBCEncrypter(b, iv)"}
;;   [b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{455817 <nil> byte}) iv])
;; 
JOKER FUNC cipher.NewCFBDecrypter has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{469627 0xc000364120 false}) NewCFBDecrypter
;;   "NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,
;; using the given Block. The iv must be the same length as the Block's block
;; size."
;;   {:added "1.0"
;;    :go "newCFBDecrypter(block, iv)"}
;;   [block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{462806 <nil> byte}) iv])
;; 
JOKER FUNC cipher.NewCFBEncrypter has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{469627 0xc000364120 false}) NewCFBEncrypter
;;   "NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,
;; using the given Block. The iv must be the same length as the Block's block
;; size."
;;   {:added "1.0"
;;    :go "newCFBEncrypter(block, iv)"}
;;   [block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{462551 <nil> byte}) iv])
;; 
JOKER FUNC cipher.NewCTR has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{469627 0xc000364120 false}) NewCTR
;;   "NewCTR returns a Stream which encrypts/decrypts using the given Block in
;; counter mode. The length of iv must be the same as the Block's block size."
;;   {:added "1.0"
;;    :go "newCTR(block, iv)"}
;;   [block, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{465758 <nil> byte}) iv])
;; 
JOKER FUNC cipher.NewGCM has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{471586 0xc000364750 false}) Error] NewGCM
;;   "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode
;; with the standard nonce length.
;; 
;; In general, the GHASH operation performed by this implementation of GCM is not constant-time.
;; An exception is when the underlying Block was created by aes.NewCipher
;; on systems with hardware support for AES. See the crypto/aes package documentation for details."
;;   {:added "1.0"
;;    :go "newGCM(cipher)"}
;;   [cipher])
;; 
JOKER FUNC cipher.NewGCMWithNonceSize has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{471586 0xc000364750 false}) Error] NewGCMWithNonceSize
;;   "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois
;; Counter Mode, which accepts nonces of the given length.
;; 
;; Only use this function if you require compatibility with an existing
;; cryptosystem that uses non-standard nonce lengths. All other users should use
;; NewGCM, which is faster and more resistant to misuse."
;;   {:added "1.0"
;;    :go "newGCMWithNonceSize(cipher, size)"}
;;   [cipher, ^Int size])
;; 
JOKER FUNC cipher.NewGCMWithTagSize has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{471586 0xc000364750 false}) Error] NewGCMWithTagSize
;;   "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois
;; Counter Mode, which generates tags with the given length.
;; 
;; Tag sizes between 12 and 16 bytes are allowed.
;; 
;; Only use this function if you require compatibility with an existing
;; cryptosystem that uses non-standard tag lengths. All other users should use
;; NewGCM, which is more resistant to misuse."
;;   {:added "1.0"
;;    :go "newGCMWithTagSize(cipher, tagSize)"}
;;   [cipher, ^Int tagSize])
;; 
JOKER FUNC cipher.NewOFB has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{469627 0xc000364120 false}) NewOFB
;;   "NewOFB returns a Stream that encrypts or decrypts using the block cipher b
;; in output feedback mode. The initialization vector iv's length must be equal
;; to b's block size."
;;   {:added "1.0"
;;    :go "newOFB(b, iv)"}
;;   [b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{467469 <nil> byte}) iv])
;; 
JOKER FUNC cmplx.Abs has: 
;; (defn ^ABEND042(cannot find typename cmplx.float64) Abs
;;   "Abs returns the absolute value (also called the modulus) of x."
;;   {:added "1.0"
;;    :go "abs(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Acos has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Acos
;;   "Acos returns the inverse cosine of x."
;;   {:added "1.0"
;;    :go "acos(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Acosh has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x."
;;   {:added "1.0"
;;    :go "acosh(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Asin has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Asin
;;   "Asin returns the inverse sine of x."
;;   {:added "1.0"
;;    :go "asin(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Asinh has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Asinh
;;   "Asinh returns the inverse hyperbolic sine of x."
;;   {:added "1.0"
;;    :go "asinh(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Atan has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Atan
;;   "Atan returns the inverse tangent of x."
;;   {:added "1.0"
;;    :go "atan(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Atanh has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x."
;;   {:added "1.0"
;;    :go "atanh(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Conj has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Conj
;;   "Conj returns the complex conjugate of x."
;;   {:added "1.0"
;;    :go "conj(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Cos has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Cos
;;   "Cos returns the cosine of x."
;;   {:added "1.0"
;;    :go "cos(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Cosh has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Cosh
;;   "Cosh returns the hyperbolic cosine of x."
;;   {:added "1.0"
;;    :go "cosh(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Cot has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Cot
;;   "Cot returns the cotangent of x."
;;   {:added "1.0"
;;    :go "cot(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Exp has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Exp
;;   "Exp returns e**x, the base-e exponential of x."
;;   {:added "1.0"
;;    :go "exp(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Inf has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Inf
;;   "Inf returns a complex infinity, complex(+Inf, +Inf)."
;;   {:added "1.0"
;;    :go "inf()"}
;;   [])
;; 
JOKER FUNC cmplx.IsInf has: 
;; (defn ^ABEND042(cannot find typename cmplx.bool) IsInf
;;   "IsInf returns true if either real(x) or imag(x) is an infinity."
;;   {:added "1.0"
;;    :go "isInf(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.IsNaN has: 
;; (defn ^ABEND042(cannot find typename cmplx.bool) IsNaN
;;   "IsNaN returns true if either real(x) or imag(x) is NaN
;; and neither is an infinity."
;;   {:added "1.0"
;;    :go "isNaN(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Log has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Log
;;   "Log returns the natural logarithm of x."
;;   {:added "1.0"
;;    :go "log(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Log10 has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Log10
;;   "Log10 returns the decimal logarithm of x."
;;   {:added "1.0"
;;    :go "log10(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.NaN has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) NaN
;;   "NaN returns a complex ``not-a-number'' value."
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])
;; 
JOKER FUNC cmplx.Phase has: 
;; (defn ^ABEND042(cannot find typename cmplx.float64) Phase
;;   "Phase returns the phase (also called the argument) of x.
;; The returned value is in the range [-Pi, Pi]."
;;   {:added "1.0"
;;    :go "phase(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Polar has: 
(defn ^[r θ] Polar
  "Polar returns the absolute value r and phase θ of x,
such that x = r * e**θi.
The phase is in the range [-Pi, Pi]."
  {:added "1.0"
   :go "polar(x)"}
  [x])

JOKER FUNC cmplx.Pow has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Pow
;;   "Pow returns x**y, the base-x exponential of y.
;; For generalized compatibility with math.Pow:
;; 	Pow(0, ±0) returns 1+0i
;; 	Pow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i."
;;   {:added "1.0"
;;    :go "pow(x, y)"}
;;   [x, y])
;; 
JOKER FUNC cmplx.Rect has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Rect
;;   "Rect returns the complex number x with polar coordinates r, θ."
;;   {:added "1.0"
;;    :go "rect(r, θ)"}
;;   [r, θ])
;; 
JOKER FUNC cmplx.Sin has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Sin
;;   "Sin returns the sine of x."
;;   {:added "1.0"
;;    :go "sin(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Sinh has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Sinh
;;   "Sinh returns the hyperbolic sine of x."
;;   {:added "1.0"
;;    :go "sinh(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Sqrt has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Sqrt
;;   "Sqrt returns the square root of x.
;; The result r is chosen so that real(r) ≥ 0 and imag(r) has the same sign as imag(x)."
;;   {:added "1.0"
;;    :go "sqrt(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Tan has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Tan
;;   "Tan returns the tangent of x."
;;   {:added "1.0"
;;    :go "tan(x)"}
;;   [x])
;; 
JOKER FUNC cmplx.Tanh has: 
;; (defn ^ABEND042(cannot find typename cmplx.complex128) Tanh
;;   "Tanh returns the hyperbolic tangent of x."
;;   {:added "1.0"
;;    :go "tanh(x)"}
;;   [x])
;; 
JOKER FUNC color.CMYKToRGB has: 
;; (defn ^[ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)] CMYKToRGB
;;   "CMYKToRGB converts a CMYK quadruple to an RGB triple."
;;   {:added "1.0"
;;    :go "cMYKToRGB(c, m, y, k)"}
;;   [c, m, y, k])
;; 
JOKER FUNC color.ModelFunc has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{3287323 0xc00046bb60 false}) ModelFunc
;;   "ModelFunc returns a Model that invokes f to implement the conversion."
;;   {:added "1.0"
;;    :go "modelFunc(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{3287452 0xc00046bc20 0xc00046bc50}) f])
;; 
JOKER FUNC color.RGBToCMYK has: 
;; (defn ^[ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)] RGBToCMYK
;;   "RGBToCMYK converts an RGB triple to a CMYK quadruple."
;;   {:added "1.0"
;;    :go "rGBToCMYK(r, g, b)"}
;;   [r, g, b])
;; 
JOKER FUNC color.RGBToYCbCr has: 
;; (defn ^[ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)] RGBToYCbCr
;;   "RGBToYCbCr converts an RGB triple to a Y'CbCr triple."
;;   {:added "1.0"
;;    :go "rGBToYCbCr(r, g, b)"}
;;   [r, g, b])
;; 
JOKER FUNC color.YCbCrToRGB has: 
;; (defn ^[ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8) ABEND042(cannot find typename color.uint8)] YCbCrToRGB
;;   "YCbCrToRGB converts a Y'CbCr triple to an RGB triple."
;;   {:added "1.0"
;;    :go "yCbCrToRGB(y, cb, cr)"}
;;   [y, cb, cr])
;; 
JOKER FUNC constant.BinaryOp has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) BinaryOp
;;   "BinaryOp returns the result of the binary expression x op y.
;; The operation must be defined for the operands. If one of the
;; operands is Unknown, the result is Unknown.
;; BinaryOp doesn't handle comparisons or shifts; use Compare
;; or Shift instead.
;; 
;; To force integer division of Int operands, use op == token.QUO_ASSIGN
;; instead of token.QUO; the result is guaranteed to be Int in this case.
;; Division by zero leads to a run-time panic."
;;   {:added "1.0"
;;    :go "binaryOp(x_, op, y_)"}
;;   [x_, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Token}) op, y_])
;; 
JOKER FUNC constant.BitLen has: 
(defn ^Int BitLen
  "BitLen returns the number of bits required to represent
the absolute value x in binary representation; x must be an Int or an Unknown.
If x is Unknown, the result is 0."
  {:added "1.0"
   :go "bitLen(x)"}
  [x])

JOKER FUNC constant.BoolVal has: 
;; (defn ^ABEND042(cannot find typename constant.bool) BoolVal
;;   "BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown.
;; If x is Unknown, the result is false."
;;   {:added "1.0"
;;    :go "boolVal(x)"}
;;   [x])
;; 
JOKER FUNC constant.Bytes has: 
;; (defn ^[ABEND042(cannot find typename constant.byte)] Bytes
;;   "Bytes returns the bytes for the absolute value of x in little-
;; endian binary representation; x must be an Int."
;;   {:added "1.0"
;;    :go "bytes(x)"}
;;   [x])
;; 
JOKER FUNC constant.Compare has: 
;; (defn ^ABEND042(cannot find typename constant.bool) Compare
;;   "Compare returns the result of the comparison x op y.
;; The comparison must be defined for the operands.
;; If one of the operands is Unknown, the result is
;; false."
;;   {:added "1.0"
;;    :go "compare(x_, op, y_)"}
;;   [x_, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Token}) op, y_])
;; 
JOKER FUNC constant.Denom has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) Denom
;;   "Denom returns the denominator of x; x must be Int, Float, or Unknown.
;; If x is Unknown, or if it is too large or small to represent as a
;; fraction, the result is Unknown. Otherwise the result is an Int >= 1."
;;   {:added "1.0"
;;    :go "denom(x)"}
;;   [x])
;; 
JOKER FUNC constant.Float32Val has: 
;; (defn ^[ABEND042(cannot find typename constant.float32) ABEND042(cannot find typename constant.bool)] Float32Val
;;   "Float32Val is like Float64Val but for float32 instead of float64."
;;   {:added "1.0"
;;    :go "float32Val(x)"}
;;   [x])
;; 
JOKER FUNC constant.Float64Val has: 
;; (defn ^[ABEND042(cannot find typename constant.float64) ABEND042(cannot find typename constant.bool)] Float64Val
;;   "Float64Val returns the nearest Go float64 value of x and whether the result is exact;
;; x must be numeric or an Unknown, but not Complex. For values too small (too close to 0)
;; to represent as float64, Float64Val silently underflows to 0. The result sign always
;; matches the sign of x, even for 0.
;; If x is Unknown, the result is (0, false)."
;;   {:added "1.0"
;;    :go "float64Val(x)"}
;;   [x])
;; 
JOKER FUNC constant.Imag has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) Imag
;;   "Imag returns the imaginary part of x, which must be a numeric or unknown value.
;; If x is Unknown, the result is Unknown."
;;   {:added "1.0"
;;    :go "imag(x)"}
;;   [x])
;; 
JOKER FUNC constant.Int64Val has: 
;; (defn ^[ABEND042(cannot find typename constant.int64) ABEND042(cannot find typename constant.bool)] Int64Val
;;   "Int64Val returns the Go int64 value of x and whether the result is exact;
;; x must be an Int or an Unknown. If the result is not exact, its value is undefined.
;; If x is Unknown, the result is (0, false)."
;;   {:added "1.0"
;;    :go "int64Val(x)"}
;;   [x])
;; 
JOKER FUNC constant.MakeBool has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) MakeBool
;;   "MakeBool returns the Bool value for b."
;;   {:added "1.0"
;;    :go "makeBool(b)"}
;;   [b])
;; 
JOKER FUNC constant.MakeFloat64 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) MakeFloat64
;;   "MakeFloat64 returns the Float value for x.
;; If x is not finite, the result is an Unknown."
;;   {:added "1.0"
;;    :go "makeFloat64(x)"}
;;   [x])
;; 
JOKER FUNC constant.MakeFromBytes has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) MakeFromBytes
;;   "MakeFromBytes returns the Int value given the bytes of its little-endian
;; binary representation. An empty byte slice argument represents 0."
;;   {:added "1.0"
;;    :go "makeFromBytes(bytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2287760 <nil> byte}) bytes])
;; 
JOKER FUNC constant.MakeFromLiteral has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) MakeFromLiteral
;;   "MakeFromLiteral returns the corresponding integer, floating-point,
;; imaginary, character, or string value for a Go literal string. The
;; tok value must be one of token.INT, token.FLOAT, token.IMAG,
;; token.CHAR, or token.STRING. The final argument must be zero.
;; If the literal string syntax is invalid, the result is an Unknown."
;;   {:added "1.0"
;;    :go "makeFromLiteral(lit, tok, zero)"}
;;   [^String lit, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Token}) tok, ^Int zero])
;; 
JOKER FUNC constant.MakeImag has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) MakeImag
;;   "MakeImag returns the Complex value x*i;
;; x must be Int, Float, or Unknown.
;; If x is Unknown, the result is Unknown."
;;   {:added "1.0"
;;    :go "makeImag(x)"}
;;   [x])
;; 
JOKER FUNC constant.MakeInt64 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) MakeInt64
;;   "MakeInt64 returns the Int value for x."
;;   {:added "1.0"
;;    :go "makeInt64(x)"}
;;   [x])
;; 
JOKER FUNC constant.MakeString has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) MakeString
;;   "MakeString returns the String value for s."
;;   {:added "1.0"
;;    :go "makeString(s)"}
;;   [^String s])
;; 
JOKER FUNC constant.MakeUint64 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) MakeUint64
;;   "MakeUint64 returns the Int value for x."
;;   {:added "1.0"
;;    :go "makeUint64(x)"}
;;   [x])
;; 
JOKER FUNC constant.MakeUnknown has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) MakeUnknown
;;   "MakeUnknown returns the Unknown value."
;;   {:added "1.0"
;;    :go "makeUnknown()"}
;;   [])
;; 
JOKER FUNC constant.Num has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) Num
;;   "Num returns the numerator of x; x must be Int, Float, or Unknown.
;; If x is Unknown, or if it is too large or small to represent as a
;; fraction, the result is Unknown. Otherwise the result is an Int
;; with the same sign as x."
;;   {:added "1.0"
;;    :go "num(x)"}
;;   [x])
;; 
JOKER FUNC constant.Real has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) Real
;;   "Real returns the real part of x, which must be a numeric or unknown value.
;; If x is Unknown, the result is Unknown."
;;   {:added "1.0"
;;    :go "real(x)"}
;;   [x])
;; 
JOKER FUNC constant.Shift has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) Shift
;;   "Shift returns the result of the shift expression x op s
;; with op == token.SHL or token.SHR (<< or >>). x must be
;; an Int or an Unknown. If x is Unknown, the result is x."
;;   {:added "1.0"
;;    :go "shift(x, op, s)"}
;;   [x, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Token}) op, ^Int s])
;; 
JOKER FUNC constant.Sign has: 
(defn ^Int Sign
  "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0;
x must be numeric or Unknown. For complex values x, the sign is 0 if x == 0,
otherwise it is != 0. If x is Unknown, the result is 1."
  {:added "1.0"
   :go "sign(x)"}
  [x])

JOKER FUNC constant.StringVal has: 
(defn ^String StringVal
  "StringVal returns the Go string value of x, which must be a String or an Unknown.
If x is Unknown, the result is ""."
  {:added "1.0"
   :go "stringVal(x)"}
  [x])

JOKER FUNC constant.ToComplex has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) ToComplex
;;   "ToComplex converts x to a Complex value if x is representable as a Complex.
;; Otherwise it returns an Unknown."
;;   {:added "1.0"
;;    :go "toComplex(x)"}
;;   [x])
;; 
JOKER FUNC constant.ToFloat has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) ToFloat
;;   "ToFloat converts x to a Float value if x is representable as a Float.
;; Otherwise it returns an Unknown."
;;   {:added "1.0"
;;    :go "toFloat(x)"}
;;   [x])
;; 
JOKER FUNC constant.ToInt has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) ToInt
;;   "ToInt converts x to an Int value if x is representable as an Int.
;; Otherwise it returns an Unknown."
;;   {:added "1.0"
;;    :go "toInt(x)"}
;;   [x])
;; 
JOKER FUNC constant.Uint64Val has: 
;; (defn ^[ABEND042(cannot find typename constant.uint64) ABEND042(cannot find typename constant.bool)] Uint64Val
;;   "Uint64Val returns the Go uint64 value of x and whether the result is exact;
;; x must be an Int or an Unknown. If the result is not exact, its value is undefined.
;; If x is Unknown, the result is (0, false)."
;;   {:added "1.0"
;;    :go "uint64Val(x)"}
;;   [x])
;; 
JOKER FUNC constant.UnaryOp has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2271748 0xc0004d9b00 false}) UnaryOp
;;   "UnaryOp returns the result of the unary expression op y.
;; The operation must be defined for the operand.
;; If prec > 0 it specifies the ^ (xor) result size in bits.
;; If y is Unknown, the result is Unknown."
;;   {:added "1.0"
;;    :go "unaryOp(op, y, prec)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Token}) op, y, ^Int prec])
;; 
JOKER FUNC context.Background has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{387315 0xc0003acba0 false}) Background
;;   "Background returns a non-nil, empty Context. It is never canceled, has no
;; values, and has no deadline. It is typically used by the main function,
;; initialization, and tests, and as the top-level Context for incoming
;; requests."
;;   {:added "1.0"
;;    :go "background()"}
;;   [])
;; 
JOKER FUNC context.TODO has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{387315 0xc0003acba0 false}) TODO
;;   "TODO returns a non-nil, empty Context. Code should use context.TODO when
;; it's unclear which Context to use or it is not yet available (because the
;; surrounding function has not yet been extended to accept a Context
;; parameter). TODO is recognized by static analysis tools that determine
;; whether Contexts are propagated correctly in a program."
;;   {:added "1.0"
;;    :go "tODO()"}
;;   [])
;; 
JOKER FUNC context.WithCancel has: 
(defn ^[ctx cancel] WithCancel
  "WithCancel returns a copy of parent with a new Done channel. The returned
context's Done channel is closed when the returned cancel function is called
or when the parent context's Done channel is closed, whichever happens first.

Canceling this context releases resources associated with it, so code should
call cancel as soon as the operations running in this Context complete."
  {:added "1.0"
   :go "withCancel(parent)"}
  [parent])

JOKER FUNC context.WithDeadline has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{387315 0xc0003acba0 false}) ABEND883(unrecognized Expr type *ast.FuncType at: &{392805 0xc0003adb30 <nil>})] WithDeadline
;;   "WithDeadline returns a copy of the parent context with the deadline adjusted
;; to be no later than d. If the parent's deadline is already earlier than d,
;; WithDeadline(parent, d) is semantically equivalent to parent. The returned
;; context's Done channel is closed when the deadline expires, when the returned
;; cancel function is called, or when the parent context's Done channel is
;; closed, whichever happens first.
;; 
;; Canceling this context releases resources associated with it, so code should
;; call cancel as soon as the operations running in this Context complete."
;;   {:added "1.0"
;;    :go "withDeadline(parent, d)"}
;;   [parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) d])
;; 
JOKER FUNC context.WithTimeout has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{387315 0xc0003acba0 false}) ABEND883(unrecognized Expr type *ast.FuncType at: &{392805 0xc0003adb30 <nil>})] WithTimeout
;;   "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
;; 
;; Canceling this context releases resources associated with it, so code should
;; call cancel as soon as the operations running in this Context complete:
;; 
;; 	func slowOperationWithTimeout(ctx context.Context) (Result, error) {
;; 		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
;; 		defer cancel()  // releases resources if slowOperation completes before timeout elapses
;; 		return slowOperation(ctx)
;; 	}"
;;   {:added "1.0"
;;    :go "withTimeout(parent, timeout)"}
;;   [parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}) timeout])
;; 
JOKER FUNC context.WithValue has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{387315 0xc0003acba0 false}) WithValue
;;   "WithValue returns a copy of parent in which the value associated with key is
;; val.
;; 
;; Use context Values only for request-scoped data that transits processes and
;; APIs, not for passing optional parameters to functions.
;; 
;; The provided key must be comparable and should not be of type
;; string or any other built-in type to avoid collisions between
;; packages using context. Users of WithValue should define their own
;; types for keys. To avoid allocating when assigning to an
;; interface{}, context keys often have concrete type
;; struct{}. Alternatively, exported context key variables' static
;; type should be a pointer or interface."
;;   {:added "1.0"
;;    :go "withValue(parent, key, val)"}
;;   [parent, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{399976 0xc00030e5d0 false}) key, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{399976 0xc00030e5d0 false}) val])
;; 
JOKER FUNC cookiejar.New has: 
;; (defn ^[{:pslist psList, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :entries ^ABEND881(unrecognized Expr type *ast.MapType at: &{5042261 string 0xc000ef7aa0}) entries, :nextseqnum nextSeqNum} Error] New
;;   "New returns a new cookie jar. A nil *Options is equivalent to a zero
;; Options."
;;   {:added "1.0"
;;    :go "new(o)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5042499 Options}) o])
;; 
JOKER FUNC crc32.Checksum has: 
;; (defn ^ABEND042(cannot find typename crc32.uint32) Checksum
;;   "Checksum returns the CRC-32 checksum of data
;; using the polynomial represented by the Table."
;;   {:added "1.0"
;;    :go "checksum(data, tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2954227 <nil> byte}) data, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2954239 Table}) tab])
;; 
JOKER FUNC crc32.ChecksumIEEE has: 
;; (defn ^ABEND042(cannot find typename crc32.uint32) ChecksumIEEE
;;   "ChecksumIEEE returns the CRC-32 checksum of data
;; using the IEEE polynomial."
;;   {:added "1.0"
;;    :go "checksumIEEE(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2954392 <nil> byte}) data])
;; 
JOKER FUNC crc32.MakeTable has: 
;; (defn ^[ABEND042(cannot find typename crc32.uint32)] MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.
;; The contents of this Table must not be modified."
;;   {:added "1.0"
;;    :go "makeTable(poly)"}
;;   [poly])
;; 
JOKER FUNC crc32.New has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash32}) New
;;   "New creates a new hash.Hash32 computing the CRC-32 checksum using the
;; polynomial represented by the Table. Its Sum method will lay the
;; value out in big-endian byte order. The returned Hash32 also
;; implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to
;; marshal and unmarshal the internal state of the hash."
;;   {:added "1.0"
;;    :go "new(tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2951537 Table}) tab])
;; 
JOKER FUNC crc32.NewIEEE has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash32}) NewIEEE
;;   "NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using
;; the IEEE polynomial. Its Sum method will lay the value out in
;; big-endian byte order. The returned Hash32 also implements
;; encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal
;; and unmarshal the internal state of the hash."
;;   {:added "1.0"
;;    :go "newIEEE()"}
;;   [])
;; 
JOKER FUNC crc32.Update has: 
;; (defn ^ABEND042(cannot find typename crc32.uint32) Update
;;   "Update returns the result of adding the bytes in p to the crc."
;;   {:added "1.0"
;;    :go "update(crc, tab, p)"}
;;   [crc, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2953202 Table}) tab, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2953212 <nil> byte}) p])
;; 
JOKER FUNC crc64.Checksum has: 
;; (defn ^ABEND042(cannot find typename crc64.uint64) Checksum
;;   "Checksum returns the CRC-64 checksum of data
;; using the polynomial represented by the Table."
;;   {:added "1.0"
;;    :go "checksum(data, tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2959811 <nil> byte}) data, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2959823 Table}) tab])
;; 
JOKER FUNC crc64.MakeTable has: 
;; (defn ^[ABEND042(cannot find typename crc64.uint64)] MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.
;; The contents of this Table must not be modified."
;;   {:added "1.0"
;;    :go "makeTable(poly)"}
;;   [poly])
;; 
JOKER FUNC crc64.New has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash64}) New
;;   "New creates a new hash.Hash64 computing the CRC-64 checksum using the
;; polynomial represented by the Table. Its Sum method will lay the
;; value out in big-endian byte order. The returned Hash64 also
;; implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to
;; marshal and unmarshal the internal state of the hash."
;;   {:added "1.0"
;;    :go "new(tab)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2956786 Table}) tab])
;; 
JOKER FUNC crc64.Update has: 
;; (defn ^ABEND042(cannot find typename crc64.uint64) Update
;;   "Update returns the result of adding the bytes in p to the crc."
;;   {:added "1.0"
;;    :go "update(crc, tab, p)"}
;;   [crc, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2959298 Table}) tab, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2959308 <nil> byte}) p])
;; 
JOKER FUNC crypto.RegisterHash has: 
;; (defn RegisterHash
;;   "RegisterHash registers a function that returns a new instance of the given
;; hash function. This is intended to be called from the init function in
;; packages that implement hash functions."
;;   {:added "1.0"
;;    :go "registerHash(h, f)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{403703 0xc00030fe60 0xc00030fe90}) f])
;; 
JOKER FUNC cryptobyte.NewBuilder has: 
;; (defn ^{:err err, :result ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8198254 <nil> byte}) result, :fixedsize fixedSize, :child ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8198298 Builder}) child, :offset ^Int offset, :pendinglenlen ^Int pendingLenLen, :pendingisasn1 pendingIsASN1, :incontinuation ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8198384 bool}) inContinuation} NewBuilder
;;   "NewBuilder creates a Builder that appends its output to the given buffer.
;; Like append(), the slice will be reallocated if its capacity is exceeded.
;; Use Bytes to get the final buffer."
;;   {:added "1.0"
;;    :go "newBuilder(buffer)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8198608 <nil> byte}) buffer])
;; 
JOKER FUNC cryptobyte.NewFixedBuilder has: 
;; (defn ^{:err err, :result ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8198254 <nil> byte}) result, :fixedsize fixedSize, :child ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8198298 Builder}) child, :offset ^Int offset, :pendinglenlen ^Int pendingLenLen, :pendingisasn1 pendingIsASN1, :incontinuation ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8198384 bool}) inContinuation} NewFixedBuilder
;;   "NewFixedBuilder creates a Builder that appends its output into the given
;; buffer. This builder does not reallocate the output buffer. Writes that
;; would exceed the buffer's capacity are treated as an error."
;;   {:added "1.0"
;;    :go "newFixedBuilder(buffer)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8198911 <nil> byte}) buffer])
;; 
JOKER FUNC csv.NewReader has: 
;; (defn ^{:comma Comma, :comment Comment, :fieldsperrecord ^Int FieldsPerRecord, :lazyquotes LazyQuotes, :trimleadingspace TrimLeadingSpace, :reuserecord ReuseRecord, :trailingcomma TrailingComma, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1600219 0xc00031fce0}) r, :numline ^Int numLine, :rawbuffer ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1600384 <nil> byte}) rawBuffer, :recordbuffer ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1600674 <nil> byte}) recordBuffer, :fieldindexes ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1600823 <nil> int}) fieldIndexes, :lastrecord ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1600915 <nil> string}) lastRecord} NewReader
;;   "NewReader returns a new Reader that reads from r."
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC csv.NewWriter has: 
;; (defn ^{:comma Comma, :usecrlf UseCRLF, :w ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1608536 0xc0004f0ce0}) w} NewWriter
;;   "NewWriter returns a new Writer that writes to w."
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC curve25519.ScalarBaseMult has: 
;; (defn ScalarBaseMult
;;   "ScalarBaseMult sets dst to the product in*base where dst and base are the x
;; coordinates of group points, base is the standard generator and all values
;; are in little-endian form."
;;   {:added "1.0"
;;    :go "scalarBaseMult(dst, in)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8208733 0xc00141e8a0}) dst, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8208733 0xc00141e8a0}) in])
;; 
JOKER FUNC curve25519.ScalarMult has: 
;; (defn ScalarMult
;;   "ScalarMult sets dst to the product in*base where dst and base are the x
;; coordinates of group points and all values are in little-endian form."
;;   {:added "1.0"
;;    :go "scalarMult(dst, in, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8208475 0xc00141e780}) dst, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8208475 0xc00141e780}) in, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8208475 0xc00141e780}) base])
;; 
JOKER FUNC debug.FreeOSMemory has: 
;; (defn FreeOSMemory
;;   "FreeOSMemory forces a garbage collection followed by an
;; attempt to return as much memory to the operating system
;; as possible. (Even if this is not called, the runtime gradually
;; returns memory to the operating system in a background task.)"
;;   {:added "1.0"
;;    :go "freeOSMemory()"}
;;   [])
;; 
JOKER FUNC debug.PrintStack has: 
;; (defn PrintStack
;;   "PrintStack prints to standard error the stack trace returned by runtime.Stack."
;;   {:added "1.0"
;;    :go "printStack()"}
;;   [])
;; 
JOKER FUNC debug.ReadGCStats has: 
;; (defn ReadGCStats
;;   "ReadGCStats reads statistics about garbage collection into stats.
;; The number of entries in the pause history is system-dependent;
;; stats.Pause slice will be reused if large enough, reallocated otherwise.
;; ReadGCStats may use the full capacity of the stats.Pause slice.
;; If stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles
;; summarizing the distribution of pause time. For example, if
;; len(stats.PauseQuantiles) is 5, it will be filled with the minimum,
;; 25%, 50%, 75%, and maximum pause times."
;;   {:added "1.0"
;;    :go "readGCStats(stats)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7046128 GCStats}) stats])
;; 
JOKER FUNC debug.SetGCPercent has: 
(defn ^Int SetGCPercent
  "SetGCPercent sets the garbage collection target percentage:
a collection is triggered when the ratio of freshly allocated data
to live data remaining after the previous collection reaches this percentage.
SetGCPercent returns the previous setting.
The initial setting is the value of the GOGC environment variable
at startup, or 100 if the variable is not set.
A negative percentage disables garbage collection."
  {:added "1.0"
   :go "setGCPercent(percent)"}
  [^Int percent])

JOKER FUNC debug.SetMaxStack has: 
(defn ^Int SetMaxStack
  "SetMaxStack sets the maximum amount of memory that
can be used by a single goroutine stack.
If any goroutine exceeds this limit while growing its stack,
the program crashes.
SetMaxStack returns the previous setting.
The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.

SetMaxStack is useful mainly for limiting the damage done by
goroutines that enter an infinite recursion. It only limits future
stack growth."
  {:added "1.0"
   :go "setMaxStack(bytes)"}
  [^Int bytes])

JOKER FUNC debug.SetMaxThreads has: 
(defn ^Int SetMaxThreads
  "SetMaxThreads sets the maximum number of operating system
threads that the Go program can use. If it attempts to use more than
this many, the program crashes.
SetMaxThreads returns the previous setting.
The initial setting is 10,000 threads.

The limit controls the number of operating system threads, not the number
of goroutines. A Go program creates a new thread only when a goroutine
is ready to run but all the existing threads are blocked in system calls, cgo calls,
or are locked to other goroutines due to use of runtime.LockOSThread.

SetMaxThreads is useful mainly for limiting the damage done by
programs that create an unbounded number of threads. The idea is
to take down the program before it takes down the operating system."
  {:added "1.0"
   :go "setMaxThreads(threads)"}
  [^Int threads])

JOKER FUNC debug.SetPanicOnFault has: 
;; (defn ^ABEND042(cannot find typename debug.bool) SetPanicOnFault
;;   "SetPanicOnFault controls the runtime's behavior when a program faults
;; at an unexpected (non-nil) address. Such faults are typically caused by
;; bugs such as runtime memory corruption, so the default response is to crash
;; the program. Programs working with memory-mapped files or unsafe
;; manipulation of memory may cause faults at non-nil addresses in less
;; dramatic situations; SetPanicOnFault allows such programs to request
;; that the runtime trigger only a panic, not a crash.
;; SetPanicOnFault applies only to the current goroutine.
;; It returns the previous setting."
;;   {:added "1.0"
;;    :go "setPanicOnFault(enabled)"}
;;   [enabled])
;; 
JOKER FUNC debug.SetTraceback has: 
;; (defn SetTraceback
;;   "SetTraceback sets the amount of detail printed by the runtime in
;; the traceback it prints before exiting due to an unrecovered panic
;; or an internal runtime error.
;; The level argument takes the same values as the GOTRACEBACK
;; environment variable. For example, SetTraceback("all") ensure
;; that the program prints all goroutines when it crashes.
;; See the package runtime documentation for details.
;; If SetTraceback is called with a level lower than that of the
;; environment variable, the call is ignored."
;;   {:added "1.0"
;;    :go "setTraceback(level)"}
;;   [^String level])
;; 
JOKER FUNC debug.Stack has: 
;; (defn ^[ABEND042(cannot find typename debug.byte)] Stack
;;   "Stack returns a formatted stack trace of the goroutine that calls it.
;; It calls runtime.Stack with a large enough buffer to capture the entire trace."
;;   {:added "1.0"
;;    :go "stack()"}
;;   [])
;; 
JOKER FUNC debug.WriteHeapDump has: 
;; (defn WriteHeapDump
;;   "WriteHeapDump writes a description of the heap and the objects in
;; it to the given file descriptor.
;; 
;; WriteHeapDump suspends the execution of all goroutines until the heap
;; dump is completely written.  Thus, the file descriptor must not be
;; connected to a pipe or socket whose other end is in the same Go
;; process; instead, use a temporary file or network socket.
;; 
;; The heap dump format is defined at https://golang.org/s/go15heapdump."
;;   {:added "1.0"
;;    :go "writeHeapDump(fd)"}
;;   [fd])
;; 
JOKER FUNC des.NewCipher has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{cipher Block}) Error] NewCipher
;;   "NewCipher creates and returns a new cipher.Block."
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{486167 <nil> byte}) key])
;; 
JOKER FUNC des.NewTripleDESCipher has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{cipher Block}) Error] NewTripleDESCipher
;;   "NewTripleDESCipher creates and returns a new cipher.Block."
;;   {:added "1.0"
;;    :go "newTripleDESCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{487298 <nil> byte}) key])
;; 
JOKER FUNC dnsmessage.NewBuilder has: 
;; (defn ^{:msg ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8244805 <nil> byte}) msg, :section section, :header header, :start ^Int start, :compression ^ABEND881(unrecognized Expr type *ast.MapType at: &{8245172 string int}) compression} NewBuilder
;;   "NewBuilder creates a new builder with compression disabled.
;; 
;; Note: Most users will want to immediately enable compression with the
;; EnableCompression method. See that method's comment for why you may or may
;; not want to enable compression.
;; 
;; The DNS message is appended to the provided initial buffer buf (which may be
;; nil) as it is built. The final message is returned by the (*Builder).Finish
;; method, which may return the same underlying array if there was sufficient
;; capacity in the slice."
;;   {:added "1.0"
;;    :go "newBuilder(buf, h)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8245728 <nil> byte}) buf, h])
;; 
JOKER FUNC dnsmessage.NewName has: 
;; (defn ^[{:data ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8261012 nameLen byte}) Data, :length Length} Error] NewName
;;   "NewName creates a new Name from a string."
;;   {:added "1.0"
;;    :go "newName(name)"}
;;   [^String name])
;; 
JOKER FUNC doc.Examples has: 
;; (defn ^[{:name ^String Name, :doc ^String Doc, :code ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{ast Node}) Code, :play ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2329751 0xc0001e09a0}) Play, :comments ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2329816 <nil> 0xc0001e0dc0}) Comments, :output ^String Output, :unordered Unordered, :emptyoutput EmptyOutput, :order ^Int Order}] Examples
;;   "Examples returns the examples found in the files, sorted by Name field.
;; The Order fields record the order in which the examples were encountered.
;; 
;; Playable Examples must be in a package whose name ends in "_test".
;; An Example is "playable" (the Play field is non-nil) in either of these
;; circumstances:
;;   - The example function is self-contained: the function references only
;;     identifiers from other packages (or predeclared identifiers, such as
;;     "int") and the test file does not include a dot import.
;;   - The entire test file is the example: the file contains exactly one
;;     example function, zero test or benchmark functions, and at least one
;;     top-level function, type, variable, or constant declaration other
;;     than the example function."
;;   {:added "1.0"
;;    :go "examples(files)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2330795 0xc000304e60}) files])
;; 
JOKER FUNC doc.IsPredeclared has: 
;; (defn ^ABEND042(cannot find typename doc.bool) IsPredeclared
;;   "IsPredeclared reports whether s is a predeclared identifier."
;;   {:added "1.0"
;;    :go "isPredeclared(s)"}
;;   [^String s])
;; 
JOKER FUNC doc.New has: 
;; (defn ^{:doc ^String Doc, :name ^String Name, :importpath ^String ImportPath, :imports ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2363232 <nil> string}) Imports, :filenames ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2363253 <nil> string}) Filenames, :notes ^ABEND881(unrecognized Expr type *ast.MapType at: &{2363274 string 0xc00046a0f0}) Notes, :bugs ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2363415 <nil> string}) Bugs, :consts ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2363450 <nil> 0xc000257240}) Consts, :types ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2363467 <nil> 0xc000257620}) Types, :vars ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2363483 <nil> 0xc000257aa0}) Vars, :funcs ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2363500 <nil> 0xc000257f20}) Funcs} New
;;   "New computes the package documentation for the given package AST.
;; New takes ownership of the AST pkg and may edit or overwrite it."
;;   {:added "1.0"
;;    :go "new(pkg, importPath, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2365447 0xc000424d40}) pkg, ^String importPath, mode])
;; 
JOKER FUNC doc.Synopsis has: 
(defn ^String Synopsis
  "Synopsis returns a cleaned version of the first sentence in s.
That sentence ends after the first period followed by space and
not preceded by exactly one uppercase letter. The result string
has no \n, \r, or \t characters and uses only single spaces between
words. If s starts with any of the IllegalPrefixes, the result
is the empty string."
  {:added "1.0"
   :go "synopsis(s)"}
  [^String s])

JOKER FUNC doc.ToHTML has: 
;; (defn ToHTML
;;   "ToHTML converts comment text to formatted HTML.
;; The comment was prepared by DocReader,
;; so it is known not to have leading, trailing blank lines
;; nor to have trailing spaces at the end of lines.
;; The comment markers have already been removed.
;; 
;; Each span of unindented non-blank lines is converted into
;; a single paragraph. There is one exception to the rule: a span that
;; consists of a single line, is followed by another paragraph span,
;; begins with a capital letter, and contains no punctuation
;; other than parentheses and commas is formatted as a heading.
;; 
;; A span of indented lines is converted into a <pre> block,
;; with the common indent prefix removed.
;; 
;; URLs in the comment text are converted into links; if the URL also appears
;; in the words map, the link is taken from the map (if the corresponding map
;; value is the empty string, the URL is not converted into a link).
;; 
;; Go identifiers that appear in the words map are italicized; if the corresponding
;; map value is not the empty string, it is considered a URL and the word is converted
;; into a link."
;;   {:added "1.0"
;;    :go "toHTML(w, text, words)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^String text, ^ABEND881(unrecognized Expr type *ast.MapType at: &{2351060 string string}) words])
;; 
JOKER FUNC doc.ToText has: 
;; (defn ToText
;;   "ToText prepares comment text for presentation in textual output.
;; It wraps paragraphs of text to width or fewer Unicode code points
;; and then prefixes each line with the indent. In preformatted sections
;; (such as program text), it prefixes each non-blank line with preIndent."
;;   {:added "1.0"
;;    :go "toText(w, text, indent, preIndent, width)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^String text, ^String indent, ^String preIndent, ^Int width])
;; 
JOKER FUNC draw.Draw has: 
;; (defn Draw
;;   "Draw calls DrawMask with a nil mask."
;;   {:added "1.0"
;;    :go "draw(dst, r, src, sp, op)"}
;;   [dst, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Rectangle}) r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Image}) src, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Point}) sp, op])
;; 
JOKER FUNC draw.DrawMask has: 
;; (defn DrawMask
;;   "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r
;; in dst with the result of a Porter-Duff composition. A nil mask is treated as opaque."
;;   {:added "1.0"
;;    :go "drawMask(dst, r, src, sp, mask, mp, op)"}
;;   [dst, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Rectangle}) r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Image}) src, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Point}) sp, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Image}) mask, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Point}) mp, op])
;; 
JOKER FUNC driver.IsScanValue has: 
;; (defn ^ABEND042(cannot find typename driver.bool) IsScanValue
;;   "IsScanValue is equivalent to IsValue.
;; It exists for compatibility."
;;   {:added "1.0"
;;    :go "isScanValue(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1138067 0xc0005781e0 false}) v])
;; 
JOKER FUNC driver.IsValue has: 
;; (defn ^ABEND042(cannot find typename driver.bool) IsValue
;;   "IsValue reports whether v is a valid Value parameter type."
;;   {:added "1.0"
;;    :go "isValue(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1137815 0xc000593c50 false}) v])
;; 
JOKER FUNC dsa.GenerateKey has: 
;; (defn ^Error GenerateKey
;;   "GenerateKey generates a public&private key pair. The Parameters of the
;; PrivateKey must already be valid (see GenerateParameters)."
;;   {:added "1.0"
;;    :go "generateKey(priv, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{504659 PrivateKey}) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand])
;; 
JOKER FUNC dsa.GenerateParameters has: 
;; (defn ^Error GenerateParameters
;;   "GenerateParameters puts a random, valid set of DSA parameters into params.
;; This function can take many seconds, even on fast machines."
;;   {:added "1.0"
;;    :go "generateParameters(params, rand, sizes)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{502933 Parameters}) params, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, sizes])
;; 
JOKER FUNC dsa.Sign has: 
;; (defn ^[r s err] Sign
;;   "Sign signs an arbitrary length hash (which should be the result of hashing a
;; larger message) using the private key, priv. It returns the signature as a
;; pair of integers. The security of the private key depends on the entropy of
;; rand.
;; 
;; Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated
;; to the byte-length of the subgroup. This function does not perform that
;; truncation itself.
;; 
;; Be aware that calling Sign with an attacker-controlled PrivateKey may
;; require an arbitrary amount of CPU."
;;   {:added "1.0"
;;    :go "sign(rand, priv, hash)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{506121 PrivateKey}) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{506139 <nil> byte}) hash])
;; 
JOKER FUNC dsa.Verify has: 
;; (defn ^ABEND042(cannot find typename dsa.bool) Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. It
;; reports whether the signature is valid.
;; 
;; Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated
;; to the byte-length of the subgroup. This function does not perform that
;; truncation itself."
;;   {:added "1.0"
;;    :go "verify(pub, hash, r, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{507625 PublicKey}) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{507642 <nil> byte}) hash, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{507655 0xc000233aa0}) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{507655 0xc000233aa0}) s])
;; 
JOKER FUNC dwarf.New has: 
;; (defn ^[{:abbrev ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1231698 <nil> byte}) abbrev, :aranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1231715 <nil> byte}) aranges, :frame ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1231732 <nil> byte}) frame, :info ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1231749 <nil> byte}) info, :line ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1231766 <nil> byte}) line, :pubnames ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1231783 <nil> byte}) pubnames, :ranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1231800 <nil> byte}) ranges, :str ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1231817 <nil> byte}) str, :abbrevcache ^ABEND881(unrecognized Expr type *ast.MapType at: &{1231854 uint64 abbrevTable}) abbrevCache, :order ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{binary ByteOrder}) order, :typecache ^ABEND881(unrecognized Expr type *ast.MapType at: &{1231920 Offset Type}) typeCache, :typesigs ^ABEND881(unrecognized Expr type *ast.MapType at: &{1231949 uint64 0xc0001fd7a0}) typeSigs, :unit ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1231983 <nil> unit}) unit} Error] New
;;   "New returns a new Data object initialized from the given parameters.
;; Rather than calling this function directly, clients should typically use
;; the DWARF method of the File type of the appropriate package debug/elf,
;; debug/macho, or debug/pe.
;; 
;; The []byte arguments are the data from the corresponding debug section
;; in the object file; for example, for an ELF object, abbrev is the contents of
;; the ".debug_abbrev" section."
;;   {:added "1.0"
;;    :go "new(abbrev, aranges, frame, info, line, pubnames, ranges, str)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1232502 <nil> byte}) abbrev, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1232502 <nil> byte}) aranges, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1232502 <nil> byte}) frame, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1232502 <nil> byte}) info, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1232502 <nil> byte}) line, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1232502 <nil> byte}) pubnames, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1232502 <nil> byte}) ranges, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1232502 <nil> byte}) str])
;; 
JOKER FUNC ecdsa.GenerateKey has: 
;; (defn ^[{:d ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{509666 0xc0000ad580}) D} Error] GenerateKey
;;   "GenerateKey generates a public and private key pair."
;;   {:added "1.0"
;;    :go "generateKey(c, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{elliptic Curve}) c, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand])
;; 
JOKER FUNC ecdsa.Sign has: 
;; (defn ^[r s err] Sign
;;   "Sign signs a hash (which should be the result of hashing a larger message)
;; using the private key, priv. If the hash is longer than the bit-length of the
;; private key's curve order, the hash will be truncated to that length.  It
;; returns the signature as a pair of integers. The security of the private key
;; depends on the entropy of rand."
;;   {:added "1.0"
;;    :go "sign(rand, priv, hash)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{512929 PrivateKey}) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{512947 <nil> byte}) hash])
;; 
JOKER FUNC ecdsa.Verify has: 
;; (defn ^ABEND042(cannot find typename ecdsa.bool) Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. Its
;; return value records whether the signature is valid."
;;   {:added "1.0"
;;    :go "verify(pub, hash, r, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{514695 PublicKey}) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{514712 <nil> byte}) hash, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{514725 0xc000327d80}) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{514725 0xc000327d80}) s])
;; 
JOKER FUNC elf.NewFile has: 
;; (defn ^[{:sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1360173 <nil> 0xc000521f40}) Sections, :progs ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1360195 <nil> 0xc000521fa0}) Progs, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Closer}) closer, :gnuneed ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1360235 <nil> verneed}) gnuNeed, :gnuversym ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1360256 <nil> byte}) gnuVersym} Error] NewFile
;;   "NewFile creates a new File for accessing an ELF binary in an underlying reader.
;; The ELF binary is expected to start at position 0 in the ReaderAt."
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReaderAt}) r])
;; 
JOKER FUNC elf.Open has: 
;; (defn ^[{:sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1360173 <nil> 0xc000521f40}) Sections, :progs ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1360195 <nil> 0xc000521fa0}) Progs, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Closer}) closer, :gnuneed ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1360235 <nil> verneed}) gnuNeed, :gnuversym ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1360256 <nil> byte}) gnuVersym} Error] Open
;;   "Open opens the named file using os.Open and prepares it for use as an ELF binary."
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])
;; 
JOKER FUNC elf.R_INFO has: 
;; (defn ^ABEND042(cannot find typename elf.uint64) R_INFO
;;   {:added "1.0"
;;    :go "r_INFO(sym, typ)"}
;;   [sym, typ])
;; 
JOKER FUNC elf.R_INFO32 has: 
;; (defn ^ABEND042(cannot find typename elf.uint32) R_INFO32
;;   {:added "1.0"
;;    :go "r_INFO32(sym, typ)"}
;;   [sym, typ])
;; 
JOKER FUNC elf.R_SYM32 has: 
;; (defn ^ABEND042(cannot find typename elf.uint32) R_SYM32
;;   {:added "1.0"
;;    :go "r_SYM32(info)"}
;;   [info])
;; 
JOKER FUNC elf.R_SYM64 has: 
;; (defn ^ABEND042(cannot find typename elf.uint32) R_SYM64
;;   {:added "1.0"
;;    :go "r_SYM64(info)"}
;;   [info])
;; 
JOKER FUNC elf.R_TYPE32 has: 
;; (defn ^ABEND042(cannot find typename elf.uint32) R_TYPE32
;;   {:added "1.0"
;;    :go "r_TYPE32(info)"}
;;   [info])
;; 
JOKER FUNC elf.R_TYPE64 has: 
;; (defn ^ABEND042(cannot find typename elf.uint32) R_TYPE64
;;   {:added "1.0"
;;    :go "r_TYPE64(info)"}
;;   [info])
;; 
JOKER FUNC elf.ST_BIND has: 
(defn ^Int ST_BIND
  {:added "1.0"
   :go "sT_BIND(info)"}
  [info])

JOKER FUNC elf.ST_INFO has: 
;; (defn ^ABEND042(cannot find typename elf.uint8) ST_INFO
;;   {:added "1.0"
;;    :go "sT_INFO(bind, typ)"}
;;   [bind, typ])
;; 
JOKER FUNC elf.ST_TYPE has: 
(defn ^Int ST_TYPE
  {:added "1.0"
   :go "sT_TYPE(info)"}
  [info])

JOKER FUNC elf.ST_VISIBILITY has: 
(defn ^Int ST_VISIBILITY
  {:added "1.0"
   :go "sT_VISIBILITY(other)"}
  [other])

JOKER FUNC elliptic.GenerateKey has: 
;; (defn ^[priv x y err] GenerateKey
;;   "GenerateKey returns a public/private key pair. The private key is
;; generated using the given reader, which must return random data."
;;   {:added "1.0"
;;    :go "generateKey(curve, rand)"}
;;   [curve, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand])
;; 
JOKER FUNC elliptic.Marshal has: 
;; (defn ^[ABEND042(cannot find typename elliptic.byte)] Marshal
;;   "Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62."
;;   {:added "1.0"
;;    :go "marshal(curve, x, y)"}
;;   [curve, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{523992 0xc0000c3360}) x, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{523992 0xc0000c3360}) y])
;; 
JOKER FUNC elliptic.P224 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{516612 0xc0001f7ef0 false}) P224
;;   "P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).
;; 
;; The cryptographic operations are implemented using constant-time algorithms."
;;   {:added "1.0"
;;    :go "p224()"}
;;   [])
;; 
JOKER FUNC elliptic.P256 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{516612 0xc0001f7ef0 false}) P256
;;   "P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)
;; 
;; The cryptographic operations are implemented using constant-time algorithms."
;;   {:added "1.0"
;;    :go "p256()"}
;;   [])
;; 
JOKER FUNC elliptic.P384 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{516612 0xc0001f7ef0 false}) P384
;;   "P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)
;; 
;; The cryptographic operations do not use constant-time algorithms."
;;   {:added "1.0"
;;    :go "p384()"}
;;   [])
;; 
JOKER FUNC elliptic.P521 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{516612 0xc0001f7ef0 false}) P521
;;   "P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)
;; 
;; The cryptographic operations do not use constant-time algorithms."
;;   {:added "1.0"
;;    :go "p521()"}
;;   [])
;; 
JOKER FUNC elliptic.Unmarshal has: 
;; (defn ^[x y] Unmarshal
;;   "Unmarshal converts a point, serialized by Marshal, into an x, y pair.
;; It is an error if the point is not in uncompressed form or is not on the curve.
;; On error, x = nil."
;;   {:added "1.0"
;;    :go "unmarshal(curve, data)"}
;;   [curve, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{524483 <nil> byte}) data])
;; 
JOKER FUNC errors.New has: 
(defn ^Error New
  "New returns an error that formats as the given text."
  {:added "1.0"
   :go "new(text)"}
  [^String text])

JOKER FUNC exec.Command has: 
;; (defn ^{:path ^String Path, :args ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5354324 <nil> string}) Args, :env ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5354628 <nil> string}) Env, :dir ^String Dir, :stdin ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) Stdin, :stdout ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) Stdout, :stderr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) Stderr, :extrafiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5356430 <nil> 0xc001631320}) ExtraFiles, :sysprocattr ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5356594 0xc001631400}) SysProcAttr, :process ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5356678 0xc0016314e0}) Process, :processstate ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5356811 0xc0016315e0}) ProcessState, :ctx ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, :lookpatherr lookPathErr, :finished finished, :childfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5357014 <nil> 0xc001631860}) childFiles, :closeafterstart ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5357042 <nil> 0xc0016318e0}) closeAfterStart, :closeafterwait ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5357071 <nil> 0xc001631960}) closeAfterWait, :goroutine ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5357100 <nil> 0xc0016319c0}) goroutine, :errch ^ABEND881(unrecognized Expr type *ast.ChanType at: &{5357132 0 3 error}) errch, :waitdone ^ABEND881(unrecognized Expr type *ast.ChanType at: &{5357186 0 3 0xc001631a80}) waitDone} Command
;;   "Command returns the Cmd struct to execute the named program with
;; the given arguments.
;; 
;; It sets only the Path and Args in the returned structure.
;; 
;; If name contains no path separators, Command uses LookPath to
;; resolve name to a complete path if possible. Otherwise it uses name
;; directly as Path.
;; 
;; The returned Cmd's Args field is constructed from the command name
;; followed by the elements of arg, so arg should not include the
;; command name itself. For example, Command("echo", "hello").
;; Args[0] is always name, not the possibly resolved Path."
;;   {:added "1.0"
;;    :go "command(name, arg)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{5357810 string}) arg])
;; 
JOKER FUNC exec.CommandContext has: 
;; (defn ^{:path ^String Path, :args ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5354324 <nil> string}) Args, :env ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5354628 <nil> string}) Env, :dir ^String Dir, :stdin ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) Stdin, :stdout ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) Stdout, :stderr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) Stderr, :extrafiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5356430 <nil> 0xc001631320}) ExtraFiles, :sysprocattr ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5356594 0xc001631400}) SysProcAttr, :process ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5356678 0xc0016314e0}) Process, :processstate ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5356811 0xc0016315e0}) ProcessState, :ctx ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, :lookpatherr lookPathErr, :finished finished, :childfiles ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5357014 <nil> 0xc001631860}) childFiles, :closeafterstart ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5357042 <nil> 0xc0016318e0}) closeAfterStart, :closeafterwait ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5357071 <nil> 0xc001631960}) closeAfterWait, :goroutine ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5357100 <nil> 0xc0016319c0}) goroutine, :errch ^ABEND881(unrecognized Expr type *ast.ChanType at: &{5357132 0 3 error}) errch, :waitdone ^ABEND881(unrecognized Expr type *ast.ChanType at: &{5357186 0 3 0xc001631a80}) waitDone} CommandContext
;;   "CommandContext is like Command but includes a context.
;; 
;; The provided context is used to kill the process (by calling
;; os.Process.Kill) if the context becomes done before the command
;; completes on its own."
;;   {:added "1.0"
;;    :go "commandContext(ctx, name, arg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, ^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{5358328 string}) arg])
;; 
JOKER FUNC exec.LookPath has: 
(defn ^[String Error] LookPath
  "LookPath searches for an executable named file in the
directories named by the PATH environment variable.
If file contains a slash, it is tried directly and the PATH is not consulted.
The result may be an absolute path or a path relative to the current directory."
  {:added "1.0"
   :go "lookPath(file)"}
  [^String file])

JOKER FUNC expvar.Do has: 
;; (defn Do
;;   "Do calls f for each exported variable.
;; The global variable map is locked during the iteration,
;; but existing entries may be concurrently updated."
;;   {:added "1.0"
;;    :go "do(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{1998670 0xc00038cc90 <nil>}) f])
;; 
JOKER FUNC expvar.Get has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{1993015 0xc0002f7aa0 false}) Get
;;   "Get retrieves a named exported variable. It returns nil if the name has
;; not been registered."
;;   {:added "1.0"
;;    :go "get(name)"}
;;   [^String name])
;; 
JOKER FUNC expvar.Handler has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{http Handler}) Handler
;;   "Handler returns the expvar HTTP Handler.
;; 
;; This is only needed to install the handler in a non-standard location."
;;   {:added "1.0"
;;    :go "handler()"}
;;   [])
;; 
JOKER FUNC expvar.NewFloat has: 
(defn ^{:f f} NewFloat
  {:added "1.0"
   :go "newFloat(name)"}
  [^String name])

JOKER FUNC expvar.NewInt has: 
(defn ^{:i i} NewInt
  {:added "1.0"
   :go "newInt(name)"}
  [^String name])

JOKER FUNC expvar.NewMap has: 
;; (defn ^{:m ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Map}) m, :keysmu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync RWMutex}) keysMu, :keys ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1994464 <nil> string}) keys} NewMap
;;   {:added "1.0"
;;    :go "newMap(name)"}
;;   [^String name])
;; 
JOKER FUNC expvar.NewString has: 
;; (defn ^{:s ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{atomic Value}) s} NewString
;;   {:added "1.0"
;;    :go "newString(name)"}
;;   [^String name])
;; 
JOKER FUNC expvar.Publish has: 
;; (defn Publish
;;   "Publish declares a named exported variable. This should be called from a
;; package's init function when it creates its Vars. If the name is already
;; registered then this will log.Panic."
;;   {:added "1.0"
;;    :go "publish(name, v)"}
;;   [^String name, v])
;; 
JOKER FUNC fcgi.ProcessEnv has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.MapType at: &{5068684 string string}) ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r
;; for which no effort was made to be included in the request itself - the data
;; is hidden in the request's context. As an example, if REMOTE_USER is set for a
;; request, it will not be found anywhere in r, but it will be included in
;; ProcessEnv's response (via r's context)."
;;   {:added "1.0"
;;    :go "processEnv(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5068669 0xc00108ed20}) r])
;; 
JOKER FUNC fcgi.Serve has: 
;; (defn ^Error Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new
;; goroutine for each. The goroutine reads requests and then calls handler
;; to reply to them.
;; If l is nil, Serve accepts connections from os.Stdin.
;; If handler is nil, http.DefaultServeMux is used."
;;   {:added "1.0"
;;    :go "serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}) l, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http Handler}) handler])
;; 
JOKER FUNC filepath.Abs has: 
(defn ^[String Error] Abs
  "Abs returns an absolute representation of path.
If the path is not absolute it will be joined with the current
working directory to turn it into an absolute path. The absolute
path name for a given file is not guaranteed to be unique.
Abs calls Clean on the result."
  {:added "1.0"
   :go "abs(path)"}
  [^String path])

JOKER FUNC filepath.Base has: 
(defn ^String Base
  "Base returns the last element of path.
Trailing path separators are removed before extracting the last element.
If the path is empty, Base returns ".".
If the path consists entirely of separators, Base returns a single separator."
  {:added "1.0"
   :go "base(path)"}
  [^String path])

JOKER FUNC filepath.Clean has: 
(defn ^String Clean
  "Clean returns the shortest path name equivalent to path
by purely lexical processing. It applies the following rules
iteratively until no further processing can be done:

	1. Replace multiple Separator elements with a single one.
	2. Eliminate each . path name element (the current directory).
	3. Eliminate each inner .. path name element (the parent directory)
	   along with the non-.. element that precedes it.
	4. Eliminate .. elements that begin a rooted path:
	   that is, replace "/.." by "/" at the beginning of a path,
	   assuming Separator is '/'.

The returned path ends in a slash only if it represents a root directory,
such as "/" on Unix or `C:\` on Windows.

Finally, any occurrences of slash are replaced by Separator.

If the result of this process is an empty string, Clean
returns the string ".".

See also Rob Pike, ``Lexical File Names in Plan 9 or
Getting Dot-Dot Right,''
https://9p.io/sys/doc/lexnames.html"
  {:added "1.0"
   :go "clean(path)"}
  [^String path])

JOKER FUNC filepath.Dir has: 
(defn ^String Dir
  "Dir returns all but the last element of path, typically the path's directory.
After dropping the final element, Dir calls Clean on the path and trailing
slashes are removed.
If the path is empty, Dir returns ".".
If the path consists entirely of separators, Dir returns a single separator.
The returned path does not end in a separator unless it is the root directory."
  {:added "1.0"
   :go "dir(path)"}
  [^String path])

JOKER FUNC filepath.EvalSymlinks has: 
(defn ^[String Error] EvalSymlinks
  "EvalSymlinks returns the path name after the evaluation of any symbolic
links.
If path is relative the result will be relative to the current directory,
unless one of the components is an absolute symbolic link.
EvalSymlinks calls Clean on the result."
  {:added "1.0"
   :go "evalSymlinks(path)"}
  [^String path])

JOKER FUNC filepath.Ext has: 
(defn ^String Ext
  "Ext returns the file name extension used by path.
The extension is the suffix beginning at the final dot
in the final element of path; it is empty if there is
no dot."
  {:added "1.0"
   :go "ext(path)"}
  [^String path])

JOKER FUNC filepath.FromSlash has: 
(defn ^String FromSlash
  "FromSlash returns the result of replacing each slash ('/') character
in path with a separator character. Multiple slashes are replaced
by multiple separators."
  {:added "1.0"
   :go "fromSlash(path)"}
  [^String path])

JOKER FUNC filepath.Glob has: 
(defn ^[matches err] Glob
  "Glob returns the names of all files matching pattern or nil
if there is no matching file. The syntax of patterns is the same
as in Match. The pattern may describe hierarchical names such as
/usr/*/bin/ed (assuming the Separator is '/').

Glob ignores file system errors such as I/O errors reading directories.
The only possible returned error is ErrBadPattern, when pattern
is malformed."
  {:added "1.0"
   :go "glob(pattern)"}
  [^String pattern])

JOKER FUNC filepath.HasPrefix has: 
;; (defn ^ABEND042(cannot find typename filepath.bool) HasPrefix
;;   "HasPrefix exists for historical compatibility and should not be used.
;; 
;; Deprecated: HasPrefix does not respect path boundaries and
;; does not ignore case when required."
;;   {:added "1.0"
;;    :go "hasPrefix(p, prefix)"}
;;   [^String p, ^String prefix])
;; 
JOKER FUNC filepath.IsAbs has: 
;; (defn ^ABEND042(cannot find typename filepath.bool) IsAbs
;;   "IsAbs reports whether the path is absolute."
;;   {:added "1.0"
;;    :go "isAbs(path)"}
;;   [^String path])
;; 
JOKER FUNC filepath.Join has: 
;; (defn ^String Join
;;   "Join joins any number of path elements into a single path, adding
;; a Separator if necessary. Join calls Clean on the result; in particular,
;; all empty strings are ignored.
;; On Windows, the result is a UNC path if and only if the first path
;; element is a UNC path."
;;   {:added "1.0"
;;    :go "join(elem)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{5422315 string}) elem])
;; 
JOKER FUNC filepath.Match has: 
(defn ^[matched err] Match
  "Match reports whether name matches the shell file name pattern.
The pattern syntax is:

	pattern:
		{ term }
	term:
		'*'         matches any sequence of non-Separator characters
		'?'         matches any single non-Separator character
		'[' [ '^' ] { character-range } ']'
		            character class (must be non-empty)
		c           matches character c (c != '*', '?', '\\', '[')
		'\\' c      matches character c

	character-range:
		c           matches character c (c != '\\', '-', ']')
		'\\' c      matches character c
		lo '-' hi   matches character c for lo <= c <= hi

Match requires pattern to match all of name, not just a substring.
The only possible returned error is ErrBadPattern, when pattern
is malformed.

On Windows, escaping is disabled. Instead, '\\' is treated as
path separator."
  {:added "1.0"
   :go "match(pattern, name)"}
  [^String pattern, ^String name])

JOKER FUNC filepath.Rel has: 
(defn ^[String Error] Rel
  "Rel returns a relative path that is lexically equivalent to targpath when
joined to basepath with an intervening separator. That is,
Join(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.
On success, the returned path will always be relative to basepath,
even if basepath and targpath share no elements.
An error is returned if targpath can't be made relative to basepath or if
knowing the current working directory would be necessary to compute it.
Rel calls Clean on the result."
  {:added "1.0"
   :go "rel(basepath, targpath)"}
  [^String basepath, ^String targpath])

JOKER FUNC filepath.Split has: 
(defn ^[dir file] Split
  "Split splits path immediately following the final Separator,
separating it into a directory and file name component.
If there is no Separator in path, Split returns an empty dir
and file set to path.
The returned values have the property that path = dir+file."
  {:added "1.0"
   :go "split(path)"}
  [^String path])

JOKER FUNC filepath.SplitList has: 
(defn ^[String] SplitList
  "SplitList splits a list of paths joined by the OS-specific ListSeparator,
usually found in PATH or GOPATH environment variables.
Unlike strings.Split, SplitList returns an empty slice when passed an empty
string."
  {:added "1.0"
   :go "splitList(path)"}
  [^String path])

JOKER FUNC filepath.ToSlash has: 
(defn ^String ToSlash
  "ToSlash returns the result of replacing each separator character
in path with a slash ('/') character. Multiple separators are
replaced by multiple slashes."
  {:added "1.0"
   :go "toSlash(path)"}
  [^String path])

JOKER FUNC filepath.VolumeName has: 
(defn ^String VolumeName
  "VolumeName returns leading volume name.
Given "C:\foo\bar" it returns "C:" on Windows.
Given "\\host\share\foo" it returns "\\host\share".
On other platforms it returns ""."
  {:added "1.0"
   :go "volumeName(path)"}
  [^String path])

JOKER FUNC filepath.Walk has: 
(defn ^Error Walk
  "Walk walks the file tree rooted at root, calling walkFn for each file or
directory in the tree, including root. All errors that arise visiting files
and directories are filtered by walkFn. The files are walked in lexical
order, which makes the output deterministic but means that for very
large directories Walk can be inefficient.
Walk does not follow symbolic links."
  {:added "1.0"
   :go "walk(root, walkFn)"}
  [^String root, walkFn])

JOKER FUNC flag.Arg has: 
(defn ^String Arg
  "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument
after flags have been processed. Arg returns an empty string if the
requested element does not exist."
  {:added "1.0"
   :go "arg(i)"}
  [^Int i])

JOKER FUNC flag.Args has: 
(defn ^[String] Args
  "Args returns the non-flag command-line arguments."
  {:added "1.0"
   :go "args()"}
  [])

JOKER FUNC flag.Bool has: 
;; (defn ^ABEND042(cannot find typename flag.bool) Bool
;;   "Bool defines a bool flag with specified name, default value, and usage string.
;; The return value is the address of a bool variable that stores the value of the flag."
;;   {:added "1.0"
;;    :go "bool(name, value, usage)"}
;;   [^String name, value, ^String usage])
;; 
JOKER FUNC flag.BoolVar has: 
;; (defn BoolVar
;;   "BoolVar defines a bool flag with specified name, default value, and usage string.
;; The argument p points to a bool variable in which to store the value of the flag."
;;   {:added "1.0"
;;    :go "boolVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2017292 bool}) p, ^String name, value, ^String usage])
;; 
JOKER FUNC flag.Duration has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}) Duration
;;   "Duration defines a time.Duration flag with specified name, default value, and usage string.
;; The return value is the address of a time.Duration variable that stores the value of the flag.
;; The flag accepts a value acceptable to time.ParseDuration."
;;   {:added "1.0"
;;    :go "duration(name, value, usage)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}) value, ^String usage])
;; 
JOKER FUNC flag.DurationVar has: 
;; (defn DurationVar
;;   "DurationVar defines a time.Duration flag with specified name, default value, and usage string.
;; The argument p points to a time.Duration variable in which to store the value of the flag.
;; The flag accepts a value acceptable to time.ParseDuration."
;;   {:added "1.0"
;;    :go "durationVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2025850 0xc000756f60}) p, ^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}) value, ^String usage])
;; 
JOKER FUNC flag.Float64 has: 
;; (defn ^ABEND042(cannot find typename flag.float64) Float64
;;   "Float64 defines a float64 flag with specified name, default value, and usage string.
;; The return value is the address of a float64 variable that stores the value of the flag."
;;   {:added "1.0"
;;    :go "float64(name, value, usage)"}
;;   [^String name, value, ^String usage])
;; 
JOKER FUNC flag.Float64Var has: 
;; (defn Float64Var
;;   "Float64Var defines a float64 flag with specified name, default value, and usage string.
;; The argument p points to a float64 variable in which to store the value of the flag."
;;   {:added "1.0"
;;    :go "float64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2024435 float64}) p, ^String name, value, ^String usage])
;; 
JOKER FUNC flag.Int has: 
(defn ^Int Int
  "Int defines an int flag with specified name, default value, and usage string.
The return value is the address of an int variable that stores the value of the flag."
  {:added "1.0"
   :go "int(name, value, usage)"}
  [^String name, ^Int value, ^String usage])

JOKER FUNC flag.Int64 has: 
;; (defn ^ABEND042(cannot find typename flag.int64) Int64
;;   "Int64 defines an int64 flag with specified name, default value, and usage string.
;; The return value is the address of an int64 variable that stores the value of the flag."
;;   {:added "1.0"
;;    :go "int64(name, value, usage)"}
;;   [^String name, value, ^String usage])
;; 
JOKER FUNC flag.Int64Var has: 
;; (defn Int64Var
;;   "Int64Var defines an int64 flag with specified name, default value, and usage string.
;; The argument p points to an int64 variable in which to store the value of the flag."
;;   {:added "1.0"
;;    :go "int64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2019612 int64}) p, ^String name, value, ^String usage])
;; 
JOKER FUNC flag.IntVar has: 
;; (defn IntVar
;;   "IntVar defines an int flag with specified name, default value, and usage string.
;; The argument p points to an int variable in which to store the value of the flag."
;;   {:added "1.0"
;;    :go "intVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2018448 int}) p, ^String name, ^Int value, ^String usage])
;; 
JOKER FUNC flag.Lookup has: 
(defn ^{:name ^String Name, :usage ^String Usage, :value Value, :defvalue ^String DefValue} Lookup
  "Lookup returns the Flag structure of the named command-line flag,
returning nil if none exists."
  {:added "1.0"
   :go "lookup(name)"}
  [^String name])

JOKER FUNC flag.NArg has: 
(defn ^Int NArg
  "NArg is the number of arguments remaining after flags have been processed."
  {:added "1.0"
   :go "nArg()"}
  [])

JOKER FUNC flag.NFlag has: 
(defn ^Int NFlag
  "NFlag returns the number of command-line flags that have been set."
  {:added "1.0"
   :go "nFlag()"}
  [])

JOKER FUNC flag.NewFlagSet has: 
;; (defn ^{:usage ^ABEND881(unrecognized Expr type *ast.FuncType at: &{2007489 0xc000401710 <nil>}) Usage, :name ^String name, :parsed parsed, :actual ^ABEND881(unrecognized Expr type *ast.MapType at: &{2007554 string 0xc0002c5820}) actual, :formal ^ABEND881(unrecognized Expr type *ast.MapType at: &{2007586 string 0xc0004c0060}) formal, :args ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2007618 <nil> string}) args, :errorhandling errorHandling, :output ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) output} NewFlagSet
;;   "NewFlagSet returns a new, empty flag set with the specified name and
;; error handling property. If the name is not empty, it will be printed
;; in the default usage message and in error messages."
;;   {:added "1.0"
;;    :go "newFlagSet(name, errorHandling)"}
;;   [^String name, errorHandling])
;; 
JOKER FUNC flag.Parse has: 
;; (defn Parse
;;   "Parse parses the command-line flags from os.Args[1:]. Must be called
;; after all flags are defined and before flags are accessed by the program."
;;   {:added "1.0"
;;    :go "parse()"}
;;   [])
;; 
JOKER FUNC flag.Parsed has: 
;; (defn ^ABEND042(cannot find typename flag.bool) Parsed
;;   "Parsed reports whether the command-line flags have been parsed."
;;   {:added "1.0"
;;    :go "parsed()"}
;;   [])
;; 
JOKER FUNC flag.PrintDefaults has: 
;; (defn PrintDefaults
;;   "PrintDefaults prints, to standard error unless configured otherwise,
;; a usage message showing the default settings of all defined
;; command-line flags.
;; For an integer valued flag x, the default output has the form
;; 	-x int
;; 		usage-message-for-x (default 7)
;; The usage message will appear on a separate line for anything but
;; a bool flag with a one-byte name. For bool flags, the type is
;; omitted and if the flag name is one byte the usage message appears
;; on the same line. The parenthetical default is omitted if the
;; default is the zero value for the type. The listed type, here int,
;; can be changed by placing a back-quoted name in the flag's usage
;; string; the first such item in the message is taken to be a parameter
;; name to show in the message and the back quotes are stripped from
;; the message when displayed. For instance, given
;; 	flag.String("I", "", "search `directory` for include files")
;; the output will be
;; 	-I directory
;; 		search directory for include files."
;;   {:added "1.0"
;;    :go "printDefaults()"}
;;   [])
;; 
JOKER FUNC flag.Set has: 
(defn ^Error Set
  "Set sets the value of the named command-line flag."
  {:added "1.0"
   :go "set(name, value)"}
  [^String name, ^String value])

JOKER FUNC flag.String has: 
(defn ^String String
  "String defines a string flag with specified name, default value, and usage string.
The return value is the address of a string variable that stores the value of the flag."
  {:added "1.0"
   :go "string(name, value, usage)"}
  [^String name, ^String value, ^String usage])

JOKER FUNC flag.StringVar has: 
;; (defn StringVar
;;   "StringVar defines a string flag with specified name, default value, and usage string.
;; The argument p points to a string variable in which to store the value of the flag."
;;   {:added "1.0"
;;    :go "stringVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2023203 string}) p, ^String name, ^String value, ^String usage])
;; 
JOKER FUNC flag.Uint has: 
(defn ^Int Uint
  "Uint defines a uint flag with specified name, default value, and usage string.
The return value is the address of a uint variable that stores the value of the flag."
  {:added "1.0"
   :go "uint(name, value, usage)"}
  [^String name, ^Int value, ^String usage])

JOKER FUNC flag.Uint64 has: 
;; (defn ^ABEND042(cannot find typename flag.uint64) Uint64
;;   "Uint64 defines a uint64 flag with specified name, default value, and usage string.
;; The return value is the address of a uint64 variable that stores the value of the flag."
;;   {:added "1.0"
;;    :go "uint64(name, value, usage)"}
;;   [^String name, value, ^String usage])
;; 
JOKER FUNC flag.Uint64Var has: 
;; (defn Uint64Var
;;   "Uint64Var defines a uint64 flag with specified name, default value, and usage string.
;; The argument p points to a uint64 variable in which to store the value of the flag."
;;   {:added "1.0"
;;    :go "uint64Var(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2021982 uint64}) p, ^String name, value, ^String usage])
;; 
JOKER FUNC flag.UintVar has: 
;; (defn UintVar
;;   "UintVar defines a uint flag with specified name, default value, and usage string.
;; The argument p points to a uint variable in which to store the value of the flag."
;;   {:added "1.0"
;;    :go "uintVar(p, name, value, usage)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2020797 uint}) p, ^String name, ^Int value, ^String usage])
;; 
JOKER FUNC flag.UnquoteUsage has: 
;; (defn ^[name usage] UnquoteUsage
;;   "UnquoteUsage extracts a back-quoted name from the usage
;; string for a flag and returns it and the un-quoted usage.
;; Given "a `name` to show" it returns ("name", "a name to show").
;; If there are no back quotes, the name is an educated guess of the
;; type of the flag's value, or the empty string if the flag is boolean."
;;   {:added "1.0"
;;    :go "unquoteUsage(flag)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2011530 Flag}) flag])
;; 
JOKER FUNC flag.Var has: 
;; (defn Var
;;   "Var defines a flag with the specified name and usage string. The type and
;; value of the flag are represented by the first argument, of type Value, which
;; typically holds a user-defined implementation of Value. For instance, the
;; caller could create a flag that turns a comma-separated string into a slice
;; of strings by giving the slice the methods of Value; in particular, Set would
;; decompose the comma-separated string into the slice."
;;   {:added "1.0"
;;    :go "var(value, name, usage)"}
;;   [value, ^String name, ^String usage])
;; 
JOKER FUNC flag.Visit has: 
;; (defn Visit
;;   "Visit visits the command-line flags in lexicographical order, calling fn
;; for each. It visits only those flags that have been set."
;;   {:added "1.0"
;;    :go "visit(fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{2009797 0xc0004207b0 <nil>}) fn])
;; 
JOKER FUNC flag.VisitAll has: 
;; (defn VisitAll
;;   "VisitAll visits the command-line flags in lexicographical order, calling
;; fn for each. It visits all flags, even those not set."
;;   {:added "1.0"
;;    :go "visitAll(fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{2009377 0xc0004170e0 <nil>}) fn])
;; 
JOKER FUNC flate.NewReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) NewReader
;;   "NewReader returns a new ReadCloser that can be used
;; to read the uncompressed version of r.
;; If r does not also implement io.ByteReader,
;; the decompressor may read more data than necessary from r.
;; It is the caller's responsibility to call Close on the ReadCloser
;; when finished reading.
;; 
;; The ReadCloser returned by NewReader also implements Resetter."
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC flate.NewReaderDict has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) NewReaderDict
;;   "NewReaderDict is like NewReader but initializes the reader
;; with a preset dictionary. The returned Reader behaves as if
;; the uncompressed data stream started with the given dictionary,
;; which has already been read. NewReaderDict is typically used
;; to read data compressed by NewWriterDict.
;; 
;; The ReadCloser returned by NewReader also implements Resetter."
;;   {:added "1.0"
;;    :go "newReaderDict(r, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{300538 <nil> byte}) dict])
;; 
JOKER FUNC flate.NewWriter has: 
;; (defn ^[{:d d, :dict ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{268996 <nil> byte}) dict} Error] NewWriter
;;   "NewWriter returns a new Writer compressing data at the given level.
;; Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);
;; higher levels typically run slower but compress more. Level 0
;; (NoCompression) does not attempt any compression; it only adds the
;; necessary DEFLATE framing.
;; Level -1 (DefaultCompression) uses the default compression level.
;; Level -2 (HuffmanOnly) will use Huffman compression only, giving
;; a very fast compression for all types of input, but sacrificing considerable
;; compression efficiency.
;; 
;; If level is in the range [-2, 9] then the error returned will be nil.
;; Otherwise the error returned will be non-nil."
;;   {:added "1.0"
;;    :go "newWriter(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^Int level])
;; 
JOKER FUNC flate.NewWriterDict has: 
;; (defn ^[{:d d, :dict ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{268996 <nil> byte}) dict} Error] NewWriterDict
;;   "NewWriterDict is like NewWriter but initializes the new
;; Writer with a preset dictionary. The returned Writer behaves
;; as if the dictionary had been written to it without producing
;; any compressed output. The compressed data written to w
;; can only be decompressed by a Reader initialized with the
;; same dictionary."
;;   {:added "1.0"
;;    :go "newWriterDict(w, level, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^Int level, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{268464 <nil> byte}) dict])
;; 
JOKER FUNC fmt.Errorf has: 
;; (defn ^Error Errorf
;;   "Errorf formats according to a format specifier and returns the string
;; as a value that satisfies error."
;;   {:added "1.0"
;;    :go "errorf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2038883 0xc0006575e0}) a])
;; 
JOKER FUNC fmt.Fprint has: 
;; (defn ^[n err] Fprint
;;   "Fprint formats using the default formats for its operands and writes to w.
;; Spaces are added between operands when neither is a string.
;; It returns the number of bytes written and any write error encountered."
;;   {:added "1.0"
;;    :go "fprint(w, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2039242 0xc0007abec0}) a])
;; 
JOKER FUNC fmt.Fprintf has: 
;; (defn ^[n err] Fprintf
;;   "Fprintf formats according to a format specifier and writes to w.
;; It returns the number of bytes written and any write error encountered."
;;   {:added "1.0"
;;    :go "fprintf(w, format, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2038129 0xc000521b80}) a])
;; 
JOKER FUNC fmt.Fprintln has: 
;; (defn ^[n err] Fprintln
;;   "Fprintln formats using the default formats for its operands and writes to w.
;; Spaces are always added between operands and a newline is appended.
;; It returns the number of bytes written and any write error encountered."
;;   {:added "1.0"
;;    :go "fprintln(w, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2040345 0xc0001da3c0}) a])
;; 
JOKER FUNC fmt.Fscan has: 
;; (defn ^[n err] Fscan
;;   "Fscan scans text read from r, storing successive space-separated
;; values into successive arguments. Newlines count as space. It
;; returns the number of items successfully scanned. If that is less
;; than the number of arguments, err will report why."
;;   {:added "1.0"
;;    :go "fscan(r, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2068051 0xc0007de480}) a])
;; 
JOKER FUNC fmt.Fscanf has: 
;; (defn ^[n err] Fscanf
;;   "Fscanf scans text read from r, storing successive space-separated
;; values into successive arguments as determined by the format. It
;; returns the number of items successfully parsed.
;; Newlines in the input must match newlines in the format."
;;   {:added "1.0"
;;    :go "fscanf(r, format, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2068740 0xc0007dee60}) a])
;; 
JOKER FUNC fmt.Fscanln has: 
;; (defn ^[n err] Fscanln
;;   "Fscanln is similar to Fscan, but stops scanning at a newline and
;; after the final item there must be a newline or EOF."
;;   {:added "1.0"
;;    :go "fscanln(r, a)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2068326 0xc0007de920}) a])
;; 
JOKER FUNC fmt.Print has: 
;; (defn ^[n err] Print
;;   "Print formats using the default formats for its operands and writes to standard output.
;; Spaces are added between operands when neither is a string.
;; It returns the number of bytes written and any write error encountered."
;;   {:added "1.0"
;;    :go "print(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2039600 0xc000675840}) a])
;; 
JOKER FUNC fmt.Printf has: 
;; (defn ^[n err] Printf
;;   "Printf formats according to a format specifier and writes to standard output.
;; It returns the number of bytes written and any write error encountered."
;;   {:added "1.0"
;;    :go "printf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2038439 0xc000656400}) a])
;; 
JOKER FUNC fmt.Println has: 
;; (defn ^[n err] Println
;;   "Println formats using the default formats for its operands and writes to standard output.
;; Spaces are always added between operands and a newline is appended.
;; It returns the number of bytes written and any write error encountered."
;;   {:added "1.0"
;;    :go "println(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2040717 0xc000604ee0}) a])
;; 
JOKER FUNC fmt.Scan has: 
;; (defn ^[n err] Scan
;;   "Scan scans text read from standard input, storing successive
;; space-separated values into successive arguments. Newlines count
;; as space. It returns the number of items successfully scanned.
;; If that is less than the number of arguments, err will report why."
;;   {:added "1.0"
;;    :go "scan(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2065779 0xc0006b4d40}) a])
;; 
JOKER FUNC fmt.Scanf has: 
;; (defn ^[n err] Scanf
;;   "Scanf scans text read from standard input, storing successive
;; space-separated values into successive arguments as determined by
;; the format. It returns the number of items successfully scanned.
;; If that is less than the number of arguments, err will report why.
;; Newlines in the input must match newlines in the format.
;; The one exception: the verb %c always scans the next rune in the
;; input, even if it is a space (or tab etc.) or newline."
;;   {:added "1.0"
;;    :go "scanf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2066543 0xc0006b5320}) a])
;; 
JOKER FUNC fmt.Scanln has: 
;; (defn ^[n err] Scanln
;;   "Scanln is similar to Scan, but stops scanning at a newline and
;; after the final item there must be a newline or EOF."
;;   {:added "1.0"
;;    :go "scanln(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2065985 0xc0006b4fc0}) a])
;; 
JOKER FUNC fmt.Sprint has: 
;; (defn ^String Sprint
;;   "Sprint formats using the default formats for its operands and returns the resulting string.
;; Spaces are added between operands when neither is a string."
;;   {:added "1.0"
;;    :go "sprint(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2039844 0xc00055e420}) a])
;; 
JOKER FUNC fmt.Sprintf has: 
;; (defn ^String Sprintf
;;   "Sprintf formats according to a format specifier and returns the resulting string."
;;   {:added "1.0"
;;    :go "sprintf(format, a)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2038635 0xc000656720}) a])
;; 
JOKER FUNC fmt.Sprintln has: 
;; (defn ^String Sprintln
;;   "Sprintln formats using the default formats for its operands and returns the resulting string.
;; Spaces are always added between operands and a newline is appended."
;;   {:added "1.0"
;;    :go "sprintln(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2040975 0xc0001d2720}) a])
;; 
JOKER FUNC fmt.Sscan has: 
;; (defn ^[n err] Sscan
;;   "Sscan scans the argument string, storing successive space-separated
;; values into successive arguments. Newlines count as space. It
;; returns the number of items successfully scanned. If that is less
;; than the number of arguments, err will report why."
;;   {:added "1.0"
;;    :go "sscan(str, a)"}
;;   [^String str, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2067065 0xc0006b5a60}) a])
;; 
JOKER FUNC fmt.Sscanf has: 
;; (defn ^[n err] Sscanf
;;   "Sscanf scans the argument string, storing successive space-separated
;; values into successive arguments as determined by the format. It
;; returns the number of items successfully parsed.
;; Newlines in the input must match newlines in the format."
;;   {:added "1.0"
;;    :go "sscanf(str, format, a)"}
;;   [^String str, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2067677 0xc0007de0c0}) a])
;; 
JOKER FUNC fmt.Sscanln has: 
;; (defn ^[n err] Sscanln
;;   "Sscanln is similar to Sscan, but stops scanning at a newline and
;; after the final item there must be a newline or EOF."
;;   {:added "1.0"
;;    :go "sscanln(str, a)"}
;;   [^String str, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2067299 0xc0006b5d40}) a])
;; 
JOKER FUNC fnv.New128 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New128
;;   "New128 returns a new 128-bit FNV-1 hash.Hash.
;; Its Sum method will lay the value out in big-endian byte order."
;;   {:added "1.0"
;;    :go "new128()"}
;;   [])
;; 
JOKER FUNC fnv.New128a has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New128a
;;   "New128a returns a new 128-bit FNV-1a hash.Hash.
;; Its Sum method will lay the value out in big-endian byte order."
;;   {:added "1.0"
;;    :go "new128a()"}
;;   [])
;; 
JOKER FUNC fnv.New32 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash32}) New32
;;   "New32 returns a new 32-bit FNV-1 hash.Hash.
;; Its Sum method will lay the value out in big-endian byte order."
;;   {:added "1.0"
;;    :go "new32()"}
;;   [])
;; 
JOKER FUNC fnv.New32a has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash32}) New32a
;;   "New32a returns a new 32-bit FNV-1a hash.Hash.
;; Its Sum method will lay the value out in big-endian byte order."
;;   {:added "1.0"
;;    :go "new32a()"}
;;   [])
;; 
JOKER FUNC fnv.New64 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash64}) New64
;;   "New64 returns a new 64-bit FNV-1 hash.Hash.
;; Its Sum method will lay the value out in big-endian byte order."
;;   {:added "1.0"
;;    :go "new64()"}
;;   [])
;; 
JOKER FUNC fnv.New64a has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash64}) New64a
;;   "New64a returns a new 64-bit FNV-1a hash.Hash.
;; Its Sum method will lay the value out in big-endian byte order."
;;   {:added "1.0"
;;    :go "new64a()"}
;;   [])
;; 
JOKER FUNC format.Node has: 
;; (defn ^Error Node
;;   "Node formats node in canonical gofmt style and writes the result to dst.
;; 
;; The node type must be *ast.File, *printer.CommentedNode, []ast.Decl,
;; []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,
;; or ast.Stmt. Node does not modify node. Imports are not sorted for
;; nodes representing partial source files (for instance, if the node is
;; not an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).
;; 
;; The function may return early (before the entire result is written)
;; and return a formatting error, for instance due to an incorrect AST."
;;   {:added "1.0"
;;    :go "node(dst, fset, node)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) dst, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2372746 0xc0005d0b40}) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{2372767 0xc0002ea030 false}) node])
;; 
JOKER FUNC format.Source has: 
;; (defn ^[[ABEND042(cannot find typename format.byte)] Error] Source
;;   "Source formats src in canonical gofmt style and returns the result
;; or an (I/O or syntax) error. src is expected to be a syntactically
;; correct Go source file, or a list of Go declarations or statements.
;; 
;; If src is a partial source file, the leading and trailing space of src
;; is applied to the result (such that it has the same leading and trailing
;; space as src), and the result is indented by the same amount as the first
;; line of src containing code. Imports are not sorted for partial source files."
;;   {:added "1.0"
;;    :go "source(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2374330 <nil> byte}) src])
;; 
JOKER FUNC gif.Decode has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{image Image}) Error] Decode
;;   "Decode reads a GIF image from r and returns the first embedded
;; image as an image.Image."
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC gif.DecodeAll has: 
;; (defn ^[{:image ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3348324 <nil> 0xc000860ec0}) Image, :delay ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3348375 <nil> int}) Delay, :loopcount ^Int LoopCount, :disposal ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3348968 <nil> byte}) Disposal, :config ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Config}) Config, :backgroundindex BackgroundIndex} Error] DecodeAll
;;   "DecodeAll reads a GIF image from r and returns the sequential frames
;; and timing information."
;;   {:added "1.0"
;;    :go "decodeAll(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC gif.DecodeConfig has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{image Config}) Error] DecodeConfig
;;   "DecodeConfig returns the global color model and dimensions of a GIF image
;; without decoding the entire image."
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC gif.Encode has: 
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in GIF format."
;;   {:added "1.0"
;;    :go "encode(w, m, o)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Image}) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{3361336 Options}) o])
;; 
JOKER FUNC gif.EncodeAll has: 
;; (defn ^Error EncodeAll
;;   "EncodeAll writes the images in g to w in GIF format with the
;; given loop count and delay between frames."
;;   {:added "1.0"
;;    :go "encodeAll(w, g)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{3360065 GIF}) g])
;; 
JOKER FUNC gob.NewDecoder has: 
;; (defn ^{:mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mutex, :r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, :buf buf, :wiretype ^ABEND881(unrecognized Expr type *ast.MapType at: &{1660747 typeId 0xc00017c0c0}) wireType, :decodercache ^ABEND881(unrecognized Expr type *ast.MapType at: &{1660844 0xc00017c460 0xc0003eb200}) decoderCache, :ignorercache ^ABEND881(unrecognized Expr type *ast.MapType at: &{1660927 typeId 0xc00017c8c0}) ignorerCache, :freelist ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1661010 decoderState}) freeList, :countbuf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1661115 <nil> byte}) countBuf, :err err} NewDecoder
;;   "NewDecoder returns a new decoder that reads from the io.Reader.
;; If r does not also implement io.ByteReader, it will be wrapped in a
;; bufio.Reader."
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC gob.NewEncoder has: 
;; (defn ^{:mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mutex, :w ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1749080 <nil> 0xc0007820c0}) w, :sent ^ABEND881(unrecognized Expr type *ast.MapType at: &{1749142 0xc0007821a0 typeId}) sent, :countstate ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1749212 encoderState}) countState, :freelist ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1749276 encoderState}) freeList, :bytebuf byteBuf, :err err} NewEncoder
;;   "NewEncoder returns a new encoder that will transmit on the io.Writer."
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC gob.Register has: 
;; (defn Register
;;   "Register records a type, identified by a value for that type, under its
;; internal type name. That name will identify the concrete type of a value
;; sent or received as an interface variable. Only types that will be
;; transferred as implementations of interface values need to be registered.
;; Expecting to be used only during initialization, it panics if the mapping
;; between types and names is not a bijection."
;;   {:added "1.0"
;;    :go "register(value)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1637234 0xc000255f50 false}) value])
;; 
JOKER FUNC gob.RegisterName has: 
;; (defn RegisterName
;;   "RegisterName is like Register but uses the provided name rather than the
;; type's default."
;;   {:added "1.0"
;;    :go "registerName(name, value)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1636013 0xc000255b60 false}) value])
;; 
JOKER FUNC gosym.NewLineTable has: 
;; (defn ^{:data ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1394016 <nil> byte}) Data, :pc PC, :line ^Int Line, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :go12 ^Int go12, :binary ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{binary ByteOrder}) binary, :quantum quantum, :ptrsize ptrsize, :functab ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1394223 <nil> byte}) functab, :nfunctab nfunctab, :filetab ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1394257 <nil> byte}) filetab, :nfiletab nfiletab, :filemap ^ABEND881(unrecognized Expr type *ast.MapType at: &{1394291 string uint32}) fileMap, :strings ^ABEND881(unrecognized Expr type *ast.MapType at: &{1394319 uint32 string}) strings} NewLineTable
;;   "NewLineTable returns a new PC/line table
;; corresponding to the encoded data.
;; Text must be the start address of the
;; corresponding text segment."
;;   {:added "1.0"
;;    :go "newLineTable(data, text)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1396568 <nil> byte}) data, text])
;; 
JOKER FUNC gosym.NewTable has: 
;; (defn ^[{:syms ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1408467 <nil> Sym}) Syms, :funcs ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1408517 <nil> Func}) Funcs, :files ^ABEND881(unrecognized Expr type *ast.MapType at: &{1408531 string 0xc0006f96a0}) Files, :objs ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1408591 <nil> Obj}) Objs, :go12line ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1408655 LineTable}) go12line} Error] NewTable
;;   "NewTable decodes the Go symbol table (the ".gosymtab" section in ELF),
;; returning an in-memory representation.
;; Starting with Go 1.3, the Go symbol table no longer includes symbol data."
;;   {:added "1.0"
;;    :go "newTable(symtab, pcln)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1412221 <nil> byte}) symtab, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1412234 LineTable}) pcln])
;; 
JOKER FUNC gzip.NewReader has: 
;; (defn ^[{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{flate Reader}) r, :decompressor ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) decompressor, :digest digest, :size size, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{334462 0xc0002d1740 byte}) buf, :err err, :multistream multistream} Error] NewReader
;;   "NewReader creates a new Reader reading the given reader.
;; If r does not also implement io.ByteReader,
;; the decompressor may read more data than necessary from r.
;; 
;; It is the caller's responsibility to call Close on the Reader when done.
;; 
;; The Reader.Header fields will be valid in the Reader returned."
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC gzip.NewWriter has: 
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :level ^Int level, :wroteheader wroteHeader, :compressor ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{341478 0xc000428060}) compressor, :digest digest, :size size, :closed closed, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{341639 0xc000428200 byte}) buf, :err err} NewWriter
;;   "NewWriter returns a new Writer.
;; Writes to the returned writer are compressed and written to w.
;; 
;; It is the caller's responsibility to call Close on the Writer when done.
;; Writes may be buffered and not flushed until Close.
;; 
;; Callers that wish to set the fields in Writer.Header must do so before
;; the first call to Write, Flush, or Close."
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC gzip.NewWriterLevel has: 
;; (defn ^[{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :level ^Int level, :wroteheader wroteHeader, :compressor ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{341478 0xc000428060}) compressor, :digest digest, :size size, :closed closed, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{341639 0xc000428200 byte}) buf, :err err} Error] NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead
;; of assuming DefaultCompression.
;; 
;; The compression level can be DefaultCompression, NoCompression, HuffmanOnly
;; or any integer value between BestSpeed and BestCompression inclusive.
;; The error returned will be nil if the level is valid."
;;   {:added "1.0"
;;    :go "newWriterLevel(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^Int level])
;; 
JOKER FUNC heap.Fix has: 
;; (defn Fix
;;   "Fix re-establishes the heap ordering after the element at index i has changed its value.
;; Changing the value of the element at index i and then calling Fix is equivalent to,
;; but less expensive than, calling Remove(h, i) followed by a Push of the new value.
;; The complexity is O(log(n)) where n = h.Len()."
;;   {:added "1.0"
;;    :go "fix(h, i)"}
;;   [h, ^Int i])
;; 
JOKER FUNC heap.Init has: 
;; (defn Init
;;   "Init establishes the heap invariants required by the other routines in this package.
;; Init is idempotent with respect to the heap invariants
;; and may be called whenever the heap invariants may have been invalidated.
;; Its complexity is O(n) where n = h.Len()."
;;   {:added "1.0"
;;    :go "init(h)"}
;;   [h])
;; 
JOKER FUNC heap.Pop has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{374050 0xc0002eb200 false}) Pop
;;   "Pop removes the minimum element (according to Less) from the heap
;; and returns it. The complexity is O(log(n)) where n = h.Len().
;; It is equivalent to Remove(h, 0)."
;;   {:added "1.0"
;;    :go "pop(h)"}
;;   [h])
;; 
JOKER FUNC heap.Push has: 
;; (defn Push
;;   "Push pushes the element x onto the heap. The complexity is
;; O(log(n)) where n = h.Len()."
;;   {:added "1.0"
;;    :go "push(h, x)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{373806 0xc0002eb080 false}) x])
;; 
JOKER FUNC heap.Remove has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{374271 0xc0002eb380 false}) Remove
;;   "Remove removes the element at index i from the heap.
;; The complexity is O(log(n)) where n = h.Len()."
;;   {:added "1.0"
;;    :go "remove(h, i)"}
;;   [h, ^Int i])
;; 
JOKER FUNC hex.Decode has: 
;; (defn ^[Int Error] Decode
;;   "Decode decodes src into DecodedLen(len(src)) bytes,
;; returning the actual number of bytes written to dst.
;; 
;; Decode expects that src contains only hexadecimal
;; characters and that src has even length.
;; If the input is malformed, Decode returns the number
;; of bytes decoded before the error."
;;   {:added "1.0"
;;    :go "decode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1758307 <nil> byte}) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1758307 <nil> byte}) src])
;; 
JOKER FUNC hex.DecodeString has: 
;; (defn ^[[ABEND042(cannot find typename hex.byte)] Error] DecodeString
;;   "DecodeString returns the bytes represented by the hexadecimal string s.
;; 
;; DecodeString expects that src contains only hexadecimal
;; characters and that src has even length.
;; If the input is malformed, DecodeString returns
;; the bytes decoded before the error."
;;   {:added "1.0"
;;    :go "decodeString(s)"}
;;   [^String s])
;; 
JOKER FUNC hex.DecodedLen has: 
(defn ^Int DecodedLen
  "DecodedLen returns the length of a decoding of x source bytes.
Specifically, it returns x / 2."
  {:added "1.0"
   :go "decodedLen(x)"}
  [^Int x])

JOKER FUNC hex.Dump has: 
;; (defn ^String Dump
;;   "Dump returns a string that contains a hex dump of the given data. The format
;; of the hex dump matches the output of `hexdump -C` on the command line."
;;   {:added "1.0"
;;    :go "dump(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1760058 <nil> byte}) data])
;; 
JOKER FUNC hex.Dumper has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io WriteCloser}) Dumper
;;   "Dumper returns a WriteCloser that writes a hex dump of all written data to
;; w. The format of the dump matches the output of `hexdump -C` on the command
;; line."
;;   {:added "1.0"
;;    :go "dumper(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC hex.Encode has: 
;; (defn ^Int Encode
;;   "Encode encodes src into EncodedLen(len(src))
;; bytes of dst. As a convenience, it returns the number
;; of bytes written to dst, but this value is always EncodedLen(len(src)).
;; Encode implements hexadecimal encoding."
;;   {:added "1.0"
;;    :go "encode(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1757239 <nil> byte}) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1757239 <nil> byte}) src])
;; 
JOKER FUNC hex.EncodeToString has: 
;; (defn ^String EncodeToString
;;   "EncodeToString returns the hexadecimal encoding of src."
;;   {:added "1.0"
;;    :go "encodeToString(src)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1759250 <nil> byte}) src])
;; 
JOKER FUNC hex.EncodedLen has: 
(defn ^Int EncodedLen
  "EncodedLen returns the length of an encoding of n source bytes.
Specifically, it returns n * 2."
  {:added "1.0"
   :go "encodedLen(n)"}
  [^Int n])

JOKER FUNC hex.NewDecoder has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) NewDecoder
;;   "NewDecoder returns an io.Reader that decodes hexadecimal characters from r.
;; NewDecoder expects that r contain only an even number of hexadecimal characters."
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC hex.NewEncoder has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) NewEncoder
;;   "NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w."
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC hmac.Equal has: 
;; (defn ^ABEND042(cannot find typename hmac.bool) Equal
;;   "Equal compares two MACs for equality without leaking timing information."
;;   {:added "1.0"
;;    :go "equal(mac1, mac2)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{567464 <nil> byte}) mac1, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{567464 <nil> byte}) mac2])
;; 
JOKER FUNC hmac.New has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New
;;   "New returns a new HMAC hash using the given hash.Hash type and key.
;; Note that unlike other hash implementations in the standard library,
;; the returned Hash does not implement encoding.BinaryMarshaler
;; or encoding.BinaryUnmarshaler."
;;   {:added "1.0"
;;    :go "new(h, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{566842 0xc0002ea5a0 0xc0002ea5d0}) h, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{566864 <nil> byte}) key])
;; 
JOKER FUNC hpack.AppendHuffmanString has: 
;; (defn ^[ABEND042(cannot find typename hpack.byte)] AppendHuffmanString
;;   "AppendHuffmanString appends s, as encoded in Huffman codes, to dst
;; and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendHuffmanString(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8331543 <nil> byte}) dst, ^String s])
;; 
JOKER FUNC hpack.HuffmanDecode has: 
;; (defn ^[Int Error] HuffmanDecode
;;   "HuffmanDecode decodes the string in v and writes the expanded
;; result to w, returning the number of bytes written to w and the
;; Write call's return value. At most one Write call is made."
;;   {:added "1.0"
;;    :go "huffmanDecode(w, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8328028 <nil> byte}) v])
;; 
JOKER FUNC hpack.HuffmanDecodeToString has: 
;; (defn ^[String Error] HuffmanDecodeToString
;;   "HuffmanDecodeToString decodes the string in v."
;;   {:added "1.0"
;;    :go "huffmanDecodeToString(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8328306 <nil> byte}) v])
;; 
JOKER FUNC hpack.HuffmanEncodeLength has: 
;; (defn ^ABEND042(cannot find typename hpack.uint64) HuffmanEncodeLength
;;   "HuffmanEncodeLength returns the number of bytes required to encode
;; s in Huffman codes. The result is round up to byte boundary."
;;   {:added "1.0"
;;    :go "huffmanEncodeLength(s)"}
;;   [^String s])
;; 
JOKER FUNC hpack.NewDecoder has: 
;; (defn ^{:dyntab dynTab, :emit ^ABEND881(unrecognized Expr type *ast.FuncType at: &{8298793 0xc0016b08d0 <nil>}) emit, :emitenabled emitEnabled, :maxstrlen ^Int maxStrLen, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8299108 <nil> byte}) buf, :savebuf ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{bytes Buffer}) saveBuf} NewDecoder
;;   "NewDecoder returns a new decoder with the provided maximum dynamic
;; table size. The emitFunc will be called for each valid field
;; parsed, in the same goroutine as calls to Write, before Write returns."
;;   {:added "1.0"
;;    :go "newDecoder(maxDynamicTableSize, emitFunc)"}
;;   [maxDynamicTableSize, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{8299564 0xc0016b09c0 <nil>}) emitFunc])
;; 
JOKER FUNC hpack.NewEncoder has: 
;; (defn ^{:dyntab dynTab, :minsize minSize, :maxsizelimit maxSizeLimit, :tablesizeupdate tableSizeUpdate, :w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8311436 <nil> byte}) buf} NewEncoder
;;   "NewEncoder returns a new Encoder which performs HPACK encoding. An
;; encoded data is written to w."
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC html.EscapeString has: 
(defn ^String EscapeString
  "EscapeString escapes special characters like "<" to become "&lt;". It
escapes only five such characters: <, >, &, ' and ".
UnescapeString(EscapeString(s)) == s always holds, but the converse isn't
always true."
  {:added "1.0"
   :go "escapeString(s)"}
  [^String s])

JOKER FUNC html.UnescapeString has: 
(defn ^String UnescapeString
  "UnescapeString unescapes entities like "&lt;" to become "<". It unescapes a
larger range of entities than EscapeString escapes. For example, "&aacute;"
unescapes to "á", as does "&#225;" and "&#xE1;".
UnescapeString(EscapeString(s)) == s always holds, but the converse isn't
always true."
  {:added "1.0"
   :go "unescapeString(s)"}
  [^String s])

JOKER FUNC http.CanonicalHeaderKey has: 
(defn ^String CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the
header key s. The canonicalization converts the first
letter and any letter following a hyphen to upper case;
the rest are converted to lowercase. For example, the
canonical key for "accept-encoding" is "Accept-Encoding".
If s contains a space or invalid header field bytes, it is
returned without modifications."
  {:added "1.0"
   :go "canonicalHeaderKey(s)"}
  [^String s])

JOKER FUNC http.DetectContentType has: 
;; (defn ^String DetectContentType
;;   "DetectContentType implements the algorithm described
;; at https://mimesniff.spec.whatwg.org/ to determine the
;; Content-Type of the given data. It considers at most the
;; first 512 bytes of data. DetectContentType always returns
;; a valid MIME type: if it cannot determine a more specific one, it
;; returns "application/octet-stream"."
;;   {:added "1.0"
;;    :go "detectContentType(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{4539554 <nil> byte}) data])
;; 
JOKER FUNC http.Error has: 
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.
;; It does not otherwise end the request; the caller should ensure no further
;; writes are done to w.
;; The error message should be plain text."
;;   {:added "1.0"
;;    :go "error(w, error, code)"}
;;   [w, ^String error, ^Int code])
;; 
JOKER FUNC http.FileServer has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4910497 0xc000538f30 false}) FileServer
;;   "FileServer returns a handler that serves HTTP requests
;; with the contents of the file system rooted at root.
;; 
;; To use the operating system's file system implementation,
;; use http.Dir:
;; 
;;     http.Handle("/", http.FileServer(http.Dir("/tmp")))
;; 
;; As a special case, the returned file server redirects any request
;; ending in "/index.html" to the same path, without the final
;; "index.html"."
;;   {:added "1.0"
;;    :go "fileServer(root)"}
;;   [root])
;; 
JOKER FUNC http.Get has: 
(defn ^[resp err] Get
  "Get issues a GET to the specified URL. If the response is one of
the following redirect codes, Get follows the redirect, up to a
maximum of 10 redirects:

   301 (Moved Permanently)
   302 (Found)
   303 (See Other)
   307 (Temporary Redirect)
   308 (Permanent Redirect)

An error is returned if there were too many redirects or if there
was an HTTP protocol error. A non-2xx response doesn't cause an
error. Any returned error will be of type *url.Error. The url.Error
value's Timeout method will report true if request timed out or was
canceled.

When err is nil, resp always contains a non-nil resp.Body.
Caller should close resp.Body when done reading from it.

Get is a wrapper around DefaultClient.Get.

To make a request with custom headers, use NewRequest and
DefaultClient.Do."
  {:added "1.0"
   :go "get(url)"}
  [^String url])

JOKER FUNC http.Handle has: 
;; (defn Handle
;;   "Handle registers the handler for the given pattern
;; in the DefaultServeMux.
;; The documentation for ServeMux explains how patterns are matched."
;;   {:added "1.0"
;;    :go "handle(pattern, handler)"}
;;   [^String pattern, handler])
;; 
JOKER FUNC http.HandleFunc has: 
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern
;; in the DefaultServeMux.
;; The documentation for ServeMux explains how patterns are matched."
;;   {:added "1.0"
;;    :go "handleFunc(pattern, handler)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{4981221 0xc000c29890 <nil>}) handler])
;; 
JOKER FUNC http.Head has: 
(defn ^[resp err] Head
  "Head issues a HEAD to the specified URL. If the response is one of
the following redirect codes, Head follows the redirect, up to a
maximum of 10 redirects:

   301 (Moved Permanently)
   302 (Found)
   303 (See Other)
   307 (Temporary Redirect)
   308 (Permanent Redirect)

Head is a wrapper around DefaultClient.Head"
  {:added "1.0"
   :go "head(url)"}
  [^String url])

JOKER FUNC http.ListenAndServe has: 
(defn ^Error ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls
Serve with handler to handle requests on incoming connections.
Accepted connections are configured to enable TCP keep-alives.

The handler is typically nil, in which case the DefaultServeMux is used.

ListenAndServe always returns a non-nil error."
  {:added "1.0"
   :go "listenAndServe(addr, handler)"}
  [^String addr, handler])

JOKER FUNC http.ListenAndServeTLS has: 
(defn ^Error ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it
expects HTTPS connections. Additionally, files containing a certificate and
matching private key for the server must be provided. If the certificate
is signed by a certificate authority, the certFile should be the concatenation
of the server's certificate, any intermediates, and the CA's certificate."
  {:added "1.0"
   :go "listenAndServeTLS(addr, certFile, keyFile, handler)"}
  [^String addr, ^String certFile, ^String keyFile, handler])

JOKER FUNC http.MaxBytesReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for
;; limiting the size of incoming request bodies. In contrast to
;; io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a
;; non-EOF error for a Read beyond the limit, and closes the
;; underlying reader when its Close method is called.
;; 
;; MaxBytesReader prevents clients from accidentally or maliciously
;; sending a large request and wasting server resources."
;;   {:added "1.0"
;;    :go "maxBytesReader(w, r, n)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) r, n])
;; 
JOKER FUNC http.NewFileTransport has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4381942 0xc000910690 false}) NewFileTransport
;;   "NewFileTransport returns a new RoundTripper, serving the provided
;; FileSystem. The returned RoundTripper ignores the URL host in its
;; incoming requests, as well as most other properties of the
;; request.
;; 
;; The typical use case for NewFileTransport is to register the "file"
;; protocol with a Transport, as in:
;; 
;;   t := &http.Transport{}
;;   t.RegisterProtocol("file", http.NewFileTransport(http.Dir("/")))
;;   c := &http.Client{Transport: t}
;;   res, err := c.Get("file:///etc/passwd")
;;   ..."
;;   {:added "1.0"
;;    :go "newFileTransport(fs)"}
;;   [fs])
;; 
JOKER FUNC http.NewRequest has: 
;; (defn ^[{:method ^String Method, :url ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4338048 0xc000b06ea0}) URL, :proto ^String Proto, :protomajor ^Int ProtoMajor, :protominor ^Int ProtoMinor, :header Header, :body ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) Body, :getbody ^ABEND881(unrecognized Expr type *ast.FuncType at: &{4340098 0xc000d4ff20 0xc000d4ff50}) GetBody, :contentlength ContentLength, :transferencoding ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{4340746 <nil> string}) TransferEncoding, :close Close, :host ^String Host, :form ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{url Values}) Form, :postform ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{url Values}) PostForm, :multipartform ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4342844 0xc0008ea400}) MultipartForm, :trailer Trailer, :remoteaddr ^String RemoteAddr, :requesturi ^String RequestURI, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4344833 0xc0008eaae0}) TLS, :cancel ^ABEND881(unrecognized Expr type *ast.ChanType at: &{4345280 4345280 2 0xc0008eaca0}) Cancel, :response ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4345448 Response}) Response, :ctx ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx} Error] NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.
;; 
;; If the provided body is also an io.Closer, the returned
;; Request.Body is set to body and will be closed by the Client
;; methods Do, Post, and PostForm, and Transport.RoundTrip.
;; 
;; NewRequest returns a Request suitable for use with Client.Do or
;; Transport.RoundTrip. To create a request for use with testing a
;; Server Handler, either use the NewRequest function in the
;; net/http/httptest package, use ReadRequest, or manually update the
;; Request fields. See the Request type's documentation for the
;; difference between inbound and outbound request fields.
;; 
;; If body is of type *bytes.Buffer, *bytes.Reader, or
;; *strings.Reader, the returned request's ContentLength is set to its
;; exact value (instead of -1), GetBody is populated (so 307 and 308
;; redirects can replay the body), and Body is set to NoBody if the
;; ContentLength is 0."
;;   {:added "1.0"
;;    :go "newRequest(method, url, body)"}
;;   [^String method, ^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) body])
;; 
JOKER FUNC http.NewServeMux has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync RWMutex}) mu, :m ^ABEND881(unrecognized Expr type *ast.MapType at: &{4974151 string muxEntry}) m, :hosts hosts} NewServeMux
;;   "NewServeMux allocates and returns a new ServeMux."
;;   {:added "1.0"
;;    :go "newServeMux()"}
;;   [])
;; 
JOKER FUNC http.NotFound has: 
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error."
;;   {:added "1.0"
;;    :go "notFound(w, r)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4968179 Request}) r])
;; 
JOKER FUNC http.NotFoundHandler has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4910497 0xc000538f30 false}) NotFoundHandler
;;   "NotFoundHandler returns a simple request handler
;; that replies to each request with a ``404 page not found'' reply."
;;   {:added "1.0"
;;    :go "notFoundHandler()"}
;;   [])
;; 
JOKER FUNC http.ParseHTTPVersion has: 
(defn ^[major minor ok] ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.
"HTTP/1.0" returns (1, 0, true)."
  {:added "1.0"
   :go "parseHTTPVersion(vers)"}
  [^String vers])

JOKER FUNC http.ParseTime has: 
(defn ^[t err] ParseTime
  "ParseTime parses a time header (such as the Date: header),
trying each of the three formats allowed by HTTP/1.1:
TimeFormat, time.RFC850, and time.ANSIC."
  {:added "1.0"
   :go "parseTime(text)"}
  [^String text])

JOKER FUNC http.Post has: 
;; (defn ^[resp err] Post
;;   "Post issues a POST to the specified URL.
;; 
;; Caller should close resp.Body when done reading from it.
;; 
;; If the provided body is an io.Closer, it is closed after the
;; request.
;; 
;; Post is a wrapper around DefaultClient.Post.
;; 
;; To set custom headers, use NewRequest and DefaultClient.Do.
;; 
;; See the Client.Do method documentation for details on how redirects
;; are handled."
;;   {:added "1.0"
;;    :go "post(url, contentType, body)"}
;;   [^String url, ^String contentType, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) body])
;; 
JOKER FUNC http.PostForm has: 
;; (defn ^[resp err] PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and
;; values URL-encoded as the request body.
;; 
;; The Content-Type header is set to application/x-www-form-urlencoded.
;; To set other headers, use NewRequest and DefaultClient.Do.
;; 
;; When err is nil, resp always contains a non-nil resp.Body.
;; Caller should close resp.Body when done reading from it.
;; 
;; PostForm is a wrapper around DefaultClient.PostForm.
;; 
;; See the Client.Do method documentation for details on how redirects
;; are handled."
;;   {:added "1.0"
;;    :go "postForm(url, data)"}
;;   [^String url, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{url Values}) data])
;; 
JOKER FUNC http.ProxyFromEnvironment has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{url URL}) Error] ProxyFromEnvironment
;;   "ProxyFromEnvironment returns the URL of the proxy to use for a
;; given request, as indicated by the environment variables
;; HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions
;; thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https
;; requests.
;; 
;; The environment values may be either a complete URL or a
;; "host[:port]", in which case the "http" scheme is assumed.
;; An error is returned if the value is a different form.
;; 
;; A nil URL and nil error are returned if no proxy is defined in the
;; environment, or a proxy should not be used for the given request,
;; as defined by NO_PROXY.
;; 
;; As a special case, if req.URL.Host is "localhost" (with or without
;; a port number), then a nil URL and nil error will be returned."
;;   {:added "1.0"
;;    :go "proxyFromEnvironment(req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4420508 Request}) req])
;; 
JOKER FUNC http.ProxyURL has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{4420705 0xc000f4efc0 0xc000f4eff0}) ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)
;; that always returns the same URL."
;;   {:added "1.0"
;;    :go "proxyURL(fixedURL)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4420695 0xc000dd3180}) fixedURL])
;; 
JOKER FUNC http.ReadRequest has: 
;; (defn ^[{:method ^String Method, :url ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4338048 0xc000b06ea0}) URL, :proto ^String Proto, :protomajor ^Int ProtoMajor, :protominor ^Int ProtoMinor, :header Header, :body ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) Body, :getbody ^ABEND881(unrecognized Expr type *ast.FuncType at: &{4340098 0xc000d4ff20 0xc000d4ff50}) GetBody, :contentlength ContentLength, :transferencoding ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{4340746 <nil> string}) TransferEncoding, :close Close, :host ^String Host, :form ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{url Values}) Form, :postform ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{url Values}) PostForm, :multipartform ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4342844 0xc0008ea400}) MultipartForm, :trailer Trailer, :remoteaddr ^String RemoteAddr, :requesturi ^String RequestURI, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4344833 0xc0008eaae0}) TLS, :cancel ^ABEND881(unrecognized Expr type *ast.ChanType at: &{4345280 4345280 2 0xc0008eaca0}) Cancel, :response ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4345448 Response}) Response, :ctx ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx} Error] ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.
;; 
;; ReadRequest is a low-level function and should only be used for
;; specialized applications; most code should use the Server to read
;; requests and handle them via the Handler interface. ReadRequest
;; only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2."
;;   {:added "1.0"
;;    :go "readRequest(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4365090 0xc000d50aa0}) b])
;; 
JOKER FUNC http.ReadResponse has: 
;; (defn ^[{:status ^String Status, :statuscode ^Int StatusCode, :proto ^String Proto, :protomajor ^Int ProtoMajor, :protominor ^Int ProtoMinor, :header Header, :body ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) Body, :contentlength ContentLength, :transferencoding ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5013491 <nil> string}) TransferEncoding, :close Close, :uncompressed Uncompressed, :trailer Trailer, :request ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5014835 Request}) Request, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5015057 0xc000b35f20}) TLS} Error] ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.
;; The req parameter optionally specifies the Request that corresponds
;; to this Response. If nil, a GET request is assumed.
;; Clients must call resp.Body.Close when finished reading resp.Body.
;; After that call, clients can inspect resp.Trailer to find key/value
;; pairs included in the response trailer."
;;   {:added "1.0"
;;    :go "readResponse(r, req)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5016240 0xc00098eac0}) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5016259 Request}) req])
;; 
JOKER FUNC http.Redirect has: 
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,
;; which may be a path relative to the request path.
;; 
;; The provided code should be in the 3xx range and is usually
;; StatusMovedPermanently, StatusFound or StatusSeeOther.
;; 
;; If the Content-Type header has not been set, Redirect sets it
;; to "text/html; charset=utf-8" and writes a small HTML body.
;; Setting the Content-Type header to any value, including nil,
;; disables that behavior."
;;   {:added "1.0"
;;    :go "redirect(w, r, url, code)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4969573 Request}) r, ^String url, ^Int code])
;; 
JOKER FUNC http.RedirectHandler has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4910497 0xc000538f30 false}) RedirectHandler
;;   "RedirectHandler returns a request handler that redirects
;; each request it receives to the given url using the given
;; status code.
;; 
;; The provided code should be in the 3xx range and is usually
;; StatusMovedPermanently, StatusFound or StatusSeeOther."
;;   {:added "1.0"
;;    :go "redirectHandler(url, code)"}
;;   [^String url, ^Int code])
;; 
JOKER FUNC http.Serve has: 
;; (defn ^Error Serve
;;   "Serve accepts incoming HTTP connections on the listener l,
;; creating a new service goroutine for each. The service goroutines
;; read requests and then call handler to reply to them.
;; 
;; The handler is typically nil, in which case the DefaultServeMux is used.
;; 
;; HTTP/2 support is only enabled if the Listener returns *tls.Conn
;; connections and they were configured with "h2" in the TLS
;; Config.NextProtos.
;; 
;; Serve always returns a non-nil error."
;;   {:added "1.0"
;;    :go "serve(l, handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}) l, handler])
;; 
JOKER FUNC http.ServeContent has: 
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the
;; provided ReadSeeker. The main benefit of ServeContent over io.Copy
;; is that it handles Range requests properly, sets the MIME type, and
;; handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,
;; and If-Range requests.
;; 
;; If the response's Content-Type header is not set, ServeContent
;; first tries to deduce the type from name's file extension and,
;; if that fails, falls back to reading the first block of the content
;; and passing it to DetectContentType.
;; The name is otherwise unused; in particular it can be empty and is
;; never sent in the response.
;; 
;; If modtime is not the zero time or Unix epoch, ServeContent
;; includes it in a Last-Modified header in the response. If the
;; request includes an If-Modified-Since header, ServeContent uses
;; modtime to decide whether the content needs to be sent at all.
;; 
;; The content's Seek method must work: ServeContent uses
;; a seek to the end of the content to determine its size.
;; 
;; If the caller has set w's ETag header formatted per RFC 7232, section 2.3,
;; ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.
;; 
;; Note that *os.File implements the io.ReadSeeker interface."
;;   {:added "1.0"
;;    :go "serveContent(w, req, name, modtime, content)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4484550 Request}) req, ^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) modtime, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadSeeker}) content])
;; 
JOKER FUNC http.ServeFile has: 
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named
;; file or directory.
;; 
;; If the provided file or directory name is a relative path, it is
;; interpreted relative to the current directory and may ascend to
;; parent directories. If the provided name is constructed from user
;; input, it should be sanitized before calling ServeFile.
;; 
;; As a precaution, ServeFile will reject requests where r.URL.Path
;; contains a ".." path element; this protects against callers who
;; might unsafely use filepath.Join on r.URL.Path without sanitizing
;; it and then use that filepath.Join result as the name argument.
;; 
;; As another special case, ServeFile redirects any request where r.URL.Path
;; ends in "/index.html" to the same path, without the final
;; "index.html". To avoid such redirects either modify the path or
;; use ServeContent.
;; 
;; Outside of those two special cases, ServeFile does not use
;; r.URL.Path for selecting the file or directory to serve; only the
;; file or directory provided in the name argument is used."
;;   {:added "1.0"
;;    :go "serveFile(w, r, name)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4499006 Request}) r, ^String name])
;; 
JOKER FUNC http.ServeTLS has: 
;; (defn ^Error ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,
;; creating a new service goroutine for each. The service goroutines
;; read requests and then call handler to reply to them.
;; 
;; The handler is typically nil, in which case the DefaultServeMux is used.
;; 
;; Additionally, files containing a certificate and matching private key
;; for the server must be provided. If the certificate is signed by a
;; certificate authority, the certFile should be the concatenation
;; of the server's certificate, any intermediates, and the CA's certificate.
;; 
;; ServeTLS always returns a non-nil error."
;;   {:added "1.0"
;;    :go "serveTLS(l, handler, certFile, keyFile)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}) l, handler, ^String certFile, ^String keyFile])
;; 
JOKER FUNC http.SetCookie has: 
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.
;; The provided cookie must have a valid Name. Invalid cookies may be
;; silently dropped."
;;   {:added "1.0"
;;    :go "setCookie(w, cookie)"}
;;   [w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4507940 Cookie}) cookie])
;; 
JOKER FUNC http.StatusText has: 
(defn ^String StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty
string if the code is unknown."
  {:added "1.0"
   :go "statusText(code)"}
  [^Int code])

JOKER FUNC http.StripPrefix has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4910497 0xc000538f30 false}) StripPrefix
;;   "StripPrefix returns a handler that serves HTTP requests
;; by removing the given prefix from the request URL's Path
;; and invoking the handler h. StripPrefix handles a
;; request for a path that doesn't begin with prefix by
;; replying with an HTTP 404 not found error."
;;   {:added "1.0"
;;    :go "stripPrefix(prefix, h)"}
;;   [^String prefix, h])
;; 
JOKER FUNC http.TimeoutHandler has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4910497 0xc000538f30 false}) TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.
;; 
;; The new Handler calls h.ServeHTTP to handle each request, but if a
;; call runs for longer than its time limit, the handler responds with
;; a 503 Service Unavailable error and the given message in its body.
;; (If msg is empty, a suitable default message will be sent.)
;; After such a timeout, writes by h to its ResponseWriter will return
;; ErrHandlerTimeout.
;; 
;; TimeoutHandler buffers all Handler writes to memory and does not
;; support the Hijacker or Flusher interfaces."
;;   {:added "1.0"
;;    :go "timeoutHandler(h, dt, msg)"}
;;   [h, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}) dt, ^String msg])
;; 
JOKER FUNC httpguts.HeaderValuesContainsToken has: 
;; (defn ^ABEND042(cannot find typename httpguts.bool) HeaderValuesContainsToken
;;   "HeaderValuesContainsToken reports whether any string in values
;; contains the provided token, ASCII case-insensitively."
;;   {:added "1.0"
;;    :go "headerValuesContainsToken(values, token)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8278502 <nil> string}) values, ^String token])
;; 
JOKER FUNC httpguts.IsTokenRune has: 
;; (defn ^ABEND042(cannot find typename httpguts.bool) IsTokenRune
;;   {:added "1.0"
;;    :go "isTokenRune(r)"}
;;   [r])
;; 
JOKER FUNC httpguts.PunycodeHostPort has: 
(defn ^[String Error] PunycodeHostPort
  "PunycodeHostPort returns the IDNA Punycode version
of the provided "host" or "host:port" string."
  {:added "1.0"
   :go "punycodeHostPort(v)"}
  [^String v])

JOKER FUNC httpguts.ValidHeaderFieldName has: 
;; (defn ^ABEND042(cannot find typename httpguts.bool) ValidHeaderFieldName
;;   "ValidHeaderFieldName reports whether v is a valid HTTP/1.x header name.
;; HTTP/2 imposes the additional restriction that uppercase ASCII
;; letters are not allowed.
;; 
;;  RFC 7230 says:
;;   header-field   = field-name ":" OWS field-value OWS
;;   field-name     = token
;;   token          = 1*tchar
;;   tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
;;           "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA"
;;   {:added "1.0"
;;    :go "validHeaderFieldName(v)"}
;;   [^String v])
;; 
JOKER FUNC httpguts.ValidHeaderFieldValue has: 
;; (defn ^ABEND042(cannot find typename httpguts.bool) ValidHeaderFieldValue
;;   "ValidHeaderFieldValue reports whether v is a valid "field-value" according to
;; http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 :
;; 
;;        message-header = field-name ":" [ field-value ]
;;        field-value    = *( field-content | LWS )
;;        field-content  = <the OCTETs making up the field-value
;;                         and consisting of either *TEXT or combinations
;;                         of token, separators, and quoted-string>
;; 
;; http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2 :
;; 
;;        TEXT           = <any OCTET except CTLs,
;;                          but including LWS>
;;        LWS            = [CRLF] 1*( SP | HT )
;;        CTL            = <any US-ASCII control character
;;                         (octets 0 - 31) and DEL (127)>
;; 
;; RFC 7230 says:
;;  field-value    = *( field-content / obs-fold )
;;  obj-fold       =  N/A to http2, and deprecated
;;  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
;;  field-vchar    = VCHAR / obs-text
;;  obs-text       = %x80-FF
;;  VCHAR          = "any visible [USASCII] character"
;; 
;; http2 further says: "Similarly, HTTP/2 allows header field values
;; that are not valid. While most of the values that can be encoded
;; will not alter header field parsing, carriage return (CR, ASCII
;; 0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII
;; 0x0) might be exploited by an attacker if they are translated
;; verbatim. Any request or response that contains a character not
;; permitted in a header field value MUST be treated as malformed
;; (Section 8.1.2.6). Valid characters are defined by the
;; field-content ABNF rule in Section 3.2 of [RFC7230]."
;; 
;; This function does not (yet?) properly handle the rejection of
;; strings that begin or end with SP or HTAB."
;;   {:added "1.0"
;;    :go "validHeaderFieldValue(v)"}
;;   [^String v])
;; 
JOKER FUNC httpguts.ValidHostHeader has: 
;; (defn ^ABEND042(cannot find typename httpguts.bool) ValidHostHeader
;;   "ValidHostHeader reports whether h is a valid host header."
;;   {:added "1.0"
;;    :go "validHostHeader(h)"}
;;   [^String h])
;; 
JOKER FUNC httpguts.ValidTrailerHeader has: 
;; (defn ^ABEND042(cannot find typename httpguts.bool) ValidTrailerHeader
;;   "ValidTrailerHeader reports whether name is a valid header field name to appear
;; in trailers.
;; See RFC 7230, Section 4.1.2"
;;   {:added "1.0"
;;    :go "validTrailerHeader(name)"}
;;   [^String name])
;; 
JOKER FUNC httpproxy.FromEnvironment has: 
(defn ^{:httpproxy ^String HTTPProxy, :httpsproxy ^String HTTPSProxy, :noproxy ^String NoProxy, :cgi CGI} FromEnvironment
  "FromEnvironment returns a Config instance populated from the
environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the
lowercase versions thereof). HTTPS_PROXY takes precedence over
HTTP_PROXY for https requests.

The environment values may be either a complete URL or a
"host[:port]", in which case the "http" scheme is assumed. An error
is returned if the value is a different form."
  {:added "1.0"
   :go "fromEnvironment()"}
  [])

JOKER FUNC httptest.NewRecorder has: 
;; (defn ^{:code ^Int Code, :headermap ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http Header}) HeaderMap, :body ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5070763 0xc00108fc00}) Body, :flushed Flushed, :result ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5070855 0xc00108fd40}) result, :snapheader ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http Header}) snapHeader, :wroteheader wroteHeader} NewRecorder
;;   "NewRecorder returns an initialized ResponseRecorder."
;;   {:added "1.0"
;;    :go "newRecorder()"}
;;   [])
;; 
JOKER FUNC httptest.NewRequest has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{http Request}) NewRequest
;;   "NewRequest returns a new incoming server Request, suitable
;; for passing to an http.Handler for testing.
;; 
;; The target is the RFC 7230 "request-target": it may be either a
;; path or an absolute URL. If target is an absolute URL, the host name
;; from the URL is used. Otherwise, "example.com" is used.
;; 
;; The TLS field is set to a non-nil dummy value if target has scheme
;; "https".
;; 
;; The Request.Proto is always HTTP/1.1.
;; 
;; An empty method means "GET".
;; 
;; The provided body may be nil. If the body is of type *bytes.Reader,
;; *strings.Reader, or *bytes.Buffer, the Request.ContentLength is
;; set.
;; 
;; NewRequest panics on error for ease of use in testing, where a
;; panic is acceptable.
;; 
;; To generate a client HTTP request instead of a server request, see
;; the NewRequest function in the net/http package."
;;   {:added "1.0"
;;    :go "newRequest(method, target, body)"}
;;   [^String method, ^String target, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) body])
;; 
JOKER FUNC httptest.NewServer has: 
;; (defn ^{:url ^String URL, :listener ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}) Listener, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079004 0xc0011e86a0}) TLS, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079118 0xc0011e87c0}) Config, :certificate ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079224 0xc0011e88a0}) certificate, :wg ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync WaitGroup}) wg, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :closed closed, :conns ^ABEND881(unrecognized Expr type *ast.MapType at: &{5079450 0xc0011e8b20 0xc0011e8b80}) conns, :client ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079627 0xc0011e8ca0}) client} NewServer
;;   "NewServer starts and returns a new Server.
;; The caller should call Close when finished, to shut it down."
;;   {:added "1.0"
;;    :go "newServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http Handler}) handler])
;; 
JOKER FUNC httptest.NewTLSServer has: 
;; (defn ^{:url ^String URL, :listener ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}) Listener, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079004 0xc0011e86a0}) TLS, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079118 0xc0011e87c0}) Config, :certificate ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079224 0xc0011e88a0}) certificate, :wg ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync WaitGroup}) wg, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :closed closed, :conns ^ABEND881(unrecognized Expr type *ast.MapType at: &{5079450 0xc0011e8b20 0xc0011e8b80}) conns, :client ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079627 0xc0011e8ca0}) client} NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.
;; The caller should call Close when finished, to shut it down."
;;   {:added "1.0"
;;    :go "newTLSServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http Handler}) handler])
;; 
JOKER FUNC httptest.NewUnstartedServer has: 
;; (defn ^{:url ^String URL, :listener ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}) Listener, :tls ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079004 0xc0011e86a0}) TLS, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079118 0xc0011e87c0}) Config, :certificate ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079224 0xc0011e88a0}) certificate, :wg ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync WaitGroup}) wg, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :closed closed, :conns ^ABEND881(unrecognized Expr type *ast.MapType at: &{5079450 0xc0011e8b20 0xc0011e8b80}) conns, :client ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5079627 0xc0011e8ca0}) client} NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.
;; 
;; After changing its configuration, the caller should call Start or
;; StartTLS.
;; 
;; The caller should call Close when finished, to shut it down."
;;   {:added "1.0"
;;    :go "newUnstartedServer(handler)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http Handler}) handler])
;; 
JOKER FUNC httptrace.ContextClientTrace has: 
;; (defn ^{:getconn ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5090750 0xc000d96750 <nil>}) GetConn, :gotconn ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5090961 0xc000d96870 <nil>}) GotConn, :putidleconn ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5091424 0xc000d96960 <nil>}) PutIdleConn, :gotfirstresponsebyte ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5091560 0xc000d96a50 <nil>}) GotFirstResponseByte, :got100continue ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5091671 0xc000d96ba0 <nil>}) Got100Continue, :got1xxresponse ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5091995 0xc000d96c00 0xc000d96c60}) Got1xxResponse, :dnsstart ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5092105 0xc000d96d20 <nil>}) DNSStart, :dnsdone ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5092180 0xc000d96db0 <nil>}) DNSDone, :connectstart ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5092388 0xc000d96ea0 <nil>}) ConnectStart, :connectdone ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5092685 0xc000d96ff0 <nil>}) ConnectDone, :tlshandshakestart ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5092943 0xc000d971a0 <nil>}) TLSHandshakeStart, :tlshandshakedone ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5093130 0xc000d97230 <nil>}) TLSHandshakeDone, :wroteheaderfield ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5093364 0xc000d97380 <nil>}) WroteHeaderField, :wroteheaders ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5093496 0xc000d97530 <nil>}) WroteHeaders, :wait100continue ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5093746 0xc000d976e0 <nil>}) Wait100Continue, :wroterequest ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5093921 0xc000d97770 <nil>}) WroteRequest} ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the
;; provided context. If none, it returns nil."
;;   {:added "1.0"
;;    :go "contextClientTrace(ctx)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx])
;; 
JOKER FUNC httptrace.WithClientTrace has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent
;; ctx. HTTP client requests made with the returned context will use
;; the provided trace hooks, in addition to any previous hooks
;; registered with ctx. Any hooks defined in the provided trace will
;; be called first."
;;   {:added "1.0"
;;    :go "withClientTrace(ctx, trace)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5089163 ClientTrace}) trace])
;; 
JOKER FUNC httputil.DumpRequest has: 
;; (defn ^[[ABEND042(cannot find typename httputil.byte)] Error] DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire
;; representation. It should only be used by servers to debug client
;; requests. The returned representation is an approximation only;
;; some details of the initial request are lost while parsing it into
;; an http.Request. In particular, the order and case of header field
;; names are lost. The order of values in multi-valued headers is kept
;; intact. HTTP/2 requests are dumped in HTTP/1.x form, not in their
;; original binary representations.
;; 
;; If body is true, DumpRequest also returns the body. To do so, it
;; consumes req.Body and then replaces it with a new io.ReadCloser
;; that yields the same bytes. If DumpRequest returns an error,
;; the state of req is undefined.
;; 
;; The documentation for http.Request.Write details which fields
;; of req are included in the dump."
;;   {:added "1.0"
;;    :go "dumpRequest(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5103758 0xc001043cc0}) req, body])
;; 
JOKER FUNC httputil.DumpRequestOut has: 
;; (defn ^[[ABEND042(cannot find typename httputil.byte)] Error] DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It
;; includes any headers that the standard http.Transport adds, such as
;; User-Agent."
;;   {:added "1.0"
;;    :go "dumpRequestOut(req, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5099971 0xc0010d2fa0}) req, body])
;; 
JOKER FUNC httputil.DumpResponse has: 
;; (defn ^[[ABEND042(cannot find typename httputil.byte)] Error] DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response."
;;   {:added "1.0"
;;    :go "dumpResponse(resp, body)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5106288 0xc00112e280}) resp, body])
;; 
JOKER FUNC httputil.NewChunkedReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r
;; out of HTTP "chunked" format before returning it.
;; The chunkedReader returns io.EOF when the final 0-length chunk is read.
;; 
;; NewChunkedReader is not needed by normal applications. The http package
;; automatically decodes chunking when reading response bodies."
;;   {:added "1.0"
;;    :go "newChunkedReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC httputil.NewChunkedWriter has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io WriteCloser}) NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP
;; "chunked" format before writing them to w. Closing the returned chunkedWriter
;; sends the final 0-length chunk that marks the end of the stream but does
;; not send the final CRLF that appears after trailers; trailers and the last
;; CRLF must be written separately.
;; 
;; NewChunkedWriter is not needed by normal applications. The http
;; package adds chunking automatically if handlers don't set a
;; Content-Length header. Using NewChunkedWriter inside a handler
;; would result in double chunking or chunking with a Content-Length
;; length, both of which are wrong."
;;   {:added "1.0"
;;    :go "newChunkedWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC httputil.NewClientConn has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) c, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5124867 0xc000fb8100}) r, :re re, :we we, :lastbody ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) lastbody, :nread ^Int nread, :nwritten ^Int nwritten, :pipereq ^ABEND881(unrecognized Expr type *ast.MapType at: &{5124994 0xc000fb83a0 uint}) pipereq, :pipe ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{textproto Pipeline}) pipe, :writereq ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5125057 0xc0010bee70 0xc0010beed0}) writeReq} NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.
;; It is low-level, old, and unused by Go's current HTTP stack.
;; We should have deleted it before Go 1.
;; 
;; Deprecated: Use the Client or Transport in package net/http instead."
;;   {:added "1.0"
;;    :go "newClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5125378 0xc000fb87c0}) r])
;; 
JOKER FUNC httputil.NewProxyClientConn has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) c, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5124867 0xc000fb8100}) r, :re re, :we we, :lastbody ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) lastbody, :nread ^Int nread, :nwritten ^Int nwritten, :pipereq ^ABEND881(unrecognized Expr type *ast.MapType at: &{5124994 0xc000fb83a0 uint}) pipereq, :pipe ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{textproto Pipeline}) pipe, :writereq ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5125057 0xc0010bee70 0xc0010beed0}) writeReq} NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.
;; It is low-level, old, and unused by Go's current HTTP stack.
;; We should have deleted it before Go 1.
;; 
;; Deprecated: Use the Client or Transport in package net/http instead."
;;   {:added "1.0"
;;    :go "newProxyClientConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5125875 0xc000fb8e20}) r])
;; 
JOKER FUNC httputil.NewServerConn has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) c, :r ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5119904 0xc001141280}) r, :re re, :we we, :lastbody ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) lastbody, :nread ^Int nread, :nwritten ^Int nwritten, :pipereq ^ABEND881(unrecognized Expr type *ast.MapType at: &{5120031 0xc001141520 uint}) pipereq, :pipe ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{textproto Pipeline}) pipe} NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.
;; It is low-level, old, and unused by Go's current HTTP stack.
;; We should have deleted it before Go 1.
;; 
;; Deprecated: Use the Server in package net/http instead."
;;   {:added "1.0"
;;    :go "newServerConn(c, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) c, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5120351 0xc0011417e0}) r])
;; 
JOKER FUNC httputil.NewSingleHostReverseProxy has: 
;; (defn ^{:director ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5107863 0xc001023530 <nil>}) Director, :transport ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http RoundTripper}) Transport, :flushinterval ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}) FlushInterval, :errorlog ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5108388 0xc00112f7c0}) ErrorLog, :bufferpool BufferPool, :modifyresponse ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5109024 0xc001023620 0xc001023650}) ModifyResponse, :errorhandler ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5109290 0xc001023740 <nil>}) ErrorHandler} NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes
;; URLs to the scheme, host, and base path provided in target. If the
;; target's path is "/base" and the incoming request was for "/dir",
;; the target request will be for /base/dir.
;; NewSingleHostReverseProxy does not rewrite the Host header.
;; To rewrite Host headers, use ReverseProxy directly with a custom
;; Director policy."
;;   {:added "1.0"
;;    :go "newSingleHostReverseProxy(target)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5110189 0xc000e345c0}) target])
;; 
JOKER FUNC idna.BidiRule has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{8341259 0xc0017f4090 <nil>}) BidiRule
;;   "BidiRule enables the Bidi rule as defined in RFC 5893. Any application
;; that relies on proper validation of labels should include this rule."
;;   {:added "1.0"
;;    :go "bidiRule()"}
;;   [])
;; 
JOKER FUNC idna.MapForLookup has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{8341259 0xc0017f4090 <nil>}) MapForLookup
;;   "MapForLookup sets validation and mapping options such that a given IDN is
;; transformed for domain name lookup according to the requirements set out in
;; Section 5 of RFC 5891. The mappings follow the recommendations of RFC 5894,
;; RFC 5895 and UTS 46. It does not add the Bidi Rule. Use the BidiRule option
;; to add this check.
;; 
;; The mappings include normalization and mapping case, width and other
;; compatibility mappings."
;;   {:added "1.0"
;;    :go "mapForLookup()"}
;;   [])
;; 
JOKER FUNC idna.New has: 
;; (defn ^{} New
;;   "New creates a new Profile.
;; 
;; With no options, the returned Profile is the most permissive and equals the
;; Punycode Profile. Options can be passed to further restrict the Profile. The
;; MapForLookup and ValidateForRegistration options set a collection of options,
;; for lookup and registration purposes respectively, which can be tailored by
;; adding more fine-grained options, where later options override earlier
;; options."
;;   {:added "1.0"
;;    :go "new(o)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{8346082 Option}) o])
;; 
JOKER FUNC idna.RemoveLeadingDots has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{8341259 0xc0017f4090 <nil>}) RemoveLeadingDots
;;   "RemoveLeadingDots removes leading label separators. Leading runes that map to
;; dots, such as U+3002 IDEOGRAPHIC FULL STOP, are removed as well.
;; 
;; This is the behavior suggested by the UTS #46 and is adopted by some
;; browsers."
;;   {:added "1.0"
;;    :go "removeLeadingDots(remove)"}
;;   [remove])
;; 
JOKER FUNC idna.StrictDomainName has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{8341259 0xc0017f4090 <nil>}) StrictDomainName
;;   "StrictDomainName limits the set of permissible ASCII characters to those
;; allowed in domain names as defined in RFC 1034 (A-Z, a-z, 0-9 and the
;; hyphen). This is set by default for MapForLookup and ValidateForRegistration.
;; 
;; This option is useful, for instance, for browsers that allow characters
;; outside this range, for example a '_' (U+005F LOW LINE). See
;; http://www.rfc-editor.org/std/std3.txt for more details This option
;; corresponds to the UseSTD3ASCIIRules option in UTS #46."
;;   {:added "1.0"
;;    :go "strictDomainName(use)"}
;;   [use])
;; 
JOKER FUNC idna.ToASCII has: 
(defn ^[String Error] ToASCII
  "ToASCII is a wrapper for Punycode.ToASCII."
  {:added "1.0"
   :go "toASCII(s)"}
  [^String s])

JOKER FUNC idna.ToUnicode has: 
(defn ^[String Error] ToUnicode
  "ToUnicode is a wrapper for Punycode.ToUnicode."
  {:added "1.0"
   :go "toUnicode(s)"}
  [^String s])

JOKER FUNC idna.Transitional has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{8341259 0xc0017f4090 <nil>}) Transitional
;;   "Transitional sets a Profile to use the Transitional mapping as defined in UTS
;; #46. This will cause, for example, "ß" to be mapped to "ss". Using the
;; transitional mapping provides a compromise between IDNA2003 and IDNA2008
;; compatibility. It is used by most browsers when resolving domain names. This
;; option is only meaningful if combined with MapForLookup."
;;   {:added "1.0"
;;    :go "transitional(transitional)"}
;;   [transitional])
;; 
JOKER FUNC idna.ValidateForRegistration has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{8341259 0xc0017f4090 <nil>}) ValidateForRegistration
;;   "ValidateForRegistration sets validation options to verify that a given IDN is
;; properly formatted for registration as defined by Section 4 of RFC 5891."
;;   {:added "1.0"
;;    :go "validateForRegistration()"}
;;   [])
;; 
JOKER FUNC idna.ValidateLabels has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{8341259 0xc0017f4090 <nil>}) ValidateLabels
;;   "ValidateLabels sets whether to check the mandatory label validation criteria
;; as defined in Section 5.4 of RFC 5891. This includes testing for correct use
;; of hyphens ('-'), normalization, validity of runes, and the context rules."
;;   {:added "1.0"
;;    :go "validateLabels(enable)"}
;;   [enable])
;; 
JOKER FUNC idna.VerifyDNSLength has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{8341259 0xc0017f4090 <nil>}) VerifyDNSLength
;;   "VerifyDNSLength sets whether a Profile should fail if any of the IDN parts
;; are longer than allowed by the RFC."
;;   {:added "1.0"
;;    :go "verifyDNSLength(verify)"}
;;   [verify])
;; 
JOKER FUNC image.Decode has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{3240222 0xc0007229f0 false}) String Error] Decode
;;   "Decode decodes an image that has been encoded in a registered format.
;; The string returned is the format name used during format registration.
;; Format registration is typically done by an init function in the codec-
;; specific package."
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC image.DecodeConfig has: 
;; (defn ^[{:colormodel ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{color Model}) ColorModel, :width ^Int Width, :height ^Int Height} String Error] DecodeConfig
;;   "DecodeConfig decodes the color model and dimensions of an image that has
;; been encoded in a registered format. The string returned is the format name
;; used during format registration. Format registration is typically done by
;; an init function in the codec-specific package."
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC image.NewAlpha has: 
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3252553 <nil> uint8}) Pix, :stride ^Int Stride, :rect Rect} NewAlpha
;;   "NewAlpha returns a new Alpha image with the given bounds."
;;   {:added "1.0"
;;    :go "newAlpha(r)"}
;;   [r])
;; 
JOKER FUNC image.NewAlpha16 has: 
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3254947 <nil> uint8}) Pix, :stride ^Int Stride, :rect Rect} NewAlpha16
;;   "NewAlpha16 returns a new Alpha16 image with the given bounds."
;;   {:added "1.0"
;;    :go "newAlpha16(r)"}
;;   [r])
;; 
JOKER FUNC image.NewCMYK has: 
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3261937 <nil> uint8}) Pix, :stride ^Int Stride, :rect Rect} NewCMYK
;;   "NewCMYK returns a new CMYK image with the given bounds."
;;   {:added "1.0"
;;    :go "newCMYK(r)"}
;;   [r])
;; 
JOKER FUNC image.NewGray has: 
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3257514 <nil> uint8}) Pix, :stride ^Int Stride, :rect Rect} NewGray
;;   "NewGray returns a new Gray image with the given bounds."
;;   {:added "1.0"
;;    :go "newGray(r)"}
;;   [r])
;; 
JOKER FUNC image.NewGray16 has: 
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3259649 <nil> uint8}) Pix, :stride ^Int Stride, :rect Rect} NewGray16
;;   "NewGray16 returns a new Gray16 image with the given bounds."
;;   {:added "1.0"
;;    :go "newGray16(r)"}
;;   [r])
;; 
JOKER FUNC image.NewNRGBA has: 
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3246935 <nil> uint8}) Pix, :stride ^Int Stride, :rect Rect} NewNRGBA
;;   "NewNRGBA returns a new NRGBA image with the given bounds."
;;   {:added "1.0"
;;    :go "newNRGBA(r)"}
;;   [r])
;; 
JOKER FUNC image.NewNRGBA64 has: 
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3249502 <nil> uint8}) Pix, :stride ^Int Stride, :rect Rect} NewNRGBA64
;;   "NewNRGBA64 returns a new NRGBA64 image with the given bounds."
;;   {:added "1.0"
;;    :go "newNRGBA64(r)"}
;;   [r])
;; 
JOKER FUNC image.NewNYCbCrA has: 
;; (defn ^{:a ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3232191 <nil> uint8}) A, :astride ^Int AStride} NewNYCbCrA
;;   "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample
;; ratio."
;;   {:added "1.0"
;;    :go "newNYCbCrA(r, subsampleRatio)"}
;;   [r, subsampleRatio])
;; 
JOKER FUNC image.NewPaletted has: 
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3264216 <nil> uint8}) Pix, :stride ^Int Stride, :rect Rect, :palette ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{color Palette}) Palette} NewPaletted
;;   "NewPaletted returns a new Paletted image with the given width, height and
;; palette."
;;   {:added "1.0"
;;    :go "newPaletted(r, p)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{color Palette}) p])
;; 
JOKER FUNC image.NewRGBA has: 
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3241368 <nil> uint8}) Pix, :stride ^Int Stride, :rect Rect} NewRGBA
;;   "NewRGBA returns a new RGBA image with the given bounds."
;;   {:added "1.0"
;;    :go "newRGBA(r)"}
;;   [r])
;; 
JOKER FUNC image.NewRGBA64 has: 
;; (defn ^{:pix ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3243906 <nil> uint8}) Pix, :stride ^Int Stride, :rect Rect} NewRGBA64
;;   "NewRGBA64 returns a new RGBA64 image with the given bounds."
;;   {:added "1.0"
;;    :go "newRGBA64(r)"}
;;   [r])
;; 
JOKER FUNC image.NewUniform has: 
;; (defn ^{:c ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{color Color}) C} NewUniform
;;   {:added "1.0"
;;    :go "newUniform(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{color Color}) c])
;; 
JOKER FUNC image.NewYCbCr has: 
;; (defn ^{:y ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3228561 <nil> uint8}) Y, :cb ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3228561 <nil> uint8}) Cb, :cr ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3228561 <nil> uint8}) Cr, :ystride ^Int YStride, :cstride ^Int CStride, :subsampleratio SubsampleRatio, :rect Rect} NewYCbCr
;;   "NewYCbCr returns a new YCbCr image with the given bounds and subsample
;; ratio."
;;   {:added "1.0"
;;    :go "newYCbCr(r, subsampleRatio)"}
;;   [r, subsampleRatio])
;; 
JOKER FUNC image.Pt has: 
(defn ^{:x ^Int X, :y ^Int Y} Pt
  "Pt is shorthand for Point{X, Y}."
  {:added "1.0"
   :go "pt(X, Y)"}
  [^Int X, ^Int Y])

JOKER FUNC image.Rect has: 
(defn ^{:min Min, :max Max} Rect
  "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned
rectangle has minimum and maximum coordinates swapped if necessary so that
it is well-formed."
  {:added "1.0"
   :go "rect(x0, y0, x1, y1)"}
  [^Int x0, ^Int y0, ^Int x1, ^Int y1])

JOKER FUNC image.RegisterFormat has: 
;; (defn RegisterFormat
;;   "RegisterFormat registers an image format for use by Decode.
;; Name is the name of the format, like "jpeg" or "png".
;; Magic is the magic prefix that identifies the format's encoding. The magic
;; string can contain "?" wildcards that each match any one byte.
;; Decode is the function that decodes the encoded image.
;; DecodeConfig is the function that decodes just its configuration."
;;   {:added "1.0"
;;    :go "registerFormat(name, magic, decode, decodeConfig)"}
;;   [^String name, ^String magic, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{3237082 0xc0004d8f30 0xc0004d8ff0}) decode, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{3237127 0xc0004d9170 0xc0004d91a0}) decodeConfig])
;; 
JOKER FUNC importer.Default has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{types Importer}) Default
;;   "Default returns an Importer for the compiler that built the running binary.
;; If available, the result implements types.ImporterFrom."
;;   {:added "1.0"
;;    :go "default()"}
;;   [])
;; 
JOKER FUNC importer.For has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{types Importer}) For
;;   "For returns an Importer for importing from installed packages
;; for the compilers "gc" and "gccgo", or for importing directly
;; from the source if the compiler argument is "source". In this
;; latter case, importing may fail under circumstances where the
;; exported API is not entirely defined in pure Go source code
;; (if the package API depends on cgo-defined entities, the type
;; checker won't have access to those).
;; 
;; If lookup is nil, the default package lookup mechanism for the
;; given compiler is used, and the resulting importer attempts
;; to resolve relative and absolute import paths to canonical
;; import path IDs before finding the imported file.
;; 
;; If lookup is non-nil, then the returned importer calls lookup
;; each time it needs to resolve an import path. In this mode
;; the importer can only be invoked with canonical import paths
;; (not relative or absolute ones); it is assumed that the translation
;; to canonical import paths is being done by the client of the
;; importer."
;;   {:added "1.0"
;;    :go "for(compiler, lookup)"}
;;   [^String compiler, lookup])
;; 
JOKER FUNC io.Copy has: 
(defn ^[written err] Copy
  "Copy copies from src to dst until either EOF is reached
on src or an error occurs. It returns the number of bytes
copied and the first error encountered while copying, if any.

A successful Copy returns err == nil, not err == EOF.
Because Copy is defined to read from src until EOF, it does
not treat an EOF from Read as an error to be reported.

If src implements the WriterTo interface,
the copy is implemented by calling src.WriteTo(dst).
Otherwise, if dst implements the ReaderFrom interface,
the copy is implemented by calling dst.ReadFrom(src)."
  {:added "1.0"
   :go "copy(dst, src)"}
  [dst, src])

JOKER FUNC io.CopyBuffer has: 
;; (defn ^[written err] CopyBuffer
;;   "CopyBuffer is identical to Copy except that it stages through the
;; provided buffer (if one is required) rather than allocating a
;; temporary one. If buf is nil, one is allocated; otherwise if it has
;; zero length, CopyBuffer panics."
;;   {:added "1.0"
;;    :go "copyBuffer(dst, src, buf)"}
;;   [dst, src, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3503212 <nil> byte}) buf])
;; 
JOKER FUNC io.CopyN has: 
(defn ^[written err] CopyN
  "CopyN copies n bytes (or until an error) from src to dst.
It returns the number of bytes copied and the earliest
error encountered while copying.
On return, written == n if and only if err == nil.

If dst implements the ReaderFrom interface,
the copy is implemented using it."
  {:added "1.0"
   :go "copyN(dst, src, n)"}
  [dst, src, n])

JOKER FUNC io.LimitReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{3493359 0xc000e696e0 false}) LimitReader
;;   "LimitReader returns a Reader that reads from r
;; but stops with EOF after n bytes.
;; The underlying implementation is a *LimitedReader."
;;   {:added "1.0"
;;    :go "limitReader(r, n)"}
;;   [r, n])
;; 
JOKER FUNC io.MultiReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{3493359 0xc000e696e0 false}) MultiReader
;;   "MultiReader returns a Reader that's the logical concatenation of
;; the provided input readers. They're read sequentially. Once all
;; inputs have returned EOF, Read will return EOF.  If any of the readers
;; return a non-nil, non-EOF error, Read will return that error."
;;   {:added "1.0"
;;    :go "multiReader(readers)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3513483 Reader}) readers])
;; 
JOKER FUNC io.MultiWriter has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{3493850 0xc000e697d0 false}) MultiWriter
;;   "MultiWriter creates a writer that duplicates its writes to all the
;; provided writers, similar to the Unix tee(1) command.
;; 
;; Each write is written to each listed writer, one at a time.
;; If a listed writer returns an error, that overall write operation
;; stops and returns the error; it does not continue down the list."
;;   {:added "1.0"
;;    :go "multiWriter(writers)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3514660 Writer}) writers])
;; 
JOKER FUNC io.NewSectionReader has: 
(defn ^{:r r, :base base, :off off, :limit limit} NewSectionReader
  "NewSectionReader returns a SectionReader that reads from r
starting at offset off and stops with EOF after n bytes."
  {:added "1.0"
   :go "newSectionReader(r, off, n)"}
  [r, off, n])

JOKER FUNC io.Pipe has: 
;; (defn ^[{:p ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{3509634 pipe}) p} {:p ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{3510432 pipe}) p}] Pipe
;;   "Pipe creates a synchronous in-memory pipe.
;; It can be used to connect code expecting an io.Reader
;; with code expecting an io.Writer.
;; 
;; Reads and Writes on the pipe are matched one to one
;; except when multiple Reads are needed to consume a single Write.
;; That is, each Write to the PipeWriter blocks until it has satisfied
;; one or more Reads from the PipeReader that fully consume
;; the written data.
;; The data is copied directly from the Write to the corresponding
;; Read (or Reads); there is no internal buffering.
;; 
;; It is safe to call Read and Write in parallel with each other or with Close.
;; Parallel calls to Read and parallel calls to Write are also safe:
;; the individual calls will be gated sequentially."
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])
;; 
JOKER FUNC io.ReadAtLeast has: 
;; (defn ^[n err] ReadAtLeast
;;   "ReadAtLeast reads from r into buf until it has read at least min bytes.
;; It returns the number of bytes copied and an error if fewer bytes were read.
;; The error is EOF only if no bytes were read.
;; If an EOF happens after reading fewer than min bytes,
;; ReadAtLeast returns ErrUnexpectedEOF.
;; If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.
;; On return, n >= min if and only if err == nil.
;; If r returns an error having read at least min bytes, the error is dropped."
;;   {:added "1.0"
;;    :go "readAtLeast(r, buf, min)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3500892 <nil> byte}) buf, ^Int min])
;; 
JOKER FUNC io.ReadFull has: 
;; (defn ^[n err] ReadFull
;;   "ReadFull reads exactly len(buf) bytes from r into buf.
;; It returns the number of bytes copied and an error if fewer bytes were read.
;; The error is EOF only if no bytes were read.
;; If an EOF happens after reading some but not all the bytes,
;; ReadFull returns ErrUnexpectedEOF.
;; On return, n == len(buf) if and only if err == nil.
;; If r returns an error having read at least len(buf) bytes, the error is dropped."
;;   {:added "1.0"
;;    :go "readFull(r, buf)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3501617 <nil> byte}) buf])
;; 
JOKER FUNC io.TeeReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{3493359 0xc000e696e0 false}) TeeReader
;;   "TeeReader returns a Reader that writes to w what it reads from r.
;; All reads from r performed through it are matched with
;; corresponding writes to w. There is no internal buffering -
;; the write must complete before the read completes.
;; Any error encountered while writing is reported as a read error."
;;   {:added "1.0"
;;    :go "teeReader(r, w)"}
;;   [r, w])
;; 
JOKER FUNC io.WriteString has: 
(defn ^[n err] WriteString
  "WriteString writes the contents of the string s to w, which accepts a slice of bytes.
If w implements a WriteString method, it is invoked directly.
Otherwise, w.Write is called exactly once."
  {:added "1.0"
   :go "writeString(w, s)"}
  [w, ^String s])

JOKER FUNC iotest.DataErrReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) DataErrReader
;;   "DataErrReader changes the way errors are handled by a Reader. Normally, a
;; Reader returns an error (typically EOF) from the first Read call after the
;; last piece of data is read. DataErrReader wraps a Reader and changes its
;; behavior so the final error is returned along with the final data, instead
;; of in the first call after the final data."
;;   {:added "1.0"
;;    :go "dataErrReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC iotest.HalfReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) HalfReader
;;   "HalfReader returns a Reader that implements Read
;; by reading half as many requested bytes from r."
;;   {:added "1.0"
;;    :go "halfReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC iotest.NewReadLogger has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) NewReadLogger
;;   "NewReadLogger returns a reader that behaves like r except
;; that it logs (using log.Printf) each read to standard error,
;; printing the prefix and the hexadecimal data read."
;;   {:added "1.0"
;;    :go "newReadLogger(prefix, r)"}
;;   [^String prefix, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC iotest.NewWriteLogger has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) NewWriteLogger
;;   "NewWriteLogger returns a writer that behaves like w except
;; that it logs (using log.Printf) each write to standard error,
;; printing the prefix and the hexadecimal data written."
;;   {:added "1.0"
;;    :go "newWriteLogger(prefix, w)"}
;;   [^String prefix, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC iotest.OneByteReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) OneByteReader
;;   "OneByteReader returns a Reader that implements
;; each non-empty Read by reading one byte from r."
;;   {:added "1.0"
;;    :go "oneByteReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC iotest.TimeoutReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) TimeoutReader
;;   "TimeoutReader returns ErrTimeout on the second read
;; with no data. Subsequent calls to read succeed."
;;   {:added "1.0"
;;    :go "timeoutReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC iotest.TruncateWriter has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) TruncateWriter
;;   "TruncateWriter returns a Writer that writes to w
;; but stops silently after n bytes."
;;   {:added "1.0"
;;    :go "truncateWriter(w, n)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, n])
;; 
JOKER FUNC ioutil.NopCloser has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) NopCloser
;;   "NopCloser returns a ReadCloser with a no-op Close method wrapping
;; the provided Reader r."
;;   {:added "1.0"
;;    :go "nopCloser(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC ioutil.ReadAll has: 
;; (defn ^[[ABEND042(cannot find typename ioutil.byte)] Error] ReadAll
;;   "ReadAll reads from r until an error or EOF and returns the data it read.
;; A successful call returns err == nil, not err == EOF. Because ReadAll is
;; defined to read from src until EOF, it does not treat an EOF from Read
;; as an error to be reported."
;;   {:added "1.0"
;;    :go "readAll(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC ioutil.ReadDir has: 
;; (defn ^[[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{os FileInfo})] Error] ReadDir
;;   "ReadDir reads the directory named by dirname and returns
;; a list of directory entries sorted by filename."
;;   {:added "1.0"
;;    :go "readDir(dirname)"}
;;   [^String dirname])
;; 
JOKER FUNC ioutil.ReadFile has: 
;; (defn ^[[ABEND042(cannot find typename ioutil.byte)] Error] ReadFile
;;   "ReadFile reads the file named by filename and returns the contents.
;; A successful call returns err == nil, not err == EOF. Because ReadFile
;; reads the whole file, it does not treat an EOF from Read as an error
;; to be reported."
;;   {:added "1.0"
;;    :go "readFile(filename)"}
;;   [^String filename])
;; 
JOKER FUNC ioutil.TempDir has: 
(defn ^[name err] TempDir
  "TempDir creates a new temporary directory in the directory dir
with a name beginning with prefix and returns the path of the
new directory. If dir is the empty string, TempDir uses the
default directory for temporary files (see os.TempDir).
Multiple programs calling TempDir simultaneously
will not choose the same directory. It is the caller's responsibility
to remove the directory when no longer needed."
  {:added "1.0"
   :go "tempDir(dir, prefix)"}
  [^String dir, ^String prefix])

JOKER FUNC ioutil.TempFile has: 
(defn ^[f err] TempFile
  "TempFile creates a new temporary file in the directory dir,
opens the file for reading and writing, and returns the resulting *os.File.
The filename is generated by taking pattern and adding a random
string to the end. If pattern includes a "*", the random string
replaces the last "*".
If dir is the empty string, TempFile uses the default directory
for temporary files (see os.TempDir).
Multiple programs calling TempFile simultaneously
will not choose the same file. The caller can use f.Name()
to find the pathname of the file. It is the caller's responsibility
to remove the file when no longer needed."
  {:added "1.0"
   :go "tempFile(dir, pattern)"}
  [^String dir, ^String pattern])

JOKER FUNC ioutil.WriteFile has: 
;; (defn ^Error WriteFile
;;   "WriteFile writes data to a file named by filename.
;; If the file does not exist, WriteFile creates it with permissions perm;
;; otherwise WriteFile truncates it before writing."
;;   {:added "1.0"
;;    :go "writeFile(filename, data, perm)"}
;;   [^String filename, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3520478 <nil> byte}) data, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{os FileMode}) perm])
;; 
JOKER FUNC jpeg.Decode has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{image Image}) Error] Decode
;;   "Decode reads a JPEG image from r and returns it as an image.Image."
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC jpeg.DecodeConfig has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{image Config}) Error] DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a JPEG image without
;; decoding the entire image."
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC jpeg.Encode has: 
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given
;; options. Default parameters are used if a nil *Options is passed."
;;   {:added "1.0"
;;    :go "encode(w, m, o)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Image}) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{3416326 Options}) o])
;; 
JOKER FUNC json.Compact has: 
;; (defn ^Error Compact
;;   "Compact appends to dst the JSON-encoded src with
;; insignificant space characters elided."
;;   {:added "1.0"
;;    :go "compact(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1871483 0xc000991a80}) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1871502 <nil> byte}) src])
;; 
JOKER FUNC json.HTMLEscape has: 
;; (defn HTMLEscape
;;   "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029
;; characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029
;; so that the JSON will be safe to embed inside HTML <script> tags.
;; For historical reasons, web browsers don't honor standard HTML
;; escaping within <script> tags, so an alternative JSON encoding must
;; be used."
;;   {:added "1.0"
;;    :go "hTMLEscape(dst, src)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1772170 0xc0007d2b80}) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1772189 <nil> byte}) src])
;; 
JOKER FUNC json.Indent has: 
;; (defn ^Error Indent
;;   "Indent appends to dst an indented form of the JSON-encoded src.
;; Each element in a JSON object or array begins on a new,
;; indented line beginning with prefix followed by one or more
;; copies of indent according to the indentation nesting.
;; The data appended to dst does not begin with the prefix nor
;; any indentation, to make it easier to embed inside other formatted JSON data.
;; Although leading space characters (space, tab, carriage return, newline)
;; at the beginning of src are dropped, trailing space characters
;; at the end of src are preserved and copied to dst.
;; For example, if src has no trailing spaces, neither will dst;
;; if src ends in a trailing newline, so will dst."
;;   {:added "1.0"
;;    :go "indent(dst, src, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1873390 0xc0009ac620}) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1873409 <nil> byte}) src, ^String prefix, ^String indent])
;; 
JOKER FUNC json.Marshal has: 
;; (defn ^[[ABEND042(cannot find typename json.byte)] Error] Marshal
;;   "Marshal returns the JSON encoding of v.
;; 
;; Marshal traverses the value v recursively.
;; If an encountered value implements the Marshaler interface
;; and is not a nil pointer, Marshal calls its MarshalJSON method
;; to produce JSON. If no MarshalJSON method is present but the
;; value implements encoding.TextMarshaler instead, Marshal calls
;; its MarshalText method and encodes the result as a JSON string.
;; The nil pointer exception is not strictly necessary
;; but mimics a similar, necessary exception in the behavior of
;; UnmarshalJSON.
;; 
;; Otherwise, Marshal uses the following type-dependent default encodings:
;; 
;; Boolean values encode as JSON booleans.
;; 
;; Floating point, integer, and Number values encode as JSON numbers.
;; 
;; String values encode as JSON strings coerced to valid UTF-8,
;; replacing invalid bytes with the Unicode replacement rune.
;; The angle brackets "<" and ">" are escaped to "\u003c" and "\u003e"
;; to keep some browsers from misinterpreting JSON output as HTML.
;; Ampersand "&" is also escaped to "\u0026" for the same reason.
;; This escaping can be disabled using an Encoder that had SetEscapeHTML(false)
;; called on it.
;; 
;; Array and slice values encode as JSON arrays, except that
;; []byte encodes as a base64-encoded string, and a nil slice
;; encodes as the null JSON value.
;; 
;; Struct values encode as JSON objects.
;; Each exported struct field becomes a member of the object, using the
;; field name as the object key, unless the field is omitted for one of the
;; reasons given below.
;; 
;; The encoding of each struct field can be customized by the format string
;; stored under the "json" key in the struct field's tag.
;; The format string gives the name of the field, possibly followed by a
;; comma-separated list of options. The name may be empty in order to
;; specify options without overriding the default field name.
;; 
;; The "omitempty" option specifies that the field should be omitted
;; from the encoding if the field has an empty value, defined as
;; false, 0, a nil pointer, a nil interface value, and any empty array,
;; slice, map, or string.
;; 
;; As a special case, if the field tag is "-", the field is always omitted.
;; Note that a field with name "-" can still be generated using the tag "-,".
;; 
;; Examples of struct field tags and their meanings:
;; 
;;   // Field appears in JSON as key "myName".
;;   Field int `json:"myName"`
;; 
;;   // Field appears in JSON as key "myName" and
;;   // the field is omitted from the object if its value is empty,
;;   // as defined above.
;;   Field int `json:"myName,omitempty"`
;; 
;;   // Field appears in JSON as key "Field" (the default), but
;;   // the field is skipped if empty.
;;   // Note the leading comma.
;;   Field int `json:",omitempty"`
;; 
;;   // Field is ignored by this package.
;;   Field int `json:"-"`
;; 
;;   // Field appears in JSON as key "-".
;;   Field int `json:"-,"`
;; 
;; The "string" option signals that a field is stored as JSON inside a
;; JSON-encoded string. It applies only to fields of string, floating point,
;; integer, or boolean types. This extra level of encoding is sometimes used
;; when communicating with JavaScript programs:
;; 
;;    Int64String int64 `json:",string"`
;; 
;; The key name will be used if it's a non-empty string consisting of
;; only Unicode letters, digits, and ASCII punctuation except quotation
;; marks, backslash, and comma.
;; 
;; Anonymous struct fields are usually marshaled as if their inner exported fields
;; were fields in the outer struct, subject to the usual Go visibility rules amended
;; as described in the next paragraph.
;; An anonymous struct field with a name given in its JSON tag is treated as
;; having that name, rather than being anonymous.
;; An anonymous struct field of interface type is treated the same as having
;; that type as its name, rather than being anonymous.
;; 
;; The Go visibility rules for struct fields are amended for JSON when
;; deciding which field to marshal or unmarshal. If there are
;; multiple fields at the same level, and that level is the least
;; nested (and would therefore be the nesting level selected by the
;; usual Go rules), the following extra rules apply:
;; 
;; 1) Of those fields, if any are JSON-tagged, only tagged fields are considered,
;; even if there are multiple untagged fields that would otherwise conflict.
;; 
;; 2) If there is exactly one field (tagged or not according to the first rule), that is selected.
;; 
;; 3) Otherwise there are multiple fields, and all are ignored; no error occurs.
;; 
;; Handling of anonymous struct fields is new in Go 1.1.
;; Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of
;; an anonymous struct field in both current and earlier versions, give the field
;; a JSON tag of "-".
;; 
;; Map values encode as JSON objects. The map's key type must either be a
;; string, an integer type, or implement encoding.TextMarshaler. The map keys
;; are sorted and used as JSON object keys by applying the following rules,
;; subject to the UTF-8 coercion described for string values above:
;;   - string keys are used directly
;;   - encoding.TextMarshalers are marshaled
;;   - integer keys are converted to strings
;; 
;; Pointer values encode as the value pointed to.
;; A nil pointer encodes as the null JSON value.
;; 
;; Interface values encode as the value contained in the interface.
;; A nil interface value encodes as the null JSON value.
;; 
;; Channel, complex, and function values cannot be encoded in JSON.
;; Attempting to encode such a value causes Marshal to return
;; an UnsupportedTypeError.
;; 
;; JSON cannot represent cyclic data structures and Marshal does not
;; handle them. Passing cyclic structures to Marshal will result in
;; an infinite recursion."
;;   {:added "1.0"
;;    :go "marshal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1771023 0xc00077e840 false}) v])
;; 
JOKER FUNC json.MarshalIndent has: 
;; (defn ^[[ABEND042(cannot find typename json.byte)] Error] MarshalIndent
;;   "MarshalIndent is like Marshal but applies Indent to format the output.
;; Each JSON element in the output will begin on a new line beginning with prefix
;; followed by one or more copies of indent according to the indentation nesting."
;;   {:added "1.0"
;;    :go "marshalIndent(v, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1771522 0xc00077f170 false}) v, ^String prefix, ^String indent])
;; 
JOKER FUNC json.NewDecoder has: 
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1858764 <nil> byte}) buf, :d d, :scanp ^Int scanp, :scanned scanned, :scan scan, :err err, :tokenstate ^Int tokenState, :tokenstack ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1858948 <nil> int}) tokenStack} NewDecoder
;;   "NewDecoder returns a new decoder that reads from r.
;; 
;; The decoder introduces its own buffering and may
;; read data from r beyond the JSON values requested."
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC json.NewEncoder has: 
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :err err, :escapehtml escapeHTML, :indentbuf ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1862852 0xc0009828e0}) indentBuf, :indentprefix ^String indentPrefix, :indentvalue ^String indentValue} NewEncoder
;;   "NewEncoder returns a new encoder that writes to w."
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC json.Unmarshal has: 
;; (defn ^Error Unmarshal
;;   "Unmarshal parses the JSON-encoded data and stores the result
;; in the value pointed to by v. If v is nil or not a pointer,
;; Unmarshal returns an InvalidUnmarshalError.
;; 
;; Unmarshal uses the inverse of the encodings that
;; Marshal uses, allocating maps, slices, and pointers as necessary,
;; with the following additional rules:
;; 
;; To unmarshal JSON into a pointer, Unmarshal first handles the case of
;; the JSON being the JSON literal null. In that case, Unmarshal sets
;; the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into
;; the value pointed at by the pointer. If the pointer is nil, Unmarshal
;; allocates a new value for it to point to.
;; 
;; To unmarshal JSON into a value implementing the Unmarshaler interface,
;; Unmarshal calls that value's UnmarshalJSON method, including
;; when the input is a JSON null.
;; Otherwise, if the value implements encoding.TextUnmarshaler
;; and the input is a JSON quoted string, Unmarshal calls that value's
;; UnmarshalText method with the unquoted form of the string.
;; 
;; To unmarshal JSON into a struct, Unmarshal matches incoming object
;; keys to the keys used by Marshal (either the struct field name or its tag),
;; preferring an exact match but also accepting a case-insensitive match. By
;; default, object keys which don't have a corresponding struct field are
;; ignored (see Decoder.DisallowUnknownFields for an alternative).
;; 
;; To unmarshal JSON into an interface value,
;; Unmarshal stores one of these in the interface value:
;; 
;; 	bool, for JSON booleans
;; 	float64, for JSON numbers
;; 	string, for JSON strings
;; 	[]interface{}, for JSON arrays
;; 	map[string]interface{}, for JSON objects
;; 	nil for JSON null
;; 
;; To unmarshal a JSON array into a slice, Unmarshal resets the slice length
;; to zero and then appends each element to the slice.
;; As a special case, to unmarshal an empty JSON array into a slice,
;; Unmarshal replaces the slice with a new empty slice.
;; 
;; To unmarshal a JSON array into a Go array, Unmarshal decodes
;; JSON array elements into corresponding Go array elements.
;; If the Go array is smaller than the JSON array,
;; the additional JSON array elements are discarded.
;; If the JSON array is smaller than the Go array,
;; the additional Go array elements are set to zero values.
;; 
;; To unmarshal a JSON object into a map, Unmarshal first establishes a map to
;; use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal
;; reuses the existing map, keeping existing entries. Unmarshal then stores
;; key-value pairs from the JSON object into the map. The map's key type must
;; either be a string, an integer, or implement encoding.TextUnmarshaler.
;; 
;; If a JSON value is not appropriate for a given target type,
;; or if a JSON number overflows the target type, Unmarshal
;; skips that field and completes the unmarshaling as best it can.
;; If no more serious errors are encountered, Unmarshal returns
;; an UnmarshalTypeError describing the earliest such error. In any
;; case, it's not guaranteed that all the remaining fields following
;; the problematic one will be unmarshaled into the target object.
;; 
;; The JSON null value unmarshals into an interface, map, pointer, or slice
;; by setting that Go value to nil. Because null is often used in JSON to mean
;; ``not present,'' unmarshaling a JSON null into any other Go type has no effect
;; on the value and produces no error.
;; 
;; When unmarshaling quoted strings, invalid UTF-8 or
;; invalid UTF-16 surrogate pairs are not treated as an error.
;; Instead, they are replaced by the Unicode replacement
;; character U+FFFD."
;;   {:added "1.0"
;;    :go "unmarshal(data, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1804096 <nil> byte}) data, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1804106 0xc00058bd40 false}) v])
;; 
JOKER FUNC json.Valid has: 
;; (defn ^ABEND042(cannot find typename json.bool) Valid
;;   "Valid reports whether data is a valid JSON encoding."
;;   {:added "1.0"
;;    :go "valid(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1840092 <nil> byte}) data])
;; 
JOKER FUNC jsonrpc.Dial has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{rpc Client}) Error] Dial
;;   "Dial connects to a JSON-RPC server at the specified network address."
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC jsonrpc.NewClient has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{rpc Client}) NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the
;; set of services at the other end of the connection."
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}) conn])
;; 
JOKER FUNC jsonrpc.NewClientCodec has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{rpc ClientCodec}) NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn."
;;   {:added "1.0"
;;    :go "newClientCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}) conn])
;; 
JOKER FUNC jsonrpc.NewServerCodec has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{rpc ServerCodec}) NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn."
;;   {:added "1.0"
;;    :go "newServerCodec(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}) conn])
;; 
JOKER FUNC jsonrpc.ServeConn has: 
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.
;; ServeConn blocks, serving the connection until the client hangs up.
;; The caller typically invokes ServeConn in a go statement."
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}) conn])
;; 
JOKER FUNC list.New has: 
(defn ^{:root root, :len ^Int len} New
  "New returns an initialized list."
  {:added "1.0"
   :go "new()"}
  [])

JOKER FUNC log.Fatal has: 
;; (defn Fatal
;;   "Fatal is equivalent to Print() followed by a call to os.Exit(1)."
;;   {:added "1.0"
;;    :go "fatal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3531563 0xc000eefdc0}) v])
;; 
JOKER FUNC log.Fatalf has: 
;; (defn Fatalf
;;   "Fatalf is equivalent to Printf() followed by a call to os.Exit(1)."
;;   {:added "1.0"
;;    :go "fatalf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3531728 0xc000ef40a0}) v])
;; 
JOKER FUNC log.Fatalln has: 
;; (defn Fatalln
;;   "Fatalln is equivalent to Println() followed by a call to os.Exit(1)."
;;   {:added "1.0"
;;    :go "fatalln(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3531890 0xc000ef4380}) v])
;; 
JOKER FUNC log.Flags has: 
(defn ^Int Flags
  "Flags returns the output flags for the standard logger."
  {:added "1.0"
   :go "flags()"}
  [])

JOKER FUNC log.New has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :prefix ^String prefix, :flag ^Int flag, :out ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) out, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3524883 <nil> byte}) buf} New
;;   "New creates a new Logger. The out variable sets the
;; destination to which log data will be written.
;; The prefix appears at the beginning of each generated log line.
;; The flag argument defines the logging properties."
;;   {:added "1.0"
;;    :go "new(out, prefix, flag)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) out, ^String prefix, ^Int flag])
;; 
JOKER FUNC log.Output has: 
(defn ^Error Output
  "Output writes the output for a logging event. The string s contains
the text to print after the prefix specified by the flags of the
Logger. A newline is appended if the last character of s is not
already a newline. Calldepth is the count of the number of
frames to skip when computing the file name and line number
if Llongfile or Lshortfile is set; a value of 1 will print the details
for the caller of Output."
  {:added "1.0"
   :go "output(calldepth, s)"}
  [^Int calldepth, ^String s])

JOKER FUNC log.Panic has: 
;; (defn Panic
;;   "Panic is equivalent to Print() followed by a call to panic()."
;;   {:added "1.0"
;;    :go "panic(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3532036 0xc000ef4620}) v])
;; 
JOKER FUNC log.Panicf has: 
;; (defn Panicf
;;   "Panicf is equivalent to Printf() followed by a call to panic()."
;;   {:added "1.0"
;;    :go "panicf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3532204 0xc000ef4900}) v])
;; 
JOKER FUNC log.Panicln has: 
;; (defn Panicln
;;   "Panicln is equivalent to Println() followed by a call to panic()."
;;   {:added "1.0"
;;    :go "panicln(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3532369 0xc000ef4be0}) v])
;; 
JOKER FUNC log.Prefix has: 
(defn ^String Prefix
  "Prefix returns the output prefix for the standard logger."
  {:added "1.0"
   :go "prefix()"}
  [])

JOKER FUNC log.Print has: 
;; (defn Print
;;   "Print calls Output to print to the standard logger.
;; Arguments are handled in the manner of fmt.Print."
;;   {:added "1.0"
;;    :go "print(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3531043 0xc000eef700}) v])
;; 
JOKER FUNC log.Printf has: 
;; (defn Printf
;;   "Printf calls Output to print to the standard logger.
;; Arguments are handled in the manner of fmt.Printf."
;;   {:added "1.0"
;;    :go "printf(format, v)"}
;;   [^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3531236 0xc000eef960}) v])
;; 
JOKER FUNC log.Println has: 
;; (defn Println
;;   "Println calls Output to print to the standard logger.
;; Arguments are handled in the manner of fmt.Println."
;;   {:added "1.0"
;;    :go "println(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{3531426 0xc000eefbc0}) v])
;; 
JOKER FUNC log.SetFlags has: 
;; (defn SetFlags
;;   "SetFlags sets the output flags for the standard logger."
;;   {:added "1.0"
;;    :go "setFlags(flag)"}
;;   [^Int flag])
;; 
JOKER FUNC log.SetOutput has: 
;; (defn SetOutput
;;   "SetOutput sets the output destination for the standard logger."
;;   {:added "1.0"
;;    :go "setOutput(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC log.SetPrefix has: 
;; (defn SetPrefix
;;   "SetPrefix sets the output prefix for the standard logger."
;;   {:added "1.0"
;;    :go "setPrefix(prefix)"}
;;   [^String prefix])
;; 
JOKER FUNC lzw.NewReader has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) NewReader
;;   "NewReader creates a new io.ReadCloser.
;; Reads from the returned io.ReadCloser read and decompress data from r.
;; If r does not also implement io.ByteReader,
;; the decompressor may read more data than necessary from r.
;; It is the caller's responsibility to call Close on the ReadCloser when
;; finished reading.
;; The number of bits to use for literal codes, litWidth, must be in the
;; range [2,8] and is typically 8. It must equal the litWidth
;; used during compression."
;;   {:added "1.0"
;;    :go "newReader(r, order, litWidth)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, order, ^Int litWidth])
;; 
JOKER FUNC lzw.NewWriter has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io WriteCloser}) NewWriter
;;   "NewWriter creates a new io.WriteCloser.
;; Writes to the returned io.WriteCloser are compressed and written to w.
;; It is the caller's responsibility to call Close on the WriteCloser when
;; finished writing.
;; The number of bits to use for literal codes, litWidth, must be in the
;; range [2,8] and is typically 8. Input bytes must be less than 1<<litWidth."
;;   {:added "1.0"
;;    :go "newWriter(w, order, litWidth)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, order, ^Int litWidth])
;; 
JOKER FUNC macho.NewFatFile has: 
;; (defn ^[{:magic Magic, :arches ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1429360 <nil> FatArch}) Arches, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Closer}) closer} Error] NewFatFile
;;   "NewFatFile creates a new FatFile for accessing all the Mach-O images in a
;; universal binary. The Mach-O binary is expected to start at position 0 in
;; the ReaderAt."
;;   {:added "1.0"
;;    :go "newFatFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReaderAt}) r])
;; 
JOKER FUNC macho.NewFile has: 
;; (defn ^[{:byteorder ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{binary ByteOrder}) ByteOrder, :loads ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1436025 <nil> Load}) Loads, :sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1436043 <nil> 0xc00017c120}) Sections, :symtab ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1436065 Symtab}) Symtab, :dysymtab ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1436083 Dysymtab}) Dysymtab, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Closer}) closer} Error] NewFile
;;   "NewFile creates a new File for accessing a Mach-O binary in an underlying reader.
;; The Mach-O binary is expected to start at position 0 in the ReaderAt."
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReaderAt}) r])
;; 
JOKER FUNC macho.Open has: 
;; (defn ^[{:byteorder ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{binary ByteOrder}) ByteOrder, :loads ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1436025 <nil> Load}) Loads, :sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1436043 <nil> 0xc00017c120}) Sections, :symtab ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1436065 Symtab}) Symtab, :dysymtab ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1436083 Dysymtab}) Dysymtab, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Closer}) closer} Error] Open
;;   "Open opens the named file using os.Open and prepares it for use as a Mach-O binary."
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])
;; 
JOKER FUNC macho.OpenFat has: 
;; (defn ^[{:magic Magic, :arches ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1429360 <nil> FatArch}) Arches, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Closer}) closer} Error] OpenFat
;;   "OpenFat opens the named file using os.Open and prepares it for use as a Mach-O
;; universal binary."
;;   {:added "1.0"
;;    :go "openFat(name)"}
;;   [^String name])
;; 
JOKER FUNC mail.ParseAddress has: 
(defn ^[{:name ^String Name, :address ^String Address} Error] ParseAddress
  "Parses a single RFC 5322 address, e.g. "Barry Gibbs <bg@example.com>""
  {:added "1.0"
   :go "parseAddress(address)"}
  [^String address])

JOKER FUNC mail.ParseAddressList has: 
(defn ^[[{:name ^String Name, :address ^String Address}] Error] ParseAddressList
  "ParseAddressList parses the given string as a list of addresses."
  {:added "1.0"
   :go "parseAddressList(list)"}
  [^String list])

JOKER FUNC mail.ParseDate has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) Error] ParseDate
;;   "ParseDate parses an RFC 5322 date string."
;;   {:added "1.0"
;;    :go "parseDate(date)"}
;;   [^String date])
;; 
JOKER FUNC mail.ReadMessage has: 
;; (defn ^[msg err] ReadMessage
;;   "ReadMessage reads a message from r.
;; The headers are parsed, and the body of the message will be available
;; for reading from msg.Body."
;;   {:added "1.0"
;;    :go "readMessage(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC math.Abs has: 
;; (defn ^ABEND042(cannot find typename math.float64) Abs
;;   "Abs returns the absolute value of x.
;; 
;; Special cases are:
;; 	Abs(±Inf) = +Inf
;; 	Abs(NaN) = NaN"
;;   {:added "1.0"
;;    :go "abs(x)"}
;;   [x])
;; 
JOKER FUNC math.Acos has: 
;; (defn ^ABEND042(cannot find typename math.float64) Acos
;;   "Acos returns the arccosine, in radians, of x.
;; 
;; Special case is:
;; 	Acos(x) = NaN if x < -1 or x > 1"
;;   {:added "1.0"
;;    :go "acos(x)"}
;;   [x])
;; 
JOKER FUNC math.Acosh has: 
;; (defn ^ABEND042(cannot find typename math.float64) Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.
;; 
;; Special cases are:
;; 	Acosh(+Inf) = +Inf
;; 	Acosh(x) = NaN if x < 1
;; 	Acosh(NaN) = NaN"
;;   {:added "1.0"
;;    :go "acosh(x)"}
;;   [x])
;; 
JOKER FUNC math.Asin has: 
;; (defn ^ABEND042(cannot find typename math.float64) Asin
;;   "Asin returns the arcsine, in radians, of x.
;; 
;; Special cases are:
;; 	Asin(±0) = ±0
;; 	Asin(x) = NaN if x < -1 or x > 1"
;;   {:added "1.0"
;;    :go "asin(x)"}
;;   [x])
;; 
JOKER FUNC math.Asinh has: 
;; (defn ^ABEND042(cannot find typename math.float64) Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.
;; 
;; Special cases are:
;; 	Asinh(±0) = ±0
;; 	Asinh(±Inf) = ±Inf
;; 	Asinh(NaN) = NaN"
;;   {:added "1.0"
;;    :go "asinh(x)"}
;;   [x])
;; 
JOKER FUNC math.Atan has: 
;; (defn ^ABEND042(cannot find typename math.float64) Atan
;;   "Atan returns the arctangent, in radians, of x.
;; 
;; Special cases are:
;;      Atan(±0) = ±0
;;      Atan(±Inf) = ±Pi/2"
;;   {:added "1.0"
;;    :go "atan(x)"}
;;   [x])
;; 
JOKER FUNC math.Atan2 has: 
;; (defn ^ABEND042(cannot find typename math.float64) Atan2
;;   "Atan2 returns the arc tangent of y/x, using
;; the signs of the two to determine the quadrant
;; of the return value.
;; 
;; Special cases are (in order):
;; 	Atan2(y, NaN) = NaN
;; 	Atan2(NaN, x) = NaN
;; 	Atan2(+0, x>=0) = +0
;; 	Atan2(-0, x>=0) = -0
;; 	Atan2(+0, x<=-0) = +Pi
;; 	Atan2(-0, x<=-0) = -Pi
;; 	Atan2(y>0, 0) = +Pi/2
;; 	Atan2(y<0, 0) = -Pi/2
;; 	Atan2(+Inf, +Inf) = +Pi/4
;; 	Atan2(-Inf, +Inf) = -Pi/4
;; 	Atan2(+Inf, -Inf) = 3Pi/4
;; 	Atan2(-Inf, -Inf) = -3Pi/4
;; 	Atan2(y, +Inf) = 0
;; 	Atan2(y>0, -Inf) = +Pi
;; 	Atan2(y<0, -Inf) = -Pi
;; 	Atan2(+Inf, x) = +Pi/2
;; 	Atan2(-Inf, x) = -Pi/2"
;;   {:added "1.0"
;;    :go "atan2(y, x)"}
;;   [y, x])
;; 
JOKER FUNC math.Atanh has: 
;; (defn ^ABEND042(cannot find typename math.float64) Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.
;; 
;; Special cases are:
;; 	Atanh(1) = +Inf
;; 	Atanh(±0) = ±0
;; 	Atanh(-1) = -Inf
;; 	Atanh(x) = NaN if x < -1 or x > 1
;; 	Atanh(NaN) = NaN"
;;   {:added "1.0"
;;    :go "atanh(x)"}
;;   [x])
;; 
JOKER FUNC math.Cbrt has: 
;; (defn ^ABEND042(cannot find typename math.float64) Cbrt
;;   "Cbrt returns the cube root of x.
;; 
;; Special cases are:
;; 	Cbrt(±0) = ±0
;; 	Cbrt(±Inf) = ±Inf
;; 	Cbrt(NaN) = NaN"
;;   {:added "1.0"
;;    :go "cbrt(x)"}
;;   [x])
;; 
JOKER FUNC math.Ceil has: 
;; (defn ^ABEND042(cannot find typename math.float64) Ceil
;;   "Ceil returns the least integer value greater than or equal to x.
;; 
;; Special cases are:
;; 	Ceil(±0) = ±0
;; 	Ceil(±Inf) = ±Inf
;; 	Ceil(NaN) = NaN"
;;   {:added "1.0"
;;    :go "ceil(x)"}
;;   [x])
;; 
JOKER FUNC math.Copysign has: 
;; (defn ^ABEND042(cannot find typename math.float64) Copysign
;;   "Copysign returns a value with the magnitude
;; of x and the sign of y."
;;   {:added "1.0"
;;    :go "copysign(x, y)"}
;;   [x, y])
;; 
JOKER FUNC math.Cos has: 
;; (defn ^ABEND042(cannot find typename math.float64) Cos
;;   "Cos returns the cosine of the radian argument x.
;; 
;; Special cases are:
;; 	Cos(±Inf) = NaN
;; 	Cos(NaN) = NaN"
;;   {:added "1.0"
;;    :go "cos(x)"}
;;   [x])
;; 
JOKER FUNC math.Cosh has: 
;; (defn ^ABEND042(cannot find typename math.float64) Cosh
;;   "Cosh returns the hyperbolic cosine of x.
;; 
;; Special cases are:
;; 	Cosh(±0) = 1
;; 	Cosh(±Inf) = +Inf
;; 	Cosh(NaN) = NaN"
;;   {:added "1.0"
;;    :go "cosh(x)"}
;;   [x])
;; 
JOKER FUNC math.Dim has: 
;; (defn ^ABEND042(cannot find typename math.float64) Dim
;;   "Dim returns the maximum of x-y or 0.
;; 
;; Special cases are:
;; 	Dim(+Inf, +Inf) = NaN
;; 	Dim(-Inf, -Inf) = NaN
;; 	Dim(x, NaN) = Dim(NaN, x) = NaN"
;;   {:added "1.0"
;;    :go "dim(x, y)"}
;;   [x, y])
;; 
JOKER FUNC math.Erf has: 
;; (defn ^ABEND042(cannot find typename math.float64) Erf
;;   "Erf returns the error function of x.
;; 
;; Special cases are:
;; 	Erf(+Inf) = 1
;; 	Erf(-Inf) = -1
;; 	Erf(NaN) = NaN"
;;   {:added "1.0"
;;    :go "erf(x)"}
;;   [x])
;; 
JOKER FUNC math.Erfc has: 
;; (defn ^ABEND042(cannot find typename math.float64) Erfc
;;   "Erfc returns the complementary error function of x.
;; 
;; Special cases are:
;; 	Erfc(+Inf) = 0
;; 	Erfc(-Inf) = 2
;; 	Erfc(NaN) = NaN"
;;   {:added "1.0"
;;    :go "erfc(x)"}
;;   [x])
;; 
JOKER FUNC math.Erfcinv has: 
;; (defn ^ABEND042(cannot find typename math.float64) Erfcinv
;;   "Erfcinv returns the inverse of Erfc(x).
;; 
;; Special cases are:
;; 	Erfcinv(0) = +Inf
;; 	Erfcinv(2) = -Inf
;; 	Erfcinv(x) = NaN if x < 0 or x > 2
;; 	Erfcinv(NaN) = NaN"
;;   {:added "1.0"
;;    :go "erfcinv(x)"}
;;   [x])
;; 
JOKER FUNC math.Erfinv has: 
;; (defn ^ABEND042(cannot find typename math.float64) Erfinv
;;   "Erfinv returns the inverse error function of x.
;; 
;; Special cases are:
;; 	Erfinv(1) = +Inf
;; 	Erfinv(-1) = -Inf
;; 	Erfinv(x) = NaN if x < -1 or x > 1
;; 	Erfinv(NaN) = NaN"
;;   {:added "1.0"
;;    :go "erfinv(x)"}
;;   [x])
;; 
JOKER FUNC math.Exp has: 
;; (defn ^ABEND042(cannot find typename math.float64) Exp
;;   "Exp returns e**x, the base-e exponential of x.
;; 
;; Special cases are:
;; 	Exp(+Inf) = +Inf
;; 	Exp(NaN) = NaN
;; Very large values overflow to 0 or +Inf.
;; Very small values underflow to 1."
;;   {:added "1.0"
;;    :go "exp(x)"}
;;   [x])
;; 
JOKER FUNC math.Exp2 has: 
;; (defn ^ABEND042(cannot find typename math.float64) Exp2
;;   "Exp2 returns 2**x, the base-2 exponential of x.
;; 
;; Special cases are the same as Exp."
;;   {:added "1.0"
;;    :go "exp2(x)"}
;;   [x])
;; 
JOKER FUNC math.Expm1 has: 
;; (defn ^ABEND042(cannot find typename math.float64) Expm1
;;   "Expm1 returns e**x - 1, the base-e exponential of x minus 1.
;; It is more accurate than Exp(x) - 1 when x is near zero.
;; 
;; Special cases are:
;; 	Expm1(+Inf) = +Inf
;; 	Expm1(-Inf) = -1
;; 	Expm1(NaN) = NaN
;; Very large values overflow to -1 or +Inf."
;;   {:added "1.0"
;;    :go "expm1(x)"}
;;   [x])
;; 
JOKER FUNC math.Float32bits has: 
;; (defn ^ABEND042(cannot find typename math.uint32) Float32bits
;;   "Float32bits returns the IEEE 754 binary representation of f."
;;   {:added "1.0"
;;    :go "float32bits(f)"}
;;   [f])
;; 
JOKER FUNC math.Float32frombits has: 
;; (defn ^ABEND042(cannot find typename math.float32) Float32frombits
;;   "Float32frombits returns the floating point number corresponding
;; to the IEEE 754 binary representation b."
;;   {:added "1.0"
;;    :go "float32frombits(b)"}
;;   [b])
;; 
JOKER FUNC math.Float64bits has: 
;; (defn ^ABEND042(cannot find typename math.uint64) Float64bits
;;   "Float64bits returns the IEEE 754 binary representation of f."
;;   {:added "1.0"
;;    :go "float64bits(f)"}
;;   [f])
;; 
JOKER FUNC math.Float64frombits has: 
;; (defn ^ABEND042(cannot find typename math.float64) Float64frombits
;;   "Float64frombits returns the floating point number corresponding
;; the IEEE 754 binary representation b."
;;   {:added "1.0"
;;    :go "float64frombits(b)"}
;;   [b])
;; 
JOKER FUNC math.Floor has: 
;; (defn ^ABEND042(cannot find typename math.float64) Floor
;;   "Floor returns the greatest integer value less than or equal to x.
;; 
;; Special cases are:
;; 	Floor(±0) = ±0
;; 	Floor(±Inf) = ±Inf
;; 	Floor(NaN) = NaN"
;;   {:added "1.0"
;;    :go "floor(x)"}
;;   [x])
;; 
JOKER FUNC math.Frexp has: 
(defn ^[frac exp] Frexp
  "Frexp breaks f into a normalized fraction
and an integral power of two.
It returns frac and exp satisfying f == frac × 2**exp,
with the absolute value of frac in the interval [½, 1).

Special cases are:
	Frexp(±0) = ±0, 0
	Frexp(±Inf) = ±Inf, 0
	Frexp(NaN) = NaN, 0"
  {:added "1.0"
   :go "frexp(f)"}
  [f])

JOKER FUNC math.Gamma has: 
;; (defn ^ABEND042(cannot find typename math.float64) Gamma
;;   "Gamma returns the Gamma function of x.
;; 
;; Special cases are:
;; 	Gamma(+Inf) = +Inf
;; 	Gamma(+0) = +Inf
;; 	Gamma(-0) = -Inf
;; 	Gamma(x) = NaN for integer x < 0
;; 	Gamma(-Inf) = NaN
;; 	Gamma(NaN) = NaN"
;;   {:added "1.0"
;;    :go "gamma(x)"}
;;   [x])
;; 
JOKER FUNC math.Hypot has: 
;; (defn ^ABEND042(cannot find typename math.float64) Hypot
;;   "Hypot returns Sqrt(p*p + q*q), taking care to avoid
;; unnecessary overflow and underflow.
;; 
;; Special cases are:
;; 	Hypot(±Inf, q) = +Inf
;; 	Hypot(p, ±Inf) = +Inf
;; 	Hypot(NaN, q) = NaN
;; 	Hypot(p, NaN) = NaN"
;;   {:added "1.0"
;;    :go "hypot(p, q)"}
;;   [p, q])
;; 
JOKER FUNC math.Ilogb has: 
(defn ^Int Ilogb
  "Ilogb returns the binary exponent of x as an integer.

Special cases are:
	Ilogb(±Inf) = MaxInt32
	Ilogb(0) = MinInt32
	Ilogb(NaN) = MaxInt32"
  {:added "1.0"
   :go "ilogb(x)"}
  [x])

JOKER FUNC math.Inf has: 
;; (defn ^ABEND042(cannot find typename math.float64) Inf
;;   "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0."
;;   {:added "1.0"
;;    :go "inf(sign)"}
;;   [^Int sign])
;; 
JOKER FUNC math.IsInf has: 
;; (defn ^ABEND042(cannot find typename math.bool) IsInf
;;   "IsInf reports whether f is an infinity, according to sign.
;; If sign > 0, IsInf reports whether f is positive infinity.
;; If sign < 0, IsInf reports whether f is negative infinity.
;; If sign == 0, IsInf reports whether f is either infinity."
;;   {:added "1.0"
;;    :go "isInf(f, sign)"}
;;   [f, ^Int sign])
;; 
JOKER FUNC math.IsNaN has: 
(defn ^is IsNaN
  "IsNaN reports whether f is an IEEE 754 ``not-a-number'' value."
  {:added "1.0"
   :go "isNaN(f)"}
  [f])

JOKER FUNC math.J0 has: 
;; (defn ^ABEND042(cannot find typename math.float64) J0
;;   "J0 returns the order-zero Bessel function of the first kind.
;; 
;; Special cases are:
;; 	J0(±Inf) = 0
;; 	J0(0) = 1
;; 	J0(NaN) = NaN"
;;   {:added "1.0"
;;    :go "j0(x)"}
;;   [x])
;; 
JOKER FUNC math.J1 has: 
;; (defn ^ABEND042(cannot find typename math.float64) J1
;;   "J1 returns the order-one Bessel function of the first kind.
;; 
;; Special cases are:
;; 	J1(±Inf) = 0
;; 	J1(NaN) = NaN"
;;   {:added "1.0"
;;    :go "j1(x)"}
;;   [x])
;; 
JOKER FUNC math.Jn has: 
;; (defn ^ABEND042(cannot find typename math.float64) Jn
;;   "Jn returns the order-n Bessel function of the first kind.
;; 
;; Special cases are:
;; 	Jn(n, ±Inf) = 0
;; 	Jn(n, NaN) = NaN"
;;   {:added "1.0"
;;    :go "jn(n, x)"}
;;   [^Int n, x])
;; 
JOKER FUNC math.Ldexp has: 
;; (defn ^ABEND042(cannot find typename math.float64) Ldexp
;;   "Ldexp is the inverse of Frexp.
;; It returns frac × 2**exp.
;; 
;; Special cases are:
;; 	Ldexp(±0, exp) = ±0
;; 	Ldexp(±Inf, exp) = ±Inf
;; 	Ldexp(NaN, exp) = NaN"
;;   {:added "1.0"
;;    :go "ldexp(frac, exp)"}
;;   [frac, ^Int exp])
;; 
JOKER FUNC math.Lgamma has: 
(defn ^[lgamma sign] Lgamma
  "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).

Special cases are:
	Lgamma(+Inf) = +Inf
	Lgamma(0) = +Inf
	Lgamma(-integer) = +Inf
	Lgamma(-Inf) = -Inf
	Lgamma(NaN) = NaN"
  {:added "1.0"
   :go "lgamma(x)"}
  [x])

JOKER FUNC math.Log has: 
;; (defn ^ABEND042(cannot find typename math.float64) Log
;;   "Log returns the natural logarithm of x.
;; 
;; Special cases are:
;; 	Log(+Inf) = +Inf
;; 	Log(0) = -Inf
;; 	Log(x < 0) = NaN
;; 	Log(NaN) = NaN"
;;   {:added "1.0"
;;    :go "log(x)"}
;;   [x])
;; 
JOKER FUNC math.Log10 has: 
;; (defn ^ABEND042(cannot find typename math.float64) Log10
;;   "Log10 returns the decimal logarithm of x.
;; The special cases are the same as for Log."
;;   {:added "1.0"
;;    :go "log10(x)"}
;;   [x])
;; 
JOKER FUNC math.Log1p has: 
;; (defn ^ABEND042(cannot find typename math.float64) Log1p
;;   "Log1p returns the natural logarithm of 1 plus its argument x.
;; It is more accurate than Log(1 + x) when x is near zero.
;; 
;; Special cases are:
;; 	Log1p(+Inf) = +Inf
;; 	Log1p(±0) = ±0
;; 	Log1p(-1) = -Inf
;; 	Log1p(x < -1) = NaN
;; 	Log1p(NaN) = NaN"
;;   {:added "1.0"
;;    :go "log1p(x)"}
;;   [x])
;; 
JOKER FUNC math.Log2 has: 
;; (defn ^ABEND042(cannot find typename math.float64) Log2
;;   "Log2 returns the binary logarithm of x.
;; The special cases are the same as for Log."
;;   {:added "1.0"
;;    :go "log2(x)"}
;;   [x])
;; 
JOKER FUNC math.Logb has: 
;; (defn ^ABEND042(cannot find typename math.float64) Logb
;;   "Logb returns the binary exponent of x.
;; 
;; Special cases are:
;; 	Logb(±Inf) = +Inf
;; 	Logb(0) = -Inf
;; 	Logb(NaN) = NaN"
;;   {:added "1.0"
;;    :go "logb(x)"}
;;   [x])
;; 
JOKER FUNC math.Max has: 
;; (defn ^ABEND042(cannot find typename math.float64) Max
;;   "Max returns the larger of x or y.
;; 
;; Special cases are:
;; 	Max(x, +Inf) = Max(+Inf, x) = +Inf
;; 	Max(x, NaN) = Max(NaN, x) = NaN
;; 	Max(+0, ±0) = Max(±0, +0) = +0
;; 	Max(-0, -0) = -0"
;;   {:added "1.0"
;;    :go "max(x, y)"}
;;   [x, y])
;; 
JOKER FUNC math.Min has: 
;; (defn ^ABEND042(cannot find typename math.float64) Min
;;   "Min returns the smaller of x or y.
;; 
;; Special cases are:
;; 	Min(x, -Inf) = Min(-Inf, x) = -Inf
;; 	Min(x, NaN) = Min(NaN, x) = NaN
;; 	Min(-0, ±0) = Min(±0, -0) = -0"
;;   {:added "1.0"
;;    :go "min(x, y)"}
;;   [x, y])
;; 
JOKER FUNC math.Mod has: 
;; (defn ^ABEND042(cannot find typename math.float64) Mod
;;   "Mod returns the floating-point remainder of x/y.
;; The magnitude of the result is less than y and its
;; sign agrees with that of x.
;; 
;; Special cases are:
;; 	Mod(±Inf, y) = NaN
;; 	Mod(NaN, y) = NaN
;; 	Mod(x, 0) = NaN
;; 	Mod(x, ±Inf) = x
;; 	Mod(x, NaN) = NaN"
;;   {:added "1.0"
;;    :go "mod(x, y)"}
;;   [x, y])
;; 
JOKER FUNC math.Modf has: 
(defn ^[int frac] Modf
  "Modf returns integer and fractional floating-point numbers
that sum to f. Both values have the same sign as f.

Special cases are:
	Modf(±Inf) = ±Inf, NaN
	Modf(NaN) = NaN, NaN"
  {:added "1.0"
   :go "modf(f)"}
  [f])

JOKER FUNC math.NaN has: 
;; (defn ^ABEND042(cannot find typename math.float64) NaN
;;   "NaN returns an IEEE 754 ``not-a-number'' value."
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])
;; 
JOKER FUNC math.Nextafter has: 
(defn ^r Nextafter
  "Nextafter returns the next representable float64 value after x towards y.

Special cases are:
	Nextafter(x, x)   = x
	Nextafter(NaN, y) = NaN
	Nextafter(x, NaN) = NaN"
  {:added "1.0"
   :go "nextafter(x, y)"}
  [x, y])

JOKER FUNC math.Nextafter32 has: 
(defn ^r Nextafter32
  "Nextafter32 returns the next representable float32 value after x towards y.

Special cases are:
	Nextafter32(x, x)   = x
	Nextafter32(NaN, y) = NaN
	Nextafter32(x, NaN) = NaN"
  {:added "1.0"
   :go "nextafter32(x, y)"}
  [x, y])

JOKER FUNC math.Pow has: 
;; (defn ^ABEND042(cannot find typename math.float64) Pow
;;   "Pow returns x**y, the base-x exponential of y.
;; 
;; Special cases are (in order):
;; 	Pow(x, ±0) = 1 for any x
;; 	Pow(1, y) = 1 for any y
;; 	Pow(x, 1) = x for any x
;; 	Pow(NaN, y) = NaN
;; 	Pow(x, NaN) = NaN
;; 	Pow(±0, y) = ±Inf for y an odd integer < 0
;; 	Pow(±0, -Inf) = +Inf
;; 	Pow(±0, +Inf) = +0
;; 	Pow(±0, y) = +Inf for finite y < 0 and not an odd integer
;; 	Pow(±0, y) = ±0 for y an odd integer > 0
;; 	Pow(±0, y) = +0 for finite y > 0 and not an odd integer
;; 	Pow(-1, ±Inf) = 1
;; 	Pow(x, +Inf) = +Inf for |x| > 1
;; 	Pow(x, -Inf) = +0 for |x| > 1
;; 	Pow(x, +Inf) = +0 for |x| < 1
;; 	Pow(x, -Inf) = +Inf for |x| < 1
;; 	Pow(+Inf, y) = +Inf for y > 0
;; 	Pow(+Inf, y) = +0 for y < 0
;; 	Pow(-Inf, y) = Pow(-0, -y)
;; 	Pow(x, y) = NaN for finite x < 0 and finite non-integer y"
;;   {:added "1.0"
;;    :go "pow(x, y)"}
;;   [x, y])
;; 
JOKER FUNC math.Pow10 has: 
;; (defn ^ABEND042(cannot find typename math.float64) Pow10
;;   "Pow10 returns 10**n, the base-10 exponential of n.
;; 
;; Special cases are:
;; 	Pow10(n) =    0 for n < -323
;; 	Pow10(n) = +Inf for n > 308"
;;   {:added "1.0"
;;    :go "pow10(n)"}
;;   [^Int n])
;; 
JOKER FUNC math.Remainder has: 
;; (defn ^ABEND042(cannot find typename math.float64) Remainder
;;   "Remainder returns the IEEE 754 floating-point remainder of x/y.
;; 
;; Special cases are:
;; 	Remainder(±Inf, y) = NaN
;; 	Remainder(NaN, y) = NaN
;; 	Remainder(x, 0) = NaN
;; 	Remainder(x, ±Inf) = x
;; 	Remainder(x, NaN) = NaN"
;;   {:added "1.0"
;;    :go "remainder(x, y)"}
;;   [x, y])
;; 
JOKER FUNC math.Round has: 
;; (defn ^ABEND042(cannot find typename math.float64) Round
;;   "Round returns the nearest integer, rounding half away from zero.
;; 
;; Special cases are:
;; 	Round(±0) = ±0
;; 	Round(±Inf) = ±Inf
;; 	Round(NaN) = NaN"
;;   {:added "1.0"
;;    :go "round(x)"}
;;   [x])
;; 
JOKER FUNC math.RoundToEven has: 
;; (defn ^ABEND042(cannot find typename math.float64) RoundToEven
;;   "RoundToEven returns the nearest integer, rounding ties to even.
;; 
;; Special cases are:
;; 	RoundToEven(±0) = ±0
;; 	RoundToEven(±Inf) = ±Inf
;; 	RoundToEven(NaN) = NaN"
;;   {:added "1.0"
;;    :go "roundToEven(x)"}
;;   [x])
;; 
JOKER FUNC math.Signbit has: 
;; (defn ^ABEND042(cannot find typename math.bool) Signbit
;;   "Signbit returns true if x is negative or negative zero."
;;   {:added "1.0"
;;    :go "signbit(x)"}
;;   [x])
;; 
JOKER FUNC math.Sin has: 
;; (defn ^ABEND042(cannot find typename math.float64) Sin
;;   "Sin returns the sine of the radian argument x.
;; 
;; Special cases are:
;; 	Sin(±0) = ±0
;; 	Sin(±Inf) = NaN
;; 	Sin(NaN) = NaN"
;;   {:added "1.0"
;;    :go "sin(x)"}
;;   [x])
;; 
JOKER FUNC math.Sincos has: 
(defn ^[sin cos] Sincos
  "Sincos returns Sin(x), Cos(x).

Special cases are:
	Sincos(±0) = ±0, 1
	Sincos(±Inf) = NaN, NaN
	Sincos(NaN) = NaN, NaN"
  {:added "1.0"
   :go "sincos(x)"}
  [x])

JOKER FUNC math.Sinh has: 
;; (defn ^ABEND042(cannot find typename math.float64) Sinh
;;   "Sinh returns the hyperbolic sine of x.
;; 
;; Special cases are:
;; 	Sinh(±0) = ±0
;; 	Sinh(±Inf) = ±Inf
;; 	Sinh(NaN) = NaN"
;;   {:added "1.0"
;;    :go "sinh(x)"}
;;   [x])
;; 
JOKER FUNC math.Sqrt has: 
;; (defn ^ABEND042(cannot find typename math.float64) Sqrt
;;   "Sqrt returns the square root of x.
;; 
;; Special cases are:
;; 	Sqrt(+Inf) = +Inf
;; 	Sqrt(±0) = ±0
;; 	Sqrt(x < 0) = NaN
;; 	Sqrt(NaN) = NaN"
;;   {:added "1.0"
;;    :go "sqrt(x)"}
;;   [x])
;; 
JOKER FUNC math.Tan has: 
;; (defn ^ABEND042(cannot find typename math.float64) Tan
;;   "Tan returns the tangent of the radian argument x.
;; 
;; Special cases are:
;; 	Tan(±0) = ±0
;; 	Tan(±Inf) = NaN
;; 	Tan(NaN) = NaN"
;;   {:added "1.0"
;;    :go "tan(x)"}
;;   [x])
;; 
JOKER FUNC math.Tanh has: 
;; (defn ^ABEND042(cannot find typename math.float64) Tanh
;;   "Tanh returns the hyperbolic tangent of x.
;; 
;; Special cases are:
;; 	Tanh(±0) = ±0
;; 	Tanh(±Inf) = ±1
;; 	Tanh(NaN) = NaN"
;;   {:added "1.0"
;;    :go "tanh(x)"}
;;   [x])
;; 
JOKER FUNC math.Trunc has: 
;; (defn ^ABEND042(cannot find typename math.float64) Trunc
;;   "Trunc returns the integer value of x.
;; 
;; Special cases are:
;; 	Trunc(±0) = ±0
;; 	Trunc(±Inf) = ±Inf
;; 	Trunc(NaN) = NaN"
;;   {:added "1.0"
;;    :go "trunc(x)"}
;;   [x])
;; 
JOKER FUNC math.Y0 has: 
;; (defn ^ABEND042(cannot find typename math.float64) Y0
;;   "Y0 returns the order-zero Bessel function of the second kind.
;; 
;; Special cases are:
;; 	Y0(+Inf) = 0
;; 	Y0(0) = -Inf
;; 	Y0(x < 0) = NaN
;; 	Y0(NaN) = NaN"
;;   {:added "1.0"
;;    :go "y0(x)"}
;;   [x])
;; 
JOKER FUNC math.Y1 has: 
;; (defn ^ABEND042(cannot find typename math.float64) Y1
;;   "Y1 returns the order-one Bessel function of the second kind.
;; 
;; Special cases are:
;; 	Y1(+Inf) = 0
;; 	Y1(0) = -Inf
;; 	Y1(x < 0) = NaN
;; 	Y1(NaN) = NaN"
;;   {:added "1.0"
;;    :go "y1(x)"}
;;   [x])
;; 
JOKER FUNC math.Yn has: 
;; (defn ^ABEND042(cannot find typename math.float64) Yn
;;   "Yn returns the order-n Bessel function of the second kind.
;; 
;; Special cases are:
;; 	Yn(n, +Inf) = 0
;; 	Yn(n ≥ 0, 0) = -Inf
;; 	Yn(n < 0, 0) = +Inf if n is odd, -Inf if n is even
;; 	Yn(n, x < 0) = NaN
;; 	Yn(n, NaN) = NaN"
;;   {:added "1.0"
;;    :go "yn(n, x)"}
;;   [^Int n, x])
;; 
JOKER FUNC md5.New has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New
;;   "New returns a new hash.Hash computing the MD5 checksum. The Hash also
;; implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to
;; marshal and unmarshal the internal state of the hash."
;;   {:added "1.0"
;;    :go "new()"}
;;   [])
;; 
JOKER FUNC md5.Sum has: 
;; (defn ^[ABEND042(cannot find typename md5.byte)] Sum
;;   "Sum returns the MD5 checksum of the data."
;;   {:added "1.0"
;;    :go "sum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{578800 <nil> byte}) data])
;; 
JOKER FUNC mime.AddExtensionType has: 
(defn ^Error AddExtensionType
  "AddExtensionType sets the MIME type associated with
the extension ext to typ. The extension should begin with
a leading dot, as in ".html"."
  {:added "1.0"
   :go "addExtensionType(ext, typ)"}
  [^String ext, ^String typ])

JOKER FUNC mime.ExtensionsByType has: 
(defn ^[[String] Error] ExtensionsByType
  "ExtensionsByType returns the extensions known to be associated with the MIME
type typ. The returned extensions will each begin with a leading dot, as in
".html". When typ has no associated extensions, ExtensionsByType returns an
nil slice."
  {:added "1.0"
   :go "extensionsByType(typ)"}
  [^String typ])

JOKER FUNC mime.FormatMediaType has: 
;; (defn ^String FormatMediaType
;;   "FormatMediaType serializes mediatype t and the parameters
;; param as a media type conforming to RFC 2045 and RFC 2616.
;; The type and parameter names are written in lower-case.
;; When any of the arguments result in a standard violation then
;; FormatMediaType returns the empty string."
;;   {:added "1.0"
;;    :go "formatMediaType(t, param)"}
;;   [^String t, ^ABEND881(unrecognized Expr type *ast.MapType at: &{3988611 string string}) param])
;; 
JOKER FUNC mime.ParseMediaType has: 
(defn ^[mediatype params err] ParseMediaType
  "ParseMediaType parses a media type value and any optional
parameters, per RFC 1521.  Media types are the values in
Content-Type and Content-Disposition headers (RFC 2183).
On success, ParseMediaType returns the media type converted
to lowercase and trimmed of white space and a non-nil map.
If there is an error parsing the optional parameter,
the media type will be returned along with the error
ErrInvalidMediaParameter.
The returned map, params, maps from the lowercase
attribute to the attribute value with its case preserved."
  {:added "1.0"
   :go "parseMediaType(v)"}
  [^String v])

JOKER FUNC mime.TypeByExtension has: 
(defn ^String TypeByExtension
  "TypeByExtension returns the MIME type associated with the file extension ext.
The extension ext should begin with a leading dot, as in ".html".
When ext has no associated type, TypeByExtension returns "".

Extensions are looked up first case-sensitively, then case-insensitively.

The built-in table is small but on unix it is augmented by the local
system's mime.types file(s) if available under one or more of these
names:

  /etc/mime.types
  /etc/apache2/mime.types
  /etc/apache/mime.types

On Windows, MIME types are extracted from the registry.

Text types have the charset parameter set to "utf-8" by default."
  {:added "1.0"
   :go "typeByExtension(ext)"}
  [^String ext])

JOKER FUNC multipart.NewReader has: 
;; (defn ^{:bufreader ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4027184 0xc000d82660}) bufReader, :currentpart ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4027212 Part}) currentPart, :partsread ^Int partsRead, :nl ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{4027254 <nil> byte}) nl, :nldashboundary ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{4027336 <nil> byte}) nlDashBoundary, :dashboundarydash ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{4027382 <nil> byte}) dashBoundaryDash, :dashboundary ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{4027425 <nil> byte}) dashBoundary} NewReader
;;   "NewReader creates a new multipart Reader reading from r using the
;; given MIME boundary.
;; 
;; The boundary is usually obtained from the "boundary" parameter of
;; the message's "Content-Type" header. Use mime.ParseMediaType to
;; parse such headers."
;;   {:added "1.0"
;;    :go "newReader(r, boundary)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, ^String boundary])
;; 
JOKER FUNC multipart.NewWriter has: 
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :boundary ^String boundary, :lastpart ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4010228 part}) lastpart} NewWriter
;;   "NewWriter returns a new multipart Writer with a random boundary,
;; writing to w."
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC net.CIDRMask has: 
;; (defn ^[ABEND042(cannot find typename net.byte)] CIDRMask
;;   "CIDRMask returns an IPMask consisting of `ones' 1 bits
;; followed by 0s up to a total length of `bits' bits.
;; For a mask of this form, CIDRMask is the inverse of IPMask.Size."
;;   {:added "1.0"
;;    :go "cIDRMask(ones, bits)"}
;;   [^Int ones, ^Int bits])
;; 
JOKER FUNC net.Dial has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4048646 0xc000d2de60 false}) Error] Dial
;;   "Dial connects to the address on the named network.
;; 
;; Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only),
;; "udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4"
;; (IPv4-only), "ip6" (IPv6-only), "unix", "unixgram" and
;; "unixpacket".
;; 
;; For TCP and UDP networks, the address has the form "host:port".
;; The host must be a literal IP address, or a host name that can be
;; resolved to IP addresses.
;; The port must be a literal port number or a service name.
;; If the host is a literal IPv6 address it must be enclosed in square
;; brackets, as in "[2001:db8::1]:80" or "[fe80::1%zone]:80".
;; The zone specifies the scope of the literal IPv6 address as defined
;; in RFC 4007.
;; The functions JoinHostPort and SplitHostPort manipulate a pair of
;; host and port in this form.
;; When using TCP, and the host resolves to multiple IP addresses,
;; Dial will try each IP address in order until one succeeds.
;; 
;; Examples:
;; 	Dial("tcp", "golang.org:http")
;; 	Dial("tcp", "192.0.2.1:http")
;; 	Dial("tcp", "198.51.100.1:80")
;; 	Dial("udp", "[2001:db8::1]:domain")
;; 	Dial("udp", "[fe80::1%lo0]:53")
;; 	Dial("tcp", ":80")
;; 
;; For IP networks, the network must be "ip", "ip4" or "ip6" followed
;; by a colon and a literal protocol number or a protocol name, and
;; the address has the form "host". The host must be a literal IP
;; address or a literal IPv6 address with zone.
;; It depends on each operating system how the operating system
;; behaves with a non-well known protocol number such as "0" or "255".
;; 
;; Examples:
;; 	Dial("ip4:1", "192.0.2.1")
;; 	Dial("ip6:ipv6-icmp", "2001:db8::1")
;; 	Dial("ip6:58", "fe80::1%lo0")
;; 
;; For TCP, UDP and IP networks, if the host is empty or a literal
;; unspecified IP address, as in ":80", "0.0.0.0:80" or "[::]:80" for
;; TCP and UDP, "", "0.0.0.0" or "::" for IP, the local system is
;; assumed.
;; 
;; For Unix networks, the address must be a file system path."
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC net.DialIP has: 
;; (defn ^[{} Error] DialIP
;;   "DialIP acts like Dial for IP networks.
;; 
;; The network must be an IP network name; see func Dial for details.
;; 
;; If laddr is nil, a local address is automatically chosen.
;; If the IP field of raddr is nil or an unspecified IP address, the
;; local system is assumed."
;;   {:added "1.0"
;;    :go "dialIP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4043560 IPAddr}) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4043560 IPAddr}) raddr])
;; 
JOKER FUNC net.DialTCP has: 
;; (defn ^[{} Error] DialTCP
;;   "DialTCP acts like Dial for TCP networks.
;; 
;; The network must be a TCP network name; see func Dial for details.
;; 
;; If laddr is nil, a local address is automatically chosen.
;; If the IP field of raddr is nil or an unspecified IP address, the
;; local system is assumed."
;;   {:added "1.0"
;;    :go "dialTCP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4218672 TCPAddr}) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4218672 TCPAddr}) raddr])
;; 
JOKER FUNC net.DialTimeout has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4048646 0xc000d2de60 false}) Error] DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.
;; 
;; The timeout includes name resolution, if required.
;; When using TCP, and the host in the address parameter resolves to
;; multiple IP addresses, the timeout is spread over each consecutive
;; dial, such that each is given an appropriate fraction of the time
;; to connect.
;; 
;; See func Dial for a description of the network and address
;; parameters."
;;   {:added "1.0"
;;    :go "dialTimeout(network, address, timeout)"}
;;   [^String network, ^String address, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}) timeout])
;; 
JOKER FUNC net.DialUDP has: 
;; (defn ^[{} Error] DialUDP
;;   "DialUDP acts like Dial for UDP networks.
;; 
;; The network must be a UDP network name; see func Dial for details.
;; 
;; If laddr is nil, a local address is automatically chosen.
;; If the IP field of raddr is nil or an unspecified IP address, the
;; local system is assumed."
;;   {:added "1.0"
;;    :go "dialUDP(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4296679 UDPAddr}) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4296679 UDPAddr}) raddr])
;; 
JOKER FUNC net.DialUnix has: 
;; (defn ^[{} Error] DialUnix
;;   "DialUnix acts like Dial for Unix networks.
;; 
;; The network must be a Unix network name; see func Dial for details.
;; 
;; If laddr is non-nil, it is used as the local address for the
;; connection."
;;   {:added "1.0"
;;    :go "dialUnix(network, laddr, raddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4098110 UnixAddr}) laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4098110 UnixAddr}) raddr])
;; 
JOKER FUNC net.FileConn has: 
;; (defn ^[c err] FileConn
;;   "FileConn returns a copy of the network connection corresponding to
;; the open file f.
;; It is the caller's responsibility to close f when finished.
;; Closing c does not affect f, and closing f does not affect c."
;;   {:added "1.0"
;;    :go "fileConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4158768 0xc00095ba80}) f])
;; 
JOKER FUNC net.FileListener has: 
;; (defn ^[ln err] FileListener
;;   "FileListener returns a copy of the network listener corresponding
;; to the open file f.
;; It is the caller's responsibility to close ln when finished.
;; Closing ln does not affect f, and closing f does not affect ln."
;;   {:added "1.0"
;;    :go "fileListener(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4159191 0xc00095bfe0}) f])
;; 
JOKER FUNC net.FilePacketConn has: 
;; (defn ^[c err] FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection
;; corresponding to the open file f.
;; It is the caller's responsibility to close f when finished.
;; Closing c does not affect f, and closing f does not affect c."
;;   {:added "1.0"
;;    :go "filePacketConn(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4159634 0xc0004def40}) f])
;; 
JOKER FUNC net.IPv4 has: 
;; (defn ^[ABEND042(cannot find typename net.byte)] IPv4
;;   "IPv4 returns the IP address (in 16-byte form) of the
;; IPv4 address a.b.c.d."
;;   {:added "1.0"
;;    :go "iPv4(a, b, c, d)"}
;;   [a, b, c, d])
;; 
JOKER FUNC net.IPv4Mask has: 
;; (defn ^[ABEND042(cannot find typename net.byte)] IPv4Mask
;;   "IPv4Mask returns the IP mask (in 4-byte form) of the
;; IPv4 mask a.b.c.d."
;;   {:added "1.0"
;;    :go "iPv4Mask(a, b, c, d)"}
;;   [a, b, c, d])
;; 
JOKER FUNC net.InterfaceAddrs has: 
;; (defn ^[[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4048330 0xc000d2daa0 false})] Error] InterfaceAddrs
;;   "InterfaceAddrs returns a list of the system's unicast interface
;; addresses.
;; 
;; The returned list does not identify the associated interface; use
;; Interfaces and Interface.Addrs for more detail."
;;   {:added "1.0"
;;    :go "interfaceAddrs()"}
;;   [])
;; 
JOKER FUNC net.InterfaceByIndex has: 
(defn ^[{:index ^Int Index, :mtu ^Int MTU, :name ^String Name, :hardwareaddr HardwareAddr, :flags Flags} Error] InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.

On Solaris, it returns one of the logical network interfaces
sharing the logical data link; for more precision use
InterfaceByName."
  {:added "1.0"
   :go "interfaceByIndex(index)"}
  [^Int index])

JOKER FUNC net.InterfaceByName has: 
(defn ^[{:index ^Int Index, :mtu ^Int MTU, :name ^String Name, :hardwareaddr HardwareAddr, :flags Flags} Error] InterfaceByName
  "InterfaceByName returns the interface specified by name."
  {:added "1.0"
   :go "interfaceByName(name)"}
  [^String name])

JOKER FUNC net.Interfaces has: 
(defn ^[[{:index ^Int Index, :mtu ^Int MTU, :name ^String Name, :hardwareaddr HardwareAddr, :flags Flags}] Error] Interfaces
  "Interfaces returns a list of the system's network interfaces."
  {:added "1.0"
   :go "interfaces()"}
  [])

JOKER FUNC net.JoinHostPort has: 
(defn ^String JoinHostPort
  "JoinHostPort combines host and port into a network address of the
form "host:port". If host contains a colon, as found in literal
IPv6 addresses, then JoinHostPort returns "[host]:port".

See func Dial for a description of the host and port parameters."
  {:added "1.0"
   :go "joinHostPort(host, port)"}
  [^String host, ^String port])

JOKER FUNC net.Listen has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4056952 0xc000fd89c0 false}) Error] Listen
;;   "Listen announces on the local network address.
;; 
;; The network must be "tcp", "tcp4", "tcp6", "unix" or "unixpacket".
;; 
;; For TCP networks, if the host in the address parameter is empty or
;; a literal unspecified IP address, Listen listens on all available
;; unicast and anycast IP addresses of the local system.
;; To only use IPv4, use network "tcp4".
;; The address can use a host name, but this is not recommended,
;; because it will create a listener for at most one of the host's IP
;; addresses.
;; If the port in the address parameter is empty or "0", as in
;; "127.0.0.1:" or "[::1]:0", a port number is automatically chosen.
;; The Addr method of Listener can be used to discover the chosen
;; port.
;; 
;; See func Dial for a description of the network and address
;; parameters."
;;   {:added "1.0"
;;    :go "listen(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC net.ListenIP has: 
;; (defn ^[{} Error] ListenIP
;;   "ListenIP acts like ListenPacket for IP networks.
;; 
;; The network must be an IP network name; see func Dial for details.
;; 
;; If the IP field of laddr is nil or an unspecified IP address,
;; ListenIP listens on all available IP addresses of the local system
;; except multicast IP addresses."
;;   {:added "1.0"
;;    :go "listenIP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4044312 IPAddr}) laddr])
;; 
JOKER FUNC net.ListenMulticastUDP has: 
;; (defn ^[{} Error] ListenMulticastUDP
;;   "ListenMulticastUDP acts like ListenPacket for UDP networks but
;; takes a group address on a specific network interface.
;; 
;; The network must be a UDP network name; see func Dial for details.
;; 
;; ListenMulticastUDP listens on all available IP addresses of the
;; local system including the group, multicast IP address.
;; If ifi is nil, ListenMulticastUDP uses the system-assigned
;; multicast interface, although this is not recommended because the
;; assignment depends on platforms and sometimes it might require
;; routing configuration.
;; If the Port field of gaddr is 0, a port number is automatically
;; chosen.
;; 
;; ListenMulticastUDP is just for convenience of simple, small
;; applications. There are golang.org/x/net/ipv4 and
;; golang.org/x/net/ipv6 packages for general purpose uses."
;;   {:added "1.0"
;;    :go "listenMulticastUDP(network, ifi, gaddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4299060 Interface}) ifi, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4299078 UDPAddr}) gaddr])
;; 
JOKER FUNC net.ListenPacket has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4054377 0xc000fd8840 false}) Error] ListenPacket
;;   "ListenPacket announces on the local network address.
;; 
;; The network must be "udp", "udp4", "udp6", "unixgram", or an IP
;; transport. The IP transports are "ip", "ip4", or "ip6" followed by
;; a colon and a literal protocol number or a protocol name, as in
;; "ip:1" or "ip:icmp".
;; 
;; For UDP and IP networks, if the host in the address parameter is
;; empty or a literal unspecified IP address, ListenPacket listens on
;; all available IP addresses of the local system except multicast IP
;; addresses.
;; To only use IPv4, use network "udp4" or "ip4:proto".
;; The address can use a host name, but this is not recommended,
;; because it will create a listener for at most one of the host's IP
;; addresses.
;; If the port in the address parameter is empty or "0", as in
;; "127.0.0.1:" or "[::1]:0", a port number is automatically chosen.
;; The LocalAddr method of PacketConn can be used to discover the
;; chosen port.
;; 
;; See func Dial for a description of the network and address
;; parameters."
;;   {:added "1.0"
;;    :go "listenPacket(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC net.ListenTCP has: 
;; (defn ^[{:fd ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4219440 netFD}) fd} Error] ListenTCP
;;   "ListenTCP acts like Listen for TCP networks.
;; 
;; The network must be a TCP network name; see func Dial for details.
;; 
;; If the IP field of laddr is nil or an unspecified IP address,
;; ListenTCP listens on all available unicast and anycast IP addresses
;; of the local system.
;; If the Port field of laddr is 0, a port number is automatically
;; chosen."
;;   {:added "1.0"
;;    :go "listenTCP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4222364 TCPAddr}) laddr])
;; 
JOKER FUNC net.ListenUDP has: 
;; (defn ^[{} Error] ListenUDP
;;   "ListenUDP acts like ListenPacket for UDP networks.
;; 
;; The network must be a UDP network name; see func Dial for details.
;; 
;; If the IP field of laddr is nil or an unspecified IP address,
;; ListenUDP listens on all available IP addresses of the local system
;; except multicast IP addresses.
;; If the Port field of laddr is 0, a port number is automatically
;; chosen."
;;   {:added "1.0"
;;    :go "listenUDP(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4297706 UDPAddr}) laddr])
;; 
JOKER FUNC net.ListenUnix has: 
;; (defn ^[{:fd ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4098798 netFD}) fd, :path ^String path, :unlink unlink, :unlinkonce ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Once}) unlinkOnce} Error] ListenUnix
;;   "ListenUnix acts like Listen for Unix networks.
;; 
;; The network must be "unix" or "unixpacket"."
;;   {:added "1.0"
;;    :go "listenUnix(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4101577 UnixAddr}) laddr])
;; 
JOKER FUNC net.ListenUnixgram has: 
;; (defn ^[{} Error] ListenUnixgram
;;   "ListenUnixgram acts like ListenPacket for Unix networks.
;; 
;; The network must be "unixgram"."
;;   {:added "1.0"
;;    :go "listenUnixgram(network, laddr)"}
;;   [^String network, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4102318 UnixAddr}) laddr])
;; 
JOKER FUNC net.LookupAddr has: 
(defn ^[names err] LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.

When using the host C library resolver, at most one result will be
returned. To bypass the host resolver, use a custom Resolver."
  {:added "1.0"
   :go "lookupAddr(addr)"}
  [^String addr])

JOKER FUNC net.LookupCNAME has: 
(defn ^[cname err] LookupCNAME
  "LookupCNAME returns the canonical name for the given host.
Callers that do not care about the canonical name can call
LookupHost or LookupIP directly; both take care of resolving
the canonical name as part of the lookup.

A canonical name is the final name after following zero
or more CNAME records.
LookupCNAME does not return an error if host does not
contain DNS "CNAME" records, as long as host resolves to
address records."
  {:added "1.0"
   :go "lookupCNAME(host)"}
  [^String host])

JOKER FUNC net.LookupHost has: 
(defn ^[addrs err] LookupHost
  "LookupHost looks up the given host using the local resolver.
It returns a slice of that host's addresses."
  {:added "1.0"
   :go "lookupHost(host)"}
  [^String host])

JOKER FUNC net.LookupIP has: 
;; (defn ^[[[ABEND042(cannot find typename net.byte)]] Error] LookupIP
;;   "LookupIP looks up host using the local resolver.
;; It returns a slice of that host's IPv4 and IPv6 addresses."
;;   {:added "1.0"
;;    :go "lookupIP(host)"}
;;   [^String host])
;; 
JOKER FUNC net.LookupMX has: 
(defn ^[[{:host ^String Host, :pref ^Int Pref}] Error] LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference."
  {:added "1.0"
   :go "lookupMX(name)"}
  [^String name])

JOKER FUNC net.LookupNS has: 
(defn ^[[{:host ^String Host}] Error] LookupNS
  "LookupNS returns the DNS NS records for the given domain name."
  {:added "1.0"
   :go "lookupNS(name)"}
  [^String name])

JOKER FUNC net.LookupPort has: 
(defn ^[port err] LookupPort
  "LookupPort looks up the port for the given network and service."
  {:added "1.0"
   :go "lookupPort(network, service)"}
  [^String network, ^String service])

JOKER FUNC net.LookupSRV has: 
(defn ^[cname addrs err] LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,
protocol, and domain name. The proto is "tcp" or "udp".
The returned records are sorted by priority and randomized
by weight within a priority.

LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name. To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly."
  {:added "1.0"
   :go "lookupSRV(service, proto, name)"}
  [^String service, ^String proto, ^String name])

JOKER FUNC net.LookupTXT has: 
(defn ^[[String] Error] LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name."
  {:added "1.0"
   :go "lookupTXT(name)"}
  [^String name])

JOKER FUNC net.ParseCIDR has: 
;; (defn ^[[ABEND042(cannot find typename net.byte)] {:ip IP, :mask Mask} Error] ParseCIDR
;;   "ParseCIDR parses s as a CIDR notation IP address and prefix length,
;; like "192.0.2.0/24" or "2001:db8::/32", as defined in
;; RFC 4632 and RFC 4291.
;; 
;; It returns the IP address and the network implied by the IP and
;; prefix length.
;; For example, ParseCIDR("192.0.2.1/24") returns the IP address
;; 192.0.2.1 and the network 192.0.2.0/24."
;;   {:added "1.0"
;;    :go "parseCIDR(s)"}
;;   [^String s])
;; 
JOKER FUNC net.ParseIP has: 
;; (defn ^[ABEND042(cannot find typename net.byte)] ParseIP
;;   "ParseIP parses s as an IP address, returning the result.
;; The string s can be in dotted decimal ("192.0.2.1")
;; or IPv6 ("2001:db8::68") form.
;; If s is not a valid textual representation of an IP address,
;; ParseIP returns nil."
;;   {:added "1.0"
;;    :go "parseIP(s)"}
;;   [^String s])
;; 
JOKER FUNC net.ParseMAC has: 
(defn ^[hw err] ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet
IP over InfiniBand link-layer address using one of the following formats:
  01:23:45:67:89:ab
  01:23:45:67:89:ab:cd:ef
  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00
  01-23-45-67-89-ab
  01-23-45-67-89-ab-cd-ef
  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00
  0123.4567.89ab
  0123.4567.89ab.cdef
  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000"
  {:added "1.0"
   :go "parseMAC(s)"}
  [^String s])

JOKER FUNC net.Pipe has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4048646 0xc000d2de60 false}) ABEND883(unrecognized Expr type *ast.InterfaceType at: &{4048646 0xc000d2de60 false})] Pipe
;;   "Pipe creates a synchronous, in-memory, full duplex
;; network connection; both ends implement the Conn interface.
;; Reads on one end are matched with writes on the other,
;; copying data directly between the two; there is no internal
;; buffering."
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])
;; 
JOKER FUNC net.ResolveIPAddr has: 
(defn ^[{:ip IP, :zone ^String Zone} Error] ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.

The network must be an IP network name.

If the host in the address parameter is not a literal IP address,
ResolveIPAddr resolves the address to an address of IP end point.
Otherwise, it parses the address as a literal IP address.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.

See func Dial for a description of the network and address
parameters."
  {:added "1.0"
   :go "resolveIPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveTCPAddr has: 
(defn ^[{:ip IP, :port ^Int Port, :zone ^String Zone} Error] ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.

The network must be a TCP network name.

If the host in the address parameter is not a literal IP address or
the port is not a literal port number, ResolveTCPAddr resolves the
address to an address of TCP end point.
Otherwise, it parses the address as a pair of literal IP address
and port number.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.

See func Dial for a description of the network and address
parameters."
  {:added "1.0"
   :go "resolveTCPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveUDPAddr has: 
(defn ^[{:ip IP, :port ^Int Port, :zone ^String Zone} Error] ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.

The network must be a UDP network name.

If the host in the address parameter is not a literal IP address or
the port is not a literal port number, ResolveUDPAddr resolves the
address to an address of UDP end point.
Otherwise, it parses the address as a pair of literal IP address
and port number.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.

See func Dial for a description of the network and address
parameters."
  {:added "1.0"
   :go "resolveUDPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveUnixAddr has: 
(defn ^[{:name ^String Name, :net ^String Net} Error] ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.

The network must be a Unix network name.

See func Dial for a description of the network and address
parameters."
  {:added "1.0"
   :go "resolveUnixAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.SplitHostPort has: 
(defn ^[host port err] SplitHostPort
  "SplitHostPort splits a network address of the form "host:port",
"host%zone:port", "[host]:port" or "[host%zone]:port" into host or
host%zone and port.

A literal IPv6 address in hostport must be enclosed in square
brackets, as in "[::1]:80", "[::1%lo0]:80".

See func Dial for a description of the hostport parameter, and host
and port results."
  {:added "1.0"
   :go "splitHostPort(hostport)"}
  [^String hostport])

JOKER FUNC nettest.TestConn has: 
;; (defn TestConn
;;   "TestConn tests that a net.Conn implementation properly satisfies the interface.
;; The tests should not produce any false positives, but may experience
;; false negatives. Thus, some issues may only be detected when the test is
;; run multiple times. For maximal effectiveness, run the tests under the
;; race detector."
;;   {:added "1.0"
;;    :go "testConn(t, mp)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8638623 0xc001c25e80}) t, mp])
;; 
JOKER FUNC os.Chdir has: 
(defn ^Error Chdir
  "Chdir changes the current working directory to the named directory.
If there is an error, it will be of type *PathError."
  {:added "1.0"
   :go "chdir(dir)"}
  [^String dir])

JOKER FUNC os.Chmod has: 
(defn ^Error Chmod
  "Chmod changes the mode of the named file to mode.
If the file is a symbolic link, it changes the mode of the link's target.
If there is an error, it will be of type *PathError.

A different subset of the mode bits are used, depending on the
operating system.

On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and
ModeSticky are used.

On Windows, the mode must be non-zero but otherwise only the 0200
bit (owner writable) of mode is used; it controls whether the
file's read-only attribute is set or cleared. attribute. The other
bits are currently unused. Use mode 0400 for a read-only file and
0600 for a readable+writable file.

On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,
and ModeTemporary are used."
  {:added "1.0"
   :go "chmod(name, mode)"}
  [^String name, mode])

JOKER FUNC os.Chown has: 
(defn ^Error Chown
  "Chown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link's target.
A uid or gid of -1 means to not change that value.
If there is an error, it will be of type *PathError.

On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or
EPLAN9 error, wrapped in *PathError."
  {:added "1.0"
   :go "chown(name, uid, gid)"}
  [^String name, ^Int uid, ^Int gid])

JOKER FUNC os.Chtimes has: 
;; (defn ^Error Chtimes
;;   "Chtimes changes the access and modification times of the named
;; file, similar to the Unix utime() or utimes() functions.
;; 
;; The underlying filesystem may truncate or round the values to a
;; less precise time unit.
;; If there is an error, it will be of type *PathError."
;;   {:added "1.0"
;;    :go "chtimes(name, atime, mtime)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) atime, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) mtime])
;; 
JOKER FUNC os.Clearenv has: 
;; (defn Clearenv
;;   "Clearenv deletes all environment variables."
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])
;; 
JOKER FUNC os.Create has: 
(defn ^[{} Error] Create
  "Create creates the named file with mode 0666 (before umask), truncating
it if it already exists. If successful, methods on the returned
File can be used for I/O; the associated file descriptor has mode
O_RDWR.
If there is an error, it will be of type *PathError."
  {:added "1.0"
   :go "create(name)"}
  [^String name])

JOKER FUNC os.Environ has: 
(defn ^[String] Environ
  "Environ returns a copy of strings representing the environment,
in the form "key=value"."
  {:added "1.0"
   :go "environ()"}
  [])

JOKER FUNC os.Executable has: 
(defn ^[String Error] Executable
  "Executable returns the path name for the executable that started
the current process. There is no guarantee that the path is still
pointing to the correct executable. If a symlink was used to start
the process, depending on the operating system, the result might
be the symlink or the path it pointed to. If a stable result is
needed, path/filepath.EvalSymlinks might help.

Executable returns an absolute path unless an error occurred.

The main use case is finding resources located relative to an
executable.

Executable is not supported on nacl."
  {:added "1.0"
   :go "executable()"}
  [])

JOKER FUNC os.Exit has: 
;; (defn Exit
;;   "Exit causes the current program to exit with the given status code.
;; Conventionally, code zero indicates success, non-zero an error.
;; The program terminates immediately; deferred functions are not run."
;;   {:added "1.0"
;;    :go "exit(code)"}
;;   [^Int code])
;; 
JOKER FUNC os.Expand has: 
;; (defn ^String Expand
;;   "Expand replaces ${var} or $var in the string based on the mapping function.
;; For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv)."
;;   {:added "1.0"
;;    :go "expand(s, mapping)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5342156 0xc0015d9b90 0xc0015d9bc0}) mapping])
;; 
JOKER FUNC os.ExpandEnv has: 
(defn ^String ExpandEnv
  "ExpandEnv replaces ${var} or $var in the string according to the values
of the current environment variables. References to undefined
variables are replaced by the empty string."
  {:added "1.0"
   :go "expandEnv(s)"}
  [^String s])

JOKER FUNC os.FindProcess has: 
;; (defn ^[{:pid ^Int Pid, :handle handle, :isdone isdone, :sigmu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync RWMutex}) sigMu} Error] FindProcess
;;   "FindProcess looks for a running process by its pid.
;; 
;; The Process it returns can be used to obtain information
;; about the underlying operating system process.
;; 
;; On Unix systems, FindProcess always succeeds and returns a Process
;; for the given pid, regardless of whether the process exists."
;;   {:added "1.0"
;;    :go "findProcess(pid)"}
;;   [^Int pid])
;; 
JOKER FUNC os.Getegid has: 
(defn ^Int Getegid
  "Getegid returns the numeric effective group id of the caller.

On Windows, it returns -1."
  {:added "1.0"
   :go "getegid()"}
  [])

JOKER FUNC os.Getenv has: 
(defn ^String Getenv
  "Getenv retrieves the value of the environment variable named by the key.
It returns the value, which will be empty if the variable is not present.
To distinguish between an empty value and an unset value, use LookupEnv."
  {:added "1.0"
   :go "getenv(key)"}
  [^String key])

JOKER FUNC os.Geteuid has: 
(defn ^Int Geteuid
  "Geteuid returns the numeric effective user id of the caller.

On Windows, it returns -1."
  {:added "1.0"
   :go "geteuid()"}
  [])

JOKER FUNC os.Getgid has: 
(defn ^Int Getgid
  "Getgid returns the numeric group id of the caller.

On Windows, it returns -1."
  {:added "1.0"
   :go "getgid()"}
  [])

JOKER FUNC os.Getgroups has: 
(defn ^[[Int] Error] Getgroups
  "Getgroups returns a list of the numeric ids of groups that the caller belongs to.

On Windows, it returns syscall.EWINDOWS. See the os/user package
for a possible alternative."
  {:added "1.0"
   :go "getgroups()"}
  [])

JOKER FUNC os.Getpagesize has: 
(defn ^Int Getpagesize
  "Getpagesize returns the underlying system's memory page size."
  {:added "1.0"
   :go "getpagesize()"}
  [])

JOKER FUNC os.Getpid has: 
(defn ^Int Getpid
  "Getpid returns the process id of the caller."
  {:added "1.0"
   :go "getpid()"}
  [])

JOKER FUNC os.Getppid has: 
(defn ^Int Getppid
  "Getppid returns the process id of the caller's parent."
  {:added "1.0"
   :go "getppid()"}
  [])

JOKER FUNC os.Getuid has: 
(defn ^Int Getuid
  "Getuid returns the numeric user id of the caller.

On Windows, it returns -1."
  {:added "1.0"
   :go "getuid()"}
  [])

JOKER FUNC os.Getwd has: 
(defn ^[dir err] Getwd
  "Getwd returns a rooted path name corresponding to the
current directory. If the current directory can be
reached via multiple paths (due to symbolic links),
Getwd may return any one of them."
  {:added "1.0"
   :go "getwd()"}
  [])

JOKER FUNC os.Hostname has: 
(defn ^[name err] Hostname
  "Hostname returns the host name reported by the kernel."
  {:added "1.0"
   :go "hostname()"}
  [])

JOKER FUNC os.IsExist has: 
;; (defn ^ABEND042(cannot find typename os.bool) IsExist
;;   "IsExist returns a boolean indicating whether the error is known to report
;; that a file or directory already exists. It is satisfied by ErrExist as
;; well as some syscall errors."
;;   {:added "1.0"
;;    :go "isExist(err)"}
;;   [err])
;; 
JOKER FUNC os.IsNotExist has: 
;; (defn ^ABEND042(cannot find typename os.bool) IsNotExist
;;   "IsNotExist returns a boolean indicating whether the error is known to
;; report that a file or directory does not exist. It is satisfied by
;; ErrNotExist as well as some syscall errors."
;;   {:added "1.0"
;;    :go "isNotExist(err)"}
;;   [err])
;; 
JOKER FUNC os.IsPathSeparator has: 
;; (defn ^ABEND042(cannot find typename os.bool) IsPathSeparator
;;   "IsPathSeparator reports whether c is a directory separator character."
;;   {:added "1.0"
;;    :go "isPathSeparator(c)"}
;;   [c])
;; 
JOKER FUNC os.IsPermission has: 
;; (defn ^ABEND042(cannot find typename os.bool) IsPermission
;;   "IsPermission returns a boolean indicating whether the error is known to
;; report that permission is denied. It is satisfied by ErrPermission as well
;; as some syscall errors."
;;   {:added "1.0"
;;    :go "isPermission(err)"}
;;   [err])
;; 
JOKER FUNC os.IsTimeout has: 
;; (defn ^ABEND042(cannot find typename os.bool) IsTimeout
;;   "IsTimeout returns a boolean indicating whether the error is known
;; to report that a timeout occurred."
;;   {:added "1.0"
;;    :go "isTimeout(err)"}
;;   [err])
;; 
JOKER FUNC os.Lchown has: 
(defn ^Error Lchown
  "Lchown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link itself.
If there is an error, it will be of type *PathError.

On Windows, it always returns the syscall.EWINDOWS error, wrapped
in *PathError."
  {:added "1.0"
   :go "lchown(name, uid, gid)"}
  [^String name, ^Int uid, ^Int gid])

JOKER FUNC os.Link has: 
(defn ^Error Link
  "Link creates newname as a hard link to the oldname file.
If there is an error, it will be of type *LinkError."
  {:added "1.0"
   :go "link(oldname, newname)"}
  [^String oldname, ^String newname])

JOKER FUNC os.LookupEnv has: 
;; (defn ^[String ABEND042(cannot find typename os.bool)] LookupEnv
;;   "LookupEnv retrieves the value of the environment variable named
;; by the key. If the variable is present in the environment the
;; value (which may be empty) is returned and the boolean is true.
;; Otherwise the returned value will be empty and the boolean will
;; be false."
;;   {:added "1.0"
;;    :go "lookupEnv(key)"}
;;   [^String key])
;; 
JOKER FUNC os.Lstat has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5290227 0xc00152af60 false}) Error] Lstat
;;   "Lstat returns a FileInfo describing the named file.
;; If the file is a symbolic link, the returned FileInfo
;; describes the symbolic link. Lstat makes no attempt to follow the link.
;; If there is an error, it will be of type *PathError."
;;   {:added "1.0"
;;    :go "lstat(name)"}
;;   [^String name])
;; 
JOKER FUNC os.Mkdir has: 
(defn ^Error Mkdir
  "Mkdir creates a new directory with the specified name and permission
bits (before umask).
If there is an error, it will be of type *PathError."
  {:added "1.0"
   :go "mkdir(name, perm)"}
  [^String name, perm])

JOKER FUNC os.MkdirAll has: 
(defn ^Error MkdirAll
  "MkdirAll creates a directory named path,
along with any necessary parents, and returns nil,
or else returns an error.
The permission bits perm (before umask) are used for all
directories that MkdirAll creates.
If path is already a directory, MkdirAll does nothing
and returns nil."
  {:added "1.0"
   :go "mkdirAll(path, perm)"}
  [^String path, perm])

JOKER FUNC os.NewFile has: 
(defn ^{} NewFile
  "NewFile returns a new File with the given file descriptor and
name. The returned value will be nil if fd is not a valid file
descriptor. On Unix systems, if the file descriptor is in
non-blocking mode, NewFile will attempt to return a pollable File
(one for which the SetDeadline methods work)."
  {:added "1.0"
   :go "newFile(fd, name)"}
  [fd, ^String name])

JOKER FUNC os.NewSyscallError has: 
(defn ^Error NewSyscallError
  "NewSyscallError returns, as an error, a new SyscallError
with the given system call name and error details.
As a convenience, if err is nil, NewSyscallError returns nil."
  {:added "1.0"
   :go "newSyscallError(syscall, err)"}
  [^String syscall, err])

JOKER FUNC os.Open has: 
(defn ^[{} Error] Open
  "Open opens the named file for reading. If successful, methods on
the returned file can be used for reading; the associated file
descriptor has mode O_RDONLY.
If there is an error, it will be of type *PathError."
  {:added "1.0"
   :go "open(name)"}
  [^String name])

JOKER FUNC os.OpenFile has: 
(defn ^[{} Error] OpenFile
  "OpenFile is the generalized open call; most users will use Open
or Create instead. It opens the named file with specified flag
(O_RDONLY etc.) and perm (before umask), if applicable. If successful,
methods on the returned File can be used for I/O.
If there is an error, it will be of type *PathError."
  {:added "1.0"
   :go "openFile(name, flag, perm)"}
  [^String name, ^Int flag, perm])

JOKER FUNC os.Pipe has: 
(defn ^[r w err] Pipe
  "Pipe returns a connected pair of Files; reads from r return bytes written to w.
It returns the files and an error, if any."
  {:added "1.0"
   :go "pipe()"}
  [])

JOKER FUNC os.Readlink has: 
(defn ^[String Error] Readlink
  "Readlink returns the destination of the named symbolic link.
If there is an error, it will be of type *PathError."
  {:added "1.0"
   :go "readlink(name)"}
  [^String name])

JOKER FUNC os.Remove has: 
(defn ^Error Remove
  "Remove removes the named file or (empty) directory.
If there is an error, it will be of type *PathError."
  {:added "1.0"
   :go "remove(name)"}
  [^String name])

JOKER FUNC os.RemoveAll has: 
(defn ^Error RemoveAll
  "RemoveAll removes path and any children it contains.
It removes everything it can but returns the first error
it encounters. If the path does not exist, RemoveAll
returns nil (no error)."
  {:added "1.0"
   :go "removeAll(path)"}
  [^String path])

JOKER FUNC os.Rename has: 
(defn ^Error Rename
  "Rename renames (moves) oldpath to newpath.
If newpath already exists and is not a directory, Rename replaces it.
OS-specific restrictions may apply when oldpath and newpath are in different directories.
If there is an error, it will be of type *LinkError."
  {:added "1.0"
   :go "rename(oldpath, newpath)"}
  [^String oldpath, ^String newpath])

JOKER FUNC os.SameFile has: 
;; (defn ^ABEND042(cannot find typename os.bool) SameFile
;;   "SameFile reports whether fi1 and fi2 describe the same file.
;; For example, on Unix this means that the device and inode fields
;; of the two underlying structures are identical; on other systems
;; the decision may be based on the path names.
;; SameFile only applies to results returned by this package's Stat.
;; It returns false in other cases."
;;   {:added "1.0"
;;    :go "sameFile(fi1, fi2)"}
;;   [fi1, fi2])
;; 
JOKER FUNC os.Setenv has: 
(defn ^Error Setenv
  "Setenv sets the value of the environment variable named by the key.
It returns an error, if any."
  {:added "1.0"
   :go "setenv(key, value)"}
  [^String key, ^String value])

JOKER FUNC os.StartProcess has: 
;; (defn ^[{:pid ^Int Pid, :handle handle, :isdone isdone, :sigmu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync RWMutex}) sigMu} Error] StartProcess
;;   "StartProcess starts a new process with the program, arguments and attributes
;; specified by name, argv and attr. The argv slice will become os.Args in the
;; new process, so it normally starts with the program name.
;; 
;; If the calling goroutine has locked the operating system thread
;; with runtime.LockOSThread and modified any inheritable OS-level
;; thread state (for example, Linux or Plan 9 name spaces), the new
;; process will inherit the caller's thread state.
;; 
;; StartProcess is a low-level interface. The os/exec package provides
;; higher-level interfaces.
;; 
;; If there is an error, it will be of type *PathError."
;;   {:added "1.0"
;;    :go "startProcess(name, argv, attr)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5278432 <nil> string}) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5278447 ProcAttr}) attr])
;; 
JOKER FUNC os.Stat has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5290227 0xc00152af60 false}) Error] Stat
;;   "Stat returns a FileInfo describing the named file.
;; If there is an error, it will be of type *PathError."
;;   {:added "1.0"
;;    :go "stat(name)"}
;;   [^String name])
;; 
JOKER FUNC os.Symlink has: 
(defn ^Error Symlink
  "Symlink creates newname as a symbolic link to oldname.
If there is an error, it will be of type *LinkError."
  {:added "1.0"
   :go "symlink(oldname, newname)"}
  [^String oldname, ^String newname])

JOKER FUNC os.TempDir has: 
(defn ^String TempDir
  "TempDir returns the default directory to use for temporary files.

On Unix systems, it returns $TMPDIR if non-empty, else /tmp.
On Windows, it uses GetTempPath, returning the first non-empty
value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.
On Plan 9, it returns /tmp.

The directory is neither guaranteed to exist nor have accessible
permissions."
  {:added "1.0"
   :go "tempDir()"}
  [])

JOKER FUNC os.Truncate has: 
(defn ^Error Truncate
  "Truncate changes the size of the named file.
If the file is a symbolic link, it changes the size of the link's target.
If there is an error, it will be of type *PathError."
  {:added "1.0"
   :go "truncate(name, size)"}
  [^String name, size])

JOKER FUNC os.Unsetenv has: 
(defn ^Error Unsetenv
  "Unsetenv unsets a single environment variable."
  {:added "1.0"
   :go "unsetenv(key)"}
  [^String key])

JOKER FUNC os.UserCacheDir has: 
(defn ^[String Error] UserCacheDir
  "UserCacheDir returns the default root directory to use for user-specific
cached data. Users should create their own application-specific subdirectory
within this one and use that.

On Unix systems, it returns $XDG_CACHE_HOME as specified by
https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html if
non-empty, else $HOME/.cache.
On Darwin, it returns $HOME/Library/Caches.
On Windows, it returns %LocalAppData%.
On Plan 9, it returns $home/lib/cache.

If the location cannot be determined (for example, $HOME is not defined),
then it will return an error."
  {:added "1.0"
   :go "userCacheDir()"}
  [])

JOKER FUNC parse.IsEmptyTree has: 
;; (defn ^ABEND042(cannot find typename parse.bool) IsEmptyTree
;;   "IsEmptyTree reports whether this tree (node) is empty of everything but space."
;;   {:added "1.0"
;;    :go "isEmptyTree(n)"}
;;   [n])
;; 
JOKER FUNC parse.New has: 
;; (defn ^{:name ^String Name, :parsename ^String ParseName, :root ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7760379 ListNode}) Root, :text ^String text, :funcs ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7760545 <nil> 0xc00075ab10}) funcs, :lex ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7760581 lexer}) lex, :token ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7760599 0xc000caa6a0 item}) token, :peekcount ^Int peekCount, :vars ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7760670 <nil> string}) vars, :treeset ^ABEND881(unrecognized Expr type *ast.MapType at: &{7760726 string 0xc000caab40}) treeSet} New
;;   "New allocates a new parse tree with the given name."
;;   {:added "1.0"
;;    :go "new(name, funcs)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{7762893 0xc000944510}) funcs])
;; 
JOKER FUNC parse.NewIdentifier has: 
;; (defn ^{:tr ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7786232 Tree}) tr, :ident ^String Ident} NewIdentifier
;;   "NewIdentifier returns a new IdentifierNode with the given identifier name."
;;   {:added "1.0"
;;    :go "newIdentifier(ident)"}
;;   [^String ident])
;; 
JOKER FUNC parse.Parse has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.MapType at: &{7761360 string 0xc000cab740}) Error] Parse
;;   "Parse returns a map from template name to parse.Tree, created by parsing the
;; templates described in the argument string. The top-level template will be
;; given the specified name. If an error is encountered, parsing stops and an
;; empty map is returned with the error."
;;   {:added "1.0"
;;    :go "parse(name, text, leftDelim, rightDelim, funcs)"}
;;   [^String name, ^String text, ^String leftDelim, ^String rightDelim, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{7761332 0xc00075af60}) funcs])
;; 
JOKER FUNC parser.ParseDir has: 
;; (defn ^[pkgs first] ParseDir
;;   "ParseDir calls ParseFile for all files with names ending in ".go" in the
;; directory specified by path and returns a map of package name -> package
;; AST with all the packages found.
;; 
;; If filter != nil, only the files with os.FileInfo entries passing through
;; the filter (and ending in ".go") are considered. The mode bits are passed
;; to ParseFile unchanged. Position information is recorded in fset, which
;; must not be nil.
;; 
;; If the directory couldn't be read, a nil map and the respective error are
;; returned. If a parse error occurred, a non-nil but incomplete map and the
;; first error encountered are returned."
;;   {:added "1.0"
;;    :go "parseDir(fset, path, filter, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2448116 0xc00065bde0}) fset, ^String path, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{2448152 0xc00087b9e0 0xc00087ba10}) filter, mode])
;; 
JOKER FUNC parser.ParseExpr has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{ast Expr}) Error] ParseExpr
;;   "ParseExpr is a convenience function for obtaining the AST of an expression x.
;; The position information recorded in the AST is undefined. The filename used
;; in error messages is the empty string."
;;   {:added "1.0"
;;    :go "parseExpr(x)"}
;;   [^String x])
;; 
JOKER FUNC parser.ParseExprFrom has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{ast Expr}) Error] ParseExprFrom
;;   "ParseExprFrom is a convenience function for parsing an expression.
;; The arguments have the same meaning as for ParseFile, but the source must
;; be a valid Go (type or value) expression. Specifically, fset must not
;; be nil."
;;   {:added "1.0"
;;    :go "parseExprFrom(fset, filename, src, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2449183 0xc0006a7100}) fset, ^String filename, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{2449220 0xc000890db0 false}) src, mode])
;; 
JOKER FUNC parser.ParseFile has: 
;; (defn ^[f err] ParseFile
;;   "ParseFile parses the source code of a single Go source file and returns
;; the corresponding ast.File node. The source code may be provided via
;; the filename of the source file, or via the src parameter.
;; 
;; If src != nil, ParseFile parses the source from src and the filename is
;; only used when recording position information. The type of the argument
;; for the src parameter must be string, []byte, or io.Reader.
;; If src == nil, ParseFile parses the file specified by filename.
;; 
;; The mode parameter controls the amount of source text parsed and other
;; optional parser functionality. Position information is recorded in the
;; file set fset, which must not be nil.
;; 
;; If the source couldn't be read, the returned AST is nil and the error
;; indicates the specific failure. If the source was read but syntax
;; errors were found, the result is a partial AST (with ast.Bad* nodes
;; representing the fragments of erroneous source code). Multiple errors
;; are returned via a scanner.ErrorList which is sorted by file position."
;;   {:added "1.0"
;;    :go "parseFile(fset, filename, src, mode)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2446643 0xc00065ae20}) fset, ^String filename, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{2446680 0xc00087b230 false}) src, mode])
;; 
JOKER FUNC path.Base has: 
(defn ^String Base
  "Base returns the last element of path.
Trailing slashes are removed before extracting the last element.
If the path is empty, Base returns ".".
If the path consists entirely of slashes, Base returns "/"."
  {:added "1.0"
   :go "base(path)"}
  [^String path])

JOKER FUNC path.Clean has: 
(defn ^String Clean
  "Clean returns the shortest path name equivalent to path
by purely lexical processing. It applies the following rules
iteratively until no further processing can be done:

	1. Replace multiple slashes with a single slash.
	2. Eliminate each . path name element (the current directory).
	3. Eliminate each inner .. path name element (the parent directory)
	   along with the non-.. element that precedes it.
	4. Eliminate .. elements that begin a rooted path:
	   that is, replace "/.." by "/" at the beginning of a path.

The returned path ends in a slash only if it is the root "/".

If the result of this process is an empty string, Clean
returns the string ".".

See also Rob Pike, ``Lexical File Names in Plan 9 or
Getting Dot-Dot Right,''
https://9p.io/sys/doc/lexnames.html"
  {:added "1.0"
   :go "clean(path)"}
  [^String path])

JOKER FUNC path.Dir has: 
(defn ^String Dir
  "Dir returns all but the last element of path, typically the path's directory.
After dropping the final element using Split, the path is Cleaned and trailing
slashes are removed.
If the path is empty, Dir returns ".".
If the path consists entirely of slashes followed by non-slash bytes, Dir
returns a single slash. In any other case, the returned path does not end in a
slash."
  {:added "1.0"
   :go "dir(path)"}
  [^String path])

JOKER FUNC path.Ext has: 
(defn ^String Ext
  "Ext returns the file name extension used by path.
The extension is the suffix beginning at the final dot
in the final slash-separated element of path;
it is empty if there is no dot."
  {:added "1.0"
   :go "ext(path)"}
  [^String path])

JOKER FUNC path.IsAbs has: 
;; (defn ^ABEND042(cannot find typename path.bool) IsAbs
;;   "IsAbs reports whether the path is absolute."
;;   {:added "1.0"
;;    :go "isAbs(path)"}
;;   [^String path])
;; 
JOKER FUNC path.Join has: 
;; (defn ^String Join
;;   "Join joins any number of path elements into a single path, adding a
;; separating slash if necessary. The result is Cleaned; in particular,
;; all empty strings are ignored."
;;   {:added "1.0"
;;    :go "join(elem)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{5409983 string}) elem])
;; 
JOKER FUNC path.Match has: 
(defn ^[matched err] Match
  "Match reports whether name matches the shell pattern.
The pattern syntax is:

	pattern:
		{ term }
	term:
		'*'         matches any sequence of non-/ characters
		'?'         matches any single non-/ character
		'[' [ '^' ] { character-range } ']'
		            character class (must be non-empty)
		c           matches character c (c != '*', '?', '\\', '[')
		'\\' c      matches character c

	character-range:
		c           matches character c (c != '\\', '-', ']')
		'\\' c      matches character c
		lo '-' hi   matches character c for lo <= c <= hi

Match requires pattern to match all of name, not just a substring.
The only possible returned error is ErrBadPattern, when pattern
is malformed."
  {:added "1.0"
   :go "match(pattern, name)"}
  [^String pattern, ^String name])

JOKER FUNC path.Split has: 
(defn ^[dir file] Split
  "Split splits path immediately following the final slash,
separating it into a directory and file name component.
If there is no slash in path, Split returns an empty dir and
file set to path.
The returned values have the property that path = dir+file."
  {:added "1.0"
   :go "split(path)"}
  [^String path])

JOKER FUNC pe.NewFile has: 
;; (defn ^[{:optionalheader ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1458033 0xc000164de0 false}) OptionalHeader, :sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1458111 <nil> 0xc0000a5200}) Sections, :symbols ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1458138 <nil> 0xc0000a52a0}) Symbols, :coffsymbols ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1458221 <nil> COFFSymbol}) COFFSymbols, :stringtable StringTable, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Closer}) closer} Error] NewFile
;;   "NewFile creates a new File for accessing a PE binary in an underlying reader."
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReaderAt}) r])
;; 
JOKER FUNC pe.Open has: 
;; (defn ^[{:optionalheader ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1458033 0xc000164de0 false}) OptionalHeader, :sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1458111 <nil> 0xc0000a5200}) Sections, :symbols ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1458138 <nil> 0xc0000a52a0}) Symbols, :coffsymbols ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1458221 <nil> COFFSymbol}) COFFSymbols, :stringtable StringTable, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Closer}) closer} Error] Open
;;   "Open opens the named file using os.Open and prepares it for use as a PE binary."
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])
;; 
JOKER FUNC pem.Decode has: 
;; (defn ^[p rest] Decode
;;   "Decode will find the next PEM formatted block (certificate, private key
;; etc) in the input. It returns that block and the remainder of the input. If
;; no PEM data is found, p is nil and the whole of the input is returned in
;; rest."
;;   {:added "1.0"
;;    :go "decode(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1876836 <nil> byte}) data])
;; 
JOKER FUNC pem.Encode has: 
;; (defn ^Error Encode
;;   "Encode writes the PEM encoding of b to out."
;;   {:added "1.0"
;;    :go "encode(out, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) out, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1881308 Block}) b])
;; 
JOKER FUNC pem.EncodeToMemory has: 
;; (defn ^[ABEND042(cannot find typename pem.byte)] EncodeToMemory
;;   "EncodeToMemory returns the PEM encoding of b.
;; 
;; If b has invalid headers and cannot be encoded,
;; EncodeToMemory returns nil. If it is important to
;; report details about this error case, use Encode instead."
;;   {:added "1.0"
;;    :go "encodeToMemory(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1883035 Block}) b])
;; 
JOKER FUNC plan9obj.NewFile has: 
;; (defn ^[{:sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1479381 <nil> 0xc000434a60}) Sections, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Closer}) closer} Error] NewFile
;;   "NewFile creates a new File for accessing a Plan 9 binary in an underlying reader.
;; The Plan 9 binary is expected to start at position 0 in the ReaderAt."
;;   {:added "1.0"
;;    :go "newFile(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReaderAt}) r])
;; 
JOKER FUNC plan9obj.Open has: 
;; (defn ^[{:sections ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1479381 <nil> 0xc000434a60}) Sections, :closer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Closer}) closer} Error] Open
;;   "Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary."
;;   {:added "1.0"
;;    :go "open(name)"}
;;   [^String name])
;; 
JOKER FUNC plugin.Open has: 
;; (defn ^[{:pluginpath ^String pluginpath, :err ^String err, :loaded ^ABEND881(unrecognized Expr type *ast.ChanType at: &{5443853 0 3 0xc00175e960}) loaded, :syms ^ABEND881(unrecognized Expr type *ast.MapType at: &{5443901 string 0xc00175ea40}) syms} Error] Open
;;   "Open opens a Go plugin.
;; If a path has already been opened, then the existing *Plugin is returned.
;; It is safe for concurrent use by multiple goroutines."
;;   {:added "1.0"
;;    :go "open(path)"}
;;   [^String path])
;; 
JOKER FUNC png.Decode has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{image Image}) Error] Decode
;;   "Decode reads a PNG image from r and returns it as an image.Image.
;; The type of Image returned depends on the PNG contents."
;;   {:added "1.0"
;;    :go "decode(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC png.DecodeConfig has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{image Config}) Error] DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a PNG image without
;; decoding the entire image."
;;   {:added "1.0"
;;    :go "decodeConfig(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC png.Encode has: 
;; (defn ^Error Encode
;;   "Encode writes the Image m to w in PNG format. Any Image may be
;; encoded, but images that are not image.NRGBA might be encoded lossily."
;;   {:added "1.0"
;;    :go "encode(w, m)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{image Image}) m])
;; 
JOKER FUNC poly1305.Sum has: 
;; (defn Sum
;;   "Sum generates an authenticator for m using a one-time key and puts the
;; 16-byte result into out. Authenticating two different messages with the same
;; key allows an attacker to forge messages at will."
;;   {:added "1.0"
;;    :go "sum(out, m, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8220702 0xc001486150}) out, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8220715 <nil> byte}) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8220727 0xc0014861b0}) key])
;; 
JOKER FUNC poly1305.Verify has: 
;; (defn ^ABEND042(cannot find typename poly1305.bool) Verify
;;   "Verify returns true if mac is a valid authenticator for m with the given
;; key."
;;   {:added "1.0"
;;    :go "verify(mac, m, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8220002 0xc00147dd40}) mac, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8220015 <nil> byte}) m, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8220027 0xc00147dda0}) key])
;; 
JOKER FUNC pprof.Cmdline has: 
;; (defn Cmdline
;;   "Cmdline responds with the running program's
;; command line, with arguments separated by NUL bytes.
;; The package initialization registers it as /debug/pprof/cmdline."
;;   {:added "1.0"
;;    :go "cmdline(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http ResponseWriter}) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5132354 0xc0010803e0}) r])
;; 
JOKER FUNC pprof.Do has: 
;; (defn Do
;;   "Do calls f with a copy of the parent context with the
;; given labels added to the parent's label map.
;; Each key/value pair in labels is inserted into the label map in the
;; order provided, overriding any previous value for the same key.
;; The augmented label map will be set for the duration of the call to f
;; and restored once f returns."
;;   {:added "1.0"
;;    :go "do(ctx, labels, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, labels, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7094256 0xc001b1b1a0 <nil>}) f])
;; 
JOKER FUNC pprof.ForLabels has: 
;; (defn ForLabels
;;   "ForLabels invokes f with each label set on the context.
;; The function f should return true to continue iteration or false to stop iteration early."
;;   {:added "1.0"
;;    :go "forLabels(ctx, f)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7090425 0xc001b00cf0 0xc001b00d20}) f])
;; 
JOKER FUNC pprof.Handler has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{http Handler}) Handler
;;   "Handler returns an HTTP handler that serves the named profile."
;;   {:added "1.0"
;;    :go "handler(name)"}
;;   [^String name])
;; 
JOKER FUNC pprof.Index has: 
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.
;; For example, "/debug/pprof/heap" serves the "heap" profile.
;; Index responds to a request for "/debug/pprof/" with an HTML page
;; listing the available profiles."
;;   {:added "1.0"
;;    :go "index(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http ResponseWriter}) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5138846 0xc00108b940}) r])
;; 
JOKER FUNC pprof.Label has: 
;; (defn ^[String ABEND042(cannot find typename pprof.bool)] Label
;;   "Label returns the value of the label with the given key on ctx, and a boolean indicating
;; whether that label exists."
;;   {:added "1.0"
;;    :go "label(ctx, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, ^String key])
;; 
JOKER FUNC pprof.Labels has: 
;; (defn ^{:list ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7088374 <nil> label}) list} Labels
;;   "Labels takes an even number of strings representing key-value pairs
;; and makes a LabelSet containing them.
;; A label overwrites a prior label with the same key."
;;   {:added "1.0"
;;    :go "labels(args)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{7089721 string}) args])
;; 
JOKER FUNC pprof.Lookup has: 
;; (defn ^{:name ^String name, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :m ^ABEND881(unrecognized Expr type *ast.MapType at: &{7065243 0xc001aa1d00 0xc001a97f20}) m, :count ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7065276 0xc001a97fb0 0xc001aba000}) count, :write ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7065294 0xc001aba060 0xc001aba090}) write} Lookup
;;   "Lookup returns the profile with the given name, or nil if no such profile exists."
;;   {:added "1.0"
;;    :go "lookup(name)"}
;;   [^String name])
;; 
JOKER FUNC pprof.NewProfile has: 
;; (defn ^{:name ^String name, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :m ^ABEND881(unrecognized Expr type *ast.MapType at: &{7065243 0xc001aa1d00 0xc001a97f20}) m, :count ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7065276 0xc001a97fb0 0xc001aba000}) count, :write ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7065294 0xc001aba060 0xc001aba090}) write} NewProfile
;;   "NewProfile creates a new profile with the given name.
;; If a profile with that name already exists, NewProfile panics.
;; The convention is to use a 'import/path.' prefix to create
;; separate name spaces for each package.
;; For compatibility with various tools that read pprof data,
;; profile names should not contain spaces."
;;   {:added "1.0"
;;    :go "newProfile(name)"}
;;   [^String name])
;; 
JOKER FUNC pprof.Profile has: 
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.
;; Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
;; The package initialization registers it as /debug/pprof/profile."
;;   {:added "1.0"
;;    :go "profile(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http ResponseWriter}) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5133491 0xc001081800}) r])
;; 
JOKER FUNC pprof.Profiles has: 
;; (defn ^[{:name ^String name, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :m ^ABEND881(unrecognized Expr type *ast.MapType at: &{7065243 0xc001aa1d00 0xc001a97f20}) m, :count ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7065276 0xc001a97fb0 0xc001aba000}) count, :write ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7065294 0xc001aba060 0xc001aba090}) write}] Profiles
;;   "Profiles returns a slice of all the known profiles, sorted by name."
;;   {:added "1.0"
;;    :go "profiles()"}
;;   [])
;; 
JOKER FUNC pprof.SetGoroutineLabels has: 
;; (defn SetGoroutineLabels
;;   "SetGoroutineLabels sets the current goroutine's labels to match ctx.
;; This is a lower-level API than Do, which should be used instead when possible."
;;   {:added "1.0"
;;    :go "setGoroutineLabels(ctx)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx])
;; 
JOKER FUNC pprof.StartCPUProfile has: 
;; (defn ^Error StartCPUProfile
;;   "StartCPUProfile enables CPU profiling for the current process.
;; While profiling, the profile will be buffered and written to w.
;; StartCPUProfile returns an error if profiling is already enabled.
;; 
;; On Unix-like systems, StartCPUProfile does not work by default for
;; Go code built with -buildmode=c-archive or -buildmode=c-shared.
;; StartCPUProfile relies on the SIGPROF signal, but that signal will
;; be delivered to the main program's SIGPROF signal handler (if any)
;; not to the one used by Go. To make it work, call os/signal.Notify
;; for syscall.SIGPROF, but note that doing so may break any profiling
;; being done by the main program."
;;   {:added "1.0"
;;    :go "startCPUProfile(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC pprof.StopCPUProfile has: 
;; (defn StopCPUProfile
;;   "StopCPUProfile stops the current CPU profile, if any.
;; StopCPUProfile only returns after all the writes for the
;; profile have completed."
;;   {:added "1.0"
;;    :go "stopCPUProfile()"}
;;   [])
;; 
JOKER FUNC pprof.Symbol has: 
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,
;; responding with a table mapping program counters to function names.
;; The package initialization registers it as /debug/pprof/symbol."
;;   {:added "1.0"
;;    :go "symbol(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http ResponseWriter}) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5135643 0xc001089420}) r])
;; 
JOKER FUNC pprof.Trace has: 
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.
;; Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
;; The package initialization registers it as /debug/pprof/trace."
;;   {:added "1.0"
;;    :go "trace(w, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{http ResponseWriter}) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5134598 0xc001088620}) r])
;; 
JOKER FUNC pprof.WithLabels has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) WithLabels
;;   "WithLabels returns a new context.Context with the given labels added.
;; A label overwrites a prior label with the same key."
;;   {:added "1.0"
;;    :go "withLabels(ctx, labels)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, labels])
;; 
JOKER FUNC pprof.WriteHeapProfile has: 
;; (defn ^Error WriteHeapProfile
;;   "WriteHeapProfile is shorthand for Lookup("heap").WriteTo(w, 0).
;; It is preserved for backwards compatibility."
;;   {:added "1.0"
;;    :go "writeHeapProfile(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC printer.Fprint has: 
;; (defn ^Error Fprint
;;   "Fprint "pretty-prints" an AST node to output.
;; It calls Config.Fprint with default settings.
;; Note that gofmt uses tabs for indentation but spaces for alignment;
;; use format.Node (package go/format) for output that matches gofmt."
;;   {:added "1.0"
;;    :go "fprint(output, fset, node)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) output, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2537769 0xc000ae3e60}) fset, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{2537790 0xc000add680 false}) node])
;; 
JOKER FUNC quick.Check has: 
;; (defn ^Error Check
;;   "Check looks for an input to f, any function that returns bool,
;; such that f returns false. It calls f repeatedly, with arbitrary
;; values for each argument. If f returns false on a given input,
;; Check returns that input as a *CheckError.
;; For example:
;; 
;; 	func TestOddMultipleOfThree(t *testing.T) {
;; 		f := func(x int) bool {
;; 			y := OddMultipleOfThree(x)
;; 			return y%2 == 1 && y%3 == 0
;; 		}
;; 		if err := quick.Check(f, nil); err != nil {
;; 			t.Error(err)
;; 		}
;; 	}"
;;   {:added "1.0"
;;    :go "check(f, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{7642723 0xc0011b3350 false}) f, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7642743 Config}) config])
;; 
JOKER FUNC quick.CheckEqual has: 
;; (defn ^Error CheckEqual
;;   "CheckEqual looks for an input on which f and g return different results.
;; It calls f and g repeatedly with arbitrary values for each argument.
;; If f and g return different answers, CheckEqual returns a *CheckEqualError
;; describing the input and the outputs."
;;   {:added "1.0"
;;    :go "checkEqual(f, g, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{7643744 0xc0011b3bf0 false}) f, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{7643744 0xc0011b3bf0 false}) g, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7643764 Config}) config])
;; 
JOKER FUNC quick.Value has: 
;; (defn ^[value ok] Value
;;   "Value returns an arbitrary value of the given type.
;; If the type implements the Generator interface, that will be used.
;; Note: To create arbitrary values for structs, all the fields must be exported."
;;   {:added "1.0"
;;    :go "value(t, rand)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{reflect Type}) t, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7636929 0xc00159a240}) rand])
;; 
JOKER FUNC quotedprintable.NewReader has: 
;; (defn ^{:br ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{4030886 0xc000d87460}) br, :rerr rerr, :line ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{4030938 <nil> byte}) line} NewReader
;;   "NewReader returns a quoted-printable reader, decoding from r."
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC quotedprintable.NewWriter has: 
;; (defn ^{:binary Binary, :w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :i ^Int i, :line ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{4034620 0xc000cf0e80 byte}) line, :cr cr} NewWriter
;;   "NewWriter returns a new Writer that writes to w."
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC rand.ExpFloat64 has: 
;; (defn ^ABEND042(cannot find typename rand.float64) ExpFloat64
;;   "ExpFloat64 returns an exponentially distributed float64 in the range
;; (0, +math.MaxFloat64] with an exponential distribution whose rate parameter
;; (lambda) is 1 and whose mean is 1/lambda (1) from the default Source.
;; To produce a distribution with a different rate parameter,
;; callers can adjust the output using:
;; 
;;  sample = ExpFloat64() / desiredRateParameter"
;;   {:added "1.0"
;;    :go "expFloat64()"}
;;   [])
;; 
JOKER FUNC rand.Float32 has: 
;; (defn ^ABEND042(cannot find typename rand.float32) Float32
;;   "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0)
;; from the default Source."
;;   {:added "1.0"
;;    :go "float32()"}
;;   [])
;; 
JOKER FUNC rand.Float64 has: 
;; (defn ^ABEND042(cannot find typename rand.float64) Float64
;;   "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)
;; from the default Source."
;;   {:added "1.0"
;;    :go "float64()"}
;;   [])
;; 
JOKER FUNC rand.Int31 has: 
;; (defn ^ABEND042(cannot find typename rand.int32) Int31
;;   "Int31 returns a non-negative pseudo-random 31-bit integer as an int32
;; from the default Source."
;;   {:added "1.0"
;;    :go "int31()"}
;;   [])
;; 
JOKER FUNC rand.Int31n has: 
;; (defn ^ABEND042(cannot find typename rand.int32) Int31n
;;   "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n)
;; from the default Source.
;; It panics if n <= 0."
;;   {:added "1.0"
;;    :go "int31n(n)"}
;;   [n])
;; 
JOKER FUNC rand.Int63 has: 
;; (defn ^ABEND042(cannot find typename rand.int64) Int63
;;   "Int63 returns a non-negative pseudo-random 63-bit integer as an int64
;; from the default Source."
;;   {:added "1.0"
;;    :go "int63()"}
;;   [])
;; 
JOKER FUNC rand.Int63n has: 
;; (defn ^ABEND042(cannot find typename rand.int64) Int63n
;;   "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n)
;; from the default Source.
;; It panics if n <= 0."
;;   {:added "1.0"
;;    :go "int63n(n)"}
;;   [n])
;; 
JOKER FUNC rand.Intn has: 
(defn ^Int Intn
  "Intn returns, as an int, a non-negative pseudo-random number in [0,n)
from the default Source.
It panics if n <= 0."
  {:added "1.0"
   :go "intn(n)"}
  [^Int n])

JOKER FUNC rand.New has: 
(defn ^{:src src, :s64 s64, :readval readVal, :readpos readPos} New
  "New returns a new Rand that uses random values from src
to generate other random values."
  {:added "1.0"
   :go "new(src)"}
  [src])

JOKER FUNC rand.NewSource has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{3970762 0xc000f452c0 false}) NewSource
;;   "NewSource returns a new pseudo-random Source seeded with the given value.
;; Unlike the default Source used by top-level functions, this source is not
;; safe for concurrent use by multiple goroutines."
;;   {:added "1.0"
;;    :go "newSource(seed)"}
;;   [seed])
;; 
JOKER FUNC rand.NewZipf has: 
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{3935587 Rand}) r, :imax imax, :v v, :q q, :s s, :oneminusq oneminusQ, :oneminusqinv oneminusQinv, :hxm hxm, :hx0minushxm hx0minusHxm} NewZipf
;;   "NewZipf returns a Zipf variate generator.
;; The generator generates values k ∈ [0, imax]
;; such that P(k) is proportional to (v + k) ** (-s).
;; Requirements: s > 1 and v >= 1."
;;   {:added "1.0"
;;    :go "newZipf(r, s, v, imax)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{3936182 Rand}) r, s, v, imax])
;; 
JOKER FUNC rand.NormFloat64 has: 
;; (defn ^ABEND042(cannot find typename rand.float64) NormFloat64
;;   "NormFloat64 returns a normally distributed float64 in the range
;; [-math.MaxFloat64, +math.MaxFloat64] with
;; standard normal distribution (mean = 0, stddev = 1)
;; from the default Source.
;; To produce a different normal distribution, callers can
;; adjust the output using:
;; 
;;  sample = NormFloat64() * desiredStdDev + desiredMean"
;;   {:added "1.0"
;;    :go "normFloat64()"}
;;   [])
;; 
JOKER FUNC rand.Perm has: 
(defn ^[Int] Perm
  "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n)
from the default Source."
  {:added "1.0"
   :go "perm(n)"}
  [^Int n])

JOKER FUNC rand.Prime has: 
;; (defn ^[p err] Prime
;;   "Prime returns a number, p, of the given size, such that p is prime
;; with high probability.
;; Prime will return error for any error returned by rand.Read or if bits < 2."
;;   {:added "1.0"
;;    :go "prime(rand, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^Int bits])
;; 
JOKER FUNC rand.Seed has: 
;; (defn Seed
;;   "Seed uses the provided seed value to initialize the default Source to a
;; deterministic state. If Seed is not called, the generator behaves as
;; if seeded by Seed(1). Seed values that have the same remainder when
;; divided by 2^31-1 generate the same pseudo-random sequence.
;; Seed, unlike the Rand.Seed method, is safe for concurrent use."
;;   {:added "1.0"
;;    :go "seed(seed)"}
;;   [seed])
;; 
JOKER FUNC rand.Shuffle has: 
;; (defn Shuffle
;;   "Shuffle pseudo-randomizes the order of elements using the default Source.
;; n is the number of elements. Shuffle panics if n < 0.
;; swap swaps the elements with indexes i and j."
;;   {:added "1.0"
;;    :go "shuffle(n, swap)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{3981065 0xc000a04480 <nil>}) swap])
;; 
JOKER FUNC rand.Uint32 has: 
;; (defn ^ABEND042(cannot find typename rand.uint32) Uint32
;;   "Uint32 returns a pseudo-random 32-bit value as a uint32
;; from the default Source."
;;   {:added "1.0"
;;    :go "uint32()"}
;;   [])
;; 
JOKER FUNC rand.Uint64 has: 
;; (defn ^ABEND042(cannot find typename rand.uint64) Uint64
;;   "Uint64 returns a pseudo-random 64-bit value as a uint64
;; from the default Source."
;;   {:added "1.0"
;;    :go "uint64()"}
;;   [])
;; 
JOKER FUNC rc4.NewCipher has: 
;; (defn ^[{:s ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{590387 0xc00024ad80 uint32}) s, :i i, :j j} Error] NewCipher
;;   "NewCipher creates and returns a new Cipher. The key argument should be the
;; RC4 key, at least 1 byte and at most 256 bytes."
;;   {:added "1.0"
;;    :go "newCipher(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{590690 <nil> byte}) key])
;; 
JOKER FUNC reflect.Append has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} Append
;;   "Append appends the values x to a slice s and returns the resulting slice.
;; As in Go, each x's value must be assignable to the slice's element type."
;;   {:added "1.0"
;;    :go "append(s, x)"}
;;   [s, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{5601144 Value}) x])
;; 
JOKER FUNC reflect.AppendSlice has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} AppendSlice
;;   "AppendSlice appends a slice t to a slice s and returns the resulting slice.
;; The slices s and t must have the same element type."
;;   {:added "1.0"
;;    :go "appendSlice(s, t)"}
;;   [s, t])
;; 
JOKER FUNC reflect.ArrayOf has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5450497 0xc001781860 false}) ArrayOf
;;   "ArrayOf returns the array type with the given count and element type.
;; For example, if t represents int, ArrayOf(5, t) represents [5]int.
;; 
;; If the resulting type would be larger than the available address space,
;; ArrayOf panics."
;;   {:added "1.0"
;;    :go "arrayOf(count, elem)"}
;;   [^Int count, elem])
;; 
JOKER FUNC reflect.ChanOf has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5450497 0xc001781860 false}) ChanOf
;;   "ChanOf returns the channel type with the given direction and element type.
;; For example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.
;; 
;; The gc runtime imposes a limit of 64 kB on channel element types.
;; If t's size is equal to or exceeds this limit, ChanOf panics."
;;   {:added "1.0"
;;    :go "chanOf(dir, t)"}
;;   [dir, t])
;; 
JOKER FUNC reflect.Copy has: 
(defn ^Int Copy
  "Copy copies the contents of src into dst until either
dst has been filled or src has been exhausted.
It returns the number of elements copied.
Dst and src each must have kind Slice or Array, and
dst and src must have the same element type.

As a special case, src can have kind String if the element type of dst is kind Uint8."
  {:added "1.0"
   :go "copy(dst, src)"}
  [dst, src])

JOKER FUNC reflect.DeepEqual has: 
;; (defn ^ABEND042(cannot find typename reflect.bool) DeepEqual
;;   "DeepEqual reports whether x and y are ``deeply equal,'' defined as follows.
;; Two values of identical type are deeply equal if one of the following cases applies.
;; Values of distinct types are never deeply equal.
;; 
;; Array values are deeply equal when their corresponding elements are deeply equal.
;; 
;; Struct values are deeply equal if their corresponding fields,
;; both exported and unexported, are deeply equal.
;; 
;; Func values are deeply equal if both are nil; otherwise they are not deeply equal.
;; 
;; Interface values are deeply equal if they hold deeply equal concrete values.
;; 
;; Map values are deeply equal when all of the following are true:
;; they are both nil or both non-nil, they have the same length,
;; and either they are the same map object or their corresponding keys
;; (matched using Go equality) map to deeply equal values.
;; 
;; Pointer values are deeply equal if they are equal using Go's == operator
;; or if they point to deeply equal values.
;; 
;; Slice values are deeply equal when all of the following are true:
;; they are both nil or both non-nil, they have the same length,
;; and either they point to the same initial entry of the same underlying array
;; (that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.
;; Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))
;; are not deeply equal.
;; 
;; Other values - numbers, bools, strings, and channels - are deeply equal
;; if they are equal using Go's == operator.
;; 
;; In general DeepEqual is a recursive relaxation of Go's == operator.
;; However, this idea is impossible to implement without some inconsistency.
;; Specifically, it is possible for a value to be unequal to itself,
;; either because it is of func type (uncomparable in general)
;; or because it is a floating-point NaN value (not equal to itself in floating-point comparison),
;; or because it is an array, struct, or interface containing
;; such a value.
;; On the other hand, pointer values are always equal to themselves,
;; even if they point at or contain such problematic values,
;; because they compare equal using Go's == operator, and that
;; is a sufficient condition to be deeply equal, regardless of content.
;; DeepEqual has been defined so that the same short-cut applies
;; to slices and maps: if x and y are the same slice or the same map,
;; they are deeply equal regardless of content.
;; 
;; As DeepEqual traverses the data values it may find a cycle. The
;; second and subsequent times that DeepEqual compares two pointer
;; values that have been compared before, it treats the values as
;; equal rather than examining the values to which they point.
;; This ensures that DeepEqual terminates."
;;   {:added "1.0"
;;    :go "deepEqual(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{5628583 0xc000fdaf60 false}) x, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{5628583 0xc000fdaf60 false}) y])
;; 
JOKER FUNC reflect.FuncOf has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5450497 0xc001781860 false}) FuncOf
;;   "FuncOf returns the function type with the given argument and result types.
;; For example if k represents int and e represents string,
;; FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.
;; 
;; The variadic argument controls whether the function is variadic. FuncOf
;; panics if the in[len(in)-1] does not represent a slice and variadic is
;; true."
;;   {:added "1.0"
;;    :go "funcOf(in, out, variadic)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5502820 <nil> Type}) in, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5502820 <nil> Type}) out, variadic])
;; 
JOKER FUNC reflect.Indirect has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} Indirect
;;   "Indirect returns the value that v points to.
;; If v is a nil pointer, Indirect returns a zero Value.
;; If v is not a pointer, Indirect returns v."
;;   {:added "1.0"
;;    :go "indirect(v)"}
;;   [v])
;; 
JOKER FUNC reflect.MakeChan has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} MakeChan
;;   "MakeChan creates a new channel with the specified type and buffer size."
;;   {:added "1.0"
;;    :go "makeChan(typ, buffer)"}
;;   [typ, ^Int buffer])
;; 
JOKER FUNC reflect.MakeFunc has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} MakeFunc
;;   "MakeFunc returns a new function of the given Type
;; that wraps the function fn. When called, that new function
;; does the following:
;; 
;; 	- converts its arguments to a slice of Values.
;; 	- runs results := fn(args).
;; 	- returns the results as a slice of Values, one per formal result.
;; 
;; The implementation fn can assume that the argument Value slice
;; has the number and type of arguments given by typ.
;; If typ describes a variadic function, the final Value is itself
;; a slice representing the variadic arguments, as in the
;; body of a variadic function. The result Value slice returned by fn
;; must have the number and type of results given by typ.
;; 
;; The Value.Call method allows the caller to invoke a typed function
;; in terms of Values; in contrast, MakeFunc allows the caller to implement
;; a typed function in terms of Values.
;; 
;; The Examples section of the documentation includes an illustration
;; of how to use MakeFunc to build a swap function for different types."
;;   {:added "1.0"
;;    :go "makeFunc(typ, fn)"}
;;   [typ, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{5540982 0xc0011e20c0 0xc0011e2120}) fn])
;; 
JOKER FUNC reflect.MakeMap has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} MakeMap
;;   "MakeMap creates a new map with the specified type."
;;   {:added "1.0"
;;    :go "makeMap(typ)"}
;;   [typ])
;; 
JOKER FUNC reflect.MakeMapWithSize has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} MakeMapWithSize
;;   "MakeMapWithSize creates a new map with the specified type
;; and initial space for approximately n elements."
;;   {:added "1.0"
;;    :go "makeMapWithSize(typ, n)"}
;;   [typ, ^Int n])
;; 
JOKER FUNC reflect.MakeSlice has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} MakeSlice
;;   "MakeSlice creates a new zero-initialized slice value
;; for the specified slice type, length, and capacity."
;;   {:added "1.0"
;;    :go "makeSlice(typ, len, cap)"}
;;   [typ, ^Int len, ^Int cap])
;; 
JOKER FUNC reflect.MapOf has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5450497 0xc001781860 false}) MapOf
;;   "MapOf returns the map type with the given key and element types.
;; For example, if k represents int and e represents string,
;; MapOf(k, e) represents map[int]string.
;; 
;; If the key type is not a valid map key type (that is, if it does
;; not implement Go's == operator), MapOf panics."
;;   {:added "1.0"
;;    :go "mapOf(key, elem)"}
;;   [key, elem])
;; 
JOKER FUNC reflect.New has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} New
;;   "New returns a Value representing a pointer to a new zero value
;; for the specified type. That is, the returned Value's Type is PtrTo(typ)."
;;   {:added "1.0"
;;    :go "new(typ)"}
;;   [typ])
;; 
JOKER FUNC reflect.NewAt has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} NewAt
;;   "NewAt returns a Value representing a pointer to a value of the
;; specified type, using p as that pointer."
;;   {:added "1.0"
;;    :go "newAt(typ, p)"}
;;   [typ, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) p])
;; 
JOKER FUNC reflect.PtrTo has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5450497 0xc001781860 false}) PtrTo
;;   "PtrTo returns the pointer type with element t.
;; For example, if t represents type Foo, PtrTo(t) represents *Foo."
;;   {:added "1.0"
;;    :go "ptrTo(t)"}
;;   [t])
;; 
JOKER FUNC reflect.Select has: 
;; (defn ^[chosen recv recvOK] Select
;;   "Select executes a select operation described by the list of cases.
;; Like the Go select statement, it blocks until at least one of the cases
;; can proceed, makes a uniform pseudo-random choice,
;; and then executes that case. It returns the index of the chosen case
;; and, if that case was a receive operation, the value received and a
;; boolean indicating whether the value corresponds to a send on the channel
;; (as opposed to a zero value received because the channel is closed)."
;;   {:added "1.0"
;;    :go "select(cases)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5605516 <nil> SelectCase}) cases])
;; 
JOKER FUNC reflect.SliceOf has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5450497 0xc001781860 false}) SliceOf
;;   "SliceOf returns the slice type with element type t.
;; For example, if t represents int, SliceOf(t) represents []int."
;;   {:added "1.0"
;;    :go "sliceOf(t)"}
;;   [t])
;; 
JOKER FUNC reflect.StructOf has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5450497 0xc001781860 false}) StructOf
;;   "StructOf returns the struct type containing fields.
;; The Offset and Index fields are ignored and computed as they would be
;; by the compiler.
;; 
;; StructOf currently does not generate wrapper methods for embedded
;; fields and panics if passed unexported StructFields.
;; These limitations may be lifted in a future version."
;;   {:added "1.0"
;;    :go "structOf(fields)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5514439 <nil> StructField}) fields])
;; 
JOKER FUNC reflect.Swapper has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{5537680 0xc000962030 <nil>}) Swapper
;;   "Swapper returns a function that swaps the elements in the provided
;; slice.
;; 
;; Swapper panics if the provided interface is not a slice."
;;   {:added "1.0"
;;    :go "swapper(slice)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{5537667 0xc0009b9ce0 false}) slice])
;; 
JOKER FUNC reflect.TypeOf has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5450497 0xc001781860 false}) TypeOf
;;   "TypeOf returns the reflection Type that represents the dynamic type of i.
;; If i is a nil interface value, TypeOf returns nil."
;;   {:added "1.0"
;;    :go "typeOf(i)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{5488149 0xc001816960 false}) i])
;; 
JOKER FUNC reflect.ValueOf has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} ValueOf
;;   "ValueOf returns a new Value initialized to the concrete value
;; stored in the interface i. ValueOf(nil) returns the zero Value."
;;   {:added "1.0"
;;    :go "valueOf(i)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{5609630 0xc001093f20 false}) i])
;; 
JOKER FUNC reflect.Zero has: 
;; (defn ^{:typ ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5545742 rtype}) typ, :ptr ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) ptr} Zero
;;   "Zero returns a Value representing the zero value for the specified type.
;; The result is different from the zero value of the Value struct,
;; which represents no value at all.
;; For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.
;; The returned value is neither addressable nor settable."
;;   {:added "1.0"
;;    :go "zero(typ)"}
;;   [typ])
;; 
JOKER FUNC regexp.Compile has: 
;; (defn ^[{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :machine ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5643745 <nil> 0xc000625520}) machine} Error] Compile
;;   "Compile parses a regular expression and returns, if successful,
;; a Regexp object that can be used to match against text.
;; 
;; When matching against text, the regexp returns a match that
;; begins as early as possible in the input (leftmost), and among those
;; it chooses the one that a backtracking search would have found first.
;; This so-called leftmost-first matching is the same semantics
;; that Perl, Python, and other implementations use, although this
;; package implements it without the expense of backtracking.
;; For POSIX leftmost-longest matching, see CompilePOSIX."
;;   {:added "1.0"
;;    :go "compile(expr)"}
;;   [^String expr])
;; 
JOKER FUNC regexp.CompilePOSIX has: 
;; (defn ^[{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :machine ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5643745 <nil> 0xc000625520}) machine} Error] CompilePOSIX
;;   "CompilePOSIX is like Compile but restricts the regular expression
;; to POSIX ERE (egrep) syntax and changes the match semantics to
;; leftmost-longest.
;; 
;; That is, when matching against text, the regexp returns a match that
;; begins as early as possible in the input (leftmost), and among those
;; it chooses a match that is as long as possible.
;; This so-called leftmost-longest matching is the same semantics
;; that early regular expression implementations used and that POSIX
;; specifies.
;; 
;; However, there can be multiple leftmost-longest matches, with different
;; submatch choices, and here this package diverges from POSIX.
;; Among the possible leftmost-longest matches, this package chooses
;; the one that a backtracking search would have found first, while POSIX
;; specifies that the match be chosen to maximize the length of the first
;; subexpression, then the second, and so on from left to right.
;; The POSIX rule is computationally prohibitive and not even well-defined.
;; See https://swtch.com/~rsc/regexp/regexp2.html#posix for details."
;;   {:added "1.0"
;;    :go "compilePOSIX(expr)"}
;;   [^String expr])
;; 
JOKER FUNC regexp.Match has: 
;; (defn ^[matched err] Match
;;   "MatchString reports whether the byte slice b
;; contains any match of the regular expression pattern.
;; More complicated queries need to use Compile and the full Regexp interface."
;;   {:added "1.0"
;;    :go "match(pattern, b)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5655154 <nil> byte}) b])
;; 
JOKER FUNC regexp.MatchReader has: 
;; (defn ^[matched err] MatchReader
;;   "MatchReader reports whether the text returned by the RuneReader
;; contains any match of the regular expression pattern.
;; More complicated queries need to use Compile and the full Regexp interface."
;;   {:added "1.0"
;;    :go "matchReader(pattern, r)"}
;;   [^String pattern, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io RuneReader}) r])
;; 
JOKER FUNC regexp.MatchString has: 
(defn ^[matched err] MatchString
  "MatchString reports whether the string s
contains any match of the regular expression pattern.
More complicated queries need to use Compile and the full Regexp interface."
  {:added "1.0"
   :go "matchString(pattern, s)"}
  [^String pattern, ^String s])

JOKER FUNC regexp.MustCompile has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :machine ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5643745 <nil> 0xc000625520}) machine} MustCompile
;;   "MustCompile is like Compile but panics if the expression cannot be parsed.
;; It simplifies safe initialization of global variables holding compiled regular
;; expressions."
;;   {:added "1.0"
;;    :go "mustCompile(str)"}
;;   [^String str])
;; 
JOKER FUNC regexp.MustCompilePOSIX has: 
;; (defn ^{:mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :machine ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5643745 <nil> 0xc000625520}) machine} MustCompilePOSIX
;;   "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.
;; It simplifies safe initialization of global variables holding compiled regular
;; expressions."
;;   {:added "1.0"
;;    :go "mustCompilePOSIX(str)"}
;;   [^String str])
;; 
JOKER FUNC regexp.QuoteMeta has: 
(defn ^String QuoteMeta
  "QuoteMeta returns a string that escapes all regular expression metacharacters
inside the argument text; the returned string is a regular expression matching
the literal text."
  {:added "1.0"
   :go "quoteMeta(s)"}
  [^String s])

JOKER FUNC ring.New has: 
;; (defn ^{:next ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{382166 Ring}) next, :prev ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{382166 Ring}) prev, :value ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{382184 0xc000324f00 false}) Value} New
;;   "New creates a ring of n elements."
;;   {:added "1.0"
;;    :go "new(n)"}
;;   [^Int n])
;; 
JOKER FUNC rpc.Accept has: 
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests
;; to DefaultServer for each incoming connection.
;; Accept blocks; the caller typically invokes it in a go statement."
;;   {:added "1.0"
;;    :go "accept(lis)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}) lis])
;; 
JOKER FUNC rpc.Dial has: 
;; (defn ^[{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: &{5162271 uint64 0xc001380200}) pending, :closing closing, :shutdown shutdown} Error] Dial
;;   "Dial connects to an RPC server at the specified network address."
;;   {:added "1.0"
;;    :go "dial(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC rpc.DialHTTP has: 
;; (defn ^[{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: &{5162271 uint64 0xc001380200}) pending, :closing closing, :shutdown shutdown} Error] DialHTTP
;;   "DialHTTP connects to an HTTP RPC server at the specified network address
;; listening on the default HTTP RPC path."
;;   {:added "1.0"
;;    :go "dialHTTP(network, address)"}
;;   [^String network, ^String address])
;; 
JOKER FUNC rpc.DialHTTPPath has: 
;; (defn ^[{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: &{5162271 uint64 0xc001380200}) pending, :closing closing, :shutdown shutdown} Error] DialHTTPPath
;;   "DialHTTPPath connects to an HTTP RPC server
;; at the specified network address and path."
;;   {:added "1.0"
;;    :go "dialHTTPPath(network, address, path)"}
;;   [^String network, ^String address, ^String path])
;; 
JOKER FUNC rpc.HandleHTTP has: 
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer
;; on DefaultRPCPath and a debugging handler on DefaultDebugPath.
;; It is still necessary to invoke http.Serve(), typically in a go statement."
;;   {:added "1.0"
;;    :go "handleHTTP()"}
;;   [])
;; 
JOKER FUNC rpc.NewClient has: 
;; (defn ^{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: &{5162271 uint64 0xc001380200}) pending, :closing closing, :shutdown shutdown} NewClient
;;   "NewClient returns a new Client to handle requests to the
;; set of services at the other end of the connection.
;; It adds a buffer to the write side of the connection so
;; the header and payload are sent as a unit.
;; 
;; The read and write halves of the connection are serialized independently,
;; so no interlocking is required. However each half may be accessed
;; concurrently so the implementation of conn should protect against
;; concurrent reads or concurrent writes."
;;   {:added "1.0"
;;    :go "newClient(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}) conn])
;; 
JOKER FUNC rpc.NewClientWithCodec has: 
;; (defn ^{:codec codec, :reqmutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) reqMutex, :request request, :mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mutex, :seq seq, :pending ^ABEND881(unrecognized Expr type *ast.MapType at: &{5162271 uint64 0xc001380200}) pending, :closing closing, :shutdown shutdown} NewClientWithCodec
;;   "NewClientWithCodec is like NewClient but uses the specified
;; codec to encode requests and decode responses."
;;   {:added "1.0"
;;    :go "newClientWithCodec(codec)"}
;;   [codec])
;; 
JOKER FUNC rpc.NewServer has: 
;; (defn ^{:servicemap ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Map}) serviceMap, :reqlock ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) reqLock, :freereq ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5176088 Request}) freeReq, :resplock ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) respLock, :freeresp ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5176153 Response}) freeResp} NewServer
;;   "NewServer returns a new Server."
;;   {:added "1.0"
;;    :go "newServer()"}
;;   [])
;; 
JOKER FUNC rpc.Register has: 
;; (defn ^Error Register
;;   "Register publishes the receiver's methods in the DefaultServer."
;;   {:added "1.0"
;;    :go "register(rcvr)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{5188990 0xc0013bb680 false}) rcvr])
;; 
JOKER FUNC rpc.RegisterName has: 
;; (defn ^Error RegisterName
;;   "RegisterName is like Register but uses the provided name for the type
;; instead of the receiver's concrete type."
;;   {:added "1.0"
;;    :go "registerName(name, rcvr)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{5189203 0xc0013bb7d0 false}) rcvr])
;; 
JOKER FUNC rpc.ServeCodec has: 
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to
;; decode requests and encode responses."
;;   {:added "1.0"
;;    :go "serveCodec(codec)"}
;;   [codec])
;; 
JOKER FUNC rpc.ServeConn has: 
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.
;; ServeConn blocks, serving the connection until the client hangs up.
;; The caller typically invokes ServeConn in a go statement.
;; ServeConn uses the gob wire format (see package gob) on the
;; connection. To use an alternate codec, use ServeCodec.
;; See NewClient's comment for information about concurrent access."
;;   {:added "1.0"
;;    :go "serveConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}) conn])
;; 
JOKER FUNC rpc.ServeRequest has: 
(defn ^Error ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.
It does not close the codec upon completion."
  {:added "1.0"
   :go "serveRequest(codec)"}
  [codec])

JOKER FUNC rsa.DecryptOAEP has: 
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] DecryptOAEP
;;   "OAEP is parameterised by a hash function that is used as a random oracle.
;; Encryption and decryption of a given message must use the same hash function
;; and sha256.New() is a reasonable choice.
;; 
;; The random parameter, if not nil, is used to blind the private-key operation
;; and avoid timing side-channel attacks. Blinding is purely internal to this
;; function – the random data need not match that used when encrypting.
;; 
;; The label parameter must match the value given when encrypting. See
;; EncryptOAEP for details."
;;   {:added "1.0"
;;    :go "decryptOAEP(hash, random, priv, ciphertext, label)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) hash, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) random, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{609828 PrivateKey}) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{609852 <nil> byte}) ciphertext, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{609866 <nil> byte}) label])
;; 
JOKER FUNC rsa.DecryptPKCS1v15 has: 
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] DecryptPKCS1v15
;;   "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.
;; If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.
;; 
;; Note that whether this function returns an error or not discloses secret
;; information. If an attacker can cause this function to run repeatedly and
;; learn whether each instance returned an error then they can decrypt and
;; forge signatures as if they had the private key. See
;; DecryptPKCS1v15SessionKey for a way of solving this problem."
;;   {:added "1.0"
;;    :go "decryptPKCS1v15(rand, priv, ciphertext)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{623241 PrivateKey}) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{623265 <nil> byte}) ciphertext])
;; 
JOKER FUNC rsa.DecryptPKCS1v15SessionKey has: 
;; (defn ^Error DecryptPKCS1v15SessionKey
;;   "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.
;; If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.
;; It returns an error if the ciphertext is the wrong length or if the
;; ciphertext is greater than the public modulus. Otherwise, no error is
;; returned. If the padding is valid, the resulting plaintext message is copied
;; into key. Otherwise, key is unchanged. These alternatives occur in constant
;; time. It is intended that the user of this function generate a random
;; session key beforehand and continue the protocol with the resulting value.
;; This will remove any possibility that an attacker can learn any information
;; about the plaintext.
;; See ``Chosen Ciphertext Attacks Against Protocols Based on the RSA
;; Encryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology
;; (Crypto '98).
;; 
;; Note that if the session key is too small then it may be possible for an
;; attacker to brute-force it. If they can do that then they can learn whether
;; a random value was used (because it'll be different for the same ciphertext)
;; and thus whether the padding was correct. This defeats the point of this
;; function. Using at least a 16-byte key will protect against this attack."
;;   {:added "1.0"
;;    :go "decryptPKCS1v15SessionKey(rand, priv, ciphertext, key)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{624891 PrivateKey}) priv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{624915 <nil> byte}) ciphertext, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{624927 <nil> byte}) key])
;; 
JOKER FUNC rsa.EncryptOAEP has: 
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] EncryptOAEP
;;   "EncryptOAEP encrypts the given message with RSA-OAEP.
;; 
;; OAEP is parameterised by a hash function that is used as a random oracle.
;; Encryption and decryption of a given message must use the same hash function
;; and sha256.New() is a reasonable choice.
;; 
;; The random parameter is used as a source of entropy to ensure that
;; encrypting the same message twice doesn't result in the same ciphertext.
;; 
;; The label parameter may contain arbitrary data that will not be encrypted,
;; but which gives important context to the message. For example, if a given
;; public key is used to decrypt two types of messages then distinct label
;; values could be used to ensure that a ciphertext for one purpose cannot be
;; used for another by an attacker. If not required it can be empty.
;; 
;; The message must be no longer than the length of the public modulus minus
;; twice the hash length, minus a further 2."
;;   {:added "1.0"
;;    :go "encryptOAEP(hash, random, pub, msg, label)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) hash, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) random, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{604680 PublicKey}) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{604696 <nil> byte}) msg, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{604710 <nil> byte}) label])
;; 
JOKER FUNC rsa.EncryptPKCS1v15 has: 
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] EncryptPKCS1v15
;;   "EncryptPKCS1v15 encrypts the given message with RSA and the padding
;; scheme from PKCS#1 v1.5.  The message must be no longer than the
;; length of the public modulus minus 11 bytes.
;; 
;; The rand parameter is used as a source of entropy to ensure that
;; encrypting the same message twice doesn't result in the same
;; ciphertext.
;; 
;; WARNING: use of this function to encrypt plaintexts other than
;; session keys is dangerous. Use RSA OAEP in new protocols."
;;   {:added "1.0"
;;    :go "encryptPKCS1v15(rand, pub, msg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{622098 PublicKey}) pub, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{622114 <nil> byte}) msg])
;; 
JOKER FUNC rsa.GenerateKey has: 
;; (defn ^[{:d ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{595499 0xc000326dc0}) D, :primes ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{595541 <nil> 0xc0002068c0}) Primes, :precomputed Precomputed} Error] GenerateKey
;;   "GenerateKey generates an RSA keypair of the given bit size using the
;; random source random (for example, crypto/rand.Reader)."
;;   {:added "1.0"
;;    :go "generateKey(random, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) random, ^Int bits])
;; 
JOKER FUNC rsa.GenerateMultiPrimeKey has: 
;; (defn ^[{:d ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{595499 0xc000326dc0}) D, :primes ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{595541 <nil> 0xc0002068c0}) Primes, :precomputed Precomputed} Error] GenerateMultiPrimeKey
;;   "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit
;; size and the given random source, as suggested in [1]. Although the public
;; keys are compatible (actually, indistinguishable) from the 2-prime case,
;; the private keys are not. Thus it may not be possible to export multi-prime
;; private keys in certain formats or to subsequently import them into other
;; code.
;; 
;; Table 1 in [2] suggests maximum numbers of primes for a given size.
;; 
;; [1] US patent 4405829 (1972, expired)
;; [2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf"
;;   {:added "1.0"
;;    :go "generateMultiPrimeKey(random, nprimes, bits)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) random, ^Int nprimes, ^Int bits])
;; 
JOKER FUNC rsa.SignPKCS1v15 has: 
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] SignPKCS1v15
;;   "SignPKCS1v15 calculates the signature of hashed using
;; RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must
;; be the result of hashing the input message using the given hash
;; function. If hash is zero, hashed is signed directly. This isn't
;; advisable except for interoperability.
;; 
;; If rand is not nil then RSA blinding will be used to avoid timing
;; side-channel attacks.
;; 
;; This function is deterministic. Thus, if the set of possible
;; messages is small, an attacker may be able to build a map from
;; messages to signatures and identify the signed messages. As ever,
;; signatures provide authenticity, not confidentiality."
;;   {:added "1.0"
;;    :go "signPKCS1v15(rand, priv, hash, hashed)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{629622 PrivateKey}) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{crypto Hash}) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{629660 <nil> byte}) hashed])
;; 
JOKER FUNC rsa.SignPSS has: 
;; (defn ^[[ABEND042(cannot find typename rsa.byte)] Error] SignPSS
;;   "SignPSS calculates the signature of hashed using RSASSA-PSS [1].
;; Note that hashed must be the result of hashing the input message using the
;; given hash function. The opts argument may be nil, in which case sensible
;; defaults are used."
;;   {:added "1.0"
;;    :go "signPSS(rand, priv, hash, hashed, opts)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{619235 PrivateKey}) priv, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{crypto Hash}) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{619273 <nil> byte}) hashed, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{619286 PSSOptions}) opts])
;; 
JOKER FUNC rsa.VerifyPKCS1v15 has: 
;; (defn ^Error VerifyPKCS1v15
;;   "VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.
;; hashed is the result of hashing the input message using the given hash
;; function and sig is the signature. A valid signature is indicated by
;; returning a nil error. If hash is zero then hashed is used directly. This
;; isn't advisable except for interoperability."
;;   {:added "1.0"
;;    :go "verifyPKCS1v15(pub, hash, hashed, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{630599 PublicKey}) pub, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{crypto Hash}) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{630636 <nil> byte}) hashed, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{630648 <nil> byte}) sig])
;; 
JOKER FUNC rsa.VerifyPSS has: 
;; (defn ^Error VerifyPSS
;;   "VerifyPSS verifies a PSS signature.
;; hashed is the result of hashing the input message using the given hash
;; function and sig is the signature. A valid signature is indicated by
;; returning a nil error. The opts argument may be nil, in which case sensible
;; defaults are used."
;;   {:added "1.0"
;;    :go "verifyPSS(pub, hash, hashed, sig, opts)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{620043 PublicKey}) pub, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{crypto Hash}) hash, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{620080 <nil> byte}) hashed, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{620092 <nil> byte}) sig, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{620105 PSSOptions}) opts])
;; 
JOKER FUNC runtime.BlockProfile has: 
;; (defn ^[n ok] BlockProfile
;;   "BlockProfile returns n, the number of records in the current blocking profile.
;; If len(p) >= n, BlockProfile copies the profile into p and returns n, true.
;; If len(p) < n, BlockProfile does not change p and returns n, false.
;; 
;; Most clients should use the runtime/pprof package or
;; the testing package's -test.blockprofile flag instead
;; of calling BlockProfile directly."
;;   {:added "1.0"
;;    :go "blockProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{6340852 <nil> BlockProfileRecord}) p])
;; 
JOKER FUNC runtime.Breakpoint has: 
;; (defn Breakpoint
;;   "Breakpoint executes a breakpoint trap."
;;   {:added "1.0"
;;    :go "breakpoint()"}
;;   [])
;; 
JOKER FUNC runtime.CPUProfile has: 
;; (defn ^[ABEND042(cannot find typename runtime.byte)] CPUProfile
;;   "CPUProfile panics.
;; It formerly provided raw access to chunks of
;; a pprof-format profile generated by the runtime.
;; The details of generating that format have changed,
;; so this functionality has been removed.
;; 
;; Deprecated: use the runtime/pprof package,
;; or the handlers in the net/http/pprof package,
;; or the testing package's -test.cpuprofile flag instead."
;;   {:added "1.0"
;;    :go "cPUProfile()"}
;;   [])
;; 
JOKER FUNC runtime.Caller has: 
(defn ^[pc file line ok] Caller
  "Caller reports file and line number information about function invocations on
the calling goroutine's stack. The argument skip is the number of stack frames
to ascend, with 0 identifying the caller of Caller.  (For historical reasons the
meaning of skip differs between Caller and Callers.) The return values report the
program counter, file name, and line number within the file of the corresponding
call. The boolean ok is false if it was not possible to recover the information."
  {:added "1.0"
   :go "caller(skip)"}
  [^Int skip])

JOKER FUNC runtime.Callers has: 
;; (defn ^Int Callers
;;   "Callers fills the slice pc with the return program counters of function invocations
;; on the calling goroutine's stack. The argument skip is the number of stack frames
;; to skip before recording in pc, with 0 identifying the frame for Callers itself and
;; 1 identifying the caller of Callers.
;; It returns the number of entries written to pc.
;; 
;; To translate these PCs into symbolic information such as function
;; names and line numbers, use CallersFrames. CallersFrames accounts
;; for inlined functions and adjusts the return program counters into
;; call program counters. Iterating over the returned slice of PCs
;; directly is discouraged, as is using FuncForPC on any of the
;; returned PCs, since these cannot account for inlining or return
;; program counter adjustment."
;;   {:added "1.0"
;;    :go "callers(skip, pc)"}
;;   [^Int skip, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{6405741 <nil> uintptr}) pc])
;; 
JOKER FUNC runtime.CallersFrames has: 
;; (defn ^{:callers ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{6294614 <nil> uintptr}) callers, :stackexpander stackExpander, :elidewrapper elideWrapper} CallersFrames
;;   "CallersFrames takes a slice of PC values returned by Callers and
;; prepares to return function/file/line information.
;; Do not change the slice until you are done with the Frames."
;;   {:added "1.0"
;;    :go "callersFrames(callers)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{6297339 <nil> uintptr}) callers])
;; 
JOKER FUNC runtime.FuncForPC has: 
;; (defn ^{:opaque ^ABEND881(unrecognized Expr type *ast.StructType at: &{6303810 0xc0013ae3f0 false}) opaque} FuncForPC
;;   "FuncForPC returns a *Func describing the function that contains the
;; given program counter address, or else nil.
;; 
;; If pc represents multiple functions because of inlining, it returns
;; the *Func describing the outermost function."
;;   {:added "1.0"
;;    :go "funcForPC(pc)"}
;;   [pc])
;; 
JOKER FUNC runtime.GC has: 
;; (defn GC
;;   "GC runs a garbage collection and blocks the caller until the
;; garbage collection is complete. It may also block the entire
;; program."
;;   {:added "1.0"
;;    :go "gC()"}
;;   [])
;; 
JOKER FUNC runtime.GOMAXPROCS has: 
(defn ^Int GOMAXPROCS
  "GOMAXPROCS sets the maximum number of CPUs that can be executing
simultaneously and returns the previous setting. If n < 1, it does not
change the current setting.
The number of logical CPUs on the local machine can be queried with NumCPU.
This call will go away when the scheduler improves."
  {:added "1.0"
   :go "gOMAXPROCS(n)"}
  [^Int n])

JOKER FUNC runtime.GOROOT has: 
(defn ^String GOROOT
  "GOROOT returns the root of the Go tree. It uses the
GOROOT environment variable, if set at process start,
or else the root used during the Go build."
  {:added "1.0"
   :go "gOROOT()"}
  [])

JOKER FUNC runtime.Goexit has: 
;; (defn Goexit
;;   "Goexit terminates the goroutine that calls it. No other goroutine is affected.
;; Goexit runs all deferred calls before terminating the goroutine. Because Goexit
;; is not a panic, any recover calls in those deferred functions will return nil.
;; 
;; Calling Goexit from the main goroutine terminates that goroutine
;; without func main returning. Since func main has not returned,
;; the program continues execution of other goroutines.
;; If all other goroutines exit, the program crashes."
;;   {:added "1.0"
;;    :go "goexit()"}
;;   [])
;; 
JOKER FUNC runtime.GoroutineProfile has: 
;; (defn ^[n ok] GoroutineProfile
;;   "GoroutineProfile returns n, the number of records in the active goroutine stack profile.
;; If len(p) >= n, GoroutineProfile copies the profile into p and returns n, true.
;; If len(p) < n, GoroutineProfile does not change p and returns n, false.
;; 
;; Most clients should use the runtime/pprof package instead
;; of calling GoroutineProfile directly."
;;   {:added "1.0"
;;    :go "goroutineProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{6343310 <nil> StackRecord}) p])
;; 
JOKER FUNC runtime.Gosched has: 
;; (defn Gosched
;;   "Gosched yields the processor, allowing other goroutines to run. It does not
;; suspend the current goroutine, so execution resumes automatically."
;;   {:added "1.0"
;;    :go "gosched()"}
;;   [])
;; 
JOKER FUNC runtime.KeepAlive has: 
;; (defn KeepAlive
;;   "KeepAlive marks its argument as currently reachable.
;; This ensures that the object is not freed, and its finalizer is not run,
;; before the point in the program where KeepAlive is called.
;; 
;; A very simplified example showing where KeepAlive is required:
;; 	type File struct { d int }
;; 	d, err := syscall.Open("/file/path", syscall.O_RDONLY, 0)
;; 	// ... do something if err != nil ...
;; 	p := &File{d}
;; 	runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })
;; 	var buf [10]byte
;; 	n, err := syscall.Read(p.d, buf[:])
;; 	// Ensure p is not finalized until Read returns.
;; 	runtime.KeepAlive(p)
;; 	// No more uses of p after this point.
;; 
;; Without the KeepAlive call, the finalizer could run at the start of
;; syscall.Read, closing the file descriptor before syscall.Read makes
;; the actual system call."
;;   {:added "1.0"
;;    :go "keepAlive(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{7010589 0xc0013263c0 false}) x])
;; 
JOKER FUNC runtime.LockOSThread has: 
;; (defn LockOSThread
;;   "LockOSThread wires the calling goroutine to its current operating system thread.
;; The calling goroutine will always execute in that thread,
;; and no other goroutine will execute in it,
;; until the calling goroutine has made as many calls to
;; UnlockOSThread as to LockOSThread.
;; If the calling goroutine exits without unlocking the thread,
;; the thread will be terminated.
;; 
;; All init functions are run on the startup thread. Calling LockOSThread
;; from an init function will cause the main function to be invoked on
;; that thread.
;; 
;; A goroutine should call LockOSThread before calling OS services or
;; non-Go library functions that depend on per-thread state."
;;   {:added "1.0"
;;    :go "lockOSThread()"}
;;   [])
;; 
JOKER FUNC runtime.MemProfile has: 
;; (defn ^[n ok] MemProfile
;;   "MemProfile returns a profile of memory allocated and freed per allocation
;; site.
;; 
;; MemProfile returns n, the number of records in the current memory profile.
;; If len(p) >= n, MemProfile copies the profile into p and returns n, true.
;; If len(p) < n, MemProfile does not change p and returns n, false.
;; 
;; If inuseZero is true, the profile includes allocation records
;; where r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.
;; These are sites where memory was allocated, but it has all
;; been released back to the runtime.
;; 
;; The returned profile may be up to two garbage collection cycles old.
;; This is to avoid skewing the profile toward allocations; because
;; allocations happen in real time but frees are delayed until the garbage
;; collector performs sweeping, the profile only accounts for allocations
;; that have had a chance to be freed by the garbage collector.
;; 
;; Most clients should use the runtime/pprof package or
;; the testing package's -test.memprofile flag instead
;; of calling MemProfile directly."
;;   {:added "1.0"
;;    :go "memProfile(p, inuseZero)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{6338180 <nil> MemProfileRecord}) p, inuseZero])
;; 
JOKER FUNC runtime.MutexProfile has: 
;; (defn ^[n ok] MutexProfile
;;   "MutexProfile returns n, the number of records in the current mutex profile.
;; If len(p) >= n, MutexProfile copies the profile into p and returns n, true.
;; Otherwise, MutexProfile does not change p, and returns n, false.
;; 
;; Most clients should use the runtime/pprof package
;; instead of calling MutexProfile directly."
;;   {:added "1.0"
;;    :go "mutexProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{6341841 <nil> BlockProfileRecord}) p])
;; 
JOKER FUNC runtime.NumCPU has: 
(defn ^Int NumCPU
  "NumCPU returns the number of logical CPUs usable by the current process.

The set of available CPUs is checked by querying the operating system
at process startup. Changes to operating system CPU allocation after
process startup are not reflected."
  {:added "1.0"
   :go "numCPU()"}
  [])

JOKER FUNC runtime.NumCgoCall has: 
;; (defn ^ABEND042(cannot find typename runtime.int64) NumCgoCall
;;   "NumCgoCall returns the number of cgo calls made by the current process."
;;   {:added "1.0"
;;    :go "numCgoCall()"}
;;   [])
;; 
JOKER FUNC runtime.NumGoroutine has: 
(defn ^Int NumGoroutine
  "NumGoroutine returns the number of goroutines that currently exist."
  {:added "1.0"
   :go "numGoroutine()"}
  [])

JOKER FUNC runtime.ReadMemStats has: 
;; (defn ReadMemStats
;;   "ReadMemStats populates m with memory allocator statistics.
;; 
;; The returned memory allocator statistics are up to date as of the
;; call to ReadMemStats. This is in contrast with a heap profile,
;; which is a snapshot as of the most recently completed garbage
;; collection cycle."
;;   {:added "1.0"
;;    :go "readMemStats(m)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5833148 MemStats}) m])
;; 
JOKER FUNC runtime.ReadTrace has: 
;; (defn ^[ABEND042(cannot find typename runtime.byte)] ReadTrace
;;   "ReadTrace returns the next chunk of binary tracing data, blocking until data
;; is available. If tracing is turned off and all the data accumulated while it
;; was on has been returned, ReadTrace returns nil. The caller must copy the
;; returned data before calling ReadTrace again.
;; ReadTrace must be called from one goroutine at a time."
;;   {:added "1.0"
;;    :go "readTrace()"}
;;   [])
;; 
JOKER FUNC runtime.SetBlockProfileRate has: 
;; (defn SetBlockProfileRate
;;   "SetBlockProfileRate controls the fraction of goroutine blocking events
;; that are reported in the blocking profile. The profiler aims to sample
;; an average of one blocking event per rate nanoseconds spent blocked.
;; 
;; To include every blocking event in the profile, pass rate = 1.
;; To turn off profiling entirely, pass rate <= 0."
;;   {:added "1.0"
;;    :go "setBlockProfileRate(rate)"}
;;   [^Int rate])
;; 
JOKER FUNC runtime.SetCPUProfileRate has: 
;; (defn SetCPUProfileRate
;;   "SetCPUProfileRate sets the CPU profiling rate to hz samples per second.
;; If hz <= 0, SetCPUProfileRate turns off profiling.
;; If the profiler is on, the rate cannot be changed without first turning it off.
;; 
;; Most clients should use the runtime/pprof package or
;; the testing package's -test.cpuprofile flag instead of calling
;; SetCPUProfileRate directly."
;;   {:added "1.0"
;;    :go "setCPUProfileRate(hz)"}
;;   [^Int hz])
;; 
JOKER FUNC runtime.SetCgoTraceback has: 
;; (defn SetCgoTraceback
;;   "SetCgoTraceback records three C functions to use to gather
;; traceback information from C code and to convert that traceback
;; information into symbolic information. These are used when printing
;; stack traces for a program that uses cgo.
;; 
;; The traceback and context functions may be called from a signal
;; handler, and must therefore use only async-signal safe functions.
;; The symbolizer function may be called while the program is
;; crashing, and so must be cautious about using memory.  None of the
;; functions may call back into Go.
;; 
;; The context function will be called with a single argument, a
;; pointer to a struct:
;; 
;; 	struct {
;; 		Context uintptr
;; 	}
;; 
;; In C syntax, this struct will be
;; 
;; 	struct {
;; 		uintptr_t Context;
;; 	};
;; 
;; If the Context field is 0, the context function is being called to
;; record the current traceback context. It should record in the
;; Context field whatever information is needed about the current
;; point of execution to later produce a stack trace, probably the
;; stack pointer and PC. In this case the context function will be
;; called from C code.
;; 
;; If the Context field is not 0, then it is a value returned by a
;; previous call to the context function. This case is called when the
;; context is no longer needed; that is, when the Go code is returning
;; to its C code caller. This permits the context function to release
;; any associated resources.
;; 
;; While it would be correct for the context function to record a
;; complete a stack trace whenever it is called, and simply copy that
;; out in the traceback function, in a typical program the context
;; function will be called many times without ever recording a
;; traceback for that context. Recording a complete stack trace in a
;; call to the context function is likely to be inefficient.
;; 
;; The traceback function will be called with a single argument, a
;; pointer to a struct:
;; 
;; 	struct {
;; 		Context    uintptr
;; 		SigContext uintptr
;; 		Buf        *uintptr
;; 		Max        uintptr
;; 	}
;; 
;; In C syntax, this struct will be
;; 
;; 	struct {
;; 		uintptr_t  Context;
;; 		uintptr_t  SigContext;
;; 		uintptr_t* Buf;
;; 		uintptr_t  Max;
;; 	};
;; 
;; The Context field will be zero to gather a traceback from the
;; current program execution point. In this case, the traceback
;; function will be called from C code.
;; 
;; Otherwise Context will be a value previously returned by a call to
;; the context function. The traceback function should gather a stack
;; trace from that saved point in the program execution. The traceback
;; function may be called from an execution thread other than the one
;; that recorded the context, but only when the context is known to be
;; valid and unchanging. The traceback function may also be called
;; deeper in the call stack on the same thread that recorded the
;; context. The traceback function may be called multiple times with
;; the same Context value; it will usually be appropriate to cache the
;; result, if possible, the first time this is called for a specific
;; context value.
;; 
;; If the traceback function is called from a signal handler on a Unix
;; system, SigContext will be the signal context argument passed to
;; the signal handler (a C ucontext_t* cast to uintptr_t). This may be
;; used to start tracing at the point where the signal occurred. If
;; the traceback function is not called from a signal handler,
;; SigContext will be zero.
;; 
;; Buf is where the traceback information should be stored. It should
;; be PC values, such that Buf[0] is the PC of the caller, Buf[1] is
;; the PC of that function's caller, and so on.  Max is the maximum
;; number of entries to store.  The function should store a zero to
;; indicate the top of the stack, or that the caller is on a different
;; stack, presumably a Go stack.
;; 
;; Unlike runtime.Callers, the PC values returned should, when passed
;; to the symbolizer function, return the file/line of the call
;; instruction.  No additional subtraction is required or appropriate.
;; 
;; On all platforms, the traceback function is invoked when a call from
;; Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,
;; and freebsd/amd64, the traceback function is also invoked when a
;; signal is received by a thread that is executing a cgo call. The
;; traceback function should not make assumptions about when it is
;; called, as future versions of Go may make additional calls.
;; 
;; The symbolizer function will be called with a single argument, a
;; pointer to a struct:
;; 
;; 	struct {
;; 		PC      uintptr // program counter to fetch information for
;; 		File    *byte   // file name (NUL terminated)
;; 		Lineno  uintptr // line number
;; 		Func    *byte   // function name (NUL terminated)
;; 		Entry   uintptr // function entry point
;; 		More    uintptr // set non-zero if more info for this PC
;; 		Data    uintptr // unused by runtime, available for function
;; 	}
;; 
;; In C syntax, this struct will be
;; 
;; 	struct {
;; 		uintptr_t PC;
;; 		char*     File;
;; 		uintptr_t Lineno;
;; 		char*     Func;
;; 		uintptr_t Entry;
;; 		uintptr_t More;
;; 		uintptr_t Data;
;; 	};
;; 
;; The PC field will be a value returned by a call to the traceback
;; function.
;; 
;; The first time the function is called for a particular traceback,
;; all the fields except PC will be 0. The function should fill in the
;; other fields if possible, setting them to 0/nil if the information
;; is not available. The Data field may be used to store any useful
;; information across calls. The More field should be set to non-zero
;; if there is more information for this PC, zero otherwise. If More
;; is set non-zero, the function will be called again with the same
;; PC, and may return different information (this is intended for use
;; with inlined functions). If More is zero, the function will be
;; called with the next PC value in the traceback. When the traceback
;; is complete, the function will be called once more with PC set to
;; zero; this may be used to free any information. Each call will
;; leave the fields of the struct set to the same values they had upon
;; return, except for the PC field when the More field is zero. The
;; function must not keep a copy of the struct pointer between calls.
;; 
;; When calling SetCgoTraceback, the version argument is the version
;; number of the structs that the functions expect to receive.
;; Currently this must be zero.
;; 
;; The symbolizer function may be nil, in which case the results of
;; the traceback function will be displayed as numbers. If the
;; traceback function is nil, the symbolizer function will never be
;; called. The context function may be nil, in which case the
;; traceback function will only be called with the context field set
;; to zero.  If the context function is nil, then calls from Go to C
;; to Go will not show a traceback for the C portion of the call stack.
;; 
;; SetCgoTraceback should be called only once, ideally from an init function."
;;   {:added "1.0"
;;    :go "setCgoTraceback(version, traceback, context, symbolizer)"}
;;   [^Int version, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) traceback, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) context, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}) symbolizer])
;; 
JOKER FUNC runtime.SetFinalizer has: 
;; (defn SetFinalizer
;;   "SetFinalizer sets the finalizer associated with obj to the provided
;; finalizer function. When the garbage collector finds an unreachable block
;; with an associated finalizer, it clears the association and runs
;; finalizer(obj) in a separate goroutine. This makes obj reachable again,
;; but now without an associated finalizer. Assuming that SetFinalizer
;; is not called again, the next time the garbage collector sees
;; that obj is unreachable, it will free obj.
;; 
;; SetFinalizer(obj, nil) clears any finalizer associated with obj.
;; 
;; The argument obj must be a pointer to an object allocated by calling
;; new, by taking the address of a composite literal, or by taking the
;; address of a local variable.
;; The argument finalizer must be a function that takes a single argument
;; to which obj's type can be assigned, and can have arbitrary ignored return
;; values. If either of these is not true, SetFinalizer may abort the
;; program.
;; 
;; Finalizers are run in dependency order: if A points at B, both have
;; finalizers, and they are otherwise unreachable, only the finalizer
;; for A runs; once A is freed, the finalizer for B can run.
;; If a cyclic structure includes a block with a finalizer, that
;; cycle is not guaranteed to be garbage collected and the finalizer
;; is not guaranteed to run, because there is no ordering that
;; respects the dependencies.
;; 
;; The finalizer is scheduled to run at some arbitrary time after the
;; program can no longer reach the object to which obj points.
;; There is no guarantee that finalizers will run before a program exits,
;; so typically they are useful only for releasing non-memory resources
;; associated with an object during a long-running program.
;; For example, an os.File object could use a finalizer to close the
;; associated operating system file descriptor when a program discards
;; an os.File without calling Close, but it would be a mistake
;; to depend on a finalizer to flush an in-memory I/O buffer such as a
;; bufio.Writer, because the buffer would not be flushed at program exit.
;; 
;; It is not guaranteed that a finalizer will run if the size of *obj is
;; zero bytes.
;; 
;; It is not guaranteed that a finalizer will run for objects allocated
;; in initializers for package-level variables. Such objects may be
;; linker-allocated, not heap-allocated.
;; 
;; A finalizer may run as soon as an object becomes unreachable.
;; In order to use finalizers correctly, the program must ensure that
;; the object is reachable until it is no longer required.
;; Objects stored in global variables, or that can be found by tracing
;; pointers from a global variable, are reachable. For other objects,
;; pass the object to a call of the KeepAlive function to mark the
;; last point in the function where the object must be reachable.
;; 
;; For example, if p points to a struct that contains a file descriptor d,
;; and p has a finalizer that closes that file descriptor, and if the last
;; use of p in a function is a call to syscall.Write(p.d, buf, size), then
;; p may be unreachable as soon as the program enters syscall.Write. The
;; finalizer may run at that moment, closing p.d, causing syscall.Write
;; to fail because it is writing to a closed file descriptor (or, worse,
;; to an entirely different file descriptor opened by a different goroutine).
;; To avoid this problem, call runtime.KeepAlive(p) after the call to
;; syscall.Write.
;; 
;; A single goroutine runs all finalizers for a program, sequentially.
;; If a finalizer must run for a long time, it should do so by starting
;; a new goroutine."
;;   {:added "1.0"
;;    :go "setFinalizer(obj, finalizer)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{7006088 0xc0011e3ef0 false}) obj, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{7006111 0xc0011e3f20 false}) finalizer])
;; 
JOKER FUNC runtime.SetMutexProfileFraction has: 
(defn ^Int SetMutexProfileFraction
  "SetMutexProfileFraction controls the fraction of mutex contention events
that are reported in the mutex profile. On average 1/rate events are
reported. The previous rate is returned.

To turn off profiling entirely, pass rate 0.
To just read the current rate, pass rate < 0.
(For n>1 the details of sampling may change.)"
  {:added "1.0"
   :go "setMutexProfileFraction(rate)"}
  [^Int rate])

JOKER FUNC runtime.Stack has: 
;; (defn ^Int Stack
;;   "Stack formats a stack trace of the calling goroutine into buf
;; and returns the number of bytes written to buf.
;; If all is true, Stack formats stack traces of all other goroutines
;; into buf after the trace for the current goroutine."
;;   {:added "1.0"
;;    :go "stack(buf, all)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{6344626 <nil> byte}) buf, all])
;; 
JOKER FUNC runtime.StartTrace has: 
(defn ^Error StartTrace
  "StartTrace enables tracing for the current process.
While tracing, the data will be buffered and available via ReadTrace.
StartTrace returns an error if tracing is already enabled.
Most clients should use the runtime/trace package or the testing package's
-test.trace flag instead of calling StartTrace directly."
  {:added "1.0"
   :go "startTrace()"}
  [])

JOKER FUNC runtime.StopTrace has: 
;; (defn StopTrace
;;   "StopTrace stops tracing, if it was previously enabled.
;; StopTrace only returns after all the reads for the trace have completed."
;;   {:added "1.0"
;;    :go "stopTrace()"}
;;   [])
;; 
JOKER FUNC runtime.ThreadCreateProfile has: 
;; (defn ^[n ok] ThreadCreateProfile
;;   "ThreadCreateProfile returns n, the number of records in the thread creation profile.
;; If len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true.
;; If len(p) < n, ThreadCreateProfile does not change p and returns n, false.
;; 
;; Most clients should use the runtime/pprof package instead
;; of calling ThreadCreateProfile directly."
;;   {:added "1.0"
;;    :go "threadCreateProfile(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{6342645 <nil> StackRecord}) p])
;; 
JOKER FUNC runtime.UnlockOSThread has: 
;; (defn UnlockOSThread
;;   "UnlockOSThread undoes an earlier call to LockOSThread.
;; If this drops the number of active LockOSThread calls on the
;; calling goroutine to zero, it unwires the calling goroutine from
;; its fixed operating system thread.
;; If there are no active LockOSThread calls, this is a no-op.
;; 
;; Before calling UnlockOSThread, the caller must ensure that the OS
;; thread is suitable for running other goroutines. If the caller made
;; any permanent changes to the state of the thread that would affect
;; other goroutines, it should not call this function and thus leave
;; the goroutine locked to the OS thread until the goroutine (and
;; hence the thread) exits."
;;   {:added "1.0"
;;    :go "unlockOSThread()"}
;;   [])
;; 
JOKER FUNC runtime.Version has: 
(defn ^String Version
  "Version returns the Go tree's version string.
It is either the commit hash and date at the time of the build or,
when possible, a release tag like "go1.3"."
  {:added "1.0"
   :go "version()"}
  [])

JOKER FUNC runtime._ELF_ST_BIND has: 
;; (defn ^ABEND042(cannot find typename runtime.byte) _ELF_ST_BIND
;;   "How to extract and insert information held in the st_info field."
;;   {:added "1.0"
;;    :go "_ELF_ST_BIND(val)"}
;;   [val])
;; 
JOKER FUNC runtime._ELF_ST_TYPE has: 
;; (defn ^ABEND042(cannot find typename runtime.byte) _ELF_ST_TYPE
;;   {:added "1.0"
;;    :go "_ELF_ST_TYPE(val)"}
;;   [val])
;; 
JOKER FUNC runtime._ExternalCode has: 
;; (defn _ExternalCode
;;   {:added "1.0"
;;    :go "_ExternalCode()"}
;;   [])
;; 
JOKER FUNC runtime._GC has: 
;; (defn _GC
;;   {:added "1.0"
;;    :go "_GC()"}
;;   [])
;; 
JOKER FUNC runtime._LostExternalCode has: 
;; (defn _LostExternalCode
;;   {:added "1.0"
;;    :go "_LostExternalCode()"}
;;   [])
;; 
JOKER FUNC runtime._LostSIGPROFDuringAtomic64 has: 
;; (defn _LostSIGPROFDuringAtomic64
;;   {:added "1.0"
;;    :go "_LostSIGPROFDuringAtomic64()"}
;;   [])
;; 
JOKER FUNC runtime._System has: 
;; (defn _System
;;   {:added "1.0"
;;    :go "_System()"}
;;   [])
;; 
JOKER FUNC runtime._VDSO has: 
;; (defn _VDSO
;;   {:added "1.0"
;;    :go "_VDSO()"}
;;   [])
;; 
JOKER FUNC runtime._cgo_panic_internal has: 
;; (defn _cgo_panic_internal
;;   {:added "1.0"
;;    :go "_cgo_panic_internal(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{6977778 byte}) p])
;; 
JOKER FUNC scanner.PrintError has: 
;; (defn PrintError
;;   "PrintError is a utility function that prints a list of errors to w,
;; one error per line, if the err parameter is an ErrorList. Otherwise
;; it prints the err string."
;;   {:added "1.0"
;;    :go "printError(w, err)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, err])
;; 
JOKER FUNC scanner.TokenString has: 
(defn ^String TokenString
  "TokenString returns a printable string for a token or Unicode character."
  {:added "1.0"
   :go "tokenString(tok)"}
  [tok])

JOKER FUNC sha1.New has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New
;;   "New returns a new hash.Hash computing the SHA1 checksum. The Hash also
;; implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to
;; marshal and unmarshal the internal state of the hash."
;;   {:added "1.0"
;;    :go "new()"}
;;   [])
;; 
JOKER FUNC sha1.Sum has: 
;; (defn ^[ABEND042(cannot find typename sha1.byte)] Sum
;;   "Sum returns the SHA-1 checksum of the data."
;;   {:added "1.0"
;;    :go "sum(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{640321 <nil> byte}) data])
;; 
JOKER FUNC sha256.New has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New
;;   "New returns a new hash.Hash computing the SHA256 checksum. The Hash
;; also implements encoding.BinaryMarshaler and
;; encoding.BinaryUnmarshaler to marshal and unmarshal the internal
;; state of the hash."
;;   {:added "1.0"
;;    :go "new()"}
;;   [])
;; 
JOKER FUNC sha256.New224 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New224
;;   "New224 returns a new hash.Hash computing the SHA224 checksum."
;;   {:added "1.0"
;;    :go "new224()"}
;;   [])
;; 
JOKER FUNC sha256.Sum224 has: 
;; (defn ^sum224 Sum224
;;   "Sum224 returns the SHA224 checksum of the data."
;;   {:added "1.0"
;;    :go "sum224(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{650541 <nil> byte}) data])
;; 
JOKER FUNC sha256.Sum256 has: 
;; (defn ^[ABEND042(cannot find typename sha256.byte)] Sum256
;;   "Sum256 returns the SHA256 checksum of the data."
;;   {:added "1.0"
;;    :go "sum256(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{650388 <nil> byte}) data])
;; 
JOKER FUNC sha512.New has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New
;;   "New returns a new hash.Hash computing the SHA-512 checksum."
;;   {:added "1.0"
;;    :go "new()"}
;;   [])
;; 
JOKER FUNC sha512.New384 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New384
;;   "New384 returns a new hash.Hash computing the SHA-384 checksum."
;;   {:added "1.0"
;;    :go "new384()"}
;;   [])
;; 
JOKER FUNC sha512.New512_224 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New512_224
;;   "New512_224 returns a new hash.Hash computing the SHA-512/224 checksum."
;;   {:added "1.0"
;;    :go "new512_224()"}
;;   [])
;; 
JOKER FUNC sha512.New512_256 has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash}) New512_256
;;   "New512_256 returns a new hash.Hash computing the SHA-512/256 checksum."
;;   {:added "1.0"
;;    :go "new512_256()"}
;;   [])
;; 
JOKER FUNC sha512.Sum384 has: 
;; (defn ^sum384 Sum384
;;   "Sum384 returns the SHA384 checksum of the data."
;;   {:added "1.0"
;;    :go "sum384(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{659639 <nil> byte}) data])
;; 
JOKER FUNC sha512.Sum512 has: 
;; (defn ^[ABEND042(cannot find typename sha512.byte)] Sum512
;;   "Sum512 returns the SHA512 checksum of the data."
;;   {:added "1.0"
;;    :go "sum512(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{659462 <nil> byte}) data])
;; 
JOKER FUNC sha512.Sum512_224 has: 
;; (defn ^sum224 Sum512_224
;;   "Sum512_224 returns the Sum512/224 checksum of the data."
;;   {:added "1.0"
;;    :go "sum512_224(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{659880 <nil> byte}) data])
;; 
JOKER FUNC sha512.Sum512_256 has: 
;; (defn ^sum256 Sum512_256
;;   "Sum512_256 returns the Sum512/256 checksum of the data."
;;   {:added "1.0"
;;    :go "sum512_256(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{660125 <nil> byte}) data])
;; 
JOKER FUNC signal.Ignore has: 
;; (defn Ignore
;;   "Ignore causes the provided signals to be ignored. If they are received by
;; the program, nothing will happen. Ignore undoes the effect of any prior
;; calls to Notify for the provided signals.
;; If no signals are provided, all incoming signals will be ignored."
;;   {:added "1.0"
;;    :go "ignore(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{5378078 0xc0016842e0}) sig])
;; 
JOKER FUNC signal.Ignored has: 
;; (defn ^ABEND042(cannot find typename signal.bool) Ignored
;;   "Ignored reports whether sig is currently ignored."
;;   {:added "1.0"
;;    :go "ignored(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{os Signal}) sig])
;; 
JOKER FUNC signal.Notify has: 
;; (defn Notify
;;   "Notify causes package signal to relay incoming signals to c.
;; If no signals are provided, all incoming signals will be relayed to c.
;; Otherwise, just the provided signals will.
;; 
;; Package signal will not block sending to c: the caller must ensure
;; that c has sufficient buffer space to keep up with the expected
;; signal rate. For a channel used for notification of just one signal value,
;; a buffer of size 1 is sufficient.
;; 
;; It is allowed to call Notify multiple times with the same channel:
;; each call expands the set of signals sent to that channel.
;; The only way to remove signals from the set is to call Stop.
;; 
;; It is allowed to call Notify multiple times with different channels
;; and the same signals: each channel receives copies of incoming
;; signals independently."
;;   {:added "1.0"
;;    :go "notify(c, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.ChanType at: &{5379089 5379093 1 0xc0016848c0}) c, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{5379111 0xc001684940}) sig])
;; 
JOKER FUNC signal.Reset has: 
;; (defn Reset
;;   "Reset undoes the effect of any prior calls to Notify for the provided
;; signals.
;; If no signals are provided, all signal handlers will be reset."
;;   {:added "1.0"
;;    :go "reset(sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{5379853 0xc0016855e0}) sig])
;; 
JOKER FUNC signal.Stop has: 
;; (defn Stop
;;   "Stop causes package signal to stop relaying incoming signals to c.
;; It undoes the effect of all prior calls to Notify using c.
;; When Stop returns, it is guaranteed that c will receive no more signals."
;;   {:added "1.0"
;;    :go "stop(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.ChanType at: &{5380120 5380124 1 0xc0016857e0}) c])
;; 
JOKER FUNC smtp.CRAMMD5Auth has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5199042 0xc0013ef260 false}) CRAMMD5Auth
;;   "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication
;; mechanism as defined in RFC 2195.
;; The returned Auth uses the given username and secret to authenticate
;; to the server using the challenge-response mechanism."
;;   {:added "1.0"
;;    :go "cRAMMD5Auth(username, secret)"}
;;   [^String username, ^String secret])
;; 
JOKER FUNC smtp.Dial has: 
;; (defn ^[{:text ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5203472 0xc00140b300}) Text, :conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) conn, :tls tls, :servername ^String serverName, :ext ^ABEND881(unrecognized Expr type *ast.MapType at: &{5203706 string string}) ext, :auth ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5203766 <nil> string}) auth, :localname ^String localName, :didhello didHello, :helloerror helloError} Error] Dial
;;   "Dial returns a new Client connected to an SMTP server at addr.
;; The addr must include a port, as in "mail.example.com:smtp"."
;;   {:added "1.0"
;;    :go "dial(addr)"}
;;   [^String addr])
;; 
JOKER FUNC smtp.NewClient has: 
;; (defn ^[{:text ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5203472 0xc00140b300}) Text, :conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) conn, :tls tls, :servername ^String serverName, :ext ^ABEND881(unrecognized Expr type *ast.MapType at: &{5203706 string string}) ext, :auth ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5203766 <nil> string}) auth, :localname ^String localName, :didhello didHello, :helloerror helloError} Error] NewClient
;;   "NewClient returns a new Client using an existing connection and host as a
;; server name to be used when authenticating."
;;   {:added "1.0"
;;    :go "newClient(conn, host)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) conn, ^String host])
;; 
JOKER FUNC smtp.PlainAuth has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{5199042 0xc0013ef260 false}) PlainAuth
;;   "PlainAuth returns an Auth that implements the PLAIN authentication
;; mechanism as defined in RFC 4616. The returned Auth uses the given
;; username and password to authenticate to host and act as identity.
;; Usually identity should be the empty string, to act as username.
;; 
;; PlainAuth will only send the credentials if the connection is using TLS
;; or is connected to localhost. Otherwise authentication will fail with an
;; error, without sending the credentials."
;;   {:added "1.0"
;;    :go "plainAuth(identity, username, password, host)"}
;;   [^String identity, ^String username, ^String password, ^String host])
;; 
JOKER FUNC smtp.SendMail has: 
;; (defn ^Error SendMail
;;   "SendMail connects to the server at addr, switches to TLS if
;; possible, authenticates with the optional mechanism a if possible,
;; and then sends an email from address from, to addresses to, with
;; message msg.
;; The addr must include a port, as in "mail.example.com:smtp".
;; 
;; The addresses in the to parameter are the SMTP RCPT addresses.
;; 
;; The msg parameter should be an RFC 822-style email with headers
;; first, a blank line, and then the message body. The lines of msg
;; should be CRLF terminated. The msg headers should usually include
;; fields such as "From", "To", "Subject", and "Cc".  Sending "Bcc"
;; messages is accomplished by including an email address in the to
;; parameter but not including it in the msg headers.
;; 
;; The SendMail function and the net/smtp package are low-level
;; mechanisms and provide no support for DKIM signing, MIME
;; attachments (see the mime/multipart package), or other mail
;; functionality. Higher-level packages exist outside of the standard
;; library."
;;   {:added "1.0"
;;    :go "sendMail(addr, a, from, to, msg)"}
;;   [^String addr, a, ^String from, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5211865 <nil> string}) to, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5211879 <nil> byte}) msg])
;; 
JOKER FUNC sort.Float64s has: 
;; (defn Float64s
;;   "Float64s sorts a slice of float64s in increasing order
;; (not-a-number values are treated as less than other values)."
;;   {:added "1.0"
;;    :go "float64s(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7132287 <nil> float64}) a])
;; 
JOKER FUNC sort.Float64sAreSorted has: 
;; (defn ^ABEND042(cannot find typename sort.bool) Float64sAreSorted
;;   "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order
;; (not-a-number values are treated as less than other values)."
;;   {:added "1.0"
;;    :go "float64sAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7132752 <nil> float64}) a])
;; 
JOKER FUNC sort.Ints has: 
;; (defn Ints
;;   "Ints sorts a slice of ints in increasing order."
;;   {:added "1.0"
;;    :go "ints(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7132119 <nil> int}) a])
;; 
JOKER FUNC sort.IntsAreSorted has: 
;; (defn ^ABEND042(cannot find typename sort.bool) IntsAreSorted
;;   "IntsAreSorted tests whether a slice of ints is sorted in increasing order."
;;   {:added "1.0"
;;    :go "intsAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7132532 <nil> int}) a])
;; 
JOKER FUNC sort.IsSorted has: 
;; (defn ^ABEND042(cannot find typename sort.bool) IsSorted
;;   "IsSorted reports whether data is sorted."
;;   {:added "1.0"
;;    :go "isSorted(data)"}
;;   [data])
;; 
JOKER FUNC sort.Reverse has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{7124619 0xc001b67fb0 false}) Reverse
;;   "Reverse returns the reverse order for data."
;;   {:added "1.0"
;;    :go "reverse(data)"}
;;   [data])
;; 
JOKER FUNC sort.Search has: 
;; (defn ^Int Search
;;   "Search uses binary search to find and return the smallest index i
;; in [0, n) at which f(i) is true, assuming that on the range [0, n),
;; f(i) == true implies f(i+1) == true. That is, Search requires that
;; f is false for some (possibly empty) prefix of the input range [0, n)
;; and then true for the (possibly empty) remainder; Search returns
;; the first true index. If there is no such index, Search returns n.
;; (Note that the "not found" return value is not -1 as in, for instance,
;; strings.Index.)
;; Search calls f(i) only for i in the range [0, n).
;; 
;; A common use of Search is to find the index i for a value x in
;; a sorted, indexable data structure such as an array or slice.
;; In this case, the argument f, typically a closure, captures the value
;; to be searched for, and how the data structure is indexed and
;; ordered.
;; 
;; For instance, given a slice data sorted in ascending order,
;; the call Search(len(data), func(i int) bool { return data[i] >= 23 })
;; returns the smallest index i such that data[i] >= 23. If the caller
;; wants to find whether 23 is in the slice, it must test data[i] == 23
;; separately.
;; 
;; Searching data sorted in descending order would use the <=
;; operator instead of the >= operator.
;; 
;; To complete the example above, the following code tries to find the value
;; x in an integer slice data sorted in ascending order:
;; 
;; 	x := 23
;; 	i := sort.Search(len(data), func(i int) bool { return data[i] >= x })
;; 	if i < len(data) && data[i] == x {
;; 		// x is present at data[i]
;; 	} else {
;; 		// x is not present in data,
;; 		// but i is the index where it would be inserted.
;; 	}
;; 
;; As a more whimsical example, this program guesses your number:
;; 
;; 	func GuessingGame() {
;; 		var s string
;; 		fmt.Printf("Pick an integer from 0 to 100.\n")
;; 		answer := sort.Search(100, func(i int) bool {
;; 			fmt.Printf("Is your number <= %d? ", i)
;; 			fmt.Scanf("%s", &s)
;; 			return s != "" && s[0] == 'y'
;; 		})
;; 		fmt.Printf("Your number is %d.\n", answer)
;; 	}"
;;   {:added "1.0"
;;    :go "search(n, f)"}
;;   [^Int n, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7142545 0xc001be2e40 0xc001be2e70}) f])
;; 
JOKER FUNC sort.SearchFloat64s has: 
;; (defn ^Int SearchFloat64s
;;   "SearchFloat64s searches for x in a sorted slice of float64s and returns the index
;; as specified by Search. The return value is the index to insert x if x is not
;; present (it could be len(a)).
;; The slice must be sorted in ascending order."
;;   {:added "1.0"
;;    :go "searchFloat64s(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7143617 <nil> float64}) a, x])
;; 
JOKER FUNC sort.SearchInts has: 
;; (defn ^Int SearchInts
;;   "SearchInts searches for x in a sorted slice of ints and returns the index
;; as specified by Search. The return value is the index to insert x if x is
;; not present (it could be len(a)).
;; The slice must be sorted in ascending order."
;;   {:added "1.0"
;;    :go "searchInts(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7143260 <nil> int}) a, ^Int x])
;; 
JOKER FUNC sort.SearchStrings has: 
;; (defn ^Int SearchStrings
;;   "SearchStrings searches for x in a sorted slice of strings and returns the index
;; as specified by Search. The return value is the index to insert x if x is not
;; present (it could be len(a)).
;; The slice must be sorted in ascending order."
;;   {:added "1.0"
;;    :go "searchStrings(a, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7143979 <nil> string}) a, ^String x])
;; 
JOKER FUNC sort.Slice has: 
;; (defn Slice
;;   "Slice sorts the provided slice given the provided less function.
;; 
;; The sort is not guaranteed to be stable. For a stable sort, use
;; SliceStable.
;; 
;; The function panics if the provided interface is not a slice."
;;   {:added "1.0"
;;    :go "slice(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{7144986 0xc001be3e90 false}) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7145004 0xc001be3ef0 0xc001be3f20}) less])
;; 
JOKER FUNC sort.SliceIsSorted has: 
;; (defn ^ABEND042(cannot find typename sort.bool) SliceIsSorted
;;   "SliceIsSorted tests whether a slice is sorted.
;; 
;; The function panics if the provided interface is not a slice."
;;   {:added "1.0"
;;    :go "sliceIsSorted(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{7145692 0xc001bf4210 false}) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7145710 0xc001bf4270 0xc001bf42a0}) less])
;; 
JOKER FUNC sort.SliceStable has: 
;; (defn SliceStable
;;   "SliceStable sorts the provided slice given the provided less
;; function while keeping the original order of equal elements.
;; 
;; The function panics if the provided interface is not a slice."
;;   {:added "1.0"
;;    :go "sliceStable(slice, less)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{7145398 0xc001bf4060 false}) slice, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7145416 0xc001bf40c0 0xc001bf40f0}) less])
;; 
JOKER FUNC sort.Sort has: 
;; (defn Sort
;;   "Sort sorts data.
;; It makes one call to data.Len to determine n, and O(n*log(n)) calls to
;; data.Less and data.Swap. The sort is not guaranteed to be stable."
;;   {:added "1.0"
;;    :go "sort(data)"}
;;   [data])
;; 
JOKER FUNC sort.Stable has: 
;; (defn Stable
;;   "Stable sorts data while keeping the original order of equal elements.
;; 
;; It makes one call to data.Len to determine n, O(n*log(n)) calls to
;; data.Less and O(n*log(n)*log(n)) calls to data.Swap."
;;   {:added "1.0"
;;    :go "stable(data)"}
;;   [data])
;; 
JOKER FUNC sort.Strings has: 
;; (defn Strings
;;   "Strings sorts a slice of strings in increasing order."
;;   {:added "1.0"
;;    :go "strings(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7132397 <nil> string}) a])
;; 
JOKER FUNC sort.StringsAreSorted has: 
;; (defn ^ABEND042(cannot find typename sort.bool) StringsAreSorted
;;   "StringsAreSorted tests whether a slice of strings is sorted in increasing order."
;;   {:added "1.0"
;;    :go "stringsAreSorted(a)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7132914 <nil> string}) a])
;; 
JOKER FUNC sql.Drivers has: 
(defn ^[String] Drivers
  "Drivers returns a sorted list of the names of the registered drivers."
  {:added "1.0"
   :go "drivers()"}
  [])

JOKER FUNC sql.Named has: 
;; (defn ^{:_named_fields_required ^ABEND881(unrecognized Expr type *ast.StructType at: &{1030353 0xc0006954a0 false}) _Named_Fields_Required, :name ^String Name, :value ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1030668 0xc0006954d0 false}) Value} Named
;;   "Named provides a more concise way to create NamedArg values.
;; 
;; Example usage:
;; 
;;     db.ExecContext(ctx, `
;;         delete from Invoice
;;         where
;;             TimeCreated < @end
;;             and TimeCreated >= @start;`,
;;         sql.Named("start", startTime),
;;         sql.Named("end", endTime),
;;     )"
;;   {:added "1.0"
;;    :go "named(name, value)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1031045 0xc000695560 false}) value])
;; 
JOKER FUNC sql.Open has: 
;; (defn ^[{:waitduration waitDuration, :connector ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{driver Connector}) connector, :numclosed numClosed, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :freeconn ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1038331 <nil> 0xc0006d9500}) freeConn, :connrequests ^ABEND881(unrecognized Expr type *ast.MapType at: &{1038359 uint64 0xc0006d2ff0}) connRequests, :nextrequest nextRequest, :numopen ^Int numOpen, :openerch ^ABEND881(unrecognized Expr type *ast.ChanType at: &{1038822 0 3 0xc0006d9780}) openerCh, :resetterch ^ABEND881(unrecognized Expr type *ast.ChanType at: &{1038855 0 3 0xc0006d97e0}) resetterCh, :closed closed, :dep ^ABEND881(unrecognized Expr type *ast.MapType at: &{1038915 finalCloser depSet}) dep, :lastput ^ABEND881(unrecognized Expr type *ast.MapType at: &{1038957 0xc0006d98e0 string}) lastPut, :maxidle ^Int maxIdle, :maxopen ^Int maxOpen, :maxlifetime ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}) maxLifetime, :cleanerch ^ABEND881(unrecognized Expr type *ast.ChanType at: &{1039299 0 3 0xc0006d9b40}) cleanerCh, :waitcount waitCount, :maxidleclosed maxIdleClosed, :maxlifetimeclosed maxLifetimeClosed, :stop ^ABEND881(unrecognized Expr type *ast.FuncType at: &{1039550 0xc0006d31d0 <nil>}) stop} Error] Open
;;   "Open opens a database specified by its database driver name and a
;; driver-specific data source name, usually consisting of at least a
;; database name and connection information.
;; 
;; Most users will open a database via a driver-specific connection
;; helper function that returns a *DB. No database drivers are included
;; in the Go standard library. See https://golang.org/s/sqldrivers for
;; a list of third-party drivers.
;; 
;; Open may just validate its arguments without creating a connection
;; to the database. To verify that the data source name is valid, call
;; Ping.
;; 
;; The returned DB is safe for concurrent use by multiple goroutines
;; and maintains its own pool of idle connections. Thus, the Open
;; function should be called just once. It is rarely necessary to
;; close a DB."
;;   {:added "1.0"
;;    :go "open(driverName, dataSourceName)"}
;;   [^String driverName, ^String dataSourceName])
;; 
JOKER FUNC sql.OpenDB has: 
;; (defn ^{:waitduration waitDuration, :connector ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{driver Connector}) connector, :numclosed numClosed, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :freeconn ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1038331 <nil> 0xc0006d9500}) freeConn, :connrequests ^ABEND881(unrecognized Expr type *ast.MapType at: &{1038359 uint64 0xc0006d2ff0}) connRequests, :nextrequest nextRequest, :numopen ^Int numOpen, :openerch ^ABEND881(unrecognized Expr type *ast.ChanType at: &{1038822 0 3 0xc0006d9780}) openerCh, :resetterch ^ABEND881(unrecognized Expr type *ast.ChanType at: &{1038855 0 3 0xc0006d97e0}) resetterCh, :closed closed, :dep ^ABEND881(unrecognized Expr type *ast.MapType at: &{1038915 finalCloser depSet}) dep, :lastput ^ABEND881(unrecognized Expr type *ast.MapType at: &{1038957 0xc0006d98e0 string}) lastPut, :maxidle ^Int maxIdle, :maxopen ^Int maxOpen, :maxlifetime ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}) maxLifetime, :cleanerch ^ABEND881(unrecognized Expr type *ast.ChanType at: &{1039299 0 3 0xc0006d9b40}) cleanerCh, :waitcount waitCount, :maxidleclosed maxIdleClosed, :maxlifetimeclosed maxLifetimeClosed, :stop ^ABEND881(unrecognized Expr type *ast.FuncType at: &{1039550 0xc0006d31d0 <nil>}) stop} OpenDB
;;   "OpenDB opens a database using a Connector, allowing drivers to
;; bypass a string based data source name.
;; 
;; Most users will open a database via a driver-specific connection
;; helper function that returns a *DB. No database drivers are included
;; in the Go standard library. See https://golang.org/s/sqldrivers for
;; a list of third-party drivers.
;; 
;; OpenDB may just validate its arguments without creating a connection
;; to the database. To verify that the data source name is valid, call
;; Ping.
;; 
;; The returned DB is safe for concurrent use by multiple goroutines
;; and maintains its own pool of idle connections. Thus, the OpenDB
;; function should be called just once. It is rarely necessary to
;; close a DB."
;;   {:added "1.0"
;;    :go "openDB(c)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{driver Connector}) c])
;; 
JOKER FUNC sql.Register has: 
;; (defn Register
;;   "Register makes a database driver available by the provided name.
;; If Register is called twice with the same name or if driver is nil,
;; it panics."
;;   {:added "1.0"
;;    :go "register(name, driver)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{driver Driver}) driver])
;; 
JOKER FUNC strconv.AppendBool has: 
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendBool
;;   "AppendBool appends "true" or "false", according to the value of b,
;; to dst and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendBool(dst, b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7184886 <nil> byte}) dst, b])
;; 
JOKER FUNC strconv.AppendFloat has: 
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendFloat
;;   "AppendFloat appends the string form of the floating-point number f,
;; as generated by FormatFloat, to dst and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendFloat(dst, f, fmt, prec, bitSize)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7174636 <nil> byte}) dst, f, fmt, ^Int prec, ^Int bitSize])
;; 
JOKER FUNC strconv.AppendInt has: 
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendInt
;;   "AppendInt appends the string form of the integer i,
;; as generated by FormatInt, to dst and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendInt(dst, i, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7200842 <nil> byte}) dst, i, ^Int base])
;; 
JOKER FUNC strconv.AppendQuote has: 
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuote
;;   "AppendQuote appends a double-quoted Go string literal representing s,
;; as generated by Quote, to dst and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendQuote(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7188182 <nil> byte}) dst, ^String s])
;; 
JOKER FUNC strconv.AppendQuoteRune has: 
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuoteRune
;;   "AppendQuoteRune appends a single-quoted Go character literal representing the rune,
;; as generated by QuoteRune, to dst and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendQuoteRune(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7189900 <nil> byte}) dst, r])
;; 
JOKER FUNC strconv.AppendQuoteRuneToASCII has: 
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuoteRuneToASCII
;;   "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,
;; as generated by QuoteRuneToASCII, to dst and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendQuoteRuneToASCII(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7190516 <nil> byte}) dst, r])
;; 
JOKER FUNC strconv.AppendQuoteRuneToGraphic has: 
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuoteRuneToGraphic
;;   "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,
;; as generated by QuoteRuneToGraphic, to dst and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendQuoteRuneToGraphic(dst, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7191143 <nil> byte}) dst, r])
;; 
JOKER FUNC strconv.AppendQuoteToASCII has: 
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuoteToASCII
;;   "AppendQuoteToASCII appends a double-quoted Go string literal representing s,
;; as generated by QuoteToASCII, to dst and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendQuoteToASCII(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7188749 <nil> byte}) dst, ^String s])
;; 
JOKER FUNC strconv.AppendQuoteToGraphic has: 
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendQuoteToGraphic
;;   "AppendQuoteToGraphic appends a double-quoted Go string literal representing s,
;; as generated by QuoteToGraphic, to dst and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendQuoteToGraphic(dst, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7189327 <nil> byte}) dst, ^String s])
;; 
JOKER FUNC strconv.AppendUint has: 
;; (defn ^[ABEND042(cannot find typename strconv.byte)] AppendUint
;;   "AppendUint appends the string form of the unsigned integer i,
;; as generated by FormatUint, to dst and returns the extended buffer."
;;   {:added "1.0"
;;    :go "appendUint(dst, i, base)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7201203 <nil> byte}) dst, i, ^Int base])
;; 
JOKER FUNC strconv.Atoi has: 
(defn ^[Int Error] Atoi
  "Atoi returns the result of ParseInt(s, 10, 0) converted to type int."
  {:added "1.0"
   :go "atoi(s)"}
  [^String s])

JOKER FUNC strconv.CanBackquote has: 
;; (defn ^ABEND042(cannot find typename strconv.bool) CanBackquote
;;   "CanBackquote reports whether the string s can be represented
;; unchanged as a single-line backquoted string without control
;; characters other than tab."
;;   {:added "1.0"
;;    :go "canBackquote(s)"}
;;   [^String s])
;; 
JOKER FUNC strconv.FormatBool has: 
(defn ^String FormatBool
  "FormatBool returns "true" or "false" according to the value of b."
  {:added "1.0"
   :go "formatBool(b)"}
  [b])

JOKER FUNC strconv.FormatFloat has: 
(defn ^String FormatFloat
  "FormatFloat converts the floating-point number f to a string,
according to the format fmt and precision prec. It rounds the
result assuming that the original was obtained from a floating-point
value of bitSize bits (32 for float32, 64 for float64).

The format fmt is one of
'b' (-ddddp±ddd, a binary exponent),
'e' (-d.dddde±dd, a decimal exponent),
'E' (-d.ddddE±dd, a decimal exponent),
'f' (-ddd.dddd, no exponent),
'g' ('e' for large exponents, 'f' otherwise), or
'G' ('E' for large exponents, 'f' otherwise).

The precision prec controls the number of digits (excluding the exponent)
printed by the 'e', 'E', 'f', 'g', and 'G' formats.
For 'e', 'E', and 'f' it is the number of digits after the decimal point.
For 'g' and 'G' it is the maximum number of significant digits (trailing
zeros are removed).
The special precision -1 uses the smallest number of digits
necessary such that ParseFloat will return f exactly."
  {:added "1.0"
   :go "formatFloat(f, fmt, prec, bitSize)"}
  [f, fmt, ^Int prec, ^Int bitSize])

JOKER FUNC strconv.FormatInt has: 
(defn ^String FormatInt
  "FormatInt returns the string representation of i in the given base,
for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
for digit values >= 10."
  {:added "1.0"
   :go "formatInt(i, base)"}
  [i, ^Int base])

JOKER FUNC strconv.FormatUint has: 
(defn ^String FormatUint
  "FormatUint returns the string representation of i in the given base,
for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
for digit values >= 10."
  {:added "1.0"
   :go "formatUint(i, base)"}
  [i, ^Int base])

JOKER FUNC strconv.IsGraphic has: 
;; (defn ^ABEND042(cannot find typename strconv.bool) IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such
;; characters include letters, marks, numbers, punctuation, symbols, and
;; spaces, from categories L, M, N, P, S, and Zs."
;;   {:added "1.0"
;;    :go "isGraphic(r)"}
;;   [r])
;; 
JOKER FUNC strconv.IsPrint has: 
;; (defn ^ABEND042(cannot find typename strconv.bool) IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go, with
;; the same definition as unicode.IsPrint: letters, numbers, punctuation,
;; symbols and ASCII space."
;;   {:added "1.0"
;;    :go "isPrint(r)"}
;;   [r])
;; 
JOKER FUNC strconv.Itoa has: 
(defn ^String Itoa
  "Itoa is shorthand for FormatInt(int64(i), 10)."
  {:added "1.0"
   :go "itoa(i)"}
  [^Int i])

JOKER FUNC strconv.ParseBool has: 
;; (defn ^[ABEND042(cannot find typename strconv.bool) Error] ParseBool
;;   "ParseBool returns the boolean value represented by the string.
;; It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.
;; Any other value returns an error."
;;   {:added "1.0"
;;    :go "parseBool(str)"}
;;   [^String str])
;; 
JOKER FUNC strconv.ParseFloat has: 
;; (defn ^[ABEND042(cannot find typename strconv.float64) Error] ParseFloat
;;   "ParseFloat converts the string s to a floating-point number
;; with the precision specified by bitSize: 32 for float32, or 64 for float64.
;; When bitSize=32, the result still has type float64, but it will be
;; convertible to float32 without changing its value.
;; 
;; If s is well-formed and near a valid floating point number,
;; ParseFloat returns the nearest floating point number rounded
;; using IEEE754 unbiased rounding.
;; 
;; The errors that ParseFloat returns have concrete type *NumError
;; and include err.Num = s.
;; 
;; If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.
;; 
;; If s is syntactically well-formed but is more than 1/2 ULP
;; away from the largest floating point number of the given size,
;; ParseFloat returns f = ±Inf, err.Err = ErrRange."
;;   {:added "1.0"
;;    :go "parseFloat(s, bitSize)"}
;;   [^String s, ^Int bitSize])
;; 
JOKER FUNC strconv.ParseInt has: 
(defn ^[i err] ParseInt
  "ParseInt interprets a string s in the given base (0, 2 to 36) and
bit size (0 to 64) and returns the corresponding value i.

If base == 0, the base is implied by the string's prefix:
base 16 for "0x", base 8 for "0", and base 10 otherwise.
For bases 1, below 0 or above 36 an error is returned.

The bitSize argument specifies the integer type
that the result must fit into. Bit sizes 0, 8, 16, 32, and 64
correspond to int, int8, int16, int32, and int64.
For a bitSize below 0 or above 64 an error is returned.

The errors that ParseInt returns have concrete type *NumError
and include err.Num = s. If s is empty or contains invalid
digits, err.Err = ErrSyntax and the returned value is 0;
if the value corresponding to s cannot be represented by a
signed integer of the given size, err.Err = ErrRange and the
returned value is the maximum magnitude integer of the
appropriate bitSize and sign."
  {:added "1.0"
   :go "parseInt(s, base, bitSize)"}
  [^String s, ^Int base, ^Int bitSize])

JOKER FUNC strconv.ParseUint has: 
;; (defn ^[ABEND042(cannot find typename strconv.uint64) Error] ParseUint
;;   "ParseUint is like ParseInt but for unsigned numbers."
;;   {:added "1.0"
;;    :go "parseUint(s, base, bitSize)"}
;;   [^String s, ^Int base, ^Int bitSize])
;; 
JOKER FUNC strconv.Quote has: 
(defn ^String Quote
  "Quote returns a double-quoted Go string literal representing s. The
returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
control characters and non-printable characters as defined by
IsPrint."
  {:added "1.0"
   :go "quote(s)"}
  [^String s])

JOKER FUNC strconv.QuoteRune has: 
(defn ^String QuoteRune
  "QuoteRune returns a single-quoted Go character literal representing the
rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100)
for control characters and non-printable characters as defined by IsPrint."
  {:added "1.0"
   :go "quoteRune(r)"}
  [r])

JOKER FUNC strconv.QuoteRuneToASCII has: 
(defn ^String QuoteRuneToASCII
  "QuoteRuneToASCII returns a single-quoted Go character literal representing
the rune. The returned string uses Go escape sequences (\t, \n, \xFF,
\u0100) for non-ASCII characters and non-printable characters as defined
by IsPrint."
  {:added "1.0"
   :go "quoteRuneToASCII(r)"}
  [r])

JOKER FUNC strconv.QuoteRuneToGraphic has: 
(defn ^String QuoteRuneToGraphic
  "QuoteRuneToGraphic returns a single-quoted Go character literal representing
the rune. The returned string uses Go escape sequences (\t, \n, \xFF,
\u0100) for non-ASCII characters and non-printable characters as defined
by IsGraphic."
  {:added "1.0"
   :go "quoteRuneToGraphic(r)"}
  [r])

JOKER FUNC strconv.QuoteToASCII has: 
(defn ^String QuoteToASCII
  "QuoteToASCII returns a double-quoted Go string literal representing s.
The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
non-ASCII characters and non-printable characters as defined by IsPrint."
  {:added "1.0"
   :go "quoteToASCII(s)"}
  [^String s])

JOKER FUNC strconv.QuoteToGraphic has: 
(defn ^String QuoteToGraphic
  "QuoteToGraphic returns a double-quoted Go string literal representing s.
The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
non-ASCII characters and non-printable characters as defined by IsGraphic."
  {:added "1.0"
   :go "quoteToGraphic(s)"}
  [^String s])

JOKER FUNC strconv.Unquote has: 
(defn ^[String Error] Unquote
  "Unquote interprets s as a single-quoted, double-quoted,
or backquoted Go string literal, returning the string value
that s quotes.  (If s is single-quoted, it would be a Go
character literal; Unquote returns the corresponding
one-character string.)"
  {:added "1.0"
   :go "unquote(s)"}
  [^String s])

JOKER FUNC strconv.UnquoteChar has: 
(defn ^[value multibyte tail err] UnquoteChar
  "UnquoteChar decodes the first character or byte in the escaped string
or character literal represented by the string s.
It returns four values:

	1) value, the decoded Unicode code point or byte value;
	2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;
	3) tail, the remainder of the string after the character; and
	4) an error that will be nil if the character is syntactically valid.

The second argument, quote, specifies the type of literal being parsed
and therefore which escaped quote character is permitted.
If set to a single quote, it permits the sequence \' and disallows unescaped '.
If set to a double quote, it permits \" and disallows unescaped ".
If set to zero, it does not permit either escape and allows both quote characters to appear unescaped."
  {:added "1.0"
   :go "unquoteChar(s, quote)"}
  [^String s, quote])

JOKER FUNC strings.Compare has: 
(defn ^Int Compare
  "Compare returns an integer comparing two strings lexicographically.
The result will be 0 if a==b, -1 if a < b, and +1 if a > b.

Compare is included only for symmetry with package bytes.
It is usually clearer and always faster to use the built-in
string comparison operators ==, <, >, and so on."
  {:added "1.0"
   :go "compare(a, b)"}
  [^String a, ^String b])

JOKER FUNC strings.Contains has: 
;; (defn ^ABEND042(cannot find typename strings.bool) Contains
;;   "Contains reports whether substr is within s."
;;   {:added "1.0"
;;    :go "contains(s, substr)"}
;;   [^String s, ^String substr])
;; 
JOKER FUNC strings.ContainsAny has: 
;; (defn ^ABEND042(cannot find typename strings.bool) ContainsAny
;;   "ContainsAny reports whether any Unicode code points in chars are within s."
;;   {:added "1.0"
;;    :go "containsAny(s, chars)"}
;;   [^String s, ^String chars])
;; 
JOKER FUNC strings.ContainsRune has: 
;; (defn ^ABEND042(cannot find typename strings.bool) ContainsRune
;;   "ContainsRune reports whether the Unicode code point r is within s."
;;   {:added "1.0"
;;    :go "containsRune(s, r)"}
;;   [^String s, r])
;; 
JOKER FUNC strings.Count has: 
(defn ^Int Count
  "Count counts the number of non-overlapping instances of substr in s.
If substr is an empty string, Count returns 1 + the number of Unicode code points in s."
  {:added "1.0"
   :go "count(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.EqualFold has: 
;; (defn ^ABEND042(cannot find typename strings.bool) EqualFold
;;   "EqualFold reports whether s and t, interpreted as UTF-8 strings,
;; are equal under Unicode case-folding."
;;   {:added "1.0"
;;    :go "equalFold(s, t)"}
;;   [^String s, ^String t])
;; 
JOKER FUNC strings.Fields has: 
(defn ^[String] Fields
  "Fields splits the string s around each instance of one or more consecutive white space
characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an
empty slice if s contains only white space."
  {:added "1.0"
   :go "fields(s)"}
  [^String s])

JOKER FUNC strings.FieldsFunc has: 
;; (defn ^[String] FieldsFunc
;;   "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)
;; and returns an array of slices of s. If all code points in s satisfy f(c) or the
;; string is empty, an empty slice is returned.
;; FieldsFunc makes no guarantees about the order in which it calls f(c).
;; If f does not return consistent results for a given c, FieldsFunc may crash."
;;   {:added "1.0"
;;    :go "fieldsFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7275863 0xc001df7710 0xc001df7740}) f])
;; 
JOKER FUNC strings.HasPrefix has: 
;; (defn ^ABEND042(cannot find typename strings.bool) HasPrefix
;;   "HasPrefix tests whether the string s begins with prefix."
;;   {:added "1.0"
;;    :go "hasPrefix(s, prefix)"}
;;   [^String s, ^String prefix])
;; 
JOKER FUNC strings.HasSuffix has: 
;; (defn ^ABEND042(cannot find typename strings.bool) HasSuffix
;;   "HasSuffix tests whether the string s ends with suffix."
;;   {:added "1.0"
;;    :go "hasSuffix(s, suffix)"}
;;   [^String s, ^String suffix])
;; 
JOKER FUNC strings.Index has: 
(defn ^Int Index
  "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s."
  {:added "1.0"
   :go "index(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.IndexAny has: 
(defn ^Int IndexAny
  "IndexAny returns the index of the first instance of any Unicode code point
from chars in s, or -1 if no Unicode code point from chars is present in s."
  {:added "1.0"
   :go "indexAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.IndexByte has: 
(defn ^Int IndexByte
  "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s."
  {:added "1.0"
   :go "indexByte(s, c)"}
  [^String s, c])

JOKER FUNC strings.IndexFunc has: 
;; (defn ^Int IndexFunc
;;   "IndexFunc returns the index into s of the first Unicode
;; code point satisfying f(c), or -1 if none do."
;;   {:added "1.0"
;;    :go "indexFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7284374 0xc001e0ff50 0xc001e0ff80}) f])
;; 
JOKER FUNC strings.IndexRune has: 
(defn ^Int IndexRune
  "IndexRune returns the index of the first instance of the Unicode code point
r, or -1 if rune is not present in s.
If r is utf8.RuneError, it returns the first instance of any
invalid UTF-8 byte sequence."
  {:added "1.0"
   :go "indexRune(s, r)"}
  [^String s, r])

JOKER FUNC strings.Join has: 
;; (defn ^String Join
;;   "Join concatenates the elements of a to create a single string. The separator string
;; sep is placed between elements in the resulting string."
;;   {:added "1.0"
;;    :go "join(a, sep)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7276820 <nil> string}) a, ^String sep])
;; 
JOKER FUNC strings.LastIndex has: 
(defn ^Int LastIndex
  "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s."
  {:added "1.0"
   :go "lastIndex(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.LastIndexAny has: 
(defn ^Int LastIndexAny
  "LastIndexAny returns the index of the last instance of any Unicode code
point from chars in s, or -1 if no Unicode code point from chars is
present in s."
  {:added "1.0"
   :go "lastIndexAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.LastIndexByte has: 
(defn ^Int LastIndexByte
  "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s."
  {:added "1.0"
   :go "lastIndexByte(s, c)"}
  [^String s, c])

JOKER FUNC strings.LastIndexFunc has: 
;; (defn ^Int LastIndexFunc
;;   "LastIndexFunc returns the index into s of the last
;; Unicode code point satisfying f(c), or -1 if none do."
;;   {:added "1.0"
;;    :go "lastIndexFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7284572 0xc001e20120 0xc001e20150}) f])
;; 
JOKER FUNC strings.Map has: 
;; (defn ^String Map
;;   "Map returns a copy of the string s with all its characters modified
;; according to the mapping function. If mapping returns a negative value, the character is
;; dropped from the string with no replacement."
;;   {:added "1.0"
;;    :go "map(mapping, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{7277962 0xc001e068d0 0xc001e06900}) mapping, ^String s])
;; 
JOKER FUNC strings.NewReader has: 
(defn ^{:s ^String s, :i i, :prevrune ^Int prevRune} NewReader
  "NewReader returns a new Reader reading from s.
It is similar to bytes.NewBufferString but more efficient and read-only."
  {:added "1.0"
   :go "newReader(s)"}
  [^String s])

JOKER FUNC strings.NewReplacer has: 
;; (defn ^{:r r} NewReplacer
;;   "NewReplacer returns a new Replacer from a list of old, new string
;; pairs. Replacements are performed in the order they appear in the
;; target string, without overlapping matches."
;;   {:added "1.0"
;;    :go "newReplacer(oldnew)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{7247822 string}) oldnew])
;; 
JOKER FUNC strings.Repeat has: 
(defn ^String Repeat
  "Repeat returns a new string consisting of count copies of the string s.

It panics if count is negative or if
the result of (len(s) * count) overflows."
  {:added "1.0"
   :go "repeat(s, count)"}
  [^String s, ^Int count])

JOKER FUNC strings.Replace has: 
(defn ^String Replace
  "Replace returns a copy of the string s with the first n
non-overlapping instances of old replaced by new.
If old is empty, it matches at the beginning of the string
and after each UTF-8 sequence, yielding up to k+1 replacements
for a k-rune string.
If n < 0, there is no limit on the number of replacements."
  {:added "1.0"
   :go "replace(s, old, new, n)"}
  [^String s, ^String old, ^String new, ^Int n])

JOKER FUNC strings.Split has: 
(defn ^[String] Split
  "Split slices s into all substrings separated by sep and returns a slice of
the substrings between those separators.

If s does not contain sep and sep is not empty, Split returns a
slice of length 1 whose only element is s.

If sep is empty, Split splits after each UTF-8 sequence. If both s
and sep are empty, Split returns an empty slice.

It is equivalent to SplitN with a count of -1."
  {:added "1.0"
   :go "split(s, sep)"}
  [^String s, ^String sep])

JOKER FUNC strings.SplitAfter has: 
(defn ^[String] SplitAfter
  "SplitAfter slices s into all substrings after each instance of sep and
returns a slice of those substrings.

If s does not contain sep and sep is not empty, SplitAfter returns
a slice of length 1 whose only element is s.

If sep is empty, SplitAfter splits after each UTF-8 sequence. If
both s and sep are empty, SplitAfter returns an empty slice.

It is equivalent to SplitAfterN with a count of -1."
  {:added "1.0"
   :go "splitAfter(s, sep)"}
  [^String s, ^String sep])

JOKER FUNC strings.SplitAfterN has: 
(defn ^[String] SplitAfterN
  "SplitAfterN slices s into substrings after each instance of sep and
returns a slice of those substrings.

The count determines the number of substrings to return:
  n > 0: at most n substrings; the last substring will be the unsplit remainder.
  n == 0: the result is nil (zero substrings)
  n < 0: all substrings

Edge cases for s and sep (for example, empty strings) are handled
as described in the documentation for SplitAfter."
  {:added "1.0"
   :go "splitAfterN(s, sep, n)"}
  [^String s, ^String sep, ^Int n])

JOKER FUNC strings.SplitN has: 
(defn ^[String] SplitN
  "SplitN slices s into substrings separated by sep and returns a slice of
the substrings between those separators.

The count determines the number of substrings to return:
  n > 0: at most n substrings; the last substring will be the unsplit remainder.
  n == 0: the result is nil (zero substrings)
  n < 0: all substrings

Edge cases for s and sep (for example, empty strings) are handled
as described in the documentation for Split."
  {:added "1.0"
   :go "splitN(s, sep, n)"}
  [^String s, ^String sep, ^Int n])

JOKER FUNC strings.Title has: 
(defn ^String Title
  "Title returns a copy of the string s with all Unicode letters that begin words
mapped to their title case.

BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly."
  {:added "1.0"
   :go "title(s)"}
  [^String s])

JOKER FUNC strings.ToLower has: 
(defn ^String ToLower
  "ToLower returns a copy of the string s with all Unicode letters mapped to their lower case."
  {:added "1.0"
   :go "toLower(s)"}
  [^String s])

JOKER FUNC strings.ToLowerSpecial has: 
;; (defn ^String ToLowerSpecial
;;   "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their
;; lower case, giving priority to the special casing rules."
;;   {:added "1.0"
;;    :go "toLowerSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unicode SpecialCase}) c, ^String s])
;; 
JOKER FUNC strings.ToTitle has: 
(defn ^String ToTitle
  "ToTitle returns a copy of the string s with all Unicode letters mapped to their title case."
  {:added "1.0"
   :go "toTitle(s)"}
  [^String s])

JOKER FUNC strings.ToTitleSpecial has: 
;; (defn ^String ToTitleSpecial
;;   "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their
;; title case, giving priority to the special casing rules."
;;   {:added "1.0"
;;    :go "toTitleSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unicode SpecialCase}) c, ^String s])
;; 
JOKER FUNC strings.ToUpper has: 
(defn ^String ToUpper
  "ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case."
  {:added "1.0"
   :go "toUpper(s)"}
  [^String s])

JOKER FUNC strings.ToUpperSpecial has: 
;; (defn ^String ToUpperSpecial
;;   "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their
;; upper case, giving priority to the special casing rules."
;;   {:added "1.0"
;;    :go "toUpperSpecial(c, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{unicode SpecialCase}) c, ^String s])
;; 
JOKER FUNC strings.Trim has: 
(defn ^String Trim
  "Trim returns a slice of the string s with all leading and
trailing Unicode code points contained in cutset removed."
  {:added "1.0"
   :go "trim(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimFunc has: 
;; (defn ^String TrimFunc
;;   "TrimFunc returns a slice of the string s with all leading
;; and trailing Unicode code points c satisfying f(c) removed."
;;   {:added "1.0"
;;    :go "trimFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7284165 0xc001e0fda0 0xc001e0fdd0}) f])
;; 
JOKER FUNC strings.TrimLeft has: 
(defn ^String TrimLeft
  "TrimLeft returns a slice of the string s with all leading
Unicode code points contained in cutset removed.

To remove a prefix, use TrimPrefix instead."
  {:added "1.0"
   :go "trimLeft(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimLeftFunc has: 
;; (defn ^String TrimLeftFunc
;;   "TrimLeftFunc returns a slice of the string s with all leading
;; Unicode code points c satisfying f(c) removed."
;;   {:added "1.0"
;;    :go "trimLeftFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7283578 0xc001e0f7d0 0xc001e0f800}) f])
;; 
JOKER FUNC strings.TrimPrefix has: 
(defn ^String TrimPrefix
  "TrimPrefix returns s without the provided leading prefix string.
If s doesn't start with prefix, s is returned unchanged."
  {:added "1.0"
   :go "trimPrefix(s, prefix)"}
  [^String s, ^String prefix])

JOKER FUNC strings.TrimRight has: 
(defn ^String TrimRight
  "TrimRight returns a slice of the string s, with all trailing
Unicode code points contained in cutset removed.

To remove a suffix, use TrimSuffix instead."
  {:added "1.0"
   :go "trimRight(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimRightFunc has: 
;; (defn ^String TrimRightFunc
;;   "TrimRightFunc returns a slice of the string s with all trailing
;; Unicode code points c satisfying f(c) removed."
;;   {:added "1.0"
;;    :go "trimRightFunc(s, f)"}
;;   [^String s, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7283827 0xc001e0fa40 0xc001e0fa70}) f])
;; 
JOKER FUNC strings.TrimSpace has: 
(defn ^String TrimSpace
  "TrimSpace returns a slice of the string s, with all leading
and trailing white space removed, as defined by Unicode."
  {:added "1.0"
   :go "trimSpace(s)"}
  [^String s])

JOKER FUNC strings.TrimSuffix has: 
(defn ^String TrimSuffix
  "TrimSuffix returns s without the provided trailing suffix string.
If s doesn't end with suffix, s is returned unchanged."
  {:added "1.0"
   :go "trimSuffix(s, suffix)"}
  [^String s, ^String suffix])

JOKER FUNC subtle.ConstantTimeByteEq has: 
(defn ^Int ConstantTimeByteEq
  "ConstantTimeByteEq returns 1 if x == y and 0 otherwise."
  {:added "1.0"
   :go "constantTimeByteEq(x, y)"}
  [x, y])

JOKER FUNC subtle.ConstantTimeCompare has: 
;; (defn ^Int ConstantTimeCompare
;;   "ConstantTimeCompare returns 1 if and only if the two slices, x
;; and y, have equal contents. The time taken is a function of the length of
;; the slices and is independent of the contents."
;;   {:added "1.0"
;;    :go "constantTimeCompare(x, y)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{664091 <nil> byte}) x, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{664091 <nil> byte}) y])
;; 
JOKER FUNC subtle.ConstantTimeCopy has: 
;; (defn ConstantTimeCopy
;;   "ConstantTimeCopy copies the contents of y into x (a slice of equal length)
;; if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v
;; takes any other value."
;;   {:added "1.0"
;;    :go "constantTimeCopy(v, x, y)"}
;;   [^Int v, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{664931 <nil> byte}) x, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{664931 <nil> byte}) y])
;; 
JOKER FUNC subtle.ConstantTimeEq has: 
(defn ^Int ConstantTimeEq
  "ConstantTimeEq returns 1 if x == y and 0 otherwise."
  {:added "1.0"
   :go "constantTimeEq(x, y)"}
  [x, y])

JOKER FUNC subtle.ConstantTimeLessOrEq has: 
(defn ^Int ConstantTimeLessOrEq
  "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise.
Its behavior is undefined if x or y are negative or > 2**31 - 1."
  {:added "1.0"
   :go "constantTimeLessOrEq(x, y)"}
  [^Int x, ^Int y])

JOKER FUNC subtle.ConstantTimeSelect has: 
(defn ^Int ConstantTimeSelect
  "ConstantTimeSelect returns x if v is 1 and y if v is 0.
Its behavior is undefined if v takes any other value."
  {:added "1.0"
   :go "constantTimeSelect(v, x, y)"}
  [^Int v, ^Int x, ^Int y])

JOKER FUNC suffixarray.New has: 
;; (defn ^{:data ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3482662 <nil> byte}) data, :sa ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3482675 <nil> int}) sa} New
;;   "New creates a new Index for data.
;; Index creation time is O(N*log(N)) for N = len(data)."
;;   {:added "1.0"
;;    :go "new(data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{3482839 <nil> byte}) data])
;; 
JOKER FUNC sync.NewCond has: 
(defn ^{:nocopy noCopy, :l L, :notify notify, :checker checker} NewCond
  "NewCond returns a new Cond with Locker l."
  {:added "1.0"
   :go "newCond(l)"}
  [l])

JOKER FUNC syntax.Compile has: 
;; (defn ^[{:inst ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5765522 <nil> Inst}) Inst, :start ^Int Start, :numcap ^Int NumCap} Error] Compile
;;   "Compile compiles the regexp into a program to be executed.
;; The regexp should have been simplified already (returned from re.Simplify)."
;;   {:added "1.0"
;;    :go "compile(re)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5701347 Regexp}) re])
;; 
JOKER FUNC syntax.EmptyOpContext has: 
;; (defn ^ABEND042(cannot find typename syntax.uint8) EmptyOpContext
;;   "EmptyOpContext returns the zero-width assertions
;; satisfied at the position between the runes r1 and r2.
;; Passing r1 == -1 indicates that the position is
;; at the beginning of the text.
;; Passing r2 == -1 indicates that the position is
;; at the end of the text."
;;   {:added "1.0"
;;    :go "emptyOpContext(r1, r2)"}
;;   [r1, r2])
;; 
JOKER FUNC syntax.IsWordChar has: 
;; (defn ^ABEND042(cannot find typename syntax.bool) IsWordChar
;;   "IsWordChar reports whether r is consider a ``word character''
;; during the evaluation of the \b and \B zero-width assertions.
;; These assertions are ASCII-only: the word characters are [A-Za-z0-9_]."
;;   {:added "1.0"
;;    :go "isWordChar(r)"}
;;   [r])
;; 
JOKER FUNC syntax.Parse has: 
;; (defn ^[{:op Op, :flags Flags, :sub ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5706194 <nil> 0xc00024a140}) Sub, :sub0 ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5706241 0xc00024a780 0xc00024a7e0}) Sub0, :rune ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5706287 <nil> rune}) Rune, :rune0 ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5706353 0xc000252620 rune}) Rune0, :min ^Int Min, :max ^Int Max, :cap ^Int Cap, :name ^String Name} Error] Parse
;;   "Parse parses a regular expression string s, controlled by the specified
;; Flags, and returns a regular expression parse tree. The syntax is
;; described in the top-level comment."
;;   {:added "1.0"
;;    :go "parse(s, flags)"}
;;   [^String s, flags])
;; 
JOKER FUNC syscall.Accept has: 
(defn ^[nfd sa err] Accept
  {:added "1.0"
   :go "accept(fd)"}
  [^Int fd])

JOKER FUNC syscall.Accept4 has: 
(defn ^[nfd sa err] Accept4
  {:added "1.0"
   :go "accept4(fd, flags)"}
  [^Int fd, ^Int flags])

JOKER FUNC syscall.Access has: 
(defn ^err Access
  {:added "1.0"
   :go "access(path, mode)"}
  [^String path, mode])

JOKER FUNC syscall.Acct has: 
(defn ^err Acct
  {:added "1.0"
   :go "acct(path)"}
  [^String path])

JOKER FUNC syscall.Adjtimex has: 
;; (defn ^[state err] Adjtimex
;;   {:added "1.0"
;;    :go "adjtimex(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7428325 Timex}) buf])
;; 
JOKER FUNC syscall.AttachLsf has: 
;; (defn ^Error AttachLsf
;;   "Deprecated: Use golang.org/x/net/bpf instead."
;;   {:added "1.0"
;;    :go "attachLsf(fd, i)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7350887 <nil> SockFilter}) i])
;; 
JOKER FUNC syscall.Bind has: 
(defn ^err Bind
  {:added "1.0"
   :go "bind(fd, sa)"}
  [^Int fd, sa])

JOKER FUNC syscall.BindToDevice has: 
(defn ^err BindToDevice
  "BindToDevice binds the socket associated with fd to device."
  {:added "1.0"
   :go "bindToDevice(fd, device)"}
  [^Int fd, ^String device])

JOKER FUNC syscall.BytePtrFromString has: 
;; (defn ^[ABEND042(cannot find typename syscall.byte) Error] BytePtrFromString
;;   "BytePtrFromString returns a pointer to a NUL-terminated array of
;; bytes containing the text of s. If s contains a NUL byte at any
;; location, it returns (nil, EINVAL)."
;;   {:added "1.0"
;;    :go "bytePtrFromString(s)"}
;;   [^String s])
;; 
JOKER FUNC syscall.ByteSliceFromString has: 
;; (defn ^[[ABEND042(cannot find typename syscall.byte)] Error] ByteSliceFromString
;;   "ByteSliceFromString returns a NUL-terminated slice of bytes
;; containing the text of s. If s contains a NUL byte at any
;; location, it returns (nil, EINVAL)."
;;   {:added "1.0"
;;    :go "byteSliceFromString(s)"}
;;   [^String s])
;; 
JOKER FUNC syscall.Chdir has: 
(defn ^err Chdir
  {:added "1.0"
   :go "chdir(path)"}
  [^String path])

JOKER FUNC syscall.Chmod has: 
(defn ^err Chmod
  {:added "1.0"
   :go "chmod(path, mode)"}
  [^String path, mode])

JOKER FUNC syscall.Chown has: 
(defn ^err Chown
  {:added "1.0"
   :go "chown(path, uid, gid)"}
  [^String path, ^Int uid, ^Int gid])

JOKER FUNC syscall.Chroot has: 
(defn ^err Chroot
  {:added "1.0"
   :go "chroot(path)"}
  [^String path])

JOKER FUNC syscall.Clearenv has: 
;; (defn Clearenv
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])
;; 
JOKER FUNC syscall.Close has: 
(defn ^err Close
  {:added "1.0"
   :go "close(fd)"}
  [^Int fd])

JOKER FUNC syscall.CloseOnExec has: 
;; (defn CloseOnExec
;;   {:added "1.0"
;;    :go "closeOnExec(fd)"}
;;   [^Int fd])
;; 
JOKER FUNC syscall.CmsgLen has: 
(defn ^Int CmsgLen
  "CmsgLen returns the value to store in the Len field of the Cmsghdr
structure, taking into account any necessary alignment."
  {:added "1.0"
   :go "cmsgLen(datalen)"}
  [^Int datalen])

JOKER FUNC syscall.CmsgSpace has: 
(defn ^Int CmsgSpace
  "CmsgSpace returns the number of bytes an ancillary element with
payload of the passed data length occupies."
  {:added "1.0"
   :go "cmsgSpace(datalen)"}
  [^Int datalen])

JOKER FUNC syscall.Connect has: 
(defn ^err Connect
  {:added "1.0"
   :go "connect(fd, sa)"}
  [^Int fd, sa])

JOKER FUNC syscall.Creat has: 
(defn ^[fd err] Creat
  {:added "1.0"
   :go "creat(path, mode)"}
  [^String path, mode])

JOKER FUNC syscall.DetachLsf has: 
(defn ^Error DetachLsf
  "Deprecated: Use golang.org/x/net/bpf instead."
  {:added "1.0"
   :go "detachLsf(fd)"}
  [^Int fd])

JOKER FUNC syscall.Dup has: 
(defn ^[fd err] Dup
  {:added "1.0"
   :go "dup(oldfd)"}
  [^Int oldfd])

JOKER FUNC syscall.Dup2 has: 
(defn ^err Dup2
  {:added "1.0"
   :go "dup2(oldfd, newfd)"}
  [^Int oldfd, ^Int newfd])

JOKER FUNC syscall.Dup3 has: 
(defn ^err Dup3
  {:added "1.0"
   :go "dup3(oldfd, newfd, flags)"}
  [^Int oldfd, ^Int newfd, ^Int flags])

JOKER FUNC syscall.Environ has: 
(defn ^[String] Environ
  {:added "1.0"
   :go "environ()"}
  [])

JOKER FUNC syscall.EpollCreate has: 
(defn ^[fd err] EpollCreate
  {:added "1.0"
   :go "epollCreate(size)"}
  [^Int size])

JOKER FUNC syscall.EpollCreate1 has: 
(defn ^[fd err] EpollCreate1
  {:added "1.0"
   :go "epollCreate1(flag)"}
  [^Int flag])

JOKER FUNC syscall.EpollCtl has: 
;; (defn ^err EpollCtl
;;   {:added "1.0"
;;    :go "epollCtl(epfd, op, fd, event)"}
;;   [^Int epfd, ^Int op, ^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7430372 EpollEvent}) event])
;; 
JOKER FUNC syscall.EpollWait has: 
;; (defn ^[n err] EpollWait
;;   {:added "1.0"
;;    :go "epollWait(epfd, events, msec)"}
;;   [^Int epfd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7463093 <nil> EpollEvent}) events, ^Int msec])
;; 
JOKER FUNC syscall.Exec has: 
;; (defn ^err Exec
;;   "Exec invokes the execve(2) system call."
;;   {:added "1.0"
;;    :go "exec(argv0, argv, envv)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7549495 <nil> string}) argv, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7549510 <nil> string}) envv])
;; 
JOKER FUNC syscall.Exit has: 
;; (defn Exit
;;   {:added "1.0"
;;    :go "exit(code)"}
;;   [^Int code])
;; 
JOKER FUNC syscall.Faccessat has: 
(defn ^err Faccessat
  {:added "1.0"
   :go "faccessat(dirfd, path, mode, flags)"}
  [^Int dirfd, ^String path, mode, ^Int flags])

JOKER FUNC syscall.Fallocate has: 
(defn ^err Fallocate
  {:added "1.0"
   :go "fallocate(fd, mode, off, len)"}
  [^Int fd, mode, off, len])

JOKER FUNC syscall.Fchdir has: 
(defn ^err Fchdir
  {:added "1.0"
   :go "fchdir(fd)"}
  [^Int fd])

JOKER FUNC syscall.Fchmod has: 
(defn ^err Fchmod
  {:added "1.0"
   :go "fchmod(fd, mode)"}
  [^Int fd, mode])

JOKER FUNC syscall.Fchmodat has: 
(defn ^err Fchmodat
  {:added "1.0"
   :go "fchmodat(dirfd, path, mode, flags)"}
  [^Int dirfd, ^String path, mode, ^Int flags])

JOKER FUNC syscall.Fchown has: 
(defn ^err Fchown
  {:added "1.0"
   :go "fchown(fd, uid, gid)"}
  [^Int fd, ^Int uid, ^Int gid])

JOKER FUNC syscall.Fchownat has: 
(defn ^err Fchownat
  {:added "1.0"
   :go "fchownat(dirfd, path, uid, gid, flags)"}
  [^Int dirfd, ^String path, ^Int uid, ^Int gid, ^Int flags])

JOKER FUNC syscall.FcntlFlock has: 
;; (defn ^Error FcntlFlock
;;   "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command."
;;   {:added "1.0"
;;    :go "fcntlFlock(fd, cmd, lk)"}
;;   [fd, ^Int cmd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7526558 Flock_t}) lk])
;; 
JOKER FUNC syscall.Fdatasync has: 
(defn ^err Fdatasync
  {:added "1.0"
   :go "fdatasync(fd)"}
  [^Int fd])

JOKER FUNC syscall.Flock has: 
(defn ^err Flock
  {:added "1.0"
   :go "flock(fd, how)"}
  [^Int fd, ^Int how])

JOKER FUNC syscall.ForkExec has: 
;; (defn ^[pid err] ForkExec
;;   "Combination of fork and exec, careful to be thread safe."
;;   {:added "1.0"
;;    :go "forkExec(argv0, argv, attr)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7548829 <nil> string}) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7548844 ProcAttr}) attr])
;; 
JOKER FUNC syscall.Fstat has: 
;; (defn ^err Fstat
;;   {:added "1.0"
;;    :go "fstat(fd, stat)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7448856 Stat_t}) stat])
;; 
JOKER FUNC syscall.Fstatfs has: 
;; (defn ^err Fstatfs
;;   {:added "1.0"
;;    :go "fstatfs(fd, buf)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7449098 Statfs_t}) buf])
;; 
JOKER FUNC syscall.Fsync has: 
(defn ^err Fsync
  {:added "1.0"
   :go "fsync(fd)"}
  [^Int fd])

JOKER FUNC syscall.Ftruncate has: 
(defn ^err Ftruncate
  {:added "1.0"
   :go "ftruncate(fd, length)"}
  [^Int fd, length])

JOKER FUNC syscall.Futimes has: 
;; (defn ^err Futimes
;;   {:added "1.0"
;;    :go "futimes(fd, tv)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7366998 <nil> Timeval}) tv])
;; 
JOKER FUNC syscall.Futimesat has: 
;; (defn ^err Futimesat
;;   {:added "1.0"
;;    :go "futimesat(dirfd, path, tv)"}
;;   [^Int dirfd, ^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7366765 <nil> Timeval}) tv])
;; 
JOKER FUNC syscall.Getcwd has: 
;; (defn ^[n err] Getcwd
;;   {:added "1.0"
;;    :go "getcwd(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7425993 <nil> byte}) buf])
;; 
JOKER FUNC syscall.Getdents has: 
;; (defn ^[n err] Getdents
;;   {:added "1.0"
;;    :go "getdents(fd, buf)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7432666 <nil> byte}) buf])
;; 
JOKER FUNC syscall.Getegid has: 
(defn ^egid Getegid
  {:added "1.0"
   :go "getegid()"}
  [])

JOKER FUNC syscall.Getenv has: 
(defn ^[value found] Getenv
  {:added "1.0"
   :go "getenv(key)"}
  [^String key])

JOKER FUNC syscall.Geteuid has: 
(defn ^euid Geteuid
  {:added "1.0"
   :go "geteuid()"}
  [])

JOKER FUNC syscall.Getgid has: 
(defn ^gid Getgid
  {:added "1.0"
   :go "getgid()"}
  [])

JOKER FUNC syscall.Getgroups has: 
(defn ^[gids err] Getgroups
  {:added "1.0"
   :go "getgroups()"}
  [])

JOKER FUNC syscall.Getpagesize has: 
(defn ^Int Getpagesize
  {:added "1.0"
   :go "getpagesize()"}
  [])

JOKER FUNC syscall.Getpeername has: 
(defn ^[sa err] Getpeername
  {:added "1.0"
   :go "getpeername(fd)"}
  [^Int fd])

JOKER FUNC syscall.Getpgid has: 
(defn ^[pgid err] Getpgid
  {:added "1.0"
   :go "getpgid(pid)"}
  [^Int pid])

JOKER FUNC syscall.Getpgrp has: 
(defn ^pid Getpgrp
  {:added "1.0"
   :go "getpgrp()"}
  [])

JOKER FUNC syscall.Getpid has: 
(defn ^pid Getpid
  {:added "1.0"
   :go "getpid()"}
  [])

JOKER FUNC syscall.Getppid has: 
(defn ^ppid Getppid
  {:added "1.0"
   :go "getppid()"}
  [])

JOKER FUNC syscall.Getpriority has: 
(defn ^[prio err] Getpriority
  {:added "1.0"
   :go "getpriority(which, who)"}
  [^Int which, ^Int who])

JOKER FUNC syscall.Getrlimit has: 
;; (defn ^err Getrlimit
;;   {:added "1.0"
;;    :go "getrlimit(resource, rlim)"}
;;   [^Int resource, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7450096 Rlimit}) rlim])
;; 
JOKER FUNC syscall.Getrusage has: 
;; (defn ^err Getrusage
;;   {:added "1.0"
;;    :go "getrusage(who, rusage)"}
;;   [^Int who, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7433894 Rusage}) rusage])
;; 
JOKER FUNC syscall.Getsockname has: 
(defn ^[sa err] Getsockname
  {:added "1.0"
   :go "getsockname(fd)"}
  [^Int fd])

JOKER FUNC syscall.GetsockoptICMPv6Filter has: 
;; (defn ^[{:data ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7397187 0xc0020014c0 uint32}) Data} Error] GetsockoptICMPv6Filter
;;   {:added "1.0"
;;    :go "getsockoptICMPv6Filter(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])
;; 
JOKER FUNC syscall.GetsockoptIPMreq has: 
;; (defn ^[{:multiaddr ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7396396 0xc002000820 byte}) Multiaddr, :interface ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7396429 0xc0020008c0 byte}) Interface} Error] GetsockoptIPMreq
;;   {:added "1.0"
;;    :go "getsockoptIPMreq(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])
;; 
JOKER FUNC syscall.GetsockoptIPMreqn has: 
;; (defn ^[{:multiaddr ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7396487 0xc0020009a0 byte}) Multiaddr, :address ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7396520 0xc002000a40 byte}) Address, :ifindex Ifindex} Error] GetsockoptIPMreqn
;;   {:added "1.0"
;;    :go "getsockoptIPMreqn(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])
;; 
JOKER FUNC syscall.GetsockoptIPv6MTUInfo has: 
(defn ^[{:addr Addr, :mtu Mtu} Error] GetsockoptIPv6MTUInfo
  {:added "1.0"
   :go "getsockoptIPv6MTUInfo(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPv6Mreq has: 
;; (defn ^[{:multiaddr ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7396596 0xc002000b80 byte}) Multiaddr, :interface Interface} Error] GetsockoptIPv6Mreq
;;   {:added "1.0"
;;    :go "getsockoptIPv6Mreq(fd, level, opt)"}
;;   [^Int fd, ^Int level, ^Int opt])
;; 
JOKER FUNC syscall.GetsockoptInet4Addr has: 
(defn ^[value err] GetsockoptInet4Addr
  {:added "1.0"
   :go "getsockoptInet4Addr(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptInt has: 
(defn ^[value err] GetsockoptInt
  {:added "1.0"
   :go "getsockoptInt(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptUcred has: 
(defn ^[{:pid Pid, :uid Uid, :gid Gid} Error] GetsockoptUcred
  {:added "1.0"
   :go "getsockoptUcred(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.Gettid has: 
(defn ^tid Gettid
  {:added "1.0"
   :go "gettid()"}
  [])

JOKER FUNC syscall.Gettimeofday has: 
;; (defn ^err Gettimeofday
;;   {:added "1.0"
;;    :go "gettimeofday(tv)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7356208 Timeval}) tv])
;; 
JOKER FUNC syscall.Getuid has: 
(defn ^uid Getuid
  {:added "1.0"
   :go "getuid()"}
  [])

JOKER FUNC syscall.Getwd has: 
(defn ^[wd err] Getwd
  {:added "1.0"
   :go "getwd()"}
  [])

JOKER FUNC syscall.Getxattr has: 
;; (defn ^[sz err] Getxattr
;;   {:added "1.0"
;;    :go "getxattr(path, attr, dest)"}
;;   [^String path, ^String attr, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7434333 <nil> byte}) dest])
;; 
JOKER FUNC syscall.InotifyAddWatch has: 
(defn ^[watchdesc err] InotifyAddWatch
  {:added "1.0"
   :go "inotifyAddWatch(fd, pathname, mask)"}
  [^Int fd, ^String pathname, mask])

JOKER FUNC syscall.InotifyInit has: 
(defn ^[fd err] InotifyInit
  {:added "1.0"
   :go "inotifyInit()"}
  [])

JOKER FUNC syscall.InotifyInit1 has: 
(defn ^[fd err] InotifyInit1
  {:added "1.0"
   :go "inotifyInit1(flags)"}
  [^Int flags])

JOKER FUNC syscall.InotifyRmWatch has: 
(defn ^[success err] InotifyRmWatch
  {:added "1.0"
   :go "inotifyRmWatch(fd, watchdesc)"}
  [^Int fd, watchdesc])

JOKER FUNC syscall.Ioperm has: 
(defn ^err Ioperm
  {:added "1.0"
   :go "ioperm(from, num, on)"}
  [^Int from, ^Int num, ^Int on])

JOKER FUNC syscall.Iopl has: 
(defn ^err Iopl
  {:added "1.0"
   :go "iopl(level)"}
  [^Int level])

JOKER FUNC syscall.Kill has: 
(defn ^err Kill
  {:added "1.0"
   :go "kill(pid, sig)"}
  [^Int pid, sig])

JOKER FUNC syscall.Klogctl has: 
;; (defn ^[n err] Klogctl
;;   {:added "1.0"
;;    :go "klogctl(typ, buf)"}
;;   [^Int typ, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7436108 <nil> byte}) buf])
;; 
JOKER FUNC syscall.Lchown has: 
(defn ^err Lchown
  {:added "1.0"
   :go "lchown(path, uid, gid)"}
  [^String path, ^Int uid, ^Int gid])

JOKER FUNC syscall.Link has: 
(defn ^err Link
  {:added "1.0"
   :go "link(oldpath, newpath)"}
  [^String oldpath, ^String newpath])

JOKER FUNC syscall.Listen has: 
(defn ^err Listen
  {:added "1.0"
   :go "listen(s, n)"}
  [^Int s, ^Int n])

JOKER FUNC syscall.Listxattr has: 
;; (defn ^[sz err] Listxattr
;;   {:added "1.0"
;;    :go "listxattr(path, dest)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7436498 <nil> byte}) dest])
;; 
JOKER FUNC syscall.LsfJump has: 
(defn ^{:code ^Int Code, :jt Jt, :jf Jf, :k K} LsfJump
  "Deprecated: Use golang.org/x/net/bpf instead."
  {:added "1.0"
   :go "lsfJump(code, k, jt, jf)"}
  [^Int code, ^Int k, ^Int jt, ^Int jf])

JOKER FUNC syscall.LsfSocket has: 
(defn ^[Int Error] LsfSocket
  "Deprecated: Use golang.org/x/net/bpf instead."
  {:added "1.0"
   :go "lsfSocket(ifindex, proto)"}
  [^Int ifindex, ^Int proto])

JOKER FUNC syscall.LsfStmt has: 
(defn ^{:code ^Int Code, :jt Jt, :jf Jf, :k K} LsfStmt
  "Deprecated: Use golang.org/x/net/bpf instead."
  {:added "1.0"
   :go "lsfStmt(code, k)"}
  [^Int code, ^Int k])

JOKER FUNC syscall.Lstat has: 
;; (defn ^err Lstat
;;   {:added "1.0"
;;    :go "lstat(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7451748 Stat_t}) stat])
;; 
JOKER FUNC syscall.Madvise has: 
;; (defn ^err Madvise
;;   {:added "1.0"
;;    :go "madvise(b, advice)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7446589 <nil> byte}) b, ^Int advice])
;; 
JOKER FUNC syscall.Mkdir has: 
(defn ^err Mkdir
  {:added "1.0"
   :go "mkdir(path, mode)"}
  [^String path, mode])

JOKER FUNC syscall.Mkdirat has: 
(defn ^err Mkdirat
  {:added "1.0"
   :go "mkdirat(dirfd, path, mode)"}
  [^Int dirfd, ^String path, mode])

JOKER FUNC syscall.Mkfifo has: 
(defn ^err Mkfifo
  {:added "1.0"
   :go "mkfifo(path, mode)"}
  [^String path, mode])

JOKER FUNC syscall.Mknod has: 
(defn ^err Mknod
  {:added "1.0"
   :go "mknod(path, mode, dev)"}
  [^String path, mode, ^Int dev])

JOKER FUNC syscall.Mknodat has: 
(defn ^err Mknodat
  {:added "1.0"
   :go "mknodat(dirfd, path, mode, dev)"}
  [^Int dirfd, ^String path, mode, ^Int dev])

JOKER FUNC syscall.Mlock has: 
;; (defn ^err Mlock
;;   {:added "1.0"
;;    :go "mlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7447307 <nil> byte}) b])
;; 
JOKER FUNC syscall.Mlockall has: 
(defn ^err Mlockall
  {:added "1.0"
   :go "mlockall(flags)"}
  [^Int flags])

JOKER FUNC syscall.Mmap has: 
(defn ^[data err] Mmap
  {:added "1.0"
   :go "mmap(fd, offset, length, prot, flags)"}
  [^Int fd, offset, ^Int length, ^Int prot, ^Int flags])

JOKER FUNC syscall.Mount has: 
(defn ^err Mount
  {:added "1.0"
   :go "mount(source, target, fstype, flags, data)"}
  [^String source, ^String target, ^String fstype, flags, ^String data])

JOKER FUNC syscall.Mprotect has: 
;; (defn ^err Mprotect
;;   {:added "1.0"
;;    :go "mprotect(b, prot)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7446951 <nil> byte}) b, ^Int prot])
;; 
JOKER FUNC syscall.Munlock has: 
;; (defn ^err Munlock
;;   {:added "1.0"
;;    :go "munlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7447640 <nil> byte}) b])
;; 
JOKER FUNC syscall.Munlockall has: 
(defn ^err Munlockall
  {:added "1.0"
   :go "munlockall()"}
  [])

JOKER FUNC syscall.Munmap has: 
;; (defn ^err Munmap
;;   {:added "1.0"
;;    :go "munmap(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7388271 <nil> byte}) b])
;; 
JOKER FUNC syscall.Nanosleep has: 
;; (defn ^err Nanosleep
;;   {:added "1.0"
;;    :go "nanosleep(time, leftover)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7437717 Timespec}) time, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7437737 Timespec}) leftover])
;; 
JOKER FUNC syscall.NetlinkRIB has: 
;; (defn ^[[ABEND042(cannot find typename syscall.byte)] Error] NetlinkRIB
;;   "NetlinkRIB returns routing information base, as known as RIB, which
;; consists of network facility information, states and parameters."
;;   {:added "1.0"
;;    :go "netlinkRIB(proto, family)"}
;;   [^Int proto, ^Int family])
;; 
JOKER FUNC syscall.NsecToTimespec has: 
(defn ^{:sec Sec, :nsec Nsec} NsecToTimespec
  "NsecToTimespec takes a number of nanoseconds since the Unix epoch
and returns the corresponding Timespec value."
  {:added "1.0"
   :go "nsecToTimespec(nsec)"}
  [nsec])

JOKER FUNC syscall.NsecToTimeval has: 
(defn ^{:sec Sec, :usec Usec} NsecToTimeval
  "NsecToTimeval takes a number of nanoseconds since the Unix epoch
and returns the corresponding Timeval value."
  {:added "1.0"
   :go "nsecToTimeval(nsec)"}
  [nsec])

JOKER FUNC syscall.Open has: 
(defn ^[fd err] Open
  {:added "1.0"
   :go "open(path, mode, perm)"}
  [^String path, ^Int mode, perm])

JOKER FUNC syscall.Openat has: 
(defn ^[fd err] Openat
  {:added "1.0"
   :go "openat(dirfd, path, flags, mode)"}
  [^Int dirfd, ^String path, ^Int flags, mode])

JOKER FUNC syscall.ParseDirent has: 
;; (defn ^[consumed count newnames] ParseDirent
;;   "ParseDirent parses up to max directory entries in buf,
;; appending the names to names. It returns the number of
;; bytes consumed from buf, the number of entries added
;; to names, and the new names slice."
;;   {:added "1.0"
;;    :go "parseDirent(buf, max, names)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7360210 <nil> byte}) buf, ^Int max, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7360233 <nil> string}) names])
;; 
JOKER FUNC syscall.ParseNetlinkMessage has: 
;; (defn ^[[{:header Header, :data ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7391406 <nil> byte}) Data}] Error] ParseNetlinkMessage
;;   "ParseNetlinkMessage parses b as an array of netlink messages and
;; returns the slice containing the NetlinkMessage structures."
;;   {:added "1.0"
;;    :go "parseNetlinkMessage(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7391574 <nil> byte}) b])
;; 
JOKER FUNC syscall.ParseNetlinkRouteAttr has: 
;; (defn ^[[{:attr Attr, :value ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7392273 <nil> byte}) Value}] Error] ParseNetlinkRouteAttr
;;   "ParseNetlinkRouteAttr parses m's payload as an array of netlink
;; route attributes and returns the slice containing the
;; NetlinkRouteAttr structures."
;;   {:added "1.0"
;;    :go "parseNetlinkRouteAttr(m)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7392468 NetlinkMessage}) m])
;; 
JOKER FUNC syscall.ParseSocketControlMessage has: 
;; (defn ^[[{:header Header, :data ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7419983 <nil> byte}) Data}] Error] ParseSocketControlMessage
;;   "ParseSocketControlMessage parses b as an array of socket control
;; messages."
;;   {:added "1.0"
;;    :go "parseSocketControlMessage(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7420107 <nil> byte}) b])
;; 
JOKER FUNC syscall.ParseUnixCredentials has: 
;; (defn ^[{:pid Pid, :uid Uid, :gid Gid} Error] ParseUnixCredentials
;;   "ParseUnixCredentials decodes a socket control message that contains
;; credentials in a Ucred structure. To receive such a message, the
;; SO_PASSCRED option must be enabled on the socket."
;;   {:added "1.0"
;;    :go "parseUnixCredentials(m)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7525704 SocketControlMessage}) m])
;; 
JOKER FUNC syscall.ParseUnixRights has: 
;; (defn ^[[Int] Error] ParseUnixRights
;;   "ParseUnixRights decodes a socket control message that contains an
;; integer array of open file descriptors from another process."
;;   {:added "1.0"
;;    :go "parseUnixRights(m)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7421337 SocketControlMessage}) m])
;; 
JOKER FUNC syscall.Pause has: 
(defn ^err Pause
  {:added "1.0"
   :go "pause()"}
  [])

JOKER FUNC syscall.Pipe has: 
;; (defn ^err Pipe
;;   {:added "1.0"
;;    :go "pipe(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7356731 <nil> int}) p])
;; 
JOKER FUNC syscall.Pipe2 has: 
;; (defn ^err Pipe2
;;   {:added "1.0"
;;    :go "pipe2(p, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7356938 <nil> int}) p, ^Int flags])
;; 
JOKER FUNC syscall.PivotRoot has: 
(defn ^err PivotRoot
  {:added "1.0"
   :go "pivotRoot(newroot, putold)"}
  [^String newroot, ^String putold])

JOKER FUNC syscall.Pread has: 
;; (defn ^[n err] Pread
;;   {:added "1.0"
;;    :go "pread(fd, p, offset)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7452083 <nil> byte}) p, offset])
;; 
JOKER FUNC syscall.PtraceAttach has: 
(defn ^err PtraceAttach
  {:added "1.0"
   :go "ptraceAttach(pid)"}
  [^Int pid])

JOKER FUNC syscall.PtraceCont has: 
(defn ^err PtraceCont
  {:added "1.0"
   :go "ptraceCont(pid, signal)"}
  [^Int pid, ^Int signal])

JOKER FUNC syscall.PtraceDetach has: 
(defn ^err PtraceDetach
  {:added "1.0"
   :go "ptraceDetach(pid)"}
  [^Int pid])

JOKER FUNC syscall.PtraceGetEventMsg has: 
(defn ^[msg err] PtraceGetEventMsg
  {:added "1.0"
   :go "ptraceGetEventMsg(pid)"}
  [^Int pid])

JOKER FUNC syscall.PtraceGetRegs has: 
;; (defn ^err PtraceGetRegs
;;   {:added "1.0"
;;    :go "ptraceGetRegs(pid, regsout)"}
;;   [^Int pid, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7381864 PtraceRegs}) regsout])
;; 
JOKER FUNC syscall.PtracePeekData has: 
;; (defn ^[count err] PtracePeekData
;;   {:added "1.0"
;;    :go "ptracePeekData(pid, addr, out)"}
;;   [^Int pid, addr, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7380188 <nil> byte}) out])
;; 
JOKER FUNC syscall.PtracePeekText has: 
;; (defn ^[count err] PtracePeekText
;;   {:added "1.0"
;;    :go "ptracePeekText(pid, addr, out)"}
;;   [^Int pid, addr, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7380053 <nil> byte}) out])
;; 
JOKER FUNC syscall.PtracePokeData has: 
;; (defn ^[count err] PtracePokeData
;;   {:added "1.0"
;;    :go "ptracePokeData(pid, addr, data)"}
;;   [^Int pid, addr, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7381722 <nil> byte}) data])
;; 
JOKER FUNC syscall.PtracePokeText has: 
;; (defn ^[count err] PtracePokeText
;;   {:added "1.0"
;;    :go "ptracePokeText(pid, addr, data)"}
;;   [^Int pid, addr, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7381568 <nil> byte}) data])
;; 
JOKER FUNC syscall.PtraceSetOptions has: 
(defn ^err PtraceSetOptions
  {:added "1.0"
   :go "ptraceSetOptions(pid, options)"}
  [^Int pid, ^Int options])

JOKER FUNC syscall.PtraceSetRegs has: 
;; (defn ^err PtraceSetRegs
;;   {:added "1.0"
;;    :go "ptraceSetRegs(pid, regs)"}
;;   [^Int pid, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7382000 PtraceRegs}) regs])
;; 
JOKER FUNC syscall.PtraceSingleStep has: 
(defn ^err PtraceSingleStep
  {:added "1.0"
   :go "ptraceSingleStep(pid)"}
  [^Int pid])

JOKER FUNC syscall.PtraceSyscall has: 
(defn ^err PtraceSyscall
  {:added "1.0"
   :go "ptraceSyscall(pid, signal)"}
  [^Int pid, ^Int signal])

JOKER FUNC syscall.Pwrite has: 
;; (defn ^[n err] Pwrite
;;   {:added "1.0"
;;    :go "pwrite(fd, p, offset)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7452494 <nil> byte}) p, offset])
;; 
JOKER FUNC syscall.RawSyscall has: 
(defn ^[r1 r2 err] RawSyscall
  {:added "1.0"
   :go "rawSyscall(trap, a1, a2, a3)"}
  [trap, a1, a2, a3])

JOKER FUNC syscall.RawSyscall6 has: 
(defn ^[r1 r2 err] RawSyscall6
  {:added "1.0"
   :go "rawSyscall6(trap, a1, a2, a3, a4, a5, a6)"}
  [trap, a1, a2, a3, a4, a5, a6])

JOKER FUNC syscall.Read has: 
;; (defn ^[n err] Read
;;   {:added "1.0"
;;    :go "read(fd, p)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7554059 <nil> byte}) p])
;; 
JOKER FUNC syscall.ReadDirent has: 
;; (defn ^[n err] ReadDirent
;;   {:added "1.0"
;;    :go "readDirent(fd, buf)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7383083 <nil> byte}) buf])
;; 
JOKER FUNC syscall.Readlink has: 
;; (defn ^[n err] Readlink
;;   {:added "1.0"
;;    :go "readlink(path, buf)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7365165 <nil> byte}) buf])
;; 
JOKER FUNC syscall.Reboot has: 
(defn ^err Reboot
  {:added "1.0"
   :go "reboot(cmd)"}
  [^Int cmd])

JOKER FUNC syscall.Recvfrom has: 
;; (defn ^[n from err] Recvfrom
;;   {:added "1.0"
;;    :go "recvfrom(fd, p, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7555829 <nil> byte}) p, ^Int flags])
;; 
JOKER FUNC syscall.Recvmsg has: 
;; (defn ^[n oobn recvflags from err] Recvmsg
;;   {:added "1.0"
;;    :go "recvmsg(fd, p, oob, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7376660 <nil> byte}) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7376660 <nil> byte}) oob, ^Int flags])
;; 
JOKER FUNC syscall.Removexattr has: 
(defn ^err Removexattr
  {:added "1.0"
   :go "removexattr(path, attr)"}
  [^String path, ^String attr])

JOKER FUNC syscall.Rename has: 
(defn ^err Rename
  {:added "1.0"
   :go "rename(oldpath, newpath)"}
  [^String oldpath, ^String newpath])

JOKER FUNC syscall.Renameat has: 
(defn ^err Renameat
  {:added "1.0"
   :go "renameat(olddirfd, oldpath, newdirfd, newpath)"}
  [^Int olddirfd, ^String oldpath, ^Int newdirfd, ^String newpath])

JOKER FUNC syscall.Rmdir has: 
(defn ^Error Rmdir
  {:added "1.0"
   :go "rmdir(path)"}
  [^String path])

JOKER FUNC syscall.Seek has: 
(defn ^[off err] Seek
  {:added "1.0"
   :go "seek(fd, offset, whence)"}
  [^Int fd, offset, ^Int whence])

JOKER FUNC syscall.Select has: 
;; (defn ^[n err] Select
;;   {:added "1.0"
;;    :go "select(nfd, r, w, e, timeout)"}
;;   [^Int nfd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7453188 FdSet}) r, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7453198 FdSet}) w, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7453208 FdSet}) e, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7453224 Timeval}) timeout])
;; 
JOKER FUNC syscall.Sendfile has: 
;; (defn ^[written err] Sendfile
;;   {:added "1.0"
;;    :go "sendfile(outfd, infd, offset, count)"}
;;   [^Int outfd, ^Int infd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7558012 int64}) offset, ^Int count])
;; 
JOKER FUNC syscall.Sendmsg has: 
;; (defn ^err Sendmsg
;;   {:added "1.0"
;;    :go "sendmsg(fd, p, oob, to, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7377606 <nil> byte}) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7377606 <nil> byte}) oob, to, ^Int flags])
;; 
JOKER FUNC syscall.SendmsgN has: 
;; (defn ^[n err] SendmsgN
;;   {:added "1.0"
;;    :go "sendmsgN(fd, p, oob, to, flags)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7377734 <nil> byte}) p, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7377734 <nil> byte}) oob, to, ^Int flags])
;; 
JOKER FUNC syscall.Sendto has: 
;; (defn ^err Sendto
;;   {:added "1.0"
;;    :go "sendto(fd, p, flags, to)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7556125 <nil> byte}) p, ^Int flags, to])
;; 
JOKER FUNC syscall.SetLsfPromisc has: 
(defn ^Error SetLsfPromisc
  "Deprecated: Use golang.org/x/net/bpf instead."
  {:added "1.0"
   :go "setLsfPromisc(name, m)"}
  [^String name, m])

JOKER FUNC syscall.SetNonblock has: 
(defn ^err SetNonblock
  {:added "1.0"
   :go "setNonblock(fd, nonblocking)"}
  [^Int fd, nonblocking])

JOKER FUNC syscall.Setdomainname has: 
;; (defn ^err Setdomainname
;;   {:added "1.0"
;;    :go "setdomainname(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7440276 <nil> byte}) p])
;; 
JOKER FUNC syscall.Setenv has: 
(defn ^Error Setenv
  {:added "1.0"
   :go "setenv(key, value)"}
  [^String key, ^String value])

JOKER FUNC syscall.Setfsgid has: 
(defn ^err Setfsgid
  {:added "1.0"
   :go "setfsgid(gid)"}
  [^Int gid])

JOKER FUNC syscall.Setfsuid has: 
(defn ^err Setfsuid
  {:added "1.0"
   :go "setfsuid(uid)"}
  [^Int uid])

JOKER FUNC syscall.Setgid has: 
(defn ^err Setgid
  {:added "1.0"
   :go "setgid(gid)"}
  [^Int gid])

JOKER FUNC syscall.Setgroups has: 
;; (defn ^err Setgroups
;;   {:added "1.0"
;;    :go "setgroups(gids)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7367984 <nil> int}) gids])
;; 
JOKER FUNC syscall.Sethostname has: 
;; (defn ^err Sethostname
;;   {:added "1.0"
;;    :go "sethostname(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7440621 <nil> byte}) p])
;; 
JOKER FUNC syscall.Setpgid has: 
(defn ^err Setpgid
  {:added "1.0"
   :go "setpgid(pid, pgid)"}
  [^Int pid, ^Int pgid])

JOKER FUNC syscall.Setpriority has: 
(defn ^err Setpriority
  {:added "1.0"
   :go "setpriority(which, who, prio)"}
  [^Int which, ^Int who, ^Int prio])

JOKER FUNC syscall.Setregid has: 
(defn ^err Setregid
  {:added "1.0"
   :go "setregid(rgid, egid)"}
  [^Int rgid, ^Int egid])

JOKER FUNC syscall.Setresgid has: 
(defn ^err Setresgid
  {:added "1.0"
   :go "setresgid(rgid, egid, sgid)"}
  [^Int rgid, ^Int egid, ^Int sgid])

JOKER FUNC syscall.Setresuid has: 
(defn ^err Setresuid
  {:added "1.0"
   :go "setresuid(ruid, euid, suid)"}
  [^Int ruid, ^Int euid, ^Int suid])

JOKER FUNC syscall.Setreuid has: 
(defn ^err Setreuid
  {:added "1.0"
   :go "setreuid(ruid, euid)"}
  [^Int ruid, ^Int euid])

JOKER FUNC syscall.Setrlimit has: 
;; (defn ^err Setrlimit
;;   {:added "1.0"
;;    :go "setrlimit(resource, rlim)"}
;;   [^Int resource, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7455096 Rlimit}) rlim])
;; 
JOKER FUNC syscall.Setsid has: 
(defn ^[pid err] Setsid
  {:added "1.0"
   :go "setsid()"}
  [])

JOKER FUNC syscall.SetsockoptByte has: 
(defn ^err SetsockoptByte
  {:added "1.0"
   :go "setsockoptByte(fd, level, opt, value)"}
  [^Int fd, ^Int level, ^Int opt, value])

JOKER FUNC syscall.SetsockoptICMPv6Filter has: 
;; (defn ^Error SetsockoptICMPv6Filter
;;   {:added "1.0"
;;    :go "setsockoptICMPv6Filter(fd, level, opt, filter)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7557043 ICMPv6Filter}) filter])
;; 
JOKER FUNC syscall.SetsockoptIPMreq has: 
;; (defn ^err SetsockoptIPMreq
;;   {:added "1.0"
;;    :go "setsockoptIPMreq(fd, level, opt, mreq)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7556741 IPMreq}) mreq])
;; 
JOKER FUNC syscall.SetsockoptIPMreqn has: 
;; (defn ^err SetsockoptIPMreqn
;;   {:added "1.0"
;;    :go "setsockoptIPMreqn(fd, level, opt, mreq)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7376526 IPMreqn}) mreq])
;; 
JOKER FUNC syscall.SetsockoptIPv6Mreq has: 
;; (defn ^err SetsockoptIPv6Mreq
;;   {:added "1.0"
;;    :go "setsockoptIPv6Mreq(fd, level, opt, mreq)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7556887 IPv6Mreq}) mreq])
;; 
JOKER FUNC syscall.SetsockoptInet4Addr has: 
;; (defn ^err SetsockoptInet4Addr
;;   {:added "1.0"
;;    :go "setsockoptInet4Addr(fd, level, opt, value)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7556603 0xc0022abb60 byte}) value])
;; 
JOKER FUNC syscall.SetsockoptInt has: 
(defn ^err SetsockoptInt
  {:added "1.0"
   :go "setsockoptInt(fd, level, opt, value)"}
  [^Int fd, ^Int level, ^Int opt, ^Int value])

JOKER FUNC syscall.SetsockoptLinger has: 
;; (defn ^err SetsockoptLinger
;;   {:added "1.0"
;;    :go "setsockoptLinger(fd, level, opt, l)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7557192 Linger}) l])
;; 
JOKER FUNC syscall.SetsockoptString has: 
(defn ^err SetsockoptString
  {:added "1.0"
   :go "setsockoptString(fd, level, opt, s)"}
  [^Int fd, ^Int level, ^Int opt, ^String s])

JOKER FUNC syscall.SetsockoptTimeval has: 
;; (defn ^err SetsockoptTimeval
;;   {:added "1.0"
;;    :go "setsockoptTimeval(fd, level, opt, tv)"}
;;   [^Int fd, ^Int level, ^Int opt, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7557484 Timeval}) tv])
;; 
JOKER FUNC syscall.Settimeofday has: 
;; (defn ^err Settimeofday
;;   {:added "1.0"
;;    :go "settimeofday(tv)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7441409 Timeval}) tv])
;; 
JOKER FUNC syscall.Setuid has: 
(defn ^err Setuid
  {:added "1.0"
   :go "setuid(uid)"}
  [^Int uid])

JOKER FUNC syscall.Setxattr has: 
;; (defn ^err Setxattr
;;   {:added "1.0"
;;    :go "setxattr(path, attr, data, flags)"}
;;   [^String path, ^String attr, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7441929 <nil> byte}) data, ^Int flags])
;; 
JOKER FUNC syscall.Shutdown has: 
(defn ^err Shutdown
  {:added "1.0"
   :go "shutdown(fd, how)"}
  [^Int fd, ^Int how])

JOKER FUNC syscall.SlicePtrFromStrings has: 
;; (defn ^[[ABEND042(cannot find typename syscall.byte)] Error] SlicePtrFromStrings
;;   "SlicePtrFromStrings converts a slice of strings to a slice of
;; pointers to NUL-terminated byte arrays. If any string contains
;; a NUL byte, it returns (nil, EINVAL)."
;;   {:added "1.0"
;;    :go "slicePtrFromStrings(ss)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7545566 <nil> string}) ss])
;; 
JOKER FUNC syscall.Socket has: 
(defn ^[fd err] Socket
  {:added "1.0"
   :go "socket(domain, typ, proto)"}
  [^Int domain, ^Int typ, ^Int proto])

JOKER FUNC syscall.Socketpair has: 
(defn ^[fd err] Socketpair
  {:added "1.0"
   :go "socketpair(domain, typ, proto)"}
  [^Int domain, ^Int typ, ^Int proto])

JOKER FUNC syscall.Splice has: 
;; (defn ^[n err] Splice
;;   {:added "1.0"
;;    :go "splice(rfd, roff, wfd, woff, len, flags)"}
;;   [^Int rfd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7455811 int64}) roff, ^Int wfd, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7455833 int64}) woff, ^Int len, ^Int flags])
;; 
JOKER FUNC syscall.StartProcess has: 
;; (defn ^[pid handle err] StartProcess
;;   "StartProcess wraps ForkExec for package os."
;;   {:added "1.0"
;;    :go "startProcess(argv0, argv, attr)"}
;;   [^String argv0, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7549001 <nil> string}) argv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7549016 ProcAttr}) attr])
;; 
JOKER FUNC syscall.Stat has: 
;; (defn ^err Stat
;;   {:added "1.0"
;;    :go "stat(path, stat)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7356061 Stat_t}) stat])
;; 
JOKER FUNC syscall.Statfs has: 
;; (defn ^err Statfs
;;   {:added "1.0"
;;    :go "statfs(path, buf)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7456198 Statfs_t}) buf])
;; 
JOKER FUNC syscall.StringBytePtr has: 
;; (defn ^ABEND042(cannot find typename syscall.byte) StringBytePtr
;;   "StringBytePtr returns a pointer to a NUL-terminated array of bytes.
;; If s contains a NUL byte this function panics instead of returning
;; an error.
;; 
;; Deprecated: Use BytePtrFromString instead."
;;   {:added "1.0"
;;    :go "stringBytePtr(s)"}
;;   [^String s])
;; 
JOKER FUNC syscall.StringByteSlice has: 
;; (defn ^[ABEND042(cannot find typename syscall.byte)] StringByteSlice
;;   "StringByteSlice converts a string to a NUL-terminated []byte,
;; If s contains a NUL byte this function panics instead of
;; returning an error.
;; 
;; Deprecated: Use ByteSliceFromString instead."
;;   {:added "1.0"
;;    :go "stringByteSlice(s)"}
;;   [^String s])
;; 
JOKER FUNC syscall.StringSlicePtr has: 
;; (defn ^[ABEND042(cannot find typename syscall.byte)] StringSlicePtr
;;   "StringSlicePtr converts a slice of strings to a slice of pointers
;; to NUL-terminated byte arrays. If any string contains a NUL byte
;; this function panics instead of returning an error.
;; 
;; Deprecated: Use SlicePtrFromStrings instead."
;;   {:added "1.0"
;;    :go "stringSlicePtr(ss)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7545215 <nil> string}) ss])
;; 
JOKER FUNC syscall.Symlink has: 
(defn ^err Symlink
  {:added "1.0"
   :go "symlink(oldpath, newpath)"}
  [^String oldpath, ^String newpath])

JOKER FUNC syscall.Sync has: 
;; (defn Sync
;;   {:added "1.0"
;;    :go "sync()"}
;;   [])
;; 
JOKER FUNC syscall.SyncFileRange has: 
(defn ^err SyncFileRange
  {:added "1.0"
   :go "syncFileRange(fd, off, n, flags)"}
  [^Int fd, off, n, ^Int flags])

JOKER FUNC syscall.Syscall has: 
(defn ^[r1 r2 err] Syscall
  {:added "1.0"
   :go "syscall(trap, a1, a2, a3)"}
  [trap, a1, a2, a3])

JOKER FUNC syscall.Syscall6 has: 
(defn ^[r1 r2 err] Syscall6
  {:added "1.0"
   :go "syscall6(trap, a1, a2, a3, a4, a5, a6)"}
  [trap, a1, a2, a3, a4, a5, a6])

JOKER FUNC syscall.Sysinfo has: 
;; (defn ^err Sysinfo
;;   {:added "1.0"
;;    :go "sysinfo(info)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7442644 Sysinfo_t}) info])
;; 
JOKER FUNC syscall.Tee has: 
(defn ^[n err] Tee
  {:added "1.0"
   :go "tee(rfd, wfd, len, flags)"}
  [^Int rfd, ^Int wfd, ^Int len, ^Int flags])

JOKER FUNC syscall.Tgkill has: 
(defn ^err Tgkill
  {:added "1.0"
   :go "tgkill(tgid, tid, sig)"}
  [^Int tgid, ^Int tid, sig])

JOKER FUNC syscall.Time has: 
;; (defn ^[tt err] Time
;;   {:added "1.0"
;;    :go "time(t)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7356321 Time_t}) t])
;; 
JOKER FUNC syscall.Times has: 
;; (defn ^[ticks err] Times
;;   {:added "1.0"
;;    :go "times(tms)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7443421 Tms}) tms])
;; 
JOKER FUNC syscall.TimespecToNsec has: 
;; (defn ^ABEND042(cannot find typename syscall.int64) TimespecToNsec
;;   "TimespecToNsec converts a Timespec value into a number of
;; nanoseconds since the Unix epoch."
;;   {:added "1.0"
;;    :go "timespecToNsec(ts)"}
;;   [ts])
;; 
JOKER FUNC syscall.TimevalToNsec has: 
;; (defn ^ABEND042(cannot find typename syscall.int64) TimevalToNsec
;;   "TimevalToNsec converts a Timeval value into a number of nanoseconds
;; since the Unix epoch."
;;   {:added "1.0"
;;    :go "timevalToNsec(tv)"}
;;   [tv])
;; 
JOKER FUNC syscall.Truncate has: 
(defn ^err Truncate
  {:added "1.0"
   :go "truncate(path, length)"}
  [^String path, length])

JOKER FUNC syscall.Umask has: 
(defn ^oldmask Umask
  {:added "1.0"
   :go "umask(mask)"}
  [^Int mask])

JOKER FUNC syscall.Uname has: 
;; (defn ^err Uname
;;   {:added "1.0"
;;    :go "uname(buf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7443872 Utsname}) buf])
;; 
JOKER FUNC syscall.UnixCredentials has: 
;; (defn ^[ABEND042(cannot find typename syscall.byte)] UnixCredentials
;;   "UnixCredentials encodes credentials into a socket control message
;; for sending to another process. This can be used for
;; authentication."
;;   {:added "1.0"
;;    :go "unixCredentials(ucred)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7525256 Ucred}) ucred])
;; 
JOKER FUNC syscall.UnixRights has: 
;; (defn ^[ABEND042(cannot find typename syscall.byte)] UnixRights
;;   "UnixRights encodes a set of open file descriptors into a socket
;; control message for sending to another process."
;;   {:added "1.0"
;;    :go "unixRights(fds)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{7420853 int}) fds])
;; 
JOKER FUNC syscall.Unlink has: 
(defn ^Error Unlink
  {:added "1.0"
   :go "unlink(path)"}
  [^String path])

JOKER FUNC syscall.Unlinkat has: 
(defn ^Error Unlinkat
  {:added "1.0"
   :go "unlinkat(dirfd, path)"}
  [^Int dirfd, ^String path])

JOKER FUNC syscall.Unmount has: 
(defn ^err Unmount
  {:added "1.0"
   :go "unmount(target, flags)"}
  [^String target, ^Int flags])

JOKER FUNC syscall.Unsetenv has: 
(defn ^Error Unsetenv
  {:added "1.0"
   :go "unsetenv(key)"}
  [^String key])

JOKER FUNC syscall.Unshare has: 
(defn ^err Unshare
  {:added "1.0"
   :go "unshare(flags)"}
  [^Int flags])

JOKER FUNC syscall.Ustat has: 
;; (defn ^err Ustat
;;   {:added "1.0"
;;    :go "ustat(dev, ubuf)"}
;;   [^Int dev, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7444649 Ustat_t}) ubuf])
;; 
JOKER FUNC syscall.Utime has: 
;; (defn ^err Utime
;;   {:added "1.0"
;;    :go "utime(path, buf)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7444896 Utimbuf}) buf])
;; 
JOKER FUNC syscall.Utimes has: 
;; (defn ^err Utimes
;;   {:added "1.0"
;;    :go "utimes(path, tv)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7365928 <nil> Timeval}) tv])
;; 
JOKER FUNC syscall.UtimesNano has: 
;; (defn ^err UtimesNano
;;   {:added "1.0"
;;    :go "utimesNano(path, ts)"}
;;   [^String path, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7366169 <nil> Timespec}) ts])
;; 
JOKER FUNC syscall.Wait4 has: 
;; (defn ^[wpid err] Wait4
;;   {:added "1.0"
;;    :go "wait4(pid, wstatus, options, rusage)"}
;;   [^Int pid, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7369602 WaitStatus}) wstatus, ^Int options, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7369635 Rusage}) rusage])
;; 
JOKER FUNC syscall.Write has: 
;; (defn ^[n err] Write
;;   {:added "1.0"
;;    :go "write(fd, p)"}
;;   [^Int fd, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7554357 <nil> byte}) p])
;; 
JOKER FUNC syslog.Dial has: 
;; (defn ^[{:priority priority, :tag ^String tag, :hostname ^String hostname, :network ^String network, :raddr ^String raddr, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :conn conn} Error] Dial
;;   "Dial establishes a connection to a log daemon by connecting to
;; address raddr on the specified network. Each write to the returned
;; writer sends a log message with the facility and severity
;; (from priority) and tag. If tag is empty, the os.Args[0] is used.
;; If network is empty, Dial will connect to the local syslog server.
;; Otherwise, see the documentation for net.Dial for valid values
;; of network and raddr."
;;   {:added "1.0"
;;    :go "dial(network, raddr, priority, tag)"}
;;   [^String network, ^String raddr, priority, ^String tag])
;; 
JOKER FUNC syslog.New has: 
;; (defn ^[{:priority priority, :tag ^String tag, :hostname ^String hostname, :network ^String network, :raddr ^String raddr, :mu ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) mu, :conn conn} Error] New
;;   "New establishes a new connection to the system log daemon. Each
;; write to the returned writer sends a log message with the given
;; priority (a combination of the syslog facility and severity) and
;; prefix tag. If tag is empty, the os.Args[0] is used."
;;   {:added "1.0"
;;    :go "new(priority, tag)"}
;;   [priority, ^String tag])
;; 
JOKER FUNC syslog.NewLogger has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{log Logger}) Error] NewLogger
;;   "NewLogger creates a log.Logger whose output is written to the
;; system log service with the specified priority, a combination of
;; the syslog facility and severity. The logFlag argument is the flag
;; set passed through to log.New to create the Logger."
;;   {:added "1.0"
;;    :go "newLogger(p, logFlag)"}
;;   [p, ^Int logFlag])
;; 
JOKER FUNC tabwriter.NewWriter has: 
;; (defn ^{:output ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) output, :minwidth ^Int minwidth, :tabwidth ^Int tabwidth, :padding ^Int padding, :padbytes ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7667214 0xc000ec26e0 byte}) padbytes, :flags ^Int flags, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7667265 <nil> byte}) buf, :pos ^Int pos, :cell cell, :endchar endChar, :lines ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7667648 <nil> 0xc001175320}) lines, :widths ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7667713 <nil> int}) widths} NewWriter
;;   "NewWriter allocates and initializes a new tabwriter.Writer.
;; The parameters are the same as for the Init function."
;;   {:added "1.0"
;;    :go "newWriter(output, minwidth, tabwidth, padding, padchar, flags)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) output, ^Int minwidth, ^Int tabwidth, ^Int padding, padchar, ^Int flags])
;; 
JOKER FUNC tar.FileInfoHeader has: 
;; (defn ^[{:typeflag Typeflag, :name ^String Name, :linkname ^String Linkname, :size Size, :mode Mode, :uid ^Int Uid, :gid ^Int Gid, :uname ^String Uname, :gname ^String Gname, :modtime ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) ModTime, :accesstime ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) AccessTime, :changetime ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) ChangeTime, :devmajor Devmajor, :devminor Devminor, :xattrs ^ABEND881(unrecognized Expr type *ast.MapType at: &{32693 string string}) Xattrs, :paxrecords ^ABEND881(unrecognized Expr type *ast.MapType at: &{33190 string string}) PAXRecords, :format Format} Error] FileInfoHeader
;;   "FileInfoHeader creates a partially-populated Header from fi.
;; If fi describes a symlink, FileInfoHeader records link as the link target.
;; If fi describes a directory, a slash is appended to the name.
;; 
;; Since os.FileInfo's Name method only returns the base name of
;; the file it describes, it may be necessary to modify Header.Name
;; to provide the full path name of the file."
;;   {:added "1.0"
;;    :go "fileInfoHeader(fi, link)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{os FileInfo}) fi, ^String link])
;; 
JOKER FUNC tar.NewReader has: 
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, :pad pad, :curr curr, :blk blk, :err err} NewReader
;;   "NewReader creates a new Reader reading from r."
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC tar.NewWriter has: 
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :pad pad, :curr curr, :hdr hdr, :blk blk, :err err} NewWriter
;;   "NewWriter creates a new Writer writing to w."
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC testing.AllocsPerRun has: 
;; (defn ^avg AllocsPerRun
;;   "AllocsPerRun returns the average number of allocations during calls to f.
;; Although the return value has type float64, it will always be an integral value.
;; 
;; To compute the number of allocations, the function will first be run once as
;; a warm-up. The average number of allocations over the specified number of
;; runs will then be measured and returned.
;; 
;; AllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore
;; it before returning."
;;   {:added "1.0"
;;    :go "allocsPerRun(runs, f)"}
;;   [^Int runs, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7558890 0xc000fca180 <nil>}) f])
;; 
JOKER FUNC testing.Benchmark has: 
;; (defn ^{:n ^Int N, :t ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}) T, :bytes Bytes, :memallocs MemAllocs, :membytes MemBytes} Benchmark
;;   "Benchmark benchmarks a single function. Useful for creating
;; custom benchmarks that do not use the "go test" command.
;; 
;; If f calls Run, the result will be an estimate of running all its
;; subbenchmarks that don't call Run in sequence in a single benchmark."
;;   {:added "1.0"
;;    :go "benchmark(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{7578113 0xc001337c80 <nil>}) f])
;; 
JOKER FUNC testing.CoverMode has: 
(defn ^String CoverMode
  "CoverMode reports what the test coverage mode is set to. The
values are "set", "count", or "atomic". The return value will be
empty if test coverage is not enabled."
  {:added "1.0"
   :go "coverMode()"}
  [])

JOKER FUNC testing.Coverage has: 
;; (defn ^ABEND042(cannot find typename testing.float64) Coverage
;;   "Coverage reports the current code coverage as a fraction in the range [0, 1].
;; If coverage is not enabled, Coverage returns 0.
;; 
;; When running a large set of sequential test cases, checking Coverage after each one
;; can be useful for identifying which test cases exercise new code paths.
;; It is not a replacement for the reports generated by 'go test -cover' and
;; 'go tool cover'."
;;   {:added "1.0"
;;    :go "coverage()"}
;;   [])
;; 
JOKER FUNC testing.Main has: 
;; (defn Main
;;   "Main is an internal function, part of the implementation of the "go test" command.
;; It was exported because it is cross-package and predates "internal" packages.
;; It is no longer used by "go test" but preserved, as much as possible, for other
;; systems that simulate "go test" using Main, but Main sometimes cannot be updated as
;; new functionality is added to the testing package.
;; Systems simulating "go test" should be updated to use MainStart."
;;   {:added "1.0"
;;    :go "main(matchString, tests, benchmarks, examples)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{7617256 0xc001326c60 0xc001326c90}) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7617299 <nil> InternalTest}) tests, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7617326 <nil> InternalBenchmark}) benchmarks, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7617356 <nil> InternalExample}) examples])
;; 
JOKER FUNC testing.MainStart has: 
;; (defn ^{:deps deps, :tests ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7617584 <nil> InternalTest}) tests, :benchmarks ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7617611 <nil> InternalBenchmark}) benchmarks, :examples ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7617643 <nil> InternalExample}) examples, :timer ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7617673 0xc000f8e640}) timer, :afteronce ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Once}) afterOnce, :numrun ^Int numRun} MainStart
;;   "MainStart is meant for use by tests generated by 'go test'.
;; It is not meant to be called directly and is not subject to the Go 1 compatibility document.
;; It may change signature from release to release."
;;   {:added "1.0"
;;    :go "mainStart(deps, tests, benchmarks, examples)"}
;;   [deps, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7618427 <nil> InternalTest}) tests, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7618454 <nil> InternalBenchmark}) benchmarks, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7618484 <nil> InternalExample}) examples])
;; 
JOKER FUNC testing.RegisterCover has: 
;; (defn RegisterCover
;;   "RegisterCover records the coverage data accumulators for the tests.
;; NOTE: This function is internal to the testing infrastructure and may change.
;; It is not covered (yet) by the Go 1 compatibility guidelines."
;;   {:added "1.0"
;;    :go "registerCover(c)"}
;;   [c])
;; 
JOKER FUNC testing.RunBenchmarks has: 
;; (defn RunBenchmarks
;;   "An internal function but exported because it is cross-package; part of the implementation
;; of the "go test" command."
;;   {:added "1.0"
;;    :go "runBenchmarks(matchString, benchmarks)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{7569929 0xc00162ae70 0xc00162aea0}) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7569977 <nil> InternalBenchmark}) benchmarks])
;; 
JOKER FUNC testing.RunExamples has: 
;; (defn ^ok RunExamples
;;   "An internal function but exported because it is cross-package; part of the implementation
;; of the "go test" command."
;;   {:added "1.0"
;;    :go "runExamples(matchString, examples)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{7578904 0xc001778630 0xc001778660}) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7578950 <nil> InternalExample}) examples])
;; 
JOKER FUNC testing.RunTests has: 
;; (defn ^ok RunTests
;;   "An internal function but exported because it is cross-package; part of the implementation
;; of the "go test" command."
;;   {:added "1.0"
;;    :go "runTests(matchString, tests)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{7621008 0xc001318570 0xc0013185a0}) matchString, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7621051 <nil> InternalTest}) tests])
;; 
JOKER FUNC testing.Short has: 
;; (defn ^ABEND042(cannot find typename testing.bool) Short
;;   "Short reports whether the -test.short flag is set."
;;   {:added "1.0"
;;    :go "short()"}
;;   [])
;; 
JOKER FUNC testing.Verbose has: 
;; (defn ^ABEND042(cannot find typename testing.bool) Verbose
;;   "Verbose reports whether the -test.v flag is set."
;;   {:added "1.0"
;;    :go "verbose()"}
;;   [])
;; 
JOKER FUNC textproto.CanonicalMIMEHeaderKey has: 
(defn ^String CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the
MIME header key s. The canonicalization converts the first
letter and any letter following a hyphen to upper case;
the rest are converted to lowercase. For example, the
canonical key for "accept-encoding" is "Accept-Encoding".
MIME header keys are assumed to be ASCII only.
If s contains a space or invalid header field bytes, it is
returned without modifications."
  {:added "1.0"
   :go "canonicalMIMEHeaderKey(s)"}
  [^String s])

JOKER FUNC textproto.Dial has: 
;; (defn ^[{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}) conn} Error] Dial
;;   "Dial connects to the given address on the given network using net.Dial
;; and then returns a new Conn for the connection."
;;   {:added "1.0"
;;    :go "dial(network, addr)"}
;;   [^String network, ^String addr])
;; 
JOKER FUNC textproto.NewConn has: 
;; (defn ^{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}) conn} NewConn
;;   "NewConn returns a new Conn using conn for I/O."
;;   {:added "1.0"
;;    :go "newConn(conn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}) conn])
;; 
JOKER FUNC textproto.NewReader has: 
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5216074 0xc001442360}) R, :dot ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5216093 dotReader}) dot, :buf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5216109 <nil> byte}) buf} NewReader
;;   "NewReader returns a new Reader reading from r.
;; 
;; To avoid denial of service attacks, the provided bufio.Reader
;; should be reading from an io.LimitReader or similar Reader to bound
;; the size of responses."
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5216400 0xc001442680}) r])
;; 
JOKER FUNC textproto.NewWriter has: 
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5238137 0xc00148a240}) W, :dot ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5238156 dotWriter}) dot} NewWriter
;;   "NewWriter returns a new Writer writing to w."
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5238235 0xc00148a420}) w])
;; 
JOKER FUNC textproto.TrimBytes has: 
;; (defn ^[ABEND042(cannot find typename textproto.byte)] TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space."
;;   {:added "1.0"
;;    :go "trimBytes(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{5243701 <nil> byte}) b])
;; 
JOKER FUNC textproto.TrimString has: 
(defn ^String TrimString
  "TrimString returns s without leading and trailing ASCII space."
  {:added "1.0"
   :go "trimString(s)"}
  [^String s])

JOKER FUNC time.After has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.ChanType at: &{7878552 7878552 2 Time}) After
;;   "After waits for the duration to elapse and then sends the current time
;; on the returned channel.
;; It is equivalent to NewTimer(d).C.
;; The underlying Timer is not recovered by the garbage collector
;; until the timer fires. If efficiency is a concern, use NewTimer
;; instead and call Timer.Stop if the timer is no longer needed."
;;   {:added "1.0"
;;    :go "after(d)"}
;;   [d])
;; 
JOKER FUNC time.AfterFunc has: 
;; (defn ^{:c ^ABEND881(unrecognized Expr type *ast.ChanType at: &{7875227 7875227 2 Time}) C, :r r} AfterFunc
;;   "AfterFunc waits for the duration to elapse and then calls f
;; in its own goroutine. It returns a Timer that can
;; be used to cancel the call using its Stop method."
;;   {:added "1.0"
;;    :go "afterFunc(d, f)"}
;;   [d, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7878789 0xc0002da8a0 <nil>}) f])
;; 
JOKER FUNC time.Date has: 
;; (defn ^{:wall wall, :ext ext, :loc ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7832628 Location}) loc} Date
;;   "Date returns the Time corresponding to
;; 	yyyy-mm-dd hh:mm:ss + nsec nanoseconds
;; in the appropriate zone for that time in the given location.
;; 
;; The month, day, hour, min, sec, and nsec values may be outside
;; their usual ranges and will be normalized during the conversion.
;; For example, October 32 converts to November 1.
;; 
;; A daylight savings time transition skips or repeats times.
;; For example, in the United States, March 13, 2011 2:15am never occurred,
;; while November 6, 2011 1:15am occurred twice. In such cases, the
;; choice of time zone, and therefore the time, is not well-defined.
;; Date returns a time that is correct in one of the two zones involved
;; in the transition, but it does not guarantee which.
;; 
;; Date panics if loc is nil."
;;   {:added "1.0"
;;    :go "date(year, month, day, hour, min, sec, nsec, loc)"}
;;   [^Int year, month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7865627 Location}) loc])
;; 
JOKER FUNC time.FixedZone has: 
;; (defn ^{:name ^String name, :zone ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7817722 <nil> zone}) zone, :tx ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7817735 <nil> zoneTrans}) tx, :cachestart cacheStart, :cacheend cacheEnd, :cachezone ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7818188 zone}) cacheZone} FixedZone
;;   "FixedZone returns a Location that always uses
;; the given zone name and offset (seconds east of UTC)."
;;   {:added "1.0"
;;    :go "fixedZone(name, offset)"}
;;   [^String name, ^Int offset])
;; 
JOKER FUNC time.LoadLocation has: 
;; (defn ^[{:name ^String name, :zone ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7817722 <nil> zone}) zone, :tx ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7817735 <nil> zoneTrans}) tx, :cachestart cacheStart, :cacheend cacheEnd, :cachezone ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7818188 zone}) cacheZone} Error] LoadLocation
;;   "LoadLocation returns the Location with the given name.
;; 
;; If the name is "" or "UTC", LoadLocation returns UTC.
;; If the name is "Local", LoadLocation returns Local.
;; 
;; Otherwise, the name is taken to be a location name corresponding to a file
;; in the IANA Time Zone database, such as "America/New_York".
;; 
;; The time zone database needed by LoadLocation may not be
;; present on all systems, especially non-Unix systems.
;; LoadLocation looks in the directory or uncompressed zip file
;; named by the ZONEINFO environment variable, if any, then looks in
;; known installation locations on Unix systems,
;; and finally looks in $GOROOT/lib/time/zoneinfo.zip."
;;   {:added "1.0"
;;    :go "loadLocation(name)"}
;;   [^String name])
;; 
JOKER FUNC time.LoadLocationFromTZData has: 
;; (defn ^[{:name ^String name, :zone ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7817722 <nil> zone}) zone, :tx ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7817735 <nil> zoneTrans}) tx, :cachestart cacheStart, :cacheend cacheEnd, :cachezone ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7818188 zone}) cacheZone} Error] LoadLocationFromTZData
;;   "LoadLocationFromTZData returns a Location with the given name
;; initialized from the IANA Time Zone database-formatted data.
;; The data should be in the format of a standard IANA time zone file
;; (for example, the content of /etc/localtime on Unix systems)."
;;   {:added "1.0"
;;    :go "loadLocationFromTZData(name, data)"}
;;   [^String name, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{7880978 <nil> byte}) data])
;; 
JOKER FUNC time.NewTicker has: 
;; (defn ^{:c ^ABEND881(unrecognized Expr type *ast.ChanType at: &{7872204 7872204 2 Time}) C, :r r} NewTicker
;;   "NewTicker returns a new Ticker containing a channel that will send the
;; time with a period specified by the duration argument.
;; It adjusts the intervals or drops ticks to make up for slow receivers.
;; The duration d must be greater than zero; if not, NewTicker will panic.
;; Stop the ticker to release associated resources."
;;   {:added "1.0"
;;    :go "newTicker(d)"}
;;   [d])
;; 
JOKER FUNC time.NewTimer has: 
;; (defn ^{:c ^ABEND881(unrecognized Expr type *ast.ChanType at: &{7875227 7875227 2 Time}) C, :r r} NewTimer
;;   "NewTimer creates a new Timer that will send
;; the current time on its channel after at least duration d."
;;   {:added "1.0"
;;    :go "newTimer(d)"}
;;   [d])
;; 
JOKER FUNC time.Now has: 
;; (defn ^{:wall wall, :ext ext, :loc ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7832628 Location}) loc} Now
;;   "Now returns the current local time."
;;   {:added "1.0"
;;    :go "now()"}
;;   [])
;; 
JOKER FUNC time.Parse has: 
;; (defn ^[{:wall wall, :ext ext, :loc ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7832628 Location}) loc} Error] Parse
;;   "Parse parses a formatted string and returns the time value it represents.
;; The layout defines the format by showing how the reference time,
;; defined to be
;; 	Mon Jan 2 15:04:05 -0700 MST 2006
;; would be interpreted if it were the value; it serves as an example of
;; the input format. The same interpretation will then be made to the
;; input string.
;; 
;; Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard
;; and convenient representations of the reference time. For more information
;; about the formats and the definition of the reference time, see the
;; documentation for ANSIC and the other constants defined by this package.
;; Also, the executable example for Time.Format demonstrates the working
;; of the layout string in detail and is a good reference.
;; 
;; Elements omitted from the value are assumed to be zero or, when
;; zero is impossible, one, so parsing "3:04pm" returns the time
;; corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is
;; 0, this time is before the zero Time).
;; Years must be in the range 0000..9999. The day of the week is checked
;; for syntax but it is otherwise ignored.
;; 
;; In the absence of a time zone indicator, Parse returns a time in UTC.
;; 
;; When parsing a time with a zone offset like -0700, if the offset corresponds
;; to a time zone used by the current location (Local), then Parse uses that
;; location and zone in the returned time. Otherwise it records the time as
;; being in a fabricated location with time fixed at the given zone offset.
;; 
;; When parsing a time with a zone abbreviation like MST, if the zone abbreviation
;; has a defined offset in the current location, then that offset is used.
;; The zone abbreviation "UTC" is recognized as UTC regardless of location.
;; If the zone abbreviation is unknown, Parse records the time as being
;; in a fabricated location with the given zone abbreviation and a zero offset.
;; This choice means that such a time can be parsed and reformatted with the
;; same layout losslessly, but the exact instant used in the representation will
;; differ by the actual zone offset. To avoid such problems, prefer time layouts
;; that use a numeric zone offset, or use ParseInLocation."
;;   {:added "1.0"
;;    :go "parse(layout, value)"}
;;   [^String layout, ^String value])
;; 
JOKER FUNC time.ParseDuration has: 
;; (defn ^[ABEND042(cannot find typename time.int64) Error] ParseDuration
;;   "ParseDuration parses a duration string.
;; A duration string is a possibly signed sequence of
;; decimal numbers, each with optional fraction and a unit suffix,
;; such as "300ms", "-1.5h" or "2h45m".
;; Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h"."
;;   {:added "1.0"
;;    :go "parseDuration(s)"}
;;   [^String s])
;; 
JOKER FUNC time.ParseInLocation has: 
;; (defn ^[{:wall wall, :ext ext, :loc ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7832628 Location}) loc} Error] ParseInLocation
;;   "ParseInLocation is like Parse but differs in two important ways.
;; First, in the absence of time zone information, Parse interprets a time as UTC;
;; ParseInLocation interprets the time as in the given location.
;; Second, when given a zone offset or abbreviation, Parse tries to match it
;; against the Local location; ParseInLocation uses the given location."
;;   {:added "1.0"
;;    :go "parseInLocation(layout, value, loc)"}
;;   [^String layout, ^String value, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7914107 Location}) loc])
;; 
JOKER FUNC time.Since has: 
;; (defn ^ABEND042(cannot find typename time.int64) Since
;;   "Since returns the time elapsed since t.
;; It is shorthand for time.Now().Sub(t)."
;;   {:added "1.0"
;;    :go "since(t)"}
;;   [t])
;; 
JOKER FUNC time.Sleep has: 
;; (defn Sleep
;;   "Sleep pauses the current goroutine for at least the duration d.
;; A negative or zero duration causes Sleep to return immediately."
;;   {:added "1.0"
;;    :go "sleep(d)"}
;;   [d])
;; 
JOKER FUNC time.Tick has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.ChanType at: &{7873685 7873685 2 Time}) Tick
;;   "Tick is a convenience wrapper for NewTicker providing access to the ticking
;; channel only. While Tick is useful for clients that have no need to shut down
;; the Ticker, be aware that without a way to shut it down the underlying
;; Ticker cannot be recovered by the garbage collector; it "leaks".
;; Unlike NewTicker, Tick will return nil if d <= 0."
;;   {:added "1.0"
;;    :go "tick(d)"}
;;   [d])
;; 
JOKER FUNC time.Unix has: 
;; (defn ^{:wall wall, :ext ext, :loc ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{7832628 Location}) loc} Unix
;;   "Unix returns the local Time corresponding to the given Unix time,
;; sec seconds and nsec nanoseconds since January 1, 1970 UTC.
;; It is valid to pass nsec outside the range [0, 999999999].
;; Not all sec values have a corresponding time value. One such
;; value is 1<<63-1 (the largest int64 value)."
;;   {:added "1.0"
;;    :go "unix(sec, nsec)"}
;;   [sec, nsec])
;; 
JOKER FUNC time.Until has: 
;; (defn ^ABEND042(cannot find typename time.int64) Until
;;   "Until returns the duration until t.
;; It is shorthand for t.Sub(time.Now())."
;;   {:added "1.0"
;;    :go "until(t)"}
;;   [t])
;; 
JOKER FUNC tls.Client has: 
;; (defn ^{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) conn, :isclient isClient, :handshakestatus handshakeStatus, :handshakemutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) handshakeMutex, :handshakeerr handshakeErr, :vers ^Int vers, :havevers haveVers, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{678077 Config}) config, :handshakes ^Int handshakes, :didresume didResume, :ciphersuite ^Int cipherSuite, :ocspresponse ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678417 <nil> byte}) ocspResponse, :scts ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678469 <nil> 0xc0002f77a0}) scts, :peercertificates ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678541 <nil> 0xc00044f160}) peerCertificates, :verifiedchains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678695 <nil> 0xc0002f7830}) verifiedChains, :servername ^String serverName, :securerenegotiation secureRenegotiation, :ekm ^ABEND881(unrecognized Expr type *ast.FuncType at: &{679076 0xc0002f78f0 0xc0002f7950}) ekm, :clientfinishedisfirst clientFinishedIsFirst, :closenotifyerr closeNotifyErr, :closenotifysent closeNotifySent, :clientfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{679851 0xc00044f8a0 byte}) clientFinished, :serverfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{679876 0xc00044f900 byte}) serverFinished, :clientprotocol ^String clientProtocol, :clientprotocolfallback clientProtocolFallback, :in in, :out out, :rawinput ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{679995 block}) rawInput, :input ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{680052 block}) input, :hand ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{bytes Buffer}) hand, :buffering buffering, :sendbuf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{680243 <nil> byte}) sendBuf, :bytessent bytesSent, :packetssent packetsSent, :warncount ^Int warnCount, :activecall activeCall, :tmp ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{680739 0xc00012c000 byte}) tmp} Client
;;   "Client returns a new TLS client side connection
;; using conn as the underlying transport.
;; The config cannot be nil: users must set either ServerName or
;; InsecureSkipVerify in the config."
;;   {:added "1.0"
;;    :go "client(conn, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) conn, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{801754 Config}) config])
;; 
JOKER FUNC tls.Dial has: 
;; (defn ^[{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) conn, :isclient isClient, :handshakestatus handshakeStatus, :handshakemutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) handshakeMutex, :handshakeerr handshakeErr, :vers ^Int vers, :havevers haveVers, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{678077 Config}) config, :handshakes ^Int handshakes, :didresume didResume, :ciphersuite ^Int cipherSuite, :ocspresponse ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678417 <nil> byte}) ocspResponse, :scts ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678469 <nil> 0xc0002f77a0}) scts, :peercertificates ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678541 <nil> 0xc00044f160}) peerCertificates, :verifiedchains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678695 <nil> 0xc0002f7830}) verifiedChains, :servername ^String serverName, :securerenegotiation secureRenegotiation, :ekm ^ABEND881(unrecognized Expr type *ast.FuncType at: &{679076 0xc0002f78f0 0xc0002f7950}) ekm, :clientfinishedisfirst clientFinishedIsFirst, :closenotifyerr closeNotifyErr, :closenotifysent closeNotifySent, :clientfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{679851 0xc00044f8a0 byte}) clientFinished, :serverfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{679876 0xc00044f900 byte}) serverFinished, :clientprotocol ^String clientProtocol, :clientprotocolfallback clientProtocolFallback, :in in, :out out, :rawinput ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{679995 block}) rawInput, :input ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{680052 block}) input, :hand ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{bytes Buffer}) hand, :buffering buffering, :sendbuf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{680243 <nil> byte}) sendBuf, :bytessent bytesSent, :packetssent packetsSent, :warncount ^Int warnCount, :activecall activeCall, :tmp ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{680739 0xc00012c000 byte}) tmp} Error] Dial
;;   "Dial connects to the given network address using net.Dial
;; and then initiates a TLS handshake, returning the resulting
;; TLS connection.
;; Dial interprets a nil configuration as equivalent to
;; the zero configuration; see the documentation of Config
;; for the defaults."
;;   {:added "1.0"
;;    :go "dial(network, addr, config)"}
;;   [^String network, ^String addr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{805510 Config}) config])
;; 
JOKER FUNC tls.DialWithDialer has: 
;; (defn ^[{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) conn, :isclient isClient, :handshakestatus handshakeStatus, :handshakemutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) handshakeMutex, :handshakeerr handshakeErr, :vers ^Int vers, :havevers haveVers, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{678077 Config}) config, :handshakes ^Int handshakes, :didresume didResume, :ciphersuite ^Int cipherSuite, :ocspresponse ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678417 <nil> byte}) ocspResponse, :scts ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678469 <nil> 0xc0002f77a0}) scts, :peercertificates ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678541 <nil> 0xc00044f160}) peerCertificates, :verifiedchains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678695 <nil> 0xc0002f7830}) verifiedChains, :servername ^String serverName, :securerenegotiation secureRenegotiation, :ekm ^ABEND881(unrecognized Expr type *ast.FuncType at: &{679076 0xc0002f78f0 0xc0002f7950}) ekm, :clientfinishedisfirst clientFinishedIsFirst, :closenotifyerr closeNotifyErr, :closenotifysent closeNotifySent, :clientfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{679851 0xc00044f8a0 byte}) clientFinished, :serverfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{679876 0xc00044f900 byte}) serverFinished, :clientprotocol ^String clientProtocol, :clientprotocolfallback clientProtocolFallback, :in in, :out out, :rawinput ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{679995 block}) rawInput, :input ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{680052 block}) input, :hand ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{bytes Buffer}) hand, :buffering buffering, :sendbuf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{680243 <nil> byte}) sendBuf, :bytessent bytesSent, :packetssent packetsSent, :warncount ^Int warnCount, :activecall activeCall, :tmp ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{680739 0xc00012c000 byte}) tmp} Error] DialWithDialer
;;   "DialWithDialer connects to the given network address using dialer.Dial and
;; then initiates a TLS handshake, returning the resulting TLS connection. Any
;; timeout or deadline given in the dialer apply to connection and TLS
;; handshake as a whole.
;; 
;; DialWithDialer interprets a nil configuration as equivalent to the zero
;; configuration; see the documentation of Config for the defaults."
;;   {:added "1.0"
;;    :go "dialWithDialer(dialer, network, addr, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{803844 0xc0002c88c0}) dialer, ^String network, ^String addr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{803886 Config}) config])
;; 
JOKER FUNC tls.Listen has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}) Error] Listen
;;   "Listen creates a TLS listener accepting connections on the
;; given network address using net.Listen.
;; The configuration config must be non-nil and must include
;; at least one certificate or else set GetCertificate."
;;   {:added "1.0"
;;    :go "listen(network, laddr, config)"}
;;   [^String network, ^String laddr, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{802878 Config}) config])
;; 
JOKER FUNC tls.LoadX509KeyPair has: 
;; (defn ^[{:certificate ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{772007 <nil> 0xc000334f60}) Certificate, :privatekey ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{crypto PrivateKey}) PrivateKey, :ocspstaple ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{772473 <nil> byte}) OCSPStaple, :signedcertificatetimestamps ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{772653 <nil> 0xc000335140}) SignedCertificateTimestamps, :leaf ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{772921 0xc0003b87e0}) Leaf} Error] LoadX509KeyPair
;;   "LoadX509KeyPair reads and parses a public/private key pair from a pair
;; of files. The files must contain PEM encoded data. The certificate file
;; may contain intermediate certificates following the leaf certificate to
;; form a certificate chain. On successful return, Certificate.Leaf will
;; be nil because the parsed form of the certificate is not retained."
;;   {:added "1.0"
;;    :go "loadX509KeyPair(certFile, keyFile)"}
;;   [^String certFile, ^String keyFile])
;; 
JOKER FUNC tls.NewLRUClientSessionCache has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{750134 0xc0004160c0 false}) NewLRUClientSessionCache
;;   "NewLRUClientSessionCache returns a ClientSessionCache with the given
;; capacity that uses an LRU strategy. If capacity is < 1, a default capacity
;; is used instead."
;;   {:added "1.0"
;;    :go "newLRUClientSessionCache(capacity)"}
;;   [^Int capacity])
;; 
JOKER FUNC tls.NewListener has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}) NewListener
;;   "NewListener creates a Listener which accepts connections from an inner
;; Listener and wraps each connection with Server.
;; The configuration config must be non-nil and must include
;; at least one certificate or else set GetCertificate."
;;   {:added "1.0"
;;    :go "newListener(inner, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}) inner, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{802518 Config}) config])
;; 
JOKER FUNC tls.Server has: 
;; (defn ^{:conn ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) conn, :isclient isClient, :handshakestatus handshakeStatus, :handshakemutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync Mutex}) handshakeMutex, :handshakeerr handshakeErr, :vers ^Int vers, :havevers haveVers, :config ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{678077 Config}) config, :handshakes ^Int handshakes, :didresume didResume, :ciphersuite ^Int cipherSuite, :ocspresponse ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678417 <nil> byte}) ocspResponse, :scts ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678469 <nil> 0xc0002f77a0}) scts, :peercertificates ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678541 <nil> 0xc00044f160}) peerCertificates, :verifiedchains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{678695 <nil> 0xc0002f7830}) verifiedChains, :servername ^String serverName, :securerenegotiation secureRenegotiation, :ekm ^ABEND881(unrecognized Expr type *ast.FuncType at: &{679076 0xc0002f78f0 0xc0002f7950}) ekm, :clientfinishedisfirst clientFinishedIsFirst, :closenotifyerr closeNotifyErr, :closenotifysent closeNotifySent, :clientfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{679851 0xc00044f8a0 byte}) clientFinished, :serverfinished ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{679876 0xc00044f900 byte}) serverFinished, :clientprotocol ^String clientProtocol, :clientprotocolfallback clientProtocolFallback, :in in, :out out, :rawinput ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{679995 block}) rawInput, :input ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{680052 block}) input, :hand ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{bytes Buffer}) hand, :buffering buffering, :sendbuf ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{680243 <nil> byte}) sendBuf, :bytessent bytesSent, :packetssent packetsSent, :warncount ^Int warnCount, :activecall activeCall, :tmp ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{680739 0xc00012c000 byte}) tmp} Server
;;   "Server returns a new TLS server side connection
;; using conn as the underlying transport.
;; The configuration config must be non-nil and must include
;; at least one certificate or else set GetCertificate."
;;   {:added "1.0"
;;    :go "server(conn, config)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{net Conn}) conn, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{801462 Config}) config])
;; 
JOKER FUNC tls.X509KeyPair has: 
;; (defn ^[{:certificate ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{772007 <nil> 0xc000334f60}) Certificate, :privatekey ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{crypto PrivateKey}) PrivateKey, :ocspstaple ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{772473 <nil> byte}) OCSPStaple, :signedcertificatetimestamps ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{772653 <nil> 0xc000335140}) SignedCertificateTimestamps, :leaf ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{772921 0xc0003b87e0}) Leaf} Error] X509KeyPair
;;   "X509KeyPair parses a public/private key pair from a pair of
;; PEM encoded data. On successful return, Certificate.Leaf will be nil because
;; the parsed form of the certificate is not retained."
;;   {:added "1.0"
;;    :go "x509KeyPair(certPEMBlock, keyPEMBlock)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{806520 <nil> byte}) certPEMBlock, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{806520 <nil> byte}) keyPEMBlock])
;; 
JOKER FUNC token.Lookup has: 
(defn ^Int Lookup
  "Lookup maps an identifier to its keyword token or IDENT (if not a keyword)."
  {:added "1.0"
   :go "lookup(ident)"}
  [^String ident])

JOKER FUNC token.NewFileSet has: 
;; (defn ^{:mutex ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{sync RWMutex}) mutex, :base ^Int base, :files ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2572324 <nil> 0xc000c20fa0}) files, :last ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2572391 File}) last} NewFileSet
;;   "NewFileSet creates a new file set."
;;   {:added "1.0"
;;    :go "newFileSet()"}
;;   [])
;; 
JOKER FUNC trace.IsEnabled has: 
;; (defn ^ABEND042(cannot find typename trace.bool) IsEnabled
;;   "IsEnabled returns whether tracing is enabled.
;; The information is advisory only. The tracing status
;; may have changed by the time this function returns."
;;   {:added "1.0"
;;    :go "isEnabled()"}
;;   [])
;; 
JOKER FUNC trace.Log has: 
;; (defn Log
;;   "Log emits a one-off event with the given category and message.
;; Category can be empty and the API assumes there are only a handful of
;; unique categories in the system."
;;   {:added "1.0"
;;    :go "log(ctx, category, message)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, ^String category, ^String message])
;; 
JOKER FUNC trace.Logf has: 
;; (defn Logf
;;   "Logf is like Log, but the value is formatted using the specified format spec."
;;   {:added "1.0"
;;    :go "logf(ctx, category, format, args)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, ^String category, ^String format, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{7121017 0xc001ba0ae0}) args])
;; 
JOKER FUNC trace.NewTask has: 
;; (defn ^[ctx task] NewTask
;;   "NewTask creates a task instance with the type taskType and returns
;; it along with a Context that carries the task.
;; If the input context contains a task, the new task is its subtask.
;; 
;; The taskType is used to classify task instances. Analysis tools
;; like the Go execution tracer may assume there are only a bounded
;; number of unique task types in the system.
;; 
;; The returned end function is used to mark the task's end.
;; The trace tool measures task latency as the time between task creation
;; and when the end function is called, and provides the latency
;; distribution per task type.
;; If the end function is called multiple times, only the first
;; call is used in the latency measurement.
;; 
;;   ctx, task := trace.NewTask(ctx, "awesomeTask")
;;   trace.WithRegion(ctx, "preparation", prepWork)
;;   // preparation of the task
;;   go func() {  // continue processing the task in a separate goroutine.
;;       defer task.End()
;;       trace.WithRegion(ctx, "remainingWork", remainingWork)
;;   }()"
;;   {:added "1.0"
;;    :go "newTask(pctx, taskType)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) pctx, ^String taskType])
;; 
JOKER FUNC trace.Start has: 
;; (defn ^Error Start
;;   "Start enables tracing for the current program.
;; While tracing, the trace will be buffered and written to w.
;; Start returns an error if tracing is already enabled."
;;   {:added "1.0"
;;    :go "start(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC trace.StartRegion has: 
;; (defn ^{:id id, :regiontype ^String regionType} StartRegion
;;   "StartRegion starts a region and returns a function for marking the
;; end of the region. The returned Region's End function must be called
;; from the same goroutine where the region was started.
;; Within each goroutine, regions must nest. That is, regions started
;; after this region must be ended before this region can be ended.
;; Recommended usage is
;; 
;;     defer trace.StartRegion(ctx, "myTracedRegion").End()"
;;   {:added "1.0"
;;    :go "startRegion(ctx, regionType)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, ^String regionType])
;; 
JOKER FUNC trace.Stop has: 
;; (defn Stop
;;   "Stop stops the current tracing, if any.
;; Stop only returns after all the writes for the trace have completed."
;;   {:added "1.0"
;;    :go "stop()"}
;;   [])
;; 
JOKER FUNC trace.WithRegion has: 
;; (defn WithRegion
;;   "WithRegion starts a region associated with its calling goroutine, runs fn,
;; and then ends the region. If the context carries a task, the region is
;; associated with the task. Otherwise, the region is attached to the background
;; task.
;; 
;; The regionType is used to classify regions, so there should be only a
;; handful of unique region types."
;;   {:added "1.0"
;;    :go "withRegion(ctx, regionType, fn)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{context Context}) ctx, ^String regionType, ^ABEND881(unrecognized Expr type *ast.FuncType at: &{7121718 0xc001b673e0 <nil>}) fn])
;; 
JOKER FUNC transform.Append has: 
;; (defn ^[result n err] Append
;;   "Append appends the result of converting src[:n] using t to dst, where
;; n <= len(src), If err == nil, n will be len(src). It calls Reset on t."
;;   {:added "1.0"
;;    :go "append(t, dst, src)"}
;;   [t, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8680653 <nil> byte}) dst, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8680653 <nil> byte}) src])
;; 
JOKER FUNC transform.Bytes has: 
;; (defn ^[result n err] Bytes
;;   "Bytes returns a new byte slice with the result of converting b[:n] using t,
;; where n <= len(b). If err == nil, n will be len(b). It calls Reset on t."
;;   {:added "1.0"
;;    :go "bytes(t, b)"}
;;   [t, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8680375 <nil> byte}) b])
;; 
JOKER FUNC transform.Chain has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{8660674 0xc002294e40 false}) Chain
;;   "Chain returns a Transformer that applies t in sequence."
;;   {:added "1.0"
;;    :go "chain(t)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{8671211 Transformer}) t])
;; 
JOKER FUNC transform.NewReader has: 
;; (defn ^{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, :t t, :err err, :dst ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8664145 <nil> byte}) dst, :dst0 ^Int dst0, :dst1 ^Int dst1, :src ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8664281 <nil> byte}) src, :src0 ^Int src0, :src1 ^Int src1, :transformcomplete transformComplete} NewReader
;;   "NewReader returns a new Reader that wraps r by transforming the bytes read
;; via t. It calls Reset on t."
;;   {:added "1.0"
;;    :go "newReader(r, t)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, t])
;; 
JOKER FUNC transform.NewWriter has: 
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :t t, :dst ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8666866 <nil> byte}) dst, :src ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8666942 <nil> byte}) src, :n ^Int n} NewWriter
;;   "NewWriter returns a new Writer that wraps w by transforming the bytes written
;; via t. It calls Reset on t."
;;   {:added "1.0"
;;    :go "newWriter(w, t)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, t])
;; 
JOKER FUNC transform.RemoveFunc has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{8660674 0xc002294e40 false}) RemoveFunc
;;   "Deprecated: use runes.Remove instead."
;;   {:added "1.0"
;;    :go "removeFunc(f)"}
;;   [^ABEND881(unrecognized Expr type *ast.FuncType at: &{8675164 0xc002217ef0 0xc002217f20}) f])
;; 
JOKER FUNC transform.String has: 
(defn ^[result n err] String
  "String returns a string with the result of converting s[:n] using t, where
n <= len(s). If err == nil, n will be len(s). It calls Reset on t."
  {:added "1.0"
   :go "string(t, s)"}
  [t, ^String s])

JOKER FUNC types.AssertableTo has: 
;; (defn ^ABEND042(cannot find typename types.bool) AssertableTo
;;   "AssertableTo reports whether a value of type V can be asserted to have type T."
;;   {:added "1.0"
;;    :go "assertableTo(V, T)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2633139 Interface}) V, T])
;; 
JOKER FUNC types.AssignableTo has: 
;; (defn ^ABEND042(cannot find typename types.bool) AssignableTo
;;   "AssignableTo reports whether a value of type V is assignable to a variable of type T."
;;   {:added "1.0"
;;    :go "assignableTo(V, T)"}
;;   [V, T])
;; 
JOKER FUNC types.Comparable has: 
;; (defn ^ABEND042(cannot find typename types.bool) Comparable
;;   "Comparable reports whether values of type T are comparable."
;;   {:added "1.0"
;;    :go "comparable(T)"}
;;   [T])
;; 
JOKER FUNC types.ConvertibleTo has: 
;; (defn ^ABEND042(cannot find typename types.bool) ConvertibleTo
;;   "ConvertibleTo reports whether a value of type V is convertible to a value of type T."
;;   {:added "1.0"
;;    :go "convertibleTo(V, T)"}
;;   [V, T])
;; 
JOKER FUNC types.DefPredeclaredTestFuncs has: 
;; (defn DefPredeclaredTestFuncs
;;   "DefPredeclaredTestFuncs defines the assert and trace built-ins.
;; These built-ins are intended for debugging and testing of this
;; package only."
;;   {:added "1.0"
;;    :go "defPredeclaredTestFuncs()"}
;;   [])
;; 
JOKER FUNC types.Default has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2584058 0xc000c469f0 false}) Default
;;   "Default returns the default "typed" type for an "untyped" type;
;; it returns the incoming type for all other types. The default type
;; for untyped nil is untyped nil."
;;   {:added "1.0"
;;    :go "default(typ)"}
;;   [typ])
;; 
JOKER FUNC types.Eval has: 
;; (defn ^[_ err] Eval
;;   "Eval returns the type and, if constant, the value for the
;; expression expr, evaluated at position pos of package pkg,
;; which must have been derived from type-checking an AST with
;; complete position information relative to the provided file
;; set.
;; 
;; If pkg == nil, the Universe scope is used and the provided
;; position pos is ignored. If pkg != nil, and pos is invalid,
;; the package scope is used. Otherwise, pos must belong to the
;; package.
;; 
;; An error is returned if pos is not within the package or
;; if the node cannot be evaluated.
;; 
;; Note: Eval should not be used instead of running Check to compute
;; types and values, but in addition to Check. Eval will re-evaluate
;; its argument each time, and it also does not know about the context
;; in which an expression is used (e.g., an assignment). Thus, top-
;; level untyped constants will return an untyped type rather then the
;; respective context-specific type."
;;   {:added "1.0"
;;    :go "eval(fset, pkg, pos, expr)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2618979 0xc000aa2020}) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2618999 Package}) pkg, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, ^String expr])
;; 
JOKER FUNC types.ExprString has: 
;; (defn ^String ExprString
;;   "ExprString returns the (possibly shortened) string representation for x.
;; Shortened representations are suitable for user interfaces but may not
;; necessarily follow Go syntax."
;;   {:added "1.0"
;;    :go "exprString(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{ast Expr}) x])
;; 
JOKER FUNC types.Id has: 
;; (defn ^String Id
;;   "Id returns name if it is exported, otherwise it
;; returns the name qualified with the package path."
;;   {:added "1.0"
;;    :go "id(pkg, name)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2815366 Package}) pkg, ^String name])
;; 
JOKER FUNC types.Identical has: 
;; (defn ^ABEND042(cannot find typename types.bool) Identical
;;   "Identical reports whether x and y are identical types.
;; Receivers of Signature types are ignored."
;;   {:added "1.0"
;;    :go "identical(x, y)"}
;;   [x, y])
;; 
JOKER FUNC types.IdenticalIgnoreTags has: 
;; (defn ^ABEND042(cannot find typename types.bool) IdenticalIgnoreTags
;;   "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.
;; Receivers of Signature types are ignored."
;;   {:added "1.0"
;;    :go "identicalIgnoreTags(x, y)"}
;;   [x, y])
;; 
JOKER FUNC types.Implements has: 
;; (defn ^ABEND042(cannot find typename types.bool) Implements
;;   "Implements reports whether type V implements interface T."
;;   {:added "1.0"
;;    :go "implements(V, T)"}
;;   [V, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2633775 Interface}) T])
;; 
JOKER FUNC types.IsInterface has: 
;; (defn ^ABEND042(cannot find typename types.bool) IsInterface
;;   "IsInterface reports whether typ is an interface type."
;;   {:added "1.0"
;;    :go "isInterface(typ)"}
;;   [typ])
;; 
JOKER FUNC types.LookupFieldOrMethod has: 
;; (defn ^[obj index indirect] LookupFieldOrMethod
;;   "LookupFieldOrMethod looks up a field or method with given package and name
;; in T and returns the corresponding *Var or *Func, an index sequence, and a
;; bool indicating if there were any pointer indirections on the path to the
;; field or method. If addressable is set, T is the type of an addressable
;; variable (only matters for method lookups).
;; 
;; The last index entry is the field or method index in the (possibly embedded)
;; type where the entry was found, either:
;; 
;; 	1) the list of declared methods of a named type; or
;; 	2) the list of all methods (method set) of an interface type; or
;; 	3) the list of fields of a struct type.
;; 
;; The earlier index entries are the indices of the embedded struct fields
;; traversed to get to the found entry, starting at depth 0.
;; 
;; If no entry is found, a nil object is returned. In this case, the returned
;; index and indirect values have the following meaning:
;; 
;; 	- If index != nil, the index sequence points to an ambiguous entry
;; 	(the same name appeared more than once at the same embedding level).
;; 
;; 	- If indirect is set, a method with a pointer receiver type was found
;;      but there was no pointer on the path from the actual receiver type to
;; 	the method's formal receiver base type, nor was the receiver addressable."
;;   {:added "1.0"
;;    :go "lookupFieldOrMethod(T, addressable, pkg, name)"}
;;   [T, addressable, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2829921 Package}) pkg, ^String name])
;; 
JOKER FUNC types.MissingMethod has: 
;; (defn ^[method wrongType] MissingMethod
;;   "MissingMethod returns (nil, false) if V implements T, otherwise it
;; returns a missing method required by T and whether it is missing or
;; just has the wrong type.
;; 
;; For non-interface types V, or if static is set, V implements T if all
;; methods of T are present in V. Otherwise (V is an interface and static
;; is not set), MissingMethod only checks that methods of T which are also
;; present in V have matching types (e.g., for a type assertion x.(T) where
;; x is of interface type V)."
;;   {:added "1.0"
;;    :go "missingMethod(V, T, static)"}
;;   [V, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2837180 Interface}) T, static])
;; 
JOKER FUNC types.NewArray has: 
(defn ^{:len len, :elem elem} NewArray
  "NewArray returns a new array type for the given element type and length.
A negative length indicates an unknown length."
  {:added "1.0"
   :go "newArray(elem, len)"}
  [elem, len])

JOKER FUNC types.NewChan has: 
(defn ^{:dir dir, :elem elem} NewChan
  "NewChan returns a new channel type for the given direction and element type."
  {:added "1.0"
   :go "newChan(dir, elem)"}
  [dir, elem])

JOKER FUNC types.NewChecker has: 
;; (defn ^{:conf ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2887952 Config}) conf, :fset ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2887966 0xc000a9aa00}) fset, :pkg ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2887987 Package}) pkg, :objmap ^ABEND881(unrecognized Expr type *ast.MapType at: &{2888011 Object 0xc000a9ab60}) objMap, :impmap ^ABEND881(unrecognized Expr type *ast.MapType at: &{2888091 importKey 0xc000a9ac20}) impMap, :files ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2888391 <nil> 0xc000a9ada0}) files, :unuseddotimports ^ABEND881(unrecognized Expr type *ast.MapType at: &{2888460 0xc000a9ae40 0xc00095fce0}) unusedDotImports, :firsterr firstErr, :methods ^ABEND881(unrecognized Expr type *ast.MapType at: &{2888636 0xc000a9b000 0xc00095fd40}) methods, :interfaces ^ABEND881(unrecognized Expr type *ast.MapType at: &{2888753 0xc000a9b0e0 0xc000a9b120}) interfaces, :untyped ^ABEND881(unrecognized Expr type *ast.MapType at: &{2888852 0xc000a9b1e0 exprInfo}) untyped, :delayed ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2888930 <nil> 0xc000a9b280}) delayed, :objpath ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2888995 <nil> Object}) objPath, :indent ^Int indent} NewChecker
;;   "NewChecker returns a new Checker instance for a given package.
;; Package files may be added incrementally via checker.Files."
;;   {:added "1.0"
;;    :go "newChecker(conf, fset, pkg, info)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2891429 Config}) conf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2891443 0xc000a9d380}) fset, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2891463 Package}) pkg, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2891478 Info}) info])
;; 
JOKER FUNC types.NewConst has: 
;; (defn ^{:val ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{constant Value}) val} NewConst
;;   "NewConst returns a new constant with value val.
;; The remaining arguments set the attributes found with all Objects."
;;   {:added "1.0"
;;    :go "newConst(pos, pkg, name, typ, val)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2819950 Package}) pkg, ^String name, typ, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{constant Value}) val])
;; 
JOKER FUNC types.NewField has: 
;; (defn ^{:embedded embedded, :isfield isField, :used used} NewField
;;   "NewField returns a new variable representing a struct field.
;; For embedded fields, the name is the unqualified type name
;; / under which the field is accessible."
;;   {:added "1.0"
;;    :go "newField(pos, pkg, name, typ, embedded)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2822780 Package}) pkg, ^String name, typ, embedded])
;; 
JOKER FUNC types.NewFunc has: 
;; (defn ^{} NewFunc
;;   "NewFunc returns a new function with the given signature, representing
;; the function's type."
;;   {:added "1.0"
;;    :go "newFunc(pos, pkg, name, sig)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2823832 Package}) pkg, ^String name, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2823859 Signature}) sig])
;; 
JOKER FUNC types.NewInterface has: 
;; (defn ^{:methods ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2590714 <nil> 0xc000c99a20}) methods, :embeddeds ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2590780 <nil> Type}) embeddeds, :allmethods ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2590846 <nil> 0xc000c99b40}) allMethods} NewInterface
;;   "NewInterface returns a new (incomplete) interface for the given methods and embedded types.
;; Each embedded type must have an underlying type of interface type.
;; NewInterface takes ownership of the provided methods and may modify their types by setting
;; missing receivers. To compute the method set of the interface, Complete must be called.
;; 
;; Deprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types
;; to be embedded. This is necessary for interfaces that embed alias type names referring to
;; non-defined (literal) interface types."
;;   {:added "1.0"
;;    :go "newInterface(methods, embeddeds)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2591858 <nil> 0xc000c99f60}) methods, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2591877 <nil> 0xc000c99fc0}) embeddeds])
;; 
JOKER FUNC types.NewInterfaceType has: 
;; (defn ^{:methods ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2590714 <nil> 0xc000c99a20}) methods, :embeddeds ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2590780 <nil> Type}) embeddeds, :allmethods ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2590846 <nil> 0xc000c99b40}) allMethods} NewInterfaceType
;;   "NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types.
;; Each embedded type must have an underlying type of interface type (this property is not
;; verified for defined types, which may be in the process of being set up and which don't
;; have a valid underlying type yet).
;; NewInterfaceType takes ownership of the provided methods and may modify their types by setting
;; missing receivers. To compute the method set of the interface, Complete must be called."
;;   {:added "1.0"
;;    :go "newInterfaceType(methods, embeddeds)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2592573 <nil> 0xc000c9c420}) methods, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2592592 <nil> Type}) embeddeds])
;; 
JOKER FUNC types.NewLabel has: 
;; (defn ^{:used used} NewLabel
;;   "NewLabel returns a new label."
;;   {:added "1.0"
;;    :go "newLabel(pos, pkg, name)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2824680 Package}) pkg, ^String name])
;; 
JOKER FUNC types.NewMap has: 
(defn ^{:key key, :elem elem} NewMap
  "NewMap returns a new map for the given key and element types."
  {:added "1.0"
   :go "newMap(key, elem)"}
  [key, elem])

JOKER FUNC types.NewMethodSet has: 
;; (defn ^{:list ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2634364 <nil> 0xc000a1ee80}) list} NewMethodSet
;;   "NewMethodSet returns the method set for the given type T.
;; It always returns a non-nil method set, even if it is empty."
;;   {:added "1.0"
;;    :go "newMethodSet(T)"}
;;   [T])
;; 
JOKER FUNC types.NewNamed has: 
;; (defn ^{:obj ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2597076 TypeName}) obj, :underlying underlying, :methods ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2597226 <nil> 0xc000ca5e40}) methods} NewNamed
;;   "NewNamed returns a new named type for the given type name, underlying type, and associated methods.
;; If the given type name obj doesn't have a type yet, its type is set to the returned named type.
;; The underlying type must not be a *Named."
;;   {:added "1.0"
;;    :go "newNamed(obj, underlying, methods)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2597572 TypeName}) obj, underlying, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2597608 <nil> 0xc000caa080}) methods])
;; 
JOKER FUNC types.NewPackage has: 
;; (defn ^{:path ^String path, :name ^String name, :scope ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2768205 Scope}) scope, :complete complete, :imports ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2768237 <nil> 0xc000756ac0}) imports, :fake fake} NewPackage
;;   "NewPackage returns a new Package for the given package path and name.
;; The package is not complete and contains no explicit imports."
;;   {:added "1.0"
;;    :go "newPackage(path, name)"}
;;   [^String path, ^String name])
;; 
JOKER FUNC types.NewParam has: 
;; (defn ^{:embedded embedded, :isfield isField, :used used} NewParam
;;   "NewParam returns a new variable representing a function parameter."
;;   {:added "1.0"
;;    :go "newParam(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2822407 Package}) pkg, ^String name, typ])
;; 
JOKER FUNC types.NewPkgName has: 
;; (defn ^{:imported ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2819106 Package}) imported, :used used} NewPkgName
;;   "NewPkgName returns a new PkgName object representing an imported package.
;; The remaining arguments set the attributes found with all Objects."
;;   {:added "1.0"
;;    :go "newPkgName(pos, pkg, name, imported)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2819346 Package}) pkg, ^String name, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2819378 Package}) imported])
;; 
JOKER FUNC types.NewPointer has: 
(defn ^{:base base} NewPointer
  "NewPointer returns a new pointer type for the given element (base) type."
  {:added "1.0"
   :go "newPointer(elem)"}
  [elem])

JOKER FUNC types.NewScope has: 
;; (defn ^{:parent ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2905815 Scope}) parent, :children ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2905832 <nil> 0xc000b73220}) children, :elems ^ABEND881(unrecognized Expr type *ast.MapType at: &{2905851 string Object}) elems, :pos ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, :end ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) end, :comment ^String comment, :isfunc isFunc} NewScope
;;   "NewScope returns a new, empty scope contained in the given parent
;; scope, if any. The comment is for debugging only."
;;   {:added "1.0"
;;    :go "newScope(parent, pos, end, comment)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2906228 Scope}) parent, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) end, ^String comment])
;; 
JOKER FUNC types.NewSignature has: 
;; (defn ^{:scope ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2588857 Scope}) scope, :recv ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2588930 Var}) recv, :params ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2588970 Tuple}) params, :results ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2589039 Tuple}) results, :variadic variadic} NewSignature
;;   "NewSignature returns a new function type for the given receiver, parameters,
;; and results, either of which may be nil. If variadic is set, the function
;; is variadic, it must have at least one parameter, and the last parameter
;; must be of unnamed slice type."
;;   {:added "1.0"
;;    :go "newSignature(recv, params, results, variadic)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2589500 Var}) recv, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2589522 Tuple}) params, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2589522 Tuple}) results, variadic])
;; 
JOKER FUNC types.NewSlice has: 
(defn ^{:elem elem} NewSlice
  "NewSlice returns a new slice type for the given element type."
  {:added "1.0"
   :go "newSlice(elem)"}
  [elem])

JOKER FUNC types.NewStruct has: 
;; (defn ^{:fields ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2586307 <nil> 0xc000c8ed60}) fields, :tags ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2586322 <nil> string}) tags} NewStruct
;;   "NewStruct returns a new struct with the given fields and corresponding field tags.
;; If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be
;; only as long as required to hold the tag with the largest index i. Consequently,
;; if no field has a tag, tags may be nil."
;;   {:added "1.0"
;;    :go "newStruct(fields, tags)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2586694 <nil> 0xc000c8ef40}) fields, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2586707 <nil> string}) tags])
;; 
JOKER FUNC types.NewTuple has: 
;; (defn ^{:vars ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{2588011 <nil> 0xc000c8ffc0}) vars} NewTuple
;;   "NewTuple returns a new tuple for the given variables."
;;   {:added "1.0"
;;    :go "newTuple(x)"}
;;   [^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{2588094 0xc000c980a0}) x])
;; 
JOKER FUNC types.NewTypeName has: 
;; (defn ^{} NewTypeName
;;   "NewTypeName returns a new type name denoting the given typ.
;; The remaining arguments set the attributes found with all Objects.
;; 
;; The typ argument may be a defined (Named) type or an alias type.
;; It may also be nil such that the returned TypeName can be used as
;; argument for NewNamed, which will set the TypeName's type as a side-
;; effect."
;;   {:added "1.0"
;;    :go "newTypeName(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2820784 Package}) pkg, ^String name, typ])
;; 
JOKER FUNC types.NewVar has: 
;; (defn ^{:embedded embedded, :isfield isField, :used used} NewVar
;;   "NewVar returns a new variable.
;; The arguments set the attributes found with all Objects."
;;   {:added "1.0"
;;    :go "newVar(pos, pkg, name, typ)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{token Pos}) pos, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2822175 Package}) pkg, ^String name, typ])
;; 
JOKER FUNC types.ObjectString has: 
(defn ^String ObjectString
  "ObjectString returns the string form of obj.
The Qualifier controls the printing of
package-level objects, and may be nil."
  {:added "1.0"
   :go "objectString(obj, qf)"}
  [obj, qf])

JOKER FUNC types.RelativeTo has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.FuncType at: &{2770931 0xc00060c390 0xc00060c3c0}) RelativeTo
;;   "RelativeTo(pkg) returns a Qualifier that fully qualifies members of
;; all packages other than pkg."
;;   {:added "1.0"
;;    :go "relativeTo(pkg)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2771077 Package}) pkg])
;; 
JOKER FUNC types.SelectionString has: 
;; (defn ^String SelectionString
;;   "SelectionString returns the string form of s.
;; The Qualifier controls the printing of
;; package-level objects, and may be nil.
;; 
;; Examples:
;; 	"field (T) f int"
;; 	"method (T) f(X) Y"
;; 	"method expr (T) f(X) Y""
;;   {:added "1.0"
;;    :go "selectionString(s, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2904659 Selection}) s, qf])
;; 
JOKER FUNC types.SizesFor has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{2800337 0xc000154b10 false}) SizesFor
;;   "SizesFor returns the Sizes used by a compiler for an architecture.
;; The result is nil if a compiler/architecture pair is not known.
;; 
;; Supported architectures for compiler "gc":
;; "386", "arm", "arm64", "amd64", "amd64p32", "mips", "mipsle",
;; "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "wasm"."
;;   {:added "1.0"
;;    :go "sizesFor(compiler, arch)"}
;;   [^String compiler, ^String arch])
;; 
JOKER FUNC types.TypeString has: 
(defn ^String TypeString
  "TypeString returns the string representation of typ.
The Qualifier controls the printing of
package-level objects, and may be nil."
  {:added "1.0"
   :go "typeString(typ, qf)"}
  [typ, qf])

JOKER FUNC types.WriteExpr has: 
;; (defn WriteExpr
;;   "WriteExpr writes the (possibly shortened) string representation for x to buf.
;; Shortened representations are suitable for user interfaces but may not
;; necessarily follow Go syntax."
;;   {:added "1.0"
;;    :go "writeExpr(buf, x)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2911760 0xc000861ce0}) buf, ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{ast Expr}) x])
;; 
JOKER FUNC types.WriteSignature has: 
;; (defn WriteSignature
;;   "WriteSignature writes the representation of the signature sig to buf,
;; without a leading "func" keyword.
;; The Qualifier controls the printing of
;; package-level objects, and may be nil."
;;   {:added "1.0"
;;    :go "writeSignature(buf, sig, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2777572 0xc0001da780}) buf, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2777591 Signature}) sig, qf])
;; 
JOKER FUNC types.WriteType has: 
;; (defn WriteType
;;   "WriteType writes the string representation of typ to buf.
;; The Qualifier controls the printing of
;; package-level objects, and may be nil."
;;   {:added "1.0"
;;    :go "writeType(buf, typ, qf)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{2772576 0xc0001e9820}) buf, typ, qf])
;; 
JOKER FUNC unicode.In has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) In
;;   "In reports whether the rune is a member of one of the ranges."
;;   {:added "1.0"
;;    :go "in(r, ranges)"}
;;   [r, ^ABEND881(unrecognized Expr type *ast.Ellipsis at: &{8127318 0xc001c49040}) ranges])
;; 
JOKER FUNC unicode.Is has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) Is
;;   "Is reports whether the rune is in the specified table of ranges."
;;   {:added "1.0"
;;    :go "is(rangeTab, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{8133986 RangeTable}) rangeTab, r])
;; 
JOKER FUNC unicode.IsControl has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsControl
;;   "IsControl reports whether the rune is a control character.
;; The C (Other) Unicode category includes more code points
;; such as surrogates; use Is(C, r) to test for them."
;;   {:added "1.0"
;;    :go "isControl(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsDigit has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsDigit
;;   "IsDigit reports whether the rune is a decimal digit."
;;   {:added "1.0"
;;    :go "isDigit(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsGraphic has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode.
;; Such characters include letters, marks, numbers, punctuation, symbols, and
;; spaces, from categories L, M, N, P, S, Zs."
;;   {:added "1.0"
;;    :go "isGraphic(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsLetter has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsLetter
;;   "IsLetter reports whether the rune is a letter (category L)."
;;   {:added "1.0"
;;    :go "isLetter(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsLower has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsLower
;;   "IsLower reports whether the rune is a lower case letter."
;;   {:added "1.0"
;;    :go "isLower(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsMark has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsMark
;;   "IsMark reports whether the rune is a mark character (category M)."
;;   {:added "1.0"
;;    :go "isMark(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsNumber has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsNumber
;;   "IsNumber reports whether the rune is a number (category N)."
;;   {:added "1.0"
;;    :go "isNumber(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsOneOf has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsOneOf
;;   "IsOneOf reports whether the rune is a member of one of the ranges.
;; The function "In" provides a nicer signature and should be used in preference to IsOneOf."
;;   {:added "1.0"
;;    :go "isOneOf(ranges, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8127107 <nil> 0xc001c48d00}) ranges, r])
;; 
JOKER FUNC unicode.IsPrint has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go. Such
;; characters include letters, marks, numbers, punctuation, symbols, and the
;; ASCII space character, from categories L, M, N, P, S and the ASCII space
;; character. This categorization is the same as IsGraphic except that the
;; only spacing character is ASCII space, U+0020."
;;   {:added "1.0"
;;    :go "isPrint(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsPunct has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsPunct
;;   "IsPunct reports whether the rune is a Unicode punctuation character
;; (category P)."
;;   {:added "1.0"
;;    :go "isPunct(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsSpace has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsSpace
;;   "IsSpace reports whether the rune is a space character as defined
;; by Unicode's White Space property; in the Latin-1 space
;; this is
;; 	'\t', '\n', '\v', '\f', '\r', ' ', U+0085 (NEL), U+00A0 (NBSP).
;; Other definitions of spacing characters are set by category
;; Z and property Pattern_White_Space."
;;   {:added "1.0"
;;    :go "isSpace(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsSymbol has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsSymbol
;;   "IsSymbol reports whether the rune is a symbolic character."
;;   {:added "1.0"
;;    :go "isSymbol(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsTitle has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsTitle
;;   "IsTitle reports whether the rune is a title case letter."
;;   {:added "1.0"
;;    :go "isTitle(r)"}
;;   [r])
;; 
JOKER FUNC unicode.IsUpper has: 
;; (defn ^ABEND042(cannot find typename unicode.bool) IsUpper
;;   "IsUpper reports whether the rune is an upper case letter."
;;   {:added "1.0"
;;    :go "isUpper(r)"}
;;   [r])
;; 
JOKER FUNC unicode.SimpleFold has: 
;; (defn ^ABEND042(cannot find typename unicode.rune) SimpleFold
;;   "SimpleFold iterates over Unicode code points equivalent under
;; the Unicode-defined simple case folding. Among the code points
;; equivalent to rune (including rune itself), SimpleFold returns the
;; smallest rune > r if one exists, or else the smallest rune >= 0.
;; If r is not a valid Unicode code point, SimpleFold(r) returns r.
;; 
;; For example:
;; 	SimpleFold('A') = 'a'
;; 	SimpleFold('a') = 'A'
;; 
;; 	SimpleFold('K') = 'k'
;; 	SimpleFold('k') = '\u212A' (Kelvin symbol, K)
;; 	SimpleFold('\u212A') = 'K'
;; 
;; 	SimpleFold('1') = '1'
;; 
;; 	SimpleFold(-2) = -2"
;;   {:added "1.0"
;;    :go "simpleFold(r)"}
;;   [r])
;; 
JOKER FUNC unicode.To has: 
;; (defn ^ABEND042(cannot find typename unicode.rune) To
;;   "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase."
;;   {:added "1.0"
;;    :go "to(_case, r)"}
;;   [^Int _case, r])
;; 
JOKER FUNC unicode.ToLower has: 
;; (defn ^ABEND042(cannot find typename unicode.rune) ToLower
;;   "ToLower maps the rune to lower case."
;;   {:added "1.0"
;;    :go "toLower(r)"}
;;   [r])
;; 
JOKER FUNC unicode.ToTitle has: 
;; (defn ^ABEND042(cannot find typename unicode.rune) ToTitle
;;   "ToTitle maps the rune to title case."
;;   {:added "1.0"
;;    :go "toTitle(r)"}
;;   [r])
;; 
JOKER FUNC unicode.ToUpper has: 
;; (defn ^ABEND042(cannot find typename unicode.rune) ToUpper
;;   "ToUpper maps the rune to upper case."
;;   {:added "1.0"
;;    :go "toUpper(r)"}
;;   [r])
;; 
JOKER FUNC unsafe.Alignof has: 
;; (defn ^ABEND042(cannot find typename unsafe.uintptr) Alignof
;;   "Alignof takes an expression x of any type and returns the required alignment
;; of a hypothetical variable v as if v was declared via var v = x.
;; It is the largest value m such that the address of v is always zero mod m.
;; It is the same as the value returned by reflect.TypeOf(x).Align().
;; As a special case, if a variable s is of struct type and f is a field
;; within that struct, then Alignof(s.f) will return the required alignment
;; of a field of that type within a struct. This case is the same as the
;; value returned by reflect.TypeOf(s.f).FieldAlign()."
;;   {:added "1.0"
;;    :go "alignof(x)"}
;;   [x])
;; 
JOKER FUNC unsafe.Offsetof has: 
;; (defn ^ABEND042(cannot find typename unsafe.uintptr) Offsetof
;;   "Offsetof returns the offset within the struct of the field represented by x,
;; which must be of the form structValue.field. In other words, it returns the
;; number of bytes between the start of the struct and the start of the field."
;;   {:added "1.0"
;;    :go "offsetof(x)"}
;;   [x])
;; 
JOKER FUNC unsafe.Sizeof has: 
;; (defn ^ABEND042(cannot find typename unsafe.uintptr) Sizeof
;;   "Sizeof takes an expression x of any type and returns the size in bytes
;; of a hypothetical variable v as if v was declared via var v = x.
;; The size does not include any memory possibly referenced by x.
;; For instance, if x is a slice, Sizeof returns the size of the slice
;; descriptor, not the size of the memory referenced by the slice."
;;   {:added "1.0"
;;    :go "sizeof(x)"}
;;   [x])
;; 
JOKER FUNC url.Parse has: 
;; (defn ^[{:scheme ^String Scheme, :opaque ^String Opaque, :user ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5253622 Userinfo}) User, :host ^String Host, :path ^String Path, :rawpath ^String RawPath, :forcequery ForceQuery, :rawquery ^String RawQuery, :fragment ^String Fragment} Error] Parse
;;   "Parse parses rawurl into a URL structure.
;; 
;; The rawurl may be relative (a path, without a host) or absolute
;; (starting with a scheme). Trying to parse a hostname and path
;; without a scheme is invalid but may not necessarily return an
;; error, due to parsing ambiguities."
;;   {:added "1.0"
;;    :go "parse(rawurl)"}
;;   [^String rawurl])
;; 
JOKER FUNC url.ParseQuery has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.MapType at: &{5267340 string 0xc0014dcb70}) Error] ParseQuery
;;   "ParseQuery parses the URL-encoded query string and returns
;; a map listing the values specified for each key.
;; ParseQuery always returns a non-nil map containing all the
;; valid query parameters found; err describes the first decoding error
;; encountered, if any.
;; 
;; Query is expected to be a list of key=value settings separated by
;; ampersands or semicolons. A setting without an equals sign is
;; interpreted as a key set to an empty value."
;;   {:added "1.0"
;;    :go "parseQuery(query)"}
;;   [^String query])
;; 
JOKER FUNC url.ParseRequestURI has: 
;; (defn ^[{:scheme ^String Scheme, :opaque ^String Opaque, :user ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{5253622 Userinfo}) User, :host ^String Host, :path ^String Path, :rawpath ^String RawPath, :forcequery ForceQuery, :rawquery ^String RawQuery, :fragment ^String Fragment} Error] ParseRequestURI
;;   "ParseRequestURI parses rawurl into a URL structure. It assumes that
;; rawurl was received in an HTTP request, so the rawurl is interpreted
;; only as an absolute URI or an absolute path.
;; The string rawurl is assumed not to have a #fragment suffix.
;; (Web browsers strip #fragment before sending the URL to a web server.)"
;;   {:added "1.0"
;;    :go "parseRequestURI(rawurl)"}
;;   [^String rawurl])
;; 
JOKER FUNC url.PathEscape has: 
(defn ^String PathEscape
  "PathEscape escapes the string so it can be safely placed
inside a URL path segment."
  {:added "1.0"
   :go "pathEscape(s)"}
  [^String s])

JOKER FUNC url.PathUnescape has: 
(defn ^[String Error] PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,
converting each 3-byte encoded substring of the form "%AB" into the
hex-decoded byte 0xAB. It returns an error if any % is not followed
by two hexadecimal digits.

PathUnescape is identical to QueryUnescape except that it does not
unescape '+' to ' ' (space)."
  {:added "1.0"
   :go "pathUnescape(s)"}
  [^String s])

JOKER FUNC url.QueryEscape has: 
(defn ^String QueryEscape
  "QueryEscape escapes the string so it can be safely placed
inside a URL query."
  {:added "1.0"
   :go "queryEscape(s)"}
  [^String s])

JOKER FUNC url.QueryUnescape has: 
(defn ^[String Error] QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,
converting each 3-byte encoded substring of the form "%AB" into the
hex-decoded byte 0xAB.
It returns an error if any % is not followed by two hexadecimal
digits."
  {:added "1.0"
   :go "queryUnescape(s)"}
  [^String s])

JOKER FUNC url.User has: 
(defn ^{:username ^String username, :password ^String password, :passwordset passwordSet} User
  "User returns a Userinfo containing the provided username
and no password set."
  {:added "1.0"
   :go "user(username)"}
  [^String username])

JOKER FUNC url.UserPassword has: 
(defn ^{:username ^String username, :password ^String password, :passwordset passwordSet} UserPassword
  "UserPassword returns a Userinfo containing the provided username
and password.

This functionality should only be used with legacy web sites.
RFC 2396 warns that interpreting Userinfo this way
``is NOT RECOMMENDED, because the passing of authentication
information in clear text (such as URI) has proven to be a
security risk in almost every case where it has been used.''"
  {:added "1.0"
   :go "userPassword(username, password)"}
  [^String username, ^String password])

JOKER FUNC user.Current has: 
(defn ^[{:uid ^String Uid, :gid ^String Gid, :username ^String Username, :name ^String Name, :homedir ^String HomeDir} Error] Current
  "Current returns the current user."
  {:added "1.0"
   :go "current()"}
  [])

JOKER FUNC user.Lookup has: 
(defn ^[{:uid ^String Uid, :gid ^String Gid, :username ^String Username, :name ^String Name, :homedir ^String HomeDir} Error] Lookup
  "Lookup looks up a user by username. If the user cannot be found, the
returned error is of type UnknownUserError."
  {:added "1.0"
   :go "lookup(username)"}
  [^String username])

JOKER FUNC user.LookupGroup has: 
(defn ^[{:gid ^String Gid, :name ^String Name} Error] LookupGroup
  "LookupGroup looks up a group by name. If the group cannot be found, the
returned error is of type UnknownGroupError."
  {:added "1.0"
   :go "lookupGroup(name)"}
  [^String name])

JOKER FUNC user.LookupGroupId has: 
(defn ^[{:gid ^String Gid, :name ^String Name} Error] LookupGroupId
  "LookupGroupId looks up a group by groupid. If the group cannot be found, the
returned error is of type UnknownGroupIdError."
  {:added "1.0"
   :go "lookupGroupId(gid)"}
  [^String gid])

JOKER FUNC user.LookupId has: 
(defn ^[{:uid ^String Uid, :gid ^String Gid, :username ^String Username, :name ^String Name, :homedir ^String HomeDir} Error] LookupId
  "LookupId looks up a user by userid. If the user cannot be found, the
returned error is of type UnknownUserIdError."
  {:added "1.0"
   :go "lookupId(uid)"}
  [^String uid])

JOKER FUNC utf16.Decode has: 
;; (defn ^[ABEND042(cannot find typename utf16.rune)] Decode
;;   "Decode returns the Unicode code point sequence represented
;; by the UTF-16 encoding s."
;;   {:added "1.0"
;;    :go "decode(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8141905 <nil> uint16}) s])
;; 
JOKER FUNC utf16.DecodeRune has: 
;; (defn ^ABEND042(cannot find typename utf16.rune) DecodeRune
;;   "DecodeRune returns the UTF-16 decoding of a surrogate pair.
;; If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns
;; the Unicode replacement code point U+FFFD."
;;   {:added "1.0"
;;    :go "decodeRune(r1, r2)"}
;;   [r1, r2])
;; 
JOKER FUNC utf16.Encode has: 
;; (defn ^[Int] Encode
;;   "Encode returns the UTF-16 encoding of the Unicode code point sequence s."
;;   {:added "1.0"
;;    :go "encode(s)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8141317 <nil> rune}) s])
;; 
JOKER FUNC utf16.EncodeRune has: 
(defn ^[r1 r2] EncodeRune
  "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.
If the rune is not a valid Unicode code point or does not need encoding,
EncodeRune returns U+FFFD, U+FFFD."
  {:added "1.0"
   :go "encodeRune(r)"}
  [r])

JOKER FUNC utf16.IsSurrogate has: 
;; (defn ^ABEND042(cannot find typename utf16.bool) IsSurrogate
;;   "IsSurrogate reports whether the specified Unicode code point
;; can appear in a surrogate pair."
;;   {:added "1.0"
;;    :go "isSurrogate(r)"}
;;   [r])
;; 
JOKER FUNC utf8.DecodeLastRune has: 
;; (defn ^[r size] DecodeLastRune
;;   "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and
;; its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if
;; the encoding is invalid, it returns (RuneError, 1). Both are impossible
;; results for correct, non-empty UTF-8.
;; 
;; An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
;; out of range, or is not the shortest possible UTF-8 encoding for the
;; value. No other validation is performed."
;;   {:added "1.0"
;;    :go "decodeLastRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8150495 <nil> byte}) p])
;; 
JOKER FUNC utf8.DecodeLastRuneInString has: 
(defn ^[r size] DecodeLastRuneInString
  "DecodeLastRuneInString is like DecodeLastRune but its input is a string. If
s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,
it returns (RuneError, 1). Both are impossible results for correct,
non-empty UTF-8.

An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
out of range, or is not the shortest possible UTF-8 encoding for the
value. No other validation is performed."
  {:added "1.0"
   :go "decodeLastRuneInString(s)"}
  [^String s])

JOKER FUNC utf8.DecodeRune has: 
;; (defn ^[r size] DecodeRune
;;   "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and
;; its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if
;; the encoding is invalid, it returns (RuneError, 1). Both are impossible
;; results for correct, non-empty UTF-8.
;; 
;; An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
;; out of range, or is not the shortest possible UTF-8 encoding for the
;; value. No other validation is performed."
;;   {:added "1.0"
;;    :go "decodeRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8147645 <nil> byte}) p])
;; 
JOKER FUNC utf8.DecodeRuneInString has: 
(defn ^[r size] DecodeRuneInString
  "DecodeRuneInString is like DecodeRune but its input is a string. If s is
empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it
returns (RuneError, 1). Both are impossible results for correct, non-empty
UTF-8.

An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
out of range, or is not the shortest possible UTF-8 encoding for the
value. No other validation is performed."
  {:added "1.0"
   :go "decodeRuneInString(s)"}
  [^String s])

JOKER FUNC utf8.EncodeRune has: 
;; (defn ^Int EncodeRune
;;   "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.
;; It returns the number of bytes written."
;;   {:added "1.0"
;;    :go "encodeRune(p, r)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8152617 <nil> byte}) p, r])
;; 
JOKER FUNC utf8.FullRune has: 
;; (defn ^ABEND042(cannot find typename utf8.bool) FullRune
;;   "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.
;; An invalid encoding is considered a full Rune since it will convert as a width-1 error rune."
;;   {:added "1.0"
;;    :go "fullRune(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8146363 <nil> byte}) p])
;; 
JOKER FUNC utf8.FullRuneInString has: 
;; (defn ^ABEND042(cannot find typename utf8.bool) FullRuneInString
;;   "FullRuneInString is like FullRune but its input is a string."
;;   {:added "1.0"
;;    :go "fullRuneInString(s)"}
;;   [^String s])
;; 
JOKER FUNC utf8.RuneCount has: 
;; (defn ^Int RuneCount
;;   "RuneCount returns the number of runes in p. Erroneous and short
;; encodings are treated as single runes of width 1 byte."
;;   {:added "1.0"
;;    :go "runeCount(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8153482 <nil> byte}) p])
;; 
JOKER FUNC utf8.RuneCountInString has: 
(defn ^n RuneCountInString
  "RuneCountInString is like RuneCount but its input is a string."
  {:added "1.0"
   :go "runeCountInString(s)"}
  [^String s])

JOKER FUNC utf8.RuneLen has: 
(defn ^Int RuneLen
  "RuneLen returns the number of bytes required to encode the rune.
It returns -1 if the rune is not a valid value to encode in UTF-8."
  {:added "1.0"
   :go "runeLen(r)"}
  [r])

JOKER FUNC utf8.RuneStart has: 
;; (defn ^ABEND042(cannot find typename utf8.bool) RuneStart
;;   "RuneStart reports whether the byte could be the first byte of an encoded,
;; possibly invalid rune. Second and subsequent bytes always have the top two
;; bits set to 10."
;;   {:added "1.0"
;;    :go "runeStart(b)"}
;;   [b])
;; 
JOKER FUNC utf8.Valid has: 
;; (defn ^ABEND042(cannot find typename utf8.bool) Valid
;;   "Valid reports whether p consists entirely of valid UTF-8-encoded runes."
;;   {:added "1.0"
;;    :go "valid(p)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{8155059 <nil> byte}) p])
;; 
JOKER FUNC utf8.ValidRune has: 
;; (defn ^ABEND042(cannot find typename utf8.bool) ValidRune
;;   "ValidRune reports whether r can be legally encoded as UTF-8.
;; Code points that are out of range or a surrogate half are illegal."
;;   {:added "1.0"
;;    :go "validRune(r)"}
;;   [r])
;; 
JOKER FUNC utf8.ValidString has: 
;; (defn ^ABEND042(cannot find typename utf8.bool) ValidString
;;   "ValidString reports whether s consists entirely of valid UTF-8-encoded runes."
;;   {:added "1.0"
;;    :go "validString(s)"}
;;   [^String s])
;; 
JOKER FUNC x509.CreateCertificate has: 
;; (defn ^[cert err] CreateCertificate
;;   "CreateCertificate creates a new X.509v3 certificate based on a template.
;; The following members of template are used:
;; 
;;  - AuthorityKeyId
;;  - BasicConstraintsValid
;;  - CRLDistributionPoints
;;  - DNSNames
;;  - EmailAddresses
;;  - ExcludedDNSDomains
;;  - ExcludedEmailAddresses
;;  - ExcludedIPRanges
;;  - ExcludedURIDomains
;;  - ExtKeyUsage
;;  - ExtraExtensions
;;  - IsCA
;;  - IssuingCertificateURL
;;  - KeyUsage
;;  - MaxPathLen
;;  - MaxPathLenZero
;;  - NotAfter
;;  - NotBefore
;;  - OCSPServer
;;  - PermittedDNSDomains
;;  - PermittedDNSDomainsCritical
;;  - PermittedEmailAddresses
;;  - PermittedIPRanges
;;  - PermittedURIDomains
;;  - PolicyIdentifiers
;;  - SerialNumber
;;  - SignatureAlgorithm
;;  - Subject
;;  - SubjectKeyId
;;  - URIs
;;  - UnknownExtKeyUsage
;; 
;; The certificate is signed by parent. If parent is equal to template then the
;; certificate is self-signed. The parameter pub is the public key of the
;; signee and priv is the private key of the signer.
;; 
;; The returned slice is the certificate in DER encoding.
;; 
;; All keys types that are implemented via crypto.Signer are supported (This
;; includes *rsa.PublicKey and *ecdsa.PublicKey.)
;; 
;; The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,
;; unless the resulting certificate is self-signed. Otherwise the value from
;; template will be used."
;;   {:added "1.0"
;;    :go "createCertificate(rand, template, parent, pub, priv)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{958545 Certificate}) template, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{958545 Certificate}) parent, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{958569 0xc000593da0 false}) pub, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{958569 0xc000593da0 false}) priv])
;; 
JOKER FUNC x509.CreateCertificateRequest has: 
;; (defn ^[csr err] CreateCertificateRequest
;;   "CreateCertificateRequest creates a new certificate request based on a
;; template. The following members of template are used:
;; 
;;  - Attributes
;;  - DNSNames
;;  - EmailAddresses
;;  - ExtraExtensions
;;  - IPAddresses
;;  - URIs
;;  - SignatureAlgorithm
;;  - Subject
;; 
;; The private key is the private key of the signer.
;; 
;; The returned slice is the certificate request in DER encoding.
;; 
;; All keys types that are implemented via crypto.Signer are supported (This
;; includes *rsa.PublicKey and *ecdsa.PublicKey.)"
;;   {:added "1.0"
;;    :go "createCertificateRequest(rand, template, priv)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{968376 CertificateRequest}) template, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{968402 0xc0005dec90 false}) priv])
;; 
JOKER FUNC x509.DecryptPEMBlock has: 
;; (defn ^[[ABEND042(cannot find typename x509.byte)] Error] DecryptPEMBlock
;;   "DecryptPEMBlock takes a password encrypted PEM block and the password used to
;; encrypt it and returns a slice of decrypted DER encoded bytes. It inspects
;; the DEK-Info header to determine the algorithm used for decryption. If no
;; DEK-Info header is present, an error is returned. If an incorrect password
;; is detected an IncorrectPasswordError is returned. Because of deficiencies
;; in the encrypted-PEM format, it's not always possible to detect an incorrect
;; password. In these cases no error will be returned but the decrypted DER
;; bytes will be random noise."
;;   {:added "1.0"
;;    :go "decryptPEMBlock(b, password)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1017186 0xc000663f60}) b, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1017207 <nil> byte}) password])
;; 
JOKER FUNC x509.EncryptPEMBlock has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{pem Block}) Error] EncryptPEMBlock
;;   "EncryptPEMBlock returns a PEM block of the specified type holding the
;; given DER-encoded data encrypted with the specified algorithm and
;; password."
;;   {:added "1.0"
;;    :go "encryptPEMBlock(rand, blockType, data, password, alg)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) rand, ^String blockType, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1019162 <nil> byte}) data, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1019162 <nil> byte}) password, alg])
;; 
JOKER FUNC x509.IsEncryptedPEMBlock has: 
;; (defn ^ABEND042(cannot find typename x509.bool) IsEncryptedPEMBlock
;;   "IsEncryptedPEMBlock returns if the PEM block is password encrypted."
;;   {:added "1.0"
;;    :go "isEncryptedPEMBlock(b)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1016361 0xc000663b00}) b])
;; 
JOKER FUNC x509.MarshalECPrivateKey has: 
;; (defn ^[[ABEND042(cannot find typename x509.byte)] Error] MarshalECPrivateKey
;;   "MarshalECPrivateKey marshals an EC private key into ASN.1, DER format."
;;   {:added "1.0"
;;    :go "marshalECPrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{881361 0xc00056e960}) key])
;; 
JOKER FUNC x509.MarshalPKCS1PrivateKey has: 
;; (defn ^[ABEND042(cannot find typename x509.byte)] MarshalPKCS1PrivateKey
;;   "MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form."
;;   {:added "1.0"
;;    :go "marshalPKCS1PrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{890442 0xc00038a740}) key])
;; 
JOKER FUNC x509.MarshalPKCS1PublicKey has: 
;; (defn ^[ABEND042(cannot find typename x509.byte)] MarshalPKCS1PublicKey
;;   "MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form."
;;   {:added "1.0"
;;    :go "marshalPKCS1PublicKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.StarExpr at: &{891835 0xc00043e280}) key])
;; 
JOKER FUNC x509.MarshalPKCS8PrivateKey has: 
;; (defn ^[[ABEND042(cannot find typename x509.byte)] Error] MarshalPKCS8PrivateKey
;;   "MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form.
;; The following key types are supported: *rsa.PrivateKey, *ecdsa.PrivateKey.
;; Unsupported key types result in an error.
;; 
;; See RFC 5208."
;;   {:added "1.0"
;;    :go "marshalPKCS8PrivateKey(key)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1012995 0xc000652f90 false}) key])
;; 
JOKER FUNC x509.MarshalPKIXPublicKey has: 
;; (defn ^[[ABEND042(cannot find typename x509.byte)] Error] MarshalPKIXPublicKey
;;   "MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format."
;;   {:added "1.0"
;;    :go "marshalPKIXPublicKey(pub)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{895037 0xc000273950 false}) pub])
;; 
JOKER FUNC x509.NewCertPool has: 
;; (defn ^{:bysubjectkeyid ^ABEND881(unrecognized Expr type *ast.MapType at: &{884355 string 0xc000579260}) bySubjectKeyId, :byname ^ABEND881(unrecognized Expr type *ast.MapType at: &{884388 string 0xc0005792c0}) byName, :certs ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{884421 <nil> 0xc00050fd00}) certs} NewCertPool
;;   "NewCertPool returns a new, empty CertPool."
;;   {:added "1.0"
;;    :go "newCertPool()"}
;;   [])
;; 
JOKER FUNC x509.ParseCRL has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{pkix CertificateList}) Error] ParseCRL
;;   "ParseCRL parses a CRL from the given bytes. It's often the case that PEM
;; encoded CRLs will appear where they should be DER encoded, so this function
;; will transparently handle PEM encoding as long as there isn't any leading
;; garbage."
;;   {:added "1.0"
;;    :go "parseCRL(crlBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{961222 <nil> byte}) crlBytes])
;; 
JOKER FUNC x509.ParseCertificate has: 
;; (defn ^[{:raw ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912589 <nil> byte}) Raw, :rawtbscertificate ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912701 <nil> byte}) RawTBSCertificate, :rawsubjectpublickeyinfo ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912779 <nil> byte}) RawSubjectPublicKeyInfo, :rawsubject ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912848 <nil> byte}) RawSubject, :rawissuer ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912903 <nil> byte}) RawIssuer, :signature ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912953 <nil> byte}) Signature, :signaturealgorithm SignatureAlgorithm, :publickeyalgorithm PublicKeyAlgorithm, :publickey ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{913059 0xc00008dfb0 false}) PublicKey, :version ^Int Version, :serialnumber ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{913118 0xc000147760}) SerialNumber, :issuer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{pkix Name}) Issuer, :subject ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{pkix Name}) Subject, :notbefore ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) NotBefore, :notafter ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) NotAfter, :keyusage KeyUsage, :extensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{913541 <nil> 0xc000147b00}) Extensions, :extraextensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{913857 <nil> 0xc000147c40}) ExtraExtensions, :unhandledcriticalextensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{914321 <nil> 0xc000147e00}) UnhandledCriticalExtensions, :extkeyusage ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{914366 <nil> ExtKeyUsage}) ExtKeyUsage, :unknownextkeyusage ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{914446 <nil> 0xc000147f00}) UnknownExtKeyUsage, :basicconstraintsvalid BasicConstraintsValid, :isca IsCA, :maxpathlen ^Int MaxPathLen, :maxpathlenzero MaxPathLenZero, :subjectkeyid ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915583 <nil> byte}) SubjectKeyId, :authoritykeyid ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915606 <nil> byte}) AuthorityKeyId, :ocspserver ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915690 <nil> string}) OCSPServer, :issuingcertificateurl ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915722 <nil> string}) IssuingCertificateURL, :dnsnames ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915967 <nil> string}) DNSNames, :emailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915992 <nil> string}) EmailAddresses, :ipaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916017 <nil> 0xc000424600}) IPAddresses, :uris ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916042 <nil> 0xc0004246a0}) URIs, :permitteddnsdomainscritical PermittedDNSDomainsCritical, :permitteddnsdomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916196 <nil> string}) PermittedDNSDomains, :excludeddnsdomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916234 <nil> string}) ExcludedDNSDomains, :permittedipranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916272 <nil> 0xc000424880}) PermittedIPRanges, :excludedipranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916314 <nil> 0xc000424920}) ExcludedIPRanges, :permittedemailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916356 <nil> string}) PermittedEmailAddresses, :excludedemailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916394 <nil> string}) ExcludedEmailAddresses, :permitteduridomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916432 <nil> string}) PermittedURIDomains, :excludeduridomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916470 <nil> string}) ExcludedURIDomains, :crldistributionpoints ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916531 <nil> string}) CRLDistributionPoints, :policyidentifiers ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916560 <nil> 0xc000424b20}) PolicyIdentifiers} Error] ParseCertificate
;;   "ParseCertificate parses a single certificate from the given ASN.1 DER data."
;;   {:added "1.0"
;;    :go "parseCertificate(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{943287 <nil> byte}) asn1Data])
;; 
JOKER FUNC x509.ParseCertificateRequest has: 
;; (defn ^[{:raw ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{963756 <nil> byte}) Raw, :rawtbscertificaterequest ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{963861 <nil> byte}) RawTBSCertificateRequest, :rawsubjectpublickeyinfo ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{963953 <nil> byte}) RawSubjectPublicKeyInfo, :rawsubject ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{964023 <nil> byte}) RawSubject, :version ^Int Version, :signature ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{964099 <nil> byte}) Signature, :signaturealgorithm SignatureAlgorithm, :publickeyalgorithm PublicKeyAlgorithm, :publickey ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{964205 0xc0005cdc50 false}) PublicKey, :subject ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{pkix Name}) Subject, :attributes ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{964315 <nil> 0xc0005d2fa0}) Attributes, :extensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{964509 <nil> 0xc0005d30c0}) Extensions, :extraextensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{964881 <nil> 0xc0005d3260}) ExtraExtensions, :dnsnames ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{964950 <nil> string}) DNSNames, :emailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{964975 <nil> string}) EmailAddresses, :ipaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{965000 <nil> 0xc0005d33a0}) IPAddresses, :uris ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{965025 <nil> 0xc0005d3440}) URIs} Error] ParseCertificateRequest
;;   "ParseCertificateRequest parses a single certificate request from the
;; given ASN.1 DER data."
;;   {:added "1.0"
;;    :go "parseCertificateRequest(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{972914 <nil> byte}) asn1Data])
;; 
JOKER FUNC x509.ParseCertificates has: 
;; (defn ^[[{:raw ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912589 <nil> byte}) Raw, :rawtbscertificate ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912701 <nil> byte}) RawTBSCertificate, :rawsubjectpublickeyinfo ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912779 <nil> byte}) RawSubjectPublicKeyInfo, :rawsubject ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912848 <nil> byte}) RawSubject, :rawissuer ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912903 <nil> byte}) RawIssuer, :signature ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{912953 <nil> byte}) Signature, :signaturealgorithm SignatureAlgorithm, :publickeyalgorithm PublicKeyAlgorithm, :publickey ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{913059 0xc00008dfb0 false}) PublicKey, :version ^Int Version, :serialnumber ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{913118 0xc000147760}) SerialNumber, :issuer ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{pkix Name}) Issuer, :subject ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{pkix Name}) Subject, :notbefore ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) NotBefore, :notafter ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) NotAfter, :keyusage KeyUsage, :extensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{913541 <nil> 0xc000147b00}) Extensions, :extraextensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{913857 <nil> 0xc000147c40}) ExtraExtensions, :unhandledcriticalextensions ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{914321 <nil> 0xc000147e00}) UnhandledCriticalExtensions, :extkeyusage ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{914366 <nil> ExtKeyUsage}) ExtKeyUsage, :unknownextkeyusage ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{914446 <nil> 0xc000147f00}) UnknownExtKeyUsage, :basicconstraintsvalid BasicConstraintsValid, :isca IsCA, :maxpathlen ^Int MaxPathLen, :maxpathlenzero MaxPathLenZero, :subjectkeyid ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915583 <nil> byte}) SubjectKeyId, :authoritykeyid ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915606 <nil> byte}) AuthorityKeyId, :ocspserver ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915690 <nil> string}) OCSPServer, :issuingcertificateurl ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915722 <nil> string}) IssuingCertificateURL, :dnsnames ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915967 <nil> string}) DNSNames, :emailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{915992 <nil> string}) EmailAddresses, :ipaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916017 <nil> 0xc000424600}) IPAddresses, :uris ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916042 <nil> 0xc0004246a0}) URIs, :permitteddnsdomainscritical PermittedDNSDomainsCritical, :permitteddnsdomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916196 <nil> string}) PermittedDNSDomains, :excludeddnsdomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916234 <nil> string}) ExcludedDNSDomains, :permittedipranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916272 <nil> 0xc000424880}) PermittedIPRanges, :excludedipranges ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916314 <nil> 0xc000424920}) ExcludedIPRanges, :permittedemailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916356 <nil> string}) PermittedEmailAddresses, :excludedemailaddresses ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916394 <nil> string}) ExcludedEmailAddresses, :permitteduridomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916432 <nil> string}) PermittedURIDomains, :excludeduridomains ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916470 <nil> string}) ExcludedURIDomains, :crldistributionpoints ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916531 <nil> string}) CRLDistributionPoints, :policyidentifiers ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{916560 <nil> 0xc000424b20}) PolicyIdentifiers}] Error] ParseCertificates
;;   "ParseCertificates parses one or more certificates from the given ASN.1 DER
;; data. The certificates must be concatenated with no intermediate padding."
;;   {:added "1.0"
;;    :go "parseCertificates(asn1Data)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{943724 <nil> byte}) asn1Data])
;; 
JOKER FUNC x509.ParseDERCRL has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{pkix CertificateList}) Error] ParseDERCRL
;;   "ParseDERCRL parses a DER encoded CRL from the given bytes."
;;   {:added "1.0"
;;    :go "parseDERCRL(derBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{961543 <nil> byte}) derBytes])
;; 
JOKER FUNC x509.ParseECPrivateKey has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{ecdsa PrivateKey}) Error] ParseECPrivateKey
;;   "ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure."
;;   {:added "1.0"
;;    :go "parseECPrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{881182 <nil> byte}) der])
;; 
JOKER FUNC x509.ParsePKCS1PrivateKey has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{rsa PrivateKey}) Error] ParsePKCS1PrivateKey
;;   "ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form."
;;   {:added "1.0"
;;    :go "parsePKCS1PrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{889268 <nil> byte}) der])
;; 
JOKER FUNC x509.ParsePKCS1PublicKey has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{rsa PublicKey}) Error] ParsePKCS1PublicKey
;;   "ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form."
;;   {:added "1.0"
;;    :go "parsePKCS1PublicKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{891233 <nil> byte}) der])
;; 
JOKER FUNC x509.ParsePKCS8PrivateKey has: 
;; (defn ^[key err] ParsePKCS8PrivateKey
;;   "ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key.
;; See RFC 5208."
;;   {:added "1.0"
;;    :go "parsePKCS8PrivateKey(der)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1011764 <nil> byte}) der])
;; 
JOKER FUNC x509.ParsePKIXPublicKey has: 
;; (defn ^[pub err] ParsePKIXPublicKey
;;   "ParsePKIXPublicKey parses a DER encoded public key. These values are
;; typically found in PEM blocks with "BEGIN PUBLIC KEY".
;; 
;; Supported key types include RSA, DSA, and ECDSA. Unknown key
;; types result in an error.
;; 
;; On success, pub will be of type *rsa.PublicKey, *dsa.PublicKey,
;; or *ecdsa.PublicKey."
;;   {:added "1.0"
;;    :go "parsePKIXPublicKey(derBytes)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{893338 <nil> byte}) derBytes])
;; 
JOKER FUNC x509.SystemCertPool has: 
;; (defn ^[{:bysubjectkeyid ^ABEND881(unrecognized Expr type *ast.MapType at: &{884355 string 0xc000579260}) bySubjectKeyId, :byname ^ABEND881(unrecognized Expr type *ast.MapType at: &{884388 string 0xc0005792c0}) byName, :certs ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{884421 <nil> 0xc00050fd00}) certs} Error] SystemCertPool
;;   "SystemCertPool returns a copy of the system cert pool.
;; 
;; Any mutations to the returned pool are not written to disk and do
;; not affect any other pool.
;; 
;; New changes in the the system cert pool might not be reflected
;; in subsequent calls."
;;   {:added "1.0"
;;    :go "systemCertPool()"}
;;   [])
;; 
JOKER FUNC xml.CopyToken has: 
;; (defn ^ABEND883(unrecognized Expr type *ast.InterfaceType at: &{1915958 0xc00062bbc0 false}) CopyToken
;;   "CopyToken returns a copy of a Token."
;;   {:added "1.0"
;;    :go "copyToken(t)"}
;;   [t])
;; 
JOKER FUNC xml.Escape has: 
;; (defn Escape
;;   "Escape is like EscapeText but omits the error return value.
;; It is provided for backwards compatibility with Go 1.0.
;; Code targeting Go 1.1 or later should use EscapeText."
;;   {:added "1.0"
;;    :go "escape(w, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1960767 <nil> byte}) s])
;; 
JOKER FUNC xml.EscapeText has: 
;; (defn ^Error EscapeText
;;   "EscapeText writes to w the properly escaped XML equivalent
;; of the plain text data s."
;;   {:added "1.0"
;;    :go "escapeText(w, s)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1958889 <nil> byte}) s])
;; 
JOKER FUNC xml.Marshal has: 
;; (defn ^[[ABEND042(cannot find typename xml.byte)] Error] Marshal
;;   "Marshal returns the XML encoding of v.
;; 
;; Marshal handles an array or slice by marshaling each of the elements.
;; Marshal handles a pointer by marshaling the value it points at or, if the
;; pointer is nil, by writing nothing. Marshal handles an interface value by
;; marshaling the value it contains or, if the interface value is nil, by
;; writing nothing. Marshal handles all other data by writing one or more XML
;; elements containing the data.
;; 
;; The name for the XML elements is taken from, in order of preference:
;;     - the tag on the XMLName field, if the data is a struct
;;     - the value of the XMLName field of type Name
;;     - the tag of the struct field used to obtain the data
;;     - the name of the struct field used to obtain the data
;;     - the name of the marshaled type
;; 
;; The XML element for a struct contains marshaled elements for each of the
;; exported fields of the struct, with these exceptions:
;;     - the XMLName field, described above, is omitted.
;;     - a field with tag "-" is omitted.
;;     - a field with tag "name,attr" becomes an attribute with
;;       the given name in the XML element.
;;     - a field with tag ",attr" becomes an attribute with the
;;       field name in the XML element.
;;     - a field with tag ",chardata" is written as character data,
;;       not as an XML element.
;;     - a field with tag ",cdata" is written as character data
;;       wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.
;;     - a field with tag ",innerxml" is written verbatim, not subject
;;       to the usual marshaling procedure.
;;     - a field with tag ",comment" is written as an XML comment, not
;;       subject to the usual marshaling procedure. It must not contain
;;       the "--" string within it.
;;     - a field with a tag including the "omitempty" option is omitted
;;       if the field value is empty. The empty values are false, 0, any
;;       nil pointer or interface value, and any array, slice, map, or
;;       string of length zero.
;;     - an anonymous struct field is handled as if the fields of its
;;       value were part of the outer struct.
;; 
;; If a field uses a tag "a>b>c", then the element c will be nested inside
;; parent elements a and b. Fields that appear next to each other that name
;; the same parent will be enclosed in one XML element.
;; 
;; If the XML name for a struct field is defined by both the field tag and the
;; struct's XMLName field, the names must match.
;; 
;; See MarshalIndent for an example.
;; 
;; Marshal will return an error if asked to marshal a channel, function, or map."
;;   {:added "1.0"
;;    :go "marshal(v)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1965283 0xc000272180 false}) v])
;; 
JOKER FUNC xml.MarshalIndent has: 
;; (defn ^[[ABEND042(cannot find typename xml.byte)] Error] MarshalIndent
;;   "MarshalIndent works like Marshal, but each XML element begins on a new
;; indented line that starts with prefix and is followed by one or more
;; copies of indent according to the nesting depth."
;;   {:added "1.0"
;;    :go "marshalIndent(v, prefix, indent)"}
;;   [^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1967148 0xc0002733b0 false}) v, ^String prefix, ^String indent])
;; 
JOKER FUNC xml.NewDecoder has: 
;; (defn ^{:strict Strict, :autoclose ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1919877 <nil> string}) AutoClose, :entity ^ABEND881(unrecognized Expr type *ast.MapType at: &{1920178 string string}) Entity, :charsetreader ^ABEND881(unrecognized Expr type *ast.FuncType at: &{1920509 0xc0005592f0 0xc0005593b0}) CharsetReader, :defaultspace ^String DefaultSpace, :r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ByteReader}) r, :t t, :buf ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{bytes Buffer}) buf, :saved ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1920872 0xc000742660}) saved, :stk ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1920902 stack}) stk, :free ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1920925 stack}) free, :needclose needClose, :toclose toClose, :nexttoken nextToken, :nextbyte ^Int nextByte, :ns ^ABEND881(unrecognized Expr type *ast.MapType at: &{1921032 string string}) ns, :err err, :line ^Int line, :offset offset, :unmarshaldepth ^Int unmarshalDepth} NewDecoder
;;   "NewDecoder creates a new XML parser reading from r.
;; If r does not implement io.ByteReader, NewDecoder will
;; do its own buffering."
;;   {:added "1.0"
;;    :go "newDecoder(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC xml.NewEncoder has: 
;; (defn ^{:p p} NewEncoder
;;   "NewEncoder returns a new encoder that writes to w."
;;   {:added "1.0"
;;    :go "newEncoder(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC xml.NewTokenDecoder has: 
;; (defn ^{:strict Strict, :autoclose ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1919877 <nil> string}) AutoClose, :entity ^ABEND881(unrecognized Expr type *ast.MapType at: &{1920178 string string}) Entity, :charsetreader ^ABEND881(unrecognized Expr type *ast.FuncType at: &{1920509 0xc0005592f0 0xc0005593b0}) CharsetReader, :defaultspace ^String DefaultSpace, :r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ByteReader}) r, :t t, :buf ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{bytes Buffer}) buf, :saved ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1920872 0xc000742660}) saved, :stk ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1920902 stack}) stk, :free ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{1920925 stack}) free, :needclose needClose, :toclose toClose, :nexttoken nextToken, :nextbyte ^Int nextByte, :ns ^ABEND881(unrecognized Expr type *ast.MapType at: &{1921032 string string}) ns, :err err, :line ^Int line, :offset offset, :unmarshaldepth ^Int unmarshalDepth} NewTokenDecoder
;;   "NewTokenDecoder creates a new XML parser using an underlying token stream."
;;   {:added "1.0"
;;    :go "newTokenDecoder(t)"}
;;   [t])
;; 
JOKER FUNC xml.Unmarshal has: 
;; (defn ^Error Unmarshal
;;   "Unmarshal parses the XML-encoded data and stores the result in
;; the value pointed to by v, which must be an arbitrary struct,
;; slice, or string. Well-formed data that does not fit into v is
;; discarded.
;; 
;; Because Unmarshal uses the reflect package, it can only assign
;; to exported (upper case) fields. Unmarshal uses a case-sensitive
;; comparison to match XML element names to tag values and struct
;; field names.
;; 
;; Unmarshal maps an XML element to a struct using the following rules.
;; In the rules, the tag of a field refers to the value associated with the
;; key 'xml' in the struct field's tag (see the example above).
;; 
;;   * If the struct has a field of type []byte or string with tag
;;      ",innerxml", Unmarshal accumulates the raw XML nested inside the
;;      element in that field. The rest of the rules still apply.
;; 
;;   * If the struct has a field named XMLName of type Name,
;;      Unmarshal records the element name in that field.
;; 
;;   * If the XMLName field has an associated tag of the form
;;      "name" or "namespace-URL name", the XML element must have
;;      the given name (and, optionally, name space) or else Unmarshal
;;      returns an error.
;; 
;;   * If the XML element has an attribute whose name matches a
;;      struct field name with an associated tag containing ",attr" or
;;      the explicit name in a struct field tag of the form "name,attr",
;;      Unmarshal records the attribute value in that field.
;; 
;;   * If the XML element has an attribute not handled by the previous
;;      rule and the struct has a field with an associated tag containing
;;      ",any,attr", Unmarshal records the attribute value in the first
;;      such field.
;; 
;;   * If the XML element contains character data, that data is
;;      accumulated in the first struct field that has tag ",chardata".
;;      The struct field may have type []byte or string.
;;      If there is no such field, the character data is discarded.
;; 
;;   * If the XML element contains comments, they are accumulated in
;;      the first struct field that has tag ",comment".  The struct
;;      field may have type []byte or string. If there is no such
;;      field, the comments are discarded.
;; 
;;   * If the XML element contains a sub-element whose name matches
;;      the prefix of a tag formatted as "a" or "a>b>c", unmarshal
;;      will descend into the XML structure looking for elements with the
;;      given names, and will map the innermost elements to that struct
;;      field. A tag starting with ">" is equivalent to one starting
;;      with the field name followed by ">".
;; 
;;   * If the XML element contains a sub-element whose name matches
;;      a struct field's XMLName tag and the struct field has no
;;      explicit name tag as per the previous rule, unmarshal maps
;;      the sub-element to that struct field.
;; 
;;   * If the XML element contains a sub-element whose name matches a
;;      field without any mode flags (",attr", ",chardata", etc), Unmarshal
;;      maps the sub-element to that struct field.
;; 
;;   * If the XML element contains a sub-element that hasn't matched any
;;      of the above rules and the struct has a field with tag ",any",
;;      unmarshal maps the sub-element to that struct field.
;; 
;;   * An anonymous struct field is handled as if the fields of its
;;      value were part of the outer struct.
;; 
;;   * A struct field with tag "-" is never unmarshaled into.
;; 
;; Unmarshal maps an XML element to a string or []byte by saving the
;; concatenation of that element's character data in the string or
;; []byte. The saved []byte is never nil.
;; 
;; Unmarshal maps an attribute value to a string or []byte by saving
;; the value in the string or slice.
;; 
;; Unmarshal maps an attribute value to an Attr by saving the attribute,
;; including its name, in the Attr.
;; 
;; Unmarshal maps an XML element or attribute value to a slice by
;; extending the length of the slice and mapping the element or attribute
;; to the newly created value.
;; 
;; Unmarshal maps an XML element or attribute value to a bool by
;; setting it to the boolean value represented by the string. Whitespace
;; is trimmed and ignored.
;; 
;; Unmarshal maps an XML element or attribute value to an integer or
;; floating-point field by setting the field to the result of
;; interpreting the string value in decimal. There is no check for
;; overflow. Whitespace is trimmed and ignored.
;; 
;; Unmarshal maps an XML element to a Name by recording the element
;; name.
;; 
;; Unmarshal maps an XML element to a pointer by setting the pointer
;; to a freshly allocated value and then mapping the element to that value.
;; 
;; A missing element or empty attribute value will be unmarshaled as a zero value.
;; If the field is a slice, a zero value will be appended to the field. Otherwise, the
;; field will be set to its zero value."
;;   {:added "1.0"
;;    :go "unmarshal(data, v)"}
;;   [^ABEND881(unrecognized Expr type *ast.ArrayType at: &{1888653 <nil> byte}) data, ^ABEND881(unrecognized Expr type *ast.InterfaceType at: &{1888663 0xc0008b5680 false}) v])
;; 
JOKER FUNC zip.FileInfoHeader has: 
;; (defn ^[{:name ^String Name, :comment ^String Comment, :nonutf8 NonUTF8, :creatorversion ^Int CreatorVersion, :readerversion ^Int ReaderVersion, :flags ^Int Flags, :method ^Int Method, :modified ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{time Time}) Modified, :modifiedtime ^Int ModifiedTime, :modifieddate ^Int ModifiedDate, :crc32 CRC32, :compressedsize CompressedSize, :uncompressedsize UncompressedSize, :compressedsize64 CompressedSize64, :uncompressedsize64 UncompressedSize64, :extra ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{116303 <nil> byte}) Extra, :externalattrs ExternalAttrs} Error] FileInfoHeader
;;   "FileInfoHeader creates a partially-populated FileHeader from an
;; os.FileInfo.
;; Because os.FileInfo's Name method returns only the base name of
;; the file it describes, it may be necessary to modify the Name field
;; of the returned header to provide the full path name of the file.
;; If compression is desired, callers should set the FileHeader.Method
;; field; it is unset by default."
;;   {:added "1.0"
;;    :go "fileInfoHeader(fi)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{os FileInfo}) fi])
;; 
JOKER FUNC zip.NewReader has: 
;; (defn ^[{:r ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReaderAt}) r, :file ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{94108 <nil> 0xc0002438c0}) File, :comment ^String Comment, :decompressors ^ABEND881(unrecognized Expr type *ast.MapType at: &{94153 uint16 Decompressor}) decompressors} Error] NewReader
;;   "NewReader returns a new Reader reading from r, which is assumed to
;; have the given size in bytes."
;;   {:added "1.0"
;;    :go "newReader(r, size)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io ReaderAt}) r, size])
;; 
JOKER FUNC zip.NewWriter has: 
;; (defn ^{:cw ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{123352 countWriter}) cw, :dir ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{123378 <nil> 0xc0002b4f40}) dir, :last ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{123401 fileWriter}) last, :closed closed, :compressors ^ABEND881(unrecognized Expr type *ast.MapType at: &{123444 uint16 Compressor}) compressors, :comment ^String comment, :testhookclosesizeoffset ^ABEND881(unrecognized Expr type *ast.FuncType at: &{123624 0xc0002b2d80 <nil>}) testHookCloseSizeOffset} NewWriter
;;   "NewWriter returns a new Writer writing a zip file to w."
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC zip.OpenReader has: 
;; (defn ^[{:f ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{94208 0xc000243a40}) f} Error] OpenReader
;;   "OpenReader will open the Zip file specified by name and return a ReadCloser."
;;   {:added "1.0"
;;    :go "openReader(name)"}
;;   [^String name])
;; 
JOKER FUNC zip.RegisterCompressor has: 
;; (defn RegisterCompressor
;;   "RegisterCompressor registers custom compressors for a specified method ID.
;; The common methods Store and Deflate are built in."
;;   {:added "1.0"
;;    :go "registerCompressor(method, comp)"}
;;   [^Int method, comp])
;; 
JOKER FUNC zip.RegisterDecompressor has: 
;; (defn RegisterDecompressor
;;   "RegisterDecompressor allows custom decompressors for a specified method ID.
;; The common methods Store and Deflate are built in."
;;   {:added "1.0"
;;    :go "registerDecompressor(method, dcomp)"}
;;   [^Int method, dcomp])
;; 
JOKER FUNC zlib.NewReader has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) Error] NewReader
;;   "NewReader creates a new ReadCloser.
;; Reads from the returned ReadCloser read and decompress data from r.
;; If r does not implement io.ByteReader, the decompressor may read more
;; data than necessary from r.
;; It is the caller's responsibility to call Close on the ReadCloser when done.
;; 
;; The ReadCloser returned by NewReader also implements Resetter."
;;   {:added "1.0"
;;    :go "newReader(r)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r])
;; 
JOKER FUNC zlib.NewReaderDict has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.SelectorExpr at: &{io ReadCloser}) Error] NewReaderDict
;;   "NewReaderDict is like NewReader but uses a preset dictionary.
;; NewReaderDict ignores the dictionary if the compressed data does not refer to it.
;; If the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.
;; 
;; The ReadCloser returned by NewReaderDict also implements Resetter."
;;   {:added "1.0"
;;    :go "newReaderDict(r, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Reader}) r, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{363975 <nil> byte}) dict])
;; 
JOKER FUNC zlib.NewWriter has: 
;; (defn ^{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :level ^Int level, :dict ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{367120 <nil> byte}) dict, :compressor ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{367140 0xc0000ad760}) compressor, :digest ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash32}) digest, :err err, :scratch ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{367211 0xc0000ad880 byte}) scratch, :wroteheader wroteHeader} NewWriter
;;   "NewWriter creates a new Writer.
;; Writes to the returned Writer are compressed and written to w.
;; 
;; It is the caller's responsibility to call Close on the Writer when done.
;; Writes may be buffered and not flushed until Close."
;;   {:added "1.0"
;;    :go "newWriter(w)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w])
;; 
JOKER FUNC zlib.NewWriterLevel has: 
;; (defn ^[{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :level ^Int level, :dict ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{367120 <nil> byte}) dict, :compressor ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{367140 0xc0000ad760}) compressor, :digest ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash32}) digest, :err err, :scratch ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{367211 0xc0000ad880 byte}) scratch, :wroteheader wroteHeader} Error] NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead
;; of assuming DefaultCompression.
;; 
;; The compression level can be DefaultCompression, NoCompression, HuffmanOnly
;; or any integer value between BestSpeed and BestCompression inclusive.
;; The error returned will be nil if the level is valid."
;;   {:added "1.0"
;;    :go "newWriterLevel(w, level)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^Int level])
;; 
JOKER FUNC zlib.NewWriterLevelDict has: 
;; (defn ^[{:w ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, :level ^Int level, :dict ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{367120 <nil> byte}) dict, :compressor ^ABEND881(unrecognized Expr type *ast.StarExpr at: &{367140 0xc0000ad760}) compressor, :digest ^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{hash Hash32}) digest, :err err, :scratch ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{367211 0xc0000ad880 byte}) scratch, :wroteheader wroteHeader} Error] NewWriterLevelDict
;;   "NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to
;; compress with.
;; 
;; The dictionary may be nil. If not, its contents should not be modified until
;; the Writer is closed."
;;   {:added "1.0"
;;    :go "newWriterLevelDict(w, level, dict)"}
;;   [^ABEND881(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}) w, ^Int level, ^ABEND881(unrecognized Expr type *ast.ArrayType at: &{368271 <nil> byte}) dict])
;; 
GO FUNC ast.Inspect has: 
// func inspect(node Object, f ABEND882(unrecognized Expr type *ast.FuncType at: &{2148299 0xc000a41440 0xc000a41470}))  {
// 	 := ast.Inspect(node, f)
// 	...ABEND: TODO...
// }
// 
GO FUNC ast.SortImports has: 
// func sortImports(fset ABEND882(unrecognized Expr type *ast.StarExpr at: &{2122700 0xc0009d0a20}), f ABEND882(unrecognized Expr type *ast.StarExpr at: &{2122718 File}))  {
// 	 := ast.SortImports(fset, f)
// 	...ABEND: TODO...
// }
// 
GO FUNC ast.Walk has: 
// func walk(v Object, node Object)  {
// 	 := ast.Walk(v, node)
// 	...ABEND: TODO...
// }
// 
GO FUNC atomic.StoreInt32 has: 
// func storeInt32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: &{7344765 int32}), val Object)  {
// 	 := atomic.StoreInt32(addr, val)
// 	...ABEND: TODO...
// }
// 
GO FUNC atomic.StoreInt64 has: 
// func storeInt64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: &{7344854 int64}), val Object)  {
// 	 := atomic.StoreInt64(addr, val)
// 	...ABEND: TODO...
// }
// 
GO FUNC atomic.StorePointer has: 
// func storePointer(addr ABEND882(unrecognized Expr type *ast.StarExpr at: &{7345230 0xc001efa780}), val ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}))  {
// 	 := atomic.StorePointer(addr, val)
// 	...ABEND: TODO...
// }
// 
GO FUNC atomic.StoreUint32 has: 
// func storeUint32(addr ABEND882(unrecognized Expr type *ast.StarExpr at: &{7344945 uint32}), val Object)  {
// 	 := atomic.StoreUint32(addr, val)
// 	...ABEND: TODO...
// }
// 
GO FUNC atomic.StoreUint64 has: 
// func storeUint64(addr ABEND882(unrecognized Expr type *ast.StarExpr at: &{7345038 uint64}), val Object)  {
// 	 := atomic.StoreUint64(addr, val)
// 	...ABEND: TODO...
// }
// 
GO FUNC atomic.StoreUintptr has: 
// func storeUintptr(addr ABEND882(unrecognized Expr type *ast.StarExpr at: &{7345133 uintptr}), val Object)  {
// 	 := atomic.StoreUintptr(addr, val)
// 	...ABEND: TODO...
// }
// 
GO FUNC cgo._cgo_panic has: 
// func _cgo_panic(a ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}), n Object)  {
// 	 := cgo._cgo_panic(a, n)
// 	...ABEND: TODO...
// }
// 
GO FUNC cgo._runtime_cgocallback has: 
// func _runtime_cgocallback()  {
// 	 := cgo._runtime_cgocallback()
// 	...ABEND: TODO...
// }
// 
GO FUNC crypto.RegisterHash has: 
// func registerHash(h Object, f ABEND882(unrecognized Expr type *ast.FuncType at: &{403703 0xc00030fe60 0xc00030fe90}))  {
// 	 := crypto.RegisterHash(h, f)
// 	...ABEND: TODO...
// }
// 
GO FUNC curve25519.ScalarBaseMult has: 
// func scalarBaseMult(dst ABEND882(unrecognized Expr type *ast.StarExpr at: &{8208733 0xc00141e8a0}), in ABEND882(unrecognized Expr type *ast.StarExpr at: &{8208733 0xc00141e8a0}))  {
// 	 := curve25519.ScalarBaseMult(dst, in)
// 	...ABEND: TODO...
// }
// 
GO FUNC curve25519.ScalarMult has: 
// func scalarMult(dst ABEND882(unrecognized Expr type *ast.StarExpr at: &{8208475 0xc00141e780}), in ABEND882(unrecognized Expr type *ast.StarExpr at: &{8208475 0xc00141e780}), base ABEND882(unrecognized Expr type *ast.StarExpr at: &{8208475 0xc00141e780}))  {
// 	 := curve25519.ScalarMult(dst, in, base)
// 	...ABEND: TODO...
// }
// 
GO FUNC debug.FreeOSMemory has: 
// func freeOSMemory()  {
// 	 := debug.FreeOSMemory()
// 	...ABEND: TODO...
// }
// 
GO FUNC debug.PrintStack has: 
// func printStack()  {
// 	 := debug.PrintStack()
// 	...ABEND: TODO...
// }
// 
GO FUNC debug.ReadGCStats has: 
// func readGCStats(stats ABEND882(unrecognized Expr type *ast.StarExpr at: &{7046128 GCStats}))  {
// 	 := debug.ReadGCStats(stats)
// 	...ABEND: TODO...
// }
// 
GO FUNC debug.SetTraceback has: 
// func setTraceback(level string)  {
// 	 := debug.SetTraceback(level)
// 	...ABEND: TODO...
// }
// 
GO FUNC debug.WriteHeapDump has: 
// func writeHeapDump(fd Object)  {
// 	 := debug.WriteHeapDump(fd)
// 	...ABEND: TODO...
// }
// 
GO FUNC doc.ToHTML has: 
// func toHTML(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}), text string, words ABEND882(unrecognized Expr type *ast.MapType at: &{2351060 string string}))  {
// 	 := doc.ToHTML(w, text, words)
// 	...ABEND: TODO...
// }
// 
GO FUNC doc.ToText has: 
// func toText(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}), text string, indent string, preIndent string, width int)  {
// 	 := doc.ToText(w, text, indent, preIndent, width)
// 	...ABEND: TODO...
// }
// 
GO FUNC draw.Draw has: 
// func draw(dst Object, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{image Rectangle}), src ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{image Image}), sp ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{image Point}), op Object)  {
// 	 := draw.Draw(dst, r, src, sp, op)
// 	...ABEND: TODO...
// }
// 
GO FUNC draw.DrawMask has: 
// func drawMask(dst Object, r ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{image Rectangle}), src ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{image Image}), sp ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{image Point}), mask ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{image Image}), mp ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{image Point}), op Object)  {
// 	 := draw.DrawMask(dst, r, src, sp, mask, mp, op)
// 	...ABEND: TODO...
// }
// 
GO FUNC expvar.Do has: 
// func do(f ABEND882(unrecognized Expr type *ast.FuncType at: &{1998670 0xc00038cc90 <nil>}))  {
// 	 := expvar.Do(f)
// 	...ABEND: TODO...
// }
// 
GO FUNC expvar.Publish has: 
// func publish(name string, v Object)  {
// 	 := expvar.Publish(name, v)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.BoolVar has: 
// func boolVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: &{2017292 bool}), name string, value Object, usage string)  {
// 	 := flag.BoolVar(p, name, value, usage)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.DurationVar has: 
// func durationVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: &{2025850 0xc000756f60}), name string, value ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{time Duration}), usage string)  {
// 	 := flag.DurationVar(p, name, value, usage)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.Float64Var has: 
// func float64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: &{2024435 float64}), name string, value Object, usage string)  {
// 	 := flag.Float64Var(p, name, value, usage)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.Int64Var has: 
// func int64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: &{2019612 int64}), name string, value Object, usage string)  {
// 	 := flag.Int64Var(p, name, value, usage)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.IntVar has: 
// func intVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: &{2018448 int}), name string, value int, usage string)  {
// 	 := flag.IntVar(p, name, value, usage)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.Parse has: 
// func parse()  {
// 	 := flag.Parse()
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.PrintDefaults has: 
// func printDefaults()  {
// 	 := flag.PrintDefaults()
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.StringVar has: 
// func stringVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: &{2023203 string}), name string, value string, usage string)  {
// 	 := flag.StringVar(p, name, value, usage)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.Uint64Var has: 
// func uint64Var(p ABEND882(unrecognized Expr type *ast.StarExpr at: &{2021982 uint64}), name string, value Object, usage string)  {
// 	 := flag.Uint64Var(p, name, value, usage)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.UintVar has: 
// func uintVar(p ABEND882(unrecognized Expr type *ast.StarExpr at: &{2020797 uint}), name string, value Object, usage string)  {
// 	 := flag.UintVar(p, name, value, usage)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.Var has: 
// func var(value Object, name string, usage string)  {
// 	 := flag.Var(value, name, usage)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.Visit has: 
// func visit(fn ABEND882(unrecognized Expr type *ast.FuncType at: &{2009797 0xc0004207b0 <nil>}))  {
// 	 := flag.Visit(fn)
// 	...ABEND: TODO...
// }
// 
GO FUNC flag.VisitAll has: 
// func visitAll(fn ABEND882(unrecognized Expr type *ast.FuncType at: &{2009377 0xc0004170e0 <nil>}))  {
// 	 := flag.VisitAll(fn)
// 	...ABEND: TODO...
// }
// 
GO FUNC gob.Register has: 
// func register(value ABEND882(unrecognized Expr type *ast.InterfaceType at: &{1637234 0xc000255f50 false}))  {
// 	 := gob.Register(value)
// 	...ABEND: TODO...
// }
// 
GO FUNC gob.RegisterName has: 
// func registerName(name string, value ABEND882(unrecognized Expr type *ast.InterfaceType at: &{1636013 0xc000255b60 false}))  {
// 	 := gob.RegisterName(name, value)
// 	...ABEND: TODO...
// }
// 
GO FUNC heap.Fix has: 
// func fix(h Object, i int)  {
// 	 := heap.Fix(h, i)
// 	...ABEND: TODO...
// }
// 
GO FUNC heap.Init has: 
// func init(h Object)  {
// 	 := heap.Init(h)
// 	...ABEND: TODO...
// }
// 
GO FUNC heap.Push has: 
// func push(h Object, x ABEND882(unrecognized Expr type *ast.InterfaceType at: &{373806 0xc0002eb080 false}))  {
// 	 := heap.Push(h, x)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.Error has: 
// func error(w Object, error string, code int)  {
// 	 := http.Error(w, error, code)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.Handle has: 
// func handle(pattern string, handler Object)  {
// 	 := http.Handle(pattern, handler)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.HandleFunc has: 
// func handleFunc(pattern string, handler ABEND882(unrecognized Expr type *ast.FuncType at: &{4981221 0xc000c29890 <nil>}))  {
// 	 := http.HandleFunc(pattern, handler)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.NotFound has: 
// func notFound(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: &{4968179 Request}))  {
// 	 := http.NotFound(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.Redirect has: 
// func redirect(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: &{4969573 Request}), url string, code int)  {
// 	 := http.Redirect(w, r, url, code)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.ServeContent has: 
// func serveContent(w Object, req ABEND882(unrecognized Expr type *ast.StarExpr at: &{4484550 Request}), name string, modtime ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{time Time}), content ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{io ReadSeeker}))  {
// 	 := http.ServeContent(w, req, name, modtime, content)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.ServeFile has: 
// func serveFile(w Object, r ABEND882(unrecognized Expr type *ast.StarExpr at: &{4499006 Request}), name string)  {
// 	 := http.ServeFile(w, r, name)
// 	...ABEND: TODO...
// }
// 
GO FUNC http.SetCookie has: 
// func setCookie(w Object, cookie ABEND882(unrecognized Expr type *ast.StarExpr at: &{4507940 Cookie}))  {
// 	 := http.SetCookie(w, cookie)
// 	...ABEND: TODO...
// }
// 
GO FUNC image.RegisterFormat has: 
// func registerFormat(name string, magic string, decode ABEND882(unrecognized Expr type *ast.FuncType at: &{3237082 0xc0004d8f30 0xc0004d8ff0}), decodeConfig ABEND882(unrecognized Expr type *ast.FuncType at: &{3237127 0xc0004d9170 0xc0004d91a0}))  {
// 	 := image.RegisterFormat(name, magic, decode, decodeConfig)
// 	...ABEND: TODO...
// }
// 
GO FUNC json.HTMLEscape has: 
// func hTMLEscape(dst ABEND882(unrecognized Expr type *ast.StarExpr at: &{1772170 0xc0007d2b80}), src ABEND882(unrecognized Expr type *ast.ArrayType at: &{1772189 <nil> byte}))  {
// 	 := json.HTMLEscape(dst, src)
// 	...ABEND: TODO...
// }
// 
GO FUNC jsonrpc.ServeConn has: 
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}))  {
// 	 := jsonrpc.ServeConn(conn)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.Fatal has: 
// func fatal(v ABEND882(unrecognized Expr type *ast.Ellipsis at: &{3531563 0xc000eefdc0}))  {
// 	 := log.Fatal(v)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.Fatalf has: 
// func fatalf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: &{3531728 0xc000ef40a0}))  {
// 	 := log.Fatalf(format, v)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.Fatalln has: 
// func fatalln(v ABEND882(unrecognized Expr type *ast.Ellipsis at: &{3531890 0xc000ef4380}))  {
// 	 := log.Fatalln(v)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.Panic has: 
// func panic(v ABEND882(unrecognized Expr type *ast.Ellipsis at: &{3532036 0xc000ef4620}))  {
// 	 := log.Panic(v)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.Panicf has: 
// func panicf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: &{3532204 0xc000ef4900}))  {
// 	 := log.Panicf(format, v)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.Panicln has: 
// func panicln(v ABEND882(unrecognized Expr type *ast.Ellipsis at: &{3532369 0xc000ef4be0}))  {
// 	 := log.Panicln(v)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.Print has: 
// func print(v ABEND882(unrecognized Expr type *ast.Ellipsis at: &{3531043 0xc000eef700}))  {
// 	 := log.Print(v)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.Printf has: 
// func printf(format string, v ABEND882(unrecognized Expr type *ast.Ellipsis at: &{3531236 0xc000eef960}))  {
// 	 := log.Printf(format, v)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.Println has: 
// func println(v ABEND882(unrecognized Expr type *ast.Ellipsis at: &{3531426 0xc000eefbc0}))  {
// 	 := log.Println(v)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.SetFlags has: 
// func setFlags(flag int)  {
// 	 := log.SetFlags(flag)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.SetOutput has: 
// func setOutput(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}))  {
// 	 := log.SetOutput(w)
// 	...ABEND: TODO...
// }
// 
GO FUNC log.SetPrefix has: 
// func setPrefix(prefix string)  {
// 	 := log.SetPrefix(prefix)
// 	...ABEND: TODO...
// }
// 
GO FUNC nettest.TestConn has: 
// func testConn(t ABEND882(unrecognized Expr type *ast.StarExpr at: &{8638623 0xc001c25e80}), mp Object)  {
// 	 := nettest.TestConn(t, mp)
// 	...ABEND: TODO...
// }
// 
GO FUNC os.Clearenv has: 
// func clearenv()  {
// 	 := os.Clearenv()
// 	...ABEND: TODO...
// }
// 
GO FUNC os.Exit has: 
// func exit(code int)  {
// 	 := os.Exit(code)
// 	...ABEND: TODO...
// }
// 
GO FUNC poly1305.Sum has: 
// func sum(out ABEND882(unrecognized Expr type *ast.StarExpr at: &{8220702 0xc001486150}), m ABEND882(unrecognized Expr type *ast.ArrayType at: &{8220715 <nil> byte}), key ABEND882(unrecognized Expr type *ast.StarExpr at: &{8220727 0xc0014861b0}))  {
// 	 := poly1305.Sum(out, m, key)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Cmdline has: 
// func cmdline(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{http ResponseWriter}), r ABEND882(unrecognized Expr type *ast.StarExpr at: &{5132354 0xc0010803e0}))  {
// 	 := pprof.Cmdline(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Do has: 
// func do(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{context Context}), labels Object, f ABEND882(unrecognized Expr type *ast.FuncType at: &{7094256 0xc001b1b1a0 <nil>}))  {
// 	 := pprof.Do(ctx, labels, f)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.ForLabels has: 
// func forLabels(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{context Context}), f ABEND882(unrecognized Expr type *ast.FuncType at: &{7090425 0xc001b00cf0 0xc001b00d20}))  {
// 	 := pprof.ForLabels(ctx, f)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Index has: 
// func index(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{http ResponseWriter}), r ABEND882(unrecognized Expr type *ast.StarExpr at: &{5138846 0xc00108b940}))  {
// 	 := pprof.Index(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Profile has: 
// func profile(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{http ResponseWriter}), r ABEND882(unrecognized Expr type *ast.StarExpr at: &{5133491 0xc001081800}))  {
// 	 := pprof.Profile(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.SetGoroutineLabels has: 
// func setGoroutineLabels(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{context Context}))  {
// 	 := pprof.SetGoroutineLabels(ctx)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.StopCPUProfile has: 
// func stopCPUProfile()  {
// 	 := pprof.StopCPUProfile()
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Symbol has: 
// func symbol(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{http ResponseWriter}), r ABEND882(unrecognized Expr type *ast.StarExpr at: &{5135643 0xc001089420}))  {
// 	 := pprof.Symbol(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC pprof.Trace has: 
// func trace(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{http ResponseWriter}), r ABEND882(unrecognized Expr type *ast.StarExpr at: &{5134598 0xc001088620}))  {
// 	 := pprof.Trace(w, r)
// 	...ABEND: TODO...
// }
// 
GO FUNC rand.Seed has: 
// func seed(seed Object)  {
// 	 := rand.Seed(seed)
// 	...ABEND: TODO...
// }
// 
GO FUNC rand.Shuffle has: 
// func shuffle(n int, swap ABEND882(unrecognized Expr type *ast.FuncType at: &{3981065 0xc000a04480 <nil>}))  {
// 	 := rand.Shuffle(n, swap)
// 	...ABEND: TODO...
// }
// 
GO FUNC rpc.Accept has: 
// func accept(lis ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{net Listener}))  {
// 	 := rpc.Accept(lis)
// 	...ABEND: TODO...
// }
// 
GO FUNC rpc.HandleHTTP has: 
// func handleHTTP()  {
// 	 := rpc.HandleHTTP()
// 	...ABEND: TODO...
// }
// 
GO FUNC rpc.ServeCodec has: 
// func serveCodec(codec Object)  {
// 	 := rpc.ServeCodec(codec)
// 	...ABEND: TODO...
// }
// 
GO FUNC rpc.ServeConn has: 
// func serveConn(conn ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{io ReadWriteCloser}))  {
// 	 := rpc.ServeConn(conn)
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.Breakpoint has: 
// func breakpoint()  {
// 	 := runtime.Breakpoint()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.GC has: 
// func gC()  {
// 	 := runtime.GC()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.Goexit has: 
// func goexit()  {
// 	 := runtime.Goexit()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.Gosched has: 
// func gosched()  {
// 	 := runtime.Gosched()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.KeepAlive has: 
// func keepAlive(x ABEND882(unrecognized Expr type *ast.InterfaceType at: &{7010589 0xc0013263c0 false}))  {
// 	 := runtime.KeepAlive(x)
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.LockOSThread has: 
// func lockOSThread()  {
// 	 := runtime.LockOSThread()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.ReadMemStats has: 
// func readMemStats(m ABEND882(unrecognized Expr type *ast.StarExpr at: &{5833148 MemStats}))  {
// 	 := runtime.ReadMemStats(m)
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.SetBlockProfileRate has: 
// func setBlockProfileRate(rate int)  {
// 	 := runtime.SetBlockProfileRate(rate)
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.SetCPUProfileRate has: 
// func setCPUProfileRate(hz int)  {
// 	 := runtime.SetCPUProfileRate(hz)
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.SetCgoTraceback has: 
// func setCgoTraceback(version int, traceback ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}), context ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}), symbolizer ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{unsafe Pointer}))  {
// 	 := runtime.SetCgoTraceback(version, traceback, context, symbolizer)
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.SetFinalizer has: 
// func setFinalizer(obj ABEND882(unrecognized Expr type *ast.InterfaceType at: &{7006088 0xc0011e3ef0 false}), finalizer ABEND882(unrecognized Expr type *ast.InterfaceType at: &{7006111 0xc0011e3f20 false}))  {
// 	 := runtime.SetFinalizer(obj, finalizer)
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.StopTrace has: 
// func stopTrace()  {
// 	 := runtime.StopTrace()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime.UnlockOSThread has: 
// func unlockOSThread()  {
// 	 := runtime.UnlockOSThread()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime._ExternalCode has: 
// func _ExternalCode()  {
// 	 := runtime._ExternalCode()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime._GC has: 
// func _GC()  {
// 	 := runtime._GC()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime._LostExternalCode has: 
// func _LostExternalCode()  {
// 	 := runtime._LostExternalCode()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime._LostSIGPROFDuringAtomic64 has: 
// func _LostSIGPROFDuringAtomic64()  {
// 	 := runtime._LostSIGPROFDuringAtomic64()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime._System has: 
// func _System()  {
// 	 := runtime._System()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime._VDSO has: 
// func _VDSO()  {
// 	 := runtime._VDSO()
// 	...ABEND: TODO...
// }
// 
GO FUNC runtime._cgo_panic_internal has: 
// func _cgo_panic_internal(p ABEND882(unrecognized Expr type *ast.StarExpr at: &{6977778 byte}))  {
// 	 := runtime._cgo_panic_internal(p)
// 	...ABEND: TODO...
// }
// 
GO FUNC scanner.PrintError has: 
// func printError(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}), err Object)  {
// 	 := scanner.PrintError(w, err)
// 	...ABEND: TODO...
// }
// 
GO FUNC signal.Ignore has: 
// func ignore(sig ABEND882(unrecognized Expr type *ast.Ellipsis at: &{5378078 0xc0016842e0}))  {
// 	 := signal.Ignore(sig)
// 	...ABEND: TODO...
// }
// 
GO FUNC signal.Notify has: 
// func notify(c ABEND882(unrecognized Expr type *ast.ChanType at: &{5379089 5379093 1 0xc0016848c0}), sig ABEND882(unrecognized Expr type *ast.Ellipsis at: &{5379111 0xc001684940}))  {
// 	 := signal.Notify(c, sig)
// 	...ABEND: TODO...
// }
// 
GO FUNC signal.Reset has: 
// func reset(sig ABEND882(unrecognized Expr type *ast.Ellipsis at: &{5379853 0xc0016855e0}))  {
// 	 := signal.Reset(sig)
// 	...ABEND: TODO...
// }
// 
GO FUNC signal.Stop has: 
// func stop(c ABEND882(unrecognized Expr type *ast.ChanType at: &{5380120 5380124 1 0xc0016857e0}))  {
// 	 := signal.Stop(c)
// 	...ABEND: TODO...
// }
// 
GO FUNC sort.Float64s has: 
// func float64s(a ABEND882(unrecognized Expr type *ast.ArrayType at: &{7132287 <nil> float64}))  {
// 	 := sort.Float64s(a)
// 	...ABEND: TODO...
// }
// 
GO FUNC sort.Ints has: 
// func ints(a ABEND882(unrecognized Expr type *ast.ArrayType at: &{7132119 <nil> int}))  {
// 	 := sort.Ints(a)
// 	...ABEND: TODO...
// }
// 
GO FUNC sort.Slice has: 
// func slice(slice ABEND882(unrecognized Expr type *ast.InterfaceType at: &{7144986 0xc001be3e90 false}), less ABEND882(unrecognized Expr type *ast.FuncType at: &{7145004 0xc001be3ef0 0xc001be3f20}))  {
// 	 := sort.Slice(slice, less)
// 	...ABEND: TODO...
// }
// 
GO FUNC sort.SliceStable has: 
// func sliceStable(slice ABEND882(unrecognized Expr type *ast.InterfaceType at: &{7145398 0xc001bf4060 false}), less ABEND882(unrecognized Expr type *ast.FuncType at: &{7145416 0xc001bf40c0 0xc001bf40f0}))  {
// 	 := sort.SliceStable(slice, less)
// 	...ABEND: TODO...
// }
// 
GO FUNC sort.Sort has: 
// func sort(data Object)  {
// 	 := sort.Sort(data)
// 	...ABEND: TODO...
// }
// 
GO FUNC sort.Stable has: 
// func stable(data Object)  {
// 	 := sort.Stable(data)
// 	...ABEND: TODO...
// }
// 
GO FUNC sort.Strings has: 
// func strings(a ABEND882(unrecognized Expr type *ast.ArrayType at: &{7132397 <nil> string}))  {
// 	 := sort.Strings(a)
// 	...ABEND: TODO...
// }
// 
GO FUNC sql.Register has: 
// func register(name string, driver ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{driver Driver}))  {
// 	 := sql.Register(name, driver)
// 	...ABEND: TODO...
// }
// 
GO FUNC subtle.ConstantTimeCopy has: 
// func constantTimeCopy(v int, x ABEND882(unrecognized Expr type *ast.ArrayType at: &{664931 <nil> byte}), y ABEND882(unrecognized Expr type *ast.ArrayType at: &{664931 <nil> byte}))  {
// 	 := subtle.ConstantTimeCopy(v, x, y)
// 	...ABEND: TODO...
// }
// 
GO FUNC syscall.Clearenv has: 
// func clearenv()  {
// 	 := syscall.Clearenv()
// 	...ABEND: TODO...
// }
// 
GO FUNC syscall.CloseOnExec has: 
// func closeOnExec(fd int)  {
// 	 := syscall.CloseOnExec(fd)
// 	...ABEND: TODO...
// }
// 
GO FUNC syscall.Exit has: 
// func exit(code int)  {
// 	 := syscall.Exit(code)
// 	...ABEND: TODO...
// }
// 
GO FUNC syscall.Sync has: 
// func sync()  {
// 	 := syscall.Sync()
// 	...ABEND: TODO...
// }
// 
GO FUNC testing.Main has: 
// func main(matchString ABEND882(unrecognized Expr type *ast.FuncType at: &{7617256 0xc001326c60 0xc001326c90}), tests ABEND882(unrecognized Expr type *ast.ArrayType at: &{7617299 <nil> InternalTest}), benchmarks ABEND882(unrecognized Expr type *ast.ArrayType at: &{7617326 <nil> InternalBenchmark}), examples ABEND882(unrecognized Expr type *ast.ArrayType at: &{7617356 <nil> InternalExample}))  {
// 	 := testing.Main(matchString, tests, benchmarks, examples)
// 	...ABEND: TODO...
// }
// 
GO FUNC testing.RegisterCover has: 
// func registerCover(c Object)  {
// 	 := testing.RegisterCover(c)
// 	...ABEND: TODO...
// }
// 
GO FUNC testing.RunBenchmarks has: 
// func runBenchmarks(matchString ABEND882(unrecognized Expr type *ast.FuncType at: &{7569929 0xc00162ae70 0xc00162aea0}), benchmarks ABEND882(unrecognized Expr type *ast.ArrayType at: &{7569977 <nil> InternalBenchmark}))  {
// 	 := testing.RunBenchmarks(matchString, benchmarks)
// 	...ABEND: TODO...
// }
// 
GO FUNC time.Sleep has: 
// func sleep(d Object)  {
// 	 := time.Sleep(d)
// 	...ABEND: TODO...
// }
// 
GO FUNC trace.Log has: 
// func log(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{context Context}), category string, message string)  {
// 	 := trace.Log(ctx, category, message)
// 	...ABEND: TODO...
// }
// 
GO FUNC trace.Logf has: 
// func logf(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{context Context}), category string, format string, args ABEND882(unrecognized Expr type *ast.Ellipsis at: &{7121017 0xc001ba0ae0}))  {
// 	 := trace.Logf(ctx, category, format, args)
// 	...ABEND: TODO...
// }
// 
GO FUNC trace.Stop has: 
// func stop()  {
// 	 := trace.Stop()
// 	...ABEND: TODO...
// }
// 
GO FUNC trace.WithRegion has: 
// func withRegion(ctx ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{context Context}), regionType string, fn ABEND882(unrecognized Expr type *ast.FuncType at: &{7121718 0xc001b673e0 <nil>}))  {
// 	 := trace.WithRegion(ctx, regionType, fn)
// 	...ABEND: TODO...
// }
// 
GO FUNC types.DefPredeclaredTestFuncs has: 
// func defPredeclaredTestFuncs()  {
// 	 := types.DefPredeclaredTestFuncs()
// 	...ABEND: TODO...
// }
// 
GO FUNC types.WriteExpr has: 
// func writeExpr(buf ABEND882(unrecognized Expr type *ast.StarExpr at: &{2911760 0xc000861ce0}), x ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{ast Expr}))  {
// 	 := types.WriteExpr(buf, x)
// 	...ABEND: TODO...
// }
// 
GO FUNC types.WriteSignature has: 
// func writeSignature(buf ABEND882(unrecognized Expr type *ast.StarExpr at: &{2777572 0xc0001da780}), sig ABEND882(unrecognized Expr type *ast.StarExpr at: &{2777591 Signature}), qf Object)  {
// 	 := types.WriteSignature(buf, sig, qf)
// 	...ABEND: TODO...
// }
// 
GO FUNC types.WriteType has: 
// func writeType(buf ABEND882(unrecognized Expr type *ast.StarExpr at: &{2772576 0xc0001e9820}), typ Object, qf Object)  {
// 	 := types.WriteType(buf, typ, qf)
// 	...ABEND: TODO...
// }
// 
GO FUNC xml.Escape has: 
// func escape(w ABEND882(unrecognized Expr type *ast.SelectorExpr at: &{io Writer}), s ABEND882(unrecognized Expr type *ast.ArrayType at: &{1960767 <nil> byte}))  {
// 	 := xml.Escape(w, s)
// 	...ABEND: TODO...
// }
// 
GO FUNC zip.RegisterCompressor has: 
// func registerCompressor(method Object, comp Object)  {
// 	 := zip.RegisterCompressor(method, comp)
// 	...ABEND: TODO...
// }
// 
GO FUNC zip.RegisterDecompressor has: 
// func registerDecompressor(method Object, dcomp Object)  {
// 	 := zip.RegisterDecompressor(method, dcomp)
// 	...ABEND: TODO...
// }
// 
Totals: types=1025 functions=1562 receivers=6046
