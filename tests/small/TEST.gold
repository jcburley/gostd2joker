Default context:
{amd64 linux /usr/local/go /home/craig/.go true false gc [] [go1.1 go1.2 go1.3 go1.4 go1.5 go1.6 go1.7 go1.8 go1.9 go1.10 go1.11]  <nil> <nil> <nil> <nil> <nil> <nil> <nil>}
Walking from tests/small to tests/small/go
Processing sourceDir=tests/small dump=false:
Walking from tests/small to tests/small/net
Processing sourceDir=tests/small dump=false:
Package net:
Processing package=net:
Walking from tests/small to tests/small/net/url
Processing sourceDir=tests/small dump=false:
Package url:
Processing package=url:
TYPE net.MX:
  tests/small/net/dnsclient.go
TYPE net.NS:
  tests/small/net/dnsclient.go
TYPE net.Resolver:
  tests/small/net/lookup.go
TYPE net.SRV:
  tests/small/net/dnsclient.go
TYPE url.Error:
  tests/small/net/url/url.go
TYPE url.EscapeError:
  tests/small/net/url/url.go
TYPE url.InvalidHostError:
  tests/small/net/url/url.go
TYPE url.URL:
  tests/small/net/url/url.go
TYPE url.Userinfo:
  tests/small/net/url/url.go
TYPE url.Values:
  tests/small/net/url/url.go
JOKER FUNC net.LookupAddr has: 
(defn ^[names err] LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.

When using the host C library resolver, at most one result will be
returned. To bypass the host resolver, use a custom Resolver."
  {:added "1.0"
   :go "lookupAddr(addr)"}
  [^String addr])

JOKER FUNC net.LookupCNAME has: 
(defn ^[cname err] LookupCNAME
  "LookupCNAME returns the canonical name for the given host.
Callers that do not care about the canonical name can call
LookupHost or LookupIP directly; both take care of resolving
the canonical name as part of the lookup.

A canonical name is the final name after following zero
or more CNAME records.
LookupCNAME does not return an error if host does not
contain DNS "CNAME" records, as long as host resolves to
address records."
  {:added "1.0"
   :go "lookupCNAME(host)"}
  [^String host])

JOKER FUNC net.LookupHost has: 
(defn ^[addrs err] LookupHost
  "LookupHost looks up the given host using the local resolver.
It returns a slice of that host's addresses."
  {:added "1.0"
   :go "lookupHost(host)"}
  [^String host])

JOKER FUNC net.LookupIP has: 
;; (defn ^[[ABEND042(cannot find typename net.IP)] Error] LookupIP
;;   "LookupIP looks up host using the local resolver.
;; It returns a slice of that host's IPv4 and IPv6 addresses."
;;   {:added "1.0"
;;    :go "lookupIP(host)"}
;;   [^String host])
;; 
JOKER FUNC net.LookupMX has: 
(defn ^[[{:host ^String Host, :pref ^Int Pref}] Error] LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference."
  {:added "1.0"
   :go "lookupMX(name)"}
  [^String name])

JOKER FUNC net.LookupNS has: 
(defn ^[[{:host ^String Host}] Error] LookupNS
  "LookupNS returns the DNS NS records for the given domain name."
  {:added "1.0"
   :go "lookupNS(name)"}
  [^String name])

JOKER FUNC net.LookupPort has: 
(defn ^[port err] LookupPort
  "LookupPort looks up the port for the given network and service."
  {:added "1.0"
   :go "lookupPort(network, service)"}
  [^String network, ^String service])

JOKER FUNC net.LookupSRV has: 
(defn ^[cname addrs err] LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,
protocol, and domain name. The proto is "tcp" or "udp".
The returned records are sorted by priority and randomized
by weight within a priority.

LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name. To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly."
  {:added "1.0"
   :go "lookupSRV(service, proto, name)"}
  [^String service, ^String proto, ^String name])

JOKER FUNC net.LookupTXT has: 
(defn ^[[String] Error] LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name."
  {:added "1.0"
   :go "lookupTXT(name)"}
  [^String name])

JOKER FUNC url.Parse has: 
;; (defn ^[{:scheme ^String Scheme, :opaque ^String Opaque, :user ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/small/net/url/url.go:347:13) User, :host ^String Host, :path ^String Path, :rawpath ^String RawPath, :forcequery ForceQuery, :rawquery ^String RawQuery, :fragment ^String Fragment} Error] Parse
;;   "Parse parses rawurl into a URL structure.
;; 
;; The rawurl may be relative (a path, without a host) or absolute
;; (starting with a scheme). Trying to parse a hostname and path
;; without a scheme is invalid but may not necessarily return an
;; error, due to parsing ambiguities."
;;   {:added "1.0"
;;    :go "parse(rawurl)"}
;;   [^String rawurl])
;; 
JOKER FUNC url.ParseQuery has: 
;; (defn ^[ABEND883(unrecognized Expr type *ast.MapType at: tests/small/net/url/url.go:804:13) Error] ParseQuery
;;   "ParseQuery parses the URL-encoded query string and returns
;; a map listing the values specified for each key.
;; ParseQuery always returns a non-nil map containing all the
;; valid query parameters found; err describes the first decoding error
;; encountered, if any.
;; 
;; Query is expected to be a list of key=value settings separated by
;; ampersands or semicolons. A setting without an equals sign is
;; interpreted as a key set to an empty value."
;;   {:added "1.0"
;;    :go "parseQuery(query)"}
;;   [^String query])
;; 
JOKER FUNC url.ParseRequestURI has: 
;; (defn ^[{:scheme ^String Scheme, :opaque ^String Opaque, :user ^ABEND881(unrecognized Expr type *ast.StarExpr at: tests/small/net/url/url.go:347:13) User, :host ^String Host, :path ^String Path, :rawpath ^String RawPath, :forcequery ForceQuery, :rawquery ^String RawQuery, :fragment ^String Fragment} Error] ParseRequestURI
;;   "ParseRequestURI parses rawurl into a URL structure. It assumes that
;; rawurl was received in an HTTP request, so the rawurl is interpreted
;; only as an absolute URI or an absolute path.
;; The string rawurl is assumed not to have a #fragment suffix.
;; (Web browsers strip #fragment before sending the URL to a web server.)"
;;   {:added "1.0"
;;    :go "parseRequestURI(rawurl)"}
;;   [^String rawurl])
;; 
JOKER FUNC url.PathEscape has: 
(defn ^String PathEscape
  "PathEscape escapes the string so it can be safely placed
inside a URL path segment."
  {:added "1.0"
   :go "pathEscape(s)"}
  [^String s])

JOKER FUNC url.PathUnescape has: 
(defn ^[String Error] PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,
converting each 3-byte encoded substring of the form "%AB" into the
hex-decoded byte 0xAB. It returns an error if any % is not followed
by two hexadecimal digits.

PathUnescape is identical to QueryUnescape except that it does not
unescape '+' to ' ' (space)."
  {:added "1.0"
   :go "pathUnescape(s)"}
  [^String s])

JOKER FUNC url.QueryEscape has: 
(defn ^String QueryEscape
  "QueryEscape escapes the string so it can be safely placed
inside a URL query."
  {:added "1.0"
   :go "queryEscape(s)"}
  [^String s])

JOKER FUNC url.QueryUnescape has: 
(defn ^[String Error] QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,
converting each 3-byte encoded substring of the form "%AB" into the
hex-decoded byte 0xAB.
It returns an error if any % is not followed by two hexadecimal
digits."
  {:added "1.0"
   :go "queryUnescape(s)"}
  [^String s])

JOKER FUNC url.User has: 
(defn ^{:username ^String username, :password ^String password, :passwordset passwordSet} User
  "User returns a Userinfo containing the provided username
and no password set."
  {:added "1.0"
   :go "user(username)"}
  [^String username])

JOKER FUNC url.UserPassword has: 
(defn ^{:username ^String username, :password ^String password, :passwordset passwordSet} UserPassword
  "UserPassword returns a Userinfo containing the provided username
and password.

This functionality should only be used with legacy web sites.
RFC 2396 warns that interpreting Userinfo this way
``is NOT RECOMMENDED, because the passing of authentication
information in clear text (such as URI) has proven to be a
security risk in almost every case where it has been used.''"
  {:added "1.0"
   :go "userPassword(username, password)"}
  [^String username, ^String password])

Totals: types=10 functions=18 receivers=46
